// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * VLAgent - is a tiny but brave agent, which helps you collect logs from various sources and stores them in VictoriaLogs.
 *
 * @schema VLAgent
 */
export class VlAgent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VLAgent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VLAgent',
  }

  /**
   * Renders a Kubernetes manifest for "VLAgent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VlAgentProps = {}): any {
    return {
      ...VlAgent.GVK,
      ...toJson_VlAgentProps(props),
    };
  }

  /**
   * Defines a "VLAgent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VlAgentProps = {}) {
    super(scope, id, {
      ...VlAgent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VlAgent.GVK,
      ...toJson_VlAgentProps(resolved),
    };
  }
}

/**
 * VLAgent - is a tiny but brave agent, which helps you collect logs from various sources and stores them in VictoriaLogs.
 *
 * @schema VLAgent
 */
export interface VlAgentProps {
  /**
   * @schema VLAgent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VLAgentSpec defines the desired state of VLAgent
   *
   * @schema VLAgent#spec
   */
  readonly spec?: VlAgentSpec;

}

/**
 * Converts an object of type 'VlAgentProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentProps(obj: VlAgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VlAgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLAgentSpec defines the desired state of VLAgent
 *
 * @schema VlAgentSpec
 */
export interface VlAgentSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VlAgentSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for VLAgent in Mode: StatefulSet
   *
   * @schema VlAgentSpec#claimTemplates
   */
  readonly claimTemplates?: VlAgentSpecClaimTemplates[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VlAgentSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VlAgentSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VlAgentSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VlAgentSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VlAgentSpec#dnsConfig
   */
  readonly dnsConfig?: VlAgentSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VlAgentSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VlAgentSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VlAgentSpec#extraEnvs
   */
  readonly extraEnvs?: VlAgentSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VlAgentSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VlAgentSpecExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VlAgentSpec#hostAliases
   */
  readonly hostAliases?: VlAgentSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VlAgentSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VlAgentSpec#image
   */
  readonly image?: VlAgentSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlAgentSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VlAgentSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VlAgentSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VlAgentSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VLAgent to be configured with.
   *
   * @schema VlAgentSpec#logFormat
   */
  readonly logFormat?: VlAgentSpecLogFormat;

  /**
   * LogLevel for VLAgent to be configured with.
   * INFO, WARN, ERROR, FATAL, PANIC
   *
   * @schema VlAgentSpec#logLevel
   */
  readonly logLevel?: VlAgentSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VlAgentSpec#managedMetadata
   */
  readonly managedMetadata?: VlAgentSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VlAgentSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VlAgentSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlAgentSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VlAgentSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VlAgentSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VlAgentSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VlAgentSpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the vlagent pods.
   *
   * @schema VlAgentSpec#podMetadata
   */
  readonly podMetadata?: VlAgentSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VlAgentSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VlAgentSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VlAgentSpec#readinessGates
   */
  readonly readinessGates?: VlAgentSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VlAgentSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * RemoteWrite list of victoria logs endpoints
   * for victorialogs it must looks like: http://victoria-logs-single:9428/
   * or for cluster different url
   * https://docs.victoriametrics.com/victorialogs/vlagent/#replication-and-high-availability
   *
   * @schema VlAgentSpec#remoteWrite
   */
  readonly remoteWrite: VlAgentSpecRemoteWrite[];

  /**
   * RemoteWriteSettings defines global settings for all remoteWrite urls.
   *
   * @schema VlAgentSpec#remoteWriteSettings
   */
  readonly remoteWriteSettings?: VlAgentSpecRemoteWriteSettings;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VlAgentSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VlAgentSpec#resources
   */
  readonly resources?: VlAgentSpecResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VlAgentSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * StatefulRollingUpdateStrategy allows configuration for strategyType
   * set it to RollingUpdate for disabling operator statefulSet rollingUpdate
   *
   * @schema VlAgentSpec#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VlAgentSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VlAgentSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VlAgentSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VlAgentSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VlAgentSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vlagent VMServiceScrape spec
   *
   * @schema VlAgentSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vlagent service spec
   *
   * @schema VlAgentSpec#serviceSpec
   */
  readonly serviceSpec?: VlAgentSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VlAgentSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * StatefulStorage configures storage for StatefulSet
   *
   * @schema VlAgentSpec#storage
   */
  readonly storage?: VlAgentSpecStorage;

  /**
   * SyslogSpec defines syslog listener configuration
   *
   * @schema VlAgentSpec#syslogSpec
   */
  readonly syslogSpec?: VlAgentSpecSyslogSpec;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VlAgentSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VlAgentSpec#tolerations
   */
  readonly tolerations?: VlAgentSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VlAgentSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VlAgentSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlAgentSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VlAgentSpec#volumeMounts
   */
  readonly volumeMounts?: VlAgentSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VlAgentSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VlAgentSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpec(obj: VlAgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => toJson_VlAgentSpecClaimTemplates(y)),
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VlAgentSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VlAgentSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VlAgentSpecExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VlAgentSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VlAgentSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlAgentSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VlAgentSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VlAgentSpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VlAgentSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VlAgentSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VlAgentSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'remoteWrite': obj.remoteWrite?.map(y => toJson_VlAgentSpecRemoteWrite(y)),
    'remoteWriteSettings': toJson_VlAgentSpecRemoteWriteSettings(obj.remoteWriteSettings),
    'replicaCount': obj.replicaCount,
    'resources': toJson_VlAgentSpecResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VlAgentSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VlAgentSpecStorage(obj.storage),
    'syslogSpec': toJson_VlAgentSpecSyslogSpec(obj.syslogSpec),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VlAgentSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VlAgentSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema VlAgentSpecClaimTemplates
 */
export interface VlAgentSpecClaimTemplates {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VlAgentSpecClaimTemplates#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VlAgentSpecClaimTemplates#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema VlAgentSpecClaimTemplates#metadata
   */
  readonly metadata?: any;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VlAgentSpecClaimTemplates#spec
   */
  readonly spec?: VlAgentSpecClaimTemplatesSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VlAgentSpecClaimTemplates#status
   */
  readonly status?: VlAgentSpecClaimTemplatesStatus;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplates(obj: VlAgentSpecClaimTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': obj.metadata,
    'spec': toJson_VlAgentSpecClaimTemplatesSpec(obj.spec),
    'status': toJson_VlAgentSpecClaimTemplatesStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VlAgentSpecDnsConfig
 */
export interface VlAgentSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VlAgentSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VlAgentSpecDnsConfig#options
   */
  readonly options?: VlAgentSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VlAgentSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VlAgentSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecDnsConfig(obj: VlAgentSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VlAgentSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VlAgentSpecExtraEnvs
 */
export interface VlAgentSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VlAgentSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VlAgentSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlAgentSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecExtraEnvs(obj: VlAgentSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VlAgentSpecExtraEnvsFrom
 */
export interface VlAgentSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VlAgentSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VlAgentSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VlAgentSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VlAgentSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VlAgentSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VlAgentSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecExtraEnvsFrom(obj: VlAgentSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VlAgentSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VlAgentSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VlAgentSpecHostAliases
 */
export interface VlAgentSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VlAgentSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VlAgentSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VlAgentSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecHostAliases(obj: VlAgentSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VlAgentSpecImage
 */
export interface VlAgentSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VlAgentSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VlAgentSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VlAgentSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VlAgentSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecImage(obj: VlAgentSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlAgentSpecImagePullSecrets
 */
export interface VlAgentSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlAgentSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecImagePullSecrets(obj: VlAgentSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VLAgent to be configured with.
 *
 * @schema VlAgentSpecLogFormat
 */
export enum VlAgentSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VLAgent to be configured with.
 * INFO, WARN, ERROR, FATAL, PANIC
 *
 * @schema VlAgentSpecLogLevel
 */
export enum VlAgentSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VlAgentSpecManagedMetadata
 */
export interface VlAgentSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlAgentSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlAgentSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlAgentSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecManagedMetadata(obj: VlAgentSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VlAgentSpecPersistentVolumeClaimRetentionPolicy
 */
export interface VlAgentSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VlAgentSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VlAgentSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VlAgentSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecPersistentVolumeClaimRetentionPolicy(obj: VlAgentSpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VlAgentSpecPodDisruptionBudget
 */
export interface VlAgentSpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VlAgentSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VlAgentSpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VlAgentSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VlAgentSpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VlAgentSpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlAgentSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecPodDisruptionBudget(obj: VlAgentSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the vlagent pods.
 *
 * @schema VlAgentSpecPodMetadata
 */
export interface VlAgentSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlAgentSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlAgentSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlAgentSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlAgentSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecPodMetadata(obj: VlAgentSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VlAgentSpecReadinessGates
 */
export interface VlAgentSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VlAgentSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VlAgentSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecReadinessGates(obj: VlAgentSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLAgentRemoteWriteSpec defines the remote storage configuration for VmAgent
 *
 * @schema VlAgentSpecRemoteWrite
 */
export interface VlAgentSpecRemoteWrite {
  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VlAgentSpecRemoteWrite#bearerTokenPath
   */
  readonly bearerTokenPath?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VlAgentSpecRemoteWrite#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VlAgentSpecRemoteWriteBearerTokenSecret;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName: headerValue
   *
   * @schema VlAgentSpecRemoteWrite#headers
   */
  readonly headers?: string[];

  /**
   * MaxDiskUsage defines the maximum file-based buffer size in bytes for the given remoteWrite
   * It overrides global configuration defined at remoteWriteSettings.maxDiskUsagePerURL
   *
   * @schema VlAgentSpecRemoteWrite#maxDiskUsage
   */
  readonly maxDiskUsage?: any;

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VlAgentSpecRemoteWrite#oauth2
   */
  readonly oauth2?: VlAgentSpecRemoteWriteOauth2;

  /**
   * ProxyURL for -remoteWrite.url. Supported proxies: http, https, socks5. Example: socks5://proxy:1234
   *
   * @schema VlAgentSpecRemoteWrite#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)
   *
   * @schema VlAgentSpecRemoteWrite#sendTimeout
   */
  readonly sendTimeout?: string;

  /**
   * TLSConfig describes tls configuration for remote write target
   *
   * @schema VlAgentSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: VlAgentSpecRemoteWriteTlsConfig;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema VlAgentSpecRemoteWrite#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWrite(obj: VlAgentSpecRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerTokenPath': obj.bearerTokenPath,
    'bearerTokenSecret': toJson_VlAgentSpecRemoteWriteBearerTokenSecret(obj.bearerTokenSecret),
    'headers': obj.headers?.map(y => y),
    'maxDiskUsage': obj.maxDiskUsage,
    'oauth2': toJson_VlAgentSpecRemoteWriteOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'sendTimeout': obj.sendTimeout,
    'tlsConfig': toJson_VlAgentSpecRemoteWriteTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteWriteSettings defines global settings for all remoteWrite urls.
 *
 * @schema VlAgentSpecRemoteWriteSettings
 */
export interface VlAgentSpecRemoteWriteSettings {
  /**
   * Interval for flushing the data to remote storage. (default 1s)
   *
   * @schema VlAgentSpecRemoteWriteSettings#flushInterval
   */
  readonly flushInterval?: string;

  /**
   * The maximum size of unpacked request to send to remote storage
   *
   * @schema VlAgentSpecRemoteWriteSettings#maxBlockSize
   */
  readonly maxBlockSize?: any;

  /**
   * The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath
   *
   * @schema VlAgentSpecRemoteWriteSettings#maxDiskUsagePerURL
   */
  readonly maxDiskUsagePerUrl?: any;

  /**
   * The number of concurrent queues
   *
   * @schema VlAgentSpecRemoteWriteSettings#queues
   */
  readonly queues?: number;

  /**
   * Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info
   *
   * @schema VlAgentSpecRemoteWriteSettings#showURL
   */
  readonly showUrl?: boolean;

  /**
   * Path to directory where temporary data for remote write component is stored (default /vlagent_pq/vlagent-remotewrite-data)
   * If defined, operator ignores spec.storage field and skips adding volume and volumeMount for pq
   *
   * @schema VlAgentSpecRemoteWriteSettings#tmpDataPath
   */
  readonly tmpDataPath?: string;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteSettings(obj: VlAgentSpecRemoteWriteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
    'maxBlockSize': obj.maxBlockSize,
    'maxDiskUsagePerURL': obj.maxDiskUsagePerUrl,
    'queues': obj.queues,
    'showURL': obj.showUrl,
    'tmpDataPath': obj.tmpDataPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VlAgentSpecResources
 */
export interface VlAgentSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VlAgentSpecResources#claims
   */
  readonly claims?: VlAgentSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecResources#limits
   */
  readonly limits?: { [key: string]: VlAgentSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecResources#requests
   */
  readonly requests?: { [key: string]: VlAgentSpecResourcesRequests };

}

/**
 * Converts an object of type 'VlAgentSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecResources(obj: VlAgentSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VlAgentSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vlagent service spec
 *
 * @schema VlAgentSpecServiceSpec
 */
export interface VlAgentSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VlAgentSpecServiceSpec#metadata
   */
  readonly metadata?: VlAgentSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VlAgentSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VlAgentSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecServiceSpec(obj: VlAgentSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VlAgentSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatefulStorage configures storage for StatefulSet
 *
 * @schema VlAgentSpecStorage
 */
export interface VlAgentSpecStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VlAgentSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VlAgentSpecStorage#emptyDir
   */
  readonly emptyDir?: VlAgentSpecStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VlAgentSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: VlAgentSpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'VlAgentSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorage(obj: VlAgentSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VlAgentSpecStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': toJson_VlAgentSpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogSpec defines syslog listener configuration
 *
 * @schema VlAgentSpecSyslogSpec
 */
export interface VlAgentSpecSyslogSpec {
  /**
   * TCPListeners defines syslog server TCP listener configuration
   *
   * @schema VlAgentSpecSyslogSpec#tcpListeners
   */
  readonly tcpListeners?: VlAgentSpecSyslogSpecTcpListeners[];

  /**
   * UDPListeners defines syslog server UDP listener configuration
   *
   * @schema VlAgentSpecSyslogSpec#udpListeners
   */
  readonly udpListeners?: VlAgentSpecSyslogSpecUdpListeners[];

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpec(obj: VlAgentSpecSyslogSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tcpListeners': obj.tcpListeners?.map(y => toJson_VlAgentSpecSyslogSpecTcpListeners(y)),
    'udpListeners': obj.udpListeners?.map(y => toJson_VlAgentSpecSyslogSpecUdpListeners(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VlAgentSpecTolerations
 */
export interface VlAgentSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VlAgentSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VlAgentSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VlAgentSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VlAgentSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VlAgentSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlAgentSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecTolerations(obj: VlAgentSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VlAgentSpecVolumeMounts
 */
export interface VlAgentSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VlAgentSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VlAgentSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VlAgentSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VlAgentSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VlAgentSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VlAgentSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VlAgentSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VlAgentSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecVolumeMounts(obj: VlAgentSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VlAgentSpecClaimTemplatesSpec
 */
export interface VlAgentSpecClaimTemplatesSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VlAgentSpecClaimTemplatesSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VlAgentSpecClaimTemplatesSpec#dataSource
   */
  readonly dataSource?: VlAgentSpecClaimTemplatesSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlAgentSpecClaimTemplatesSpec#dataSourceRef
   */
  readonly dataSourceRef?: VlAgentSpecClaimTemplatesSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VlAgentSpecClaimTemplatesSpec#resources
   */
  readonly resources?: VlAgentSpecClaimTemplatesSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VlAgentSpecClaimTemplatesSpec#selector
   */
  readonly selector?: VlAgentSpecClaimTemplatesSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VlAgentSpecClaimTemplatesSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VlAgentSpecClaimTemplatesSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VlAgentSpecClaimTemplatesSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VlAgentSpecClaimTemplatesSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpec(obj: VlAgentSpecClaimTemplatesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VlAgentSpecClaimTemplatesSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VlAgentSpecClaimTemplatesSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VlAgentSpecClaimTemplatesSpecResources(obj.resources),
    'selector': toJson_VlAgentSpecClaimTemplatesSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VlAgentSpecClaimTemplatesStatus
 */
export interface VlAgentSpecClaimTemplatesStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VlAgentSpecClaimTemplatesStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VlAgentSpecClaimTemplatesStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VlAgentSpecClaimTemplatesStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VlAgentSpecClaimTemplatesStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VlAgentSpecClaimTemplatesStatus#capacity
   */
  readonly capacity?: { [key: string]: VlAgentSpecClaimTemplatesStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VlAgentSpecClaimTemplatesStatus#conditions
   */
  readonly conditions?: VlAgentSpecClaimTemplatesStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VlAgentSpecClaimTemplatesStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VlAgentSpecClaimTemplatesStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VlAgentSpecClaimTemplatesStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VlAgentSpecClaimTemplatesStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesStatus(obj: VlAgentSpecClaimTemplatesStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VlAgentSpecClaimTemplatesStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VlAgentSpecClaimTemplatesStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VlAgentSpecDnsConfigOptions
 */
export interface VlAgentSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VlAgentSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VlAgentSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlAgentSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecDnsConfigOptions(obj: VlAgentSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VlAgentSpecExtraEnvsFromConfigMapRef
 */
export interface VlAgentSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VlAgentSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecExtraEnvsFromConfigMapRef(obj: VlAgentSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VlAgentSpecExtraEnvsFromSecretRef
 */
export interface VlAgentSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VlAgentSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecExtraEnvsFromSecretRef(obj: VlAgentSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VlAgentSpecPodDisruptionBudgetMaxUnavailable
 */
export class VlAgentSpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VlAgentSpecPodDisruptionBudgetMaxUnavailable {
    return new VlAgentSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VlAgentSpecPodDisruptionBudgetMaxUnavailable {
    return new VlAgentSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VlAgentSpecPodDisruptionBudgetMinAvailable
 */
export class VlAgentSpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VlAgentSpecPodDisruptionBudgetMinAvailable {
    return new VlAgentSpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VlAgentSpecPodDisruptionBudgetMinAvailable {
    return new VlAgentSpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VlAgentSpecRemoteWriteBearerTokenSecret
 */
export interface VlAgentSpecRemoteWriteBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteBearerTokenSecret(obj: VlAgentSpecRemoteWriteBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VlAgentSpecRemoteWriteOauth2
 */
export interface VlAgentSpecRemoteWriteOauth2 {
  /**
   * ClientIDFile defines path to pre-mounted OAuth2 client id
   *
   * @schema VlAgentSpecRemoteWriteOauth2#clientIDFile
   */
  readonly clientIdFile?: string;

  /**
   * ClientIDSecret defines secret or configmap containing the OAuth2 client id
   *
   * @schema VlAgentSpecRemoteWriteOauth2#clientIDSecret
   */
  readonly clientIdSecret?: VlAgentSpecRemoteWriteOauth2ClientIdSecret;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VlAgentSpecRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret?: VlAgentSpecRemoteWriteOauth2ClientSecret;

  /**
   * ClientSecretFile defines path to pre-mounted OAuth2 client secret
   *
   * @schema VlAgentSpecRemoteWriteOauth2#clientSecretFile
   */
  readonly clientSecretFile?: string;

  /**
   * EndpointParams to append to the token URL
   *
   * @schema VlAgentSpecRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * Scopes used for the token request
   *
   * @schema VlAgentSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TokenURL defines URL to fetch the token from
   *
   * @schema VlAgentSpecRemoteWriteOauth2#tokenURL
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteOauth2(obj: VlAgentSpecRemoteWriteOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIDFile': obj.clientIdFile,
    'clientIDSecret': toJson_VlAgentSpecRemoteWriteOauth2ClientIdSecret(obj.clientIdSecret),
    'clientSecret': toJson_VlAgentSpecRemoteWriteOauth2ClientSecret(obj.clientSecret),
    'clientSecretFile': obj.clientSecretFile,
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenURL': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig describes tls configuration for remote write target
 *
 * @schema VlAgentSpecRemoteWriteTlsConfig
 */
export interface VlAgentSpecRemoteWriteTlsConfig {
  /**
   * CAFile defines path to the pre-mounted file with TLS ca certificate
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * CASecret defines secret reference with tls CA key by given key
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#caSecretKeyRef
   */
  readonly caSecretKeyRef?: VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef;

  /**
   * CertFile defines path to the pre-mounted file with TLS certificate
   * mutually exclusive with CertSecret
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * CertSecret defines secret reference with TLS cert by given key
   * mutually exclusive with CASecret
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#certSecretKeyRef
   */
  readonly certSecretKeyRef?: VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef;

  /**
   * Disable target certificate validation.
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * KeyFile defines path to the pre-mounted file with TLS cert key
   * mutually exclusive with CertSecret
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * CertSecret defines secret reference with TLS key by given key
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#keySecretKeyRef
   */
  readonly keySecretKeyRef?: VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VlAgentSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteTlsConfig(obj: VlAgentSpecRemoteWriteTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'caSecretKeyRef': toJson_VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef(obj.caSecretKeyRef),
    'certFile': obj.certFile,
    'certSecretKeyRef': toJson_VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef(obj.certSecretKeyRef),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecretKeyRef': toJson_VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef(obj.keySecretKeyRef),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VlAgentSpecResourcesClaims
 */
export interface VlAgentSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VlAgentSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VlAgentSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VlAgentSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecResourcesClaims(obj: VlAgentSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlAgentSpecResourcesLimits
 */
export class VlAgentSpecResourcesLimits {
  public static fromNumber(value: number): VlAgentSpecResourcesLimits {
    return new VlAgentSpecResourcesLimits(value);
  }
  public static fromString(value: string): VlAgentSpecResourcesLimits {
    return new VlAgentSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlAgentSpecResourcesRequests
 */
export class VlAgentSpecResourcesRequests {
  public static fromNumber(value: number): VlAgentSpecResourcesRequests {
    return new VlAgentSpecResourcesRequests(value);
  }
  public static fromString(value: string): VlAgentSpecResourcesRequests {
    return new VlAgentSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VlAgentSpecServiceSpecMetadata
 */
export interface VlAgentSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlAgentSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlAgentSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlAgentSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlAgentSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecServiceSpecMetadata(obj: VlAgentSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VlAgentSpecStorageEmptyDir
 */
export interface VlAgentSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VlAgentSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VlAgentSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VlAgentSpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VlAgentSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageEmptyDir(obj: VlAgentSpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PVC spec to be used by the StatefulSets/Deployments.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplate
 */
export interface VlAgentSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: VlAgentSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: VlAgentSpecStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: VlAgentSpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplate(obj: VlAgentSpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_VlAgentSpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_VlAgentSpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_VlAgentSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogTCPListener defines configuration for TCP syslog server listen
 *
 * @schema VlAgentSpecSyslogSpecTcpListeners
 */
export interface VlAgentSpecSyslogSpecTcpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#tenantID
   */
  readonly tenantId?: string;

  /**
   * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
   *
   * @schema VlAgentSpecSyslogSpecTcpListeners#tlsConfig
   */
  readonly tlsConfig?: VlAgentSpecSyslogSpecTcpListenersTlsConfig;

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpecTcpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpecTcpListeners(obj: VlAgentSpecSyslogSpecTcpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
    'tlsConfig': toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogUDPListener defines configuration for UDP syslog server listen
 *
 * @schema VlAgentSpecSyslogSpecUdpListeners
 */
export interface VlAgentSpecSyslogSpecUdpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlAgentSpecSyslogSpecUdpListeners#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpecUdpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpecUdpListeners(obj: VlAgentSpecSyslogSpecUdpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VlAgentSpecClaimTemplatesSpecDataSource
 */
export interface VlAgentSpecClaimTemplatesSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpecDataSource(obj: VlAgentSpecClaimTemplatesSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VlAgentSpecClaimTemplatesSpecDataSourceRef
 */
export interface VlAgentSpecClaimTemplatesSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlAgentSpecClaimTemplatesSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpecDataSourceRef(obj: VlAgentSpecClaimTemplatesSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VlAgentSpecClaimTemplatesSpecResources
 */
export interface VlAgentSpecClaimTemplatesSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecClaimTemplatesSpecResources#limits
   */
  readonly limits?: { [key: string]: VlAgentSpecClaimTemplatesSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecClaimTemplatesSpecResources#requests
   */
  readonly requests?: { [key: string]: VlAgentSpecClaimTemplatesSpecResourcesRequests };

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpecResources(obj: VlAgentSpecClaimTemplatesSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VlAgentSpecClaimTemplatesSpecSelector
 */
export interface VlAgentSpecClaimTemplatesSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VlAgentSpecClaimTemplatesSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VlAgentSpecClaimTemplatesSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpecSelector(obj: VlAgentSpecClaimTemplatesSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlAgentSpecClaimTemplatesStatusAllocatedResources
 */
export class VlAgentSpecClaimTemplatesStatusAllocatedResources {
  public static fromNumber(value: number): VlAgentSpecClaimTemplatesStatusAllocatedResources {
    return new VlAgentSpecClaimTemplatesStatusAllocatedResources(value);
  }
  public static fromString(value: string): VlAgentSpecClaimTemplatesStatusAllocatedResources {
    return new VlAgentSpecClaimTemplatesStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlAgentSpecClaimTemplatesStatusCapacity
 */
export class VlAgentSpecClaimTemplatesStatusCapacity {
  public static fromNumber(value: number): VlAgentSpecClaimTemplatesStatusCapacity {
    return new VlAgentSpecClaimTemplatesStatusCapacity(value);
  }
  public static fromString(value: string): VlAgentSpecClaimTemplatesStatusCapacity {
    return new VlAgentSpecClaimTemplatesStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VlAgentSpecClaimTemplatesStatusConditions
 */
export interface VlAgentSpecClaimTemplatesStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VlAgentSpecClaimTemplatesStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesStatusConditions(obj: VlAgentSpecClaimTemplatesStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VlAgentSpecClaimTemplatesStatusModifyVolumeStatus
 */
export interface VlAgentSpecClaimTemplatesStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VlAgentSpecClaimTemplatesStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VlAgentSpecClaimTemplatesStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesStatusModifyVolumeStatus(obj: VlAgentSpecClaimTemplatesStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientIDSecret defines secret or configmap containing the OAuth2 client id
 *
 * @schema VlAgentSpecRemoteWriteOauth2ClientIdSecret
 */
export interface VlAgentSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteOauth2ClientIdSecret(obj: VlAgentSpecRemoteWriteOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VlAgentSpecRemoteWriteOauth2ClientSecret
 */
export interface VlAgentSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteOauth2ClientSecret(obj: VlAgentSpecRemoteWriteOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CASecret defines secret reference with tls CA key by given key
 *
 * @schema VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef
 */
export interface VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef(obj: VlAgentSpecRemoteWriteTlsConfigCaSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecret defines secret reference with TLS cert by given key
 * mutually exclusive with CASecret
 *
 * @schema VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef
 */
export interface VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef(obj: VlAgentSpecRemoteWriteTlsConfigCertSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecret defines secret reference with TLS key by given key
 *
 * @schema VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef
 */
export interface VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef(obj: VlAgentSpecRemoteWriteTlsConfigKeySecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VlAgentSpecStorageEmptyDirSizeLimit
 */
export class VlAgentSpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VlAgentSpecStorageEmptyDirSizeLimit {
    return new VlAgentSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VlAgentSpecStorageEmptyDirSizeLimit {
    return new VlAgentSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateMetadata
 */
export interface VlAgentSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateMetadata(obj: VlAgentSpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpec
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: VlAgentSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: VlAgentSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: VlAgentSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpec(obj: VlAgentSpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VlAgentSpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VlAgentSpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_VlAgentSpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateStatus
 */
export interface VlAgentSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: VlAgentSpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: VlAgentSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateStatus(obj: VlAgentSpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VlAgentSpecStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
 *
 * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfig
 */
export interface VlAgentSpecSyslogSpecTcpListenersTlsConfig {
  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecret
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfig#certSecret
   */
  readonly certSecret?: VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret;

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfig#keySecret
   */
  readonly keySecret?: VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret;

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpecTcpListenersTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfig(obj: VlAgentSpecSyslogSpecTcpListenersTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certFile': obj.certFile,
    'certSecret': toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret(obj.certSecret),
    'keyFile': obj.keyFile,
    'keySecret': toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret(obj.keySecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlAgentSpecClaimTemplatesSpecResourcesLimits
 */
export class VlAgentSpecClaimTemplatesSpecResourcesLimits {
  public static fromNumber(value: number): VlAgentSpecClaimTemplatesSpecResourcesLimits {
    return new VlAgentSpecClaimTemplatesSpecResourcesLimits(value);
  }
  public static fromString(value: string): VlAgentSpecClaimTemplatesSpecResourcesLimits {
    return new VlAgentSpecClaimTemplatesSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlAgentSpecClaimTemplatesSpecResourcesRequests
 */
export class VlAgentSpecClaimTemplatesSpecResourcesRequests {
  public static fromNumber(value: number): VlAgentSpecClaimTemplatesSpecResourcesRequests {
    return new VlAgentSpecClaimTemplatesSpecResourcesRequests(value);
  }
  public static fromString(value: string): VlAgentSpecClaimTemplatesSpecResourcesRequests {
    return new VlAgentSpecClaimTemplatesSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions
 */
export interface VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions(obj: VlAgentSpecClaimTemplatesSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpecDataSource(obj: VlAgentSpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: VlAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecResources
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpecResources(obj: VlAgentSpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpecSelector(obj: VlAgentSpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VlAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlAgentSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class VlAgentSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): VlAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new VlAgentSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): VlAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new VlAgentSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface VlAgentSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateStatusConditions(obj: VlAgentSpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: VlAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret
 */
export interface VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret(obj: VlAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret
 */
export interface VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret(obj: VlAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VlAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VlAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: VlAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VLCluster is fast, cost-effective and scalable logs database.
 *
 * @schema VLCluster
 */
export class VlCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VLCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VLCluster',
  }

  /**
   * Renders a Kubernetes manifest for "VLCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VlClusterProps = {}): any {
    return {
      ...VlCluster.GVK,
      ...toJson_VlClusterProps(props),
    };
  }

  /**
   * Defines a "VLCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VlClusterProps = {}) {
    super(scope, id, {
      ...VlCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VlCluster.GVK,
      ...toJson_VlClusterProps(resolved),
    };
  }
}

/**
 * VLCluster is fast, cost-effective and scalable logs database.
 *
 * @schema VLCluster
 */
export interface VlClusterProps {
  /**
   * @schema VLCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VLClusterSpec defines the desired state of VLCluster
   *
   * @schema VLCluster#spec
   */
  readonly spec?: VlClusterSpec;

}

/**
 * Converts an object of type 'VlClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterProps(obj: VlClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VlClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLClusterSpec defines the desired state of VLCluster
 *
 * @schema VlClusterSpec
 */
export interface VlClusterSpec {
  /**
   * ClusterDomainName defines domain name suffix for in-cluster dns addresses
   * aka .cluster.local
   * used by vlinsert and vlselect to build vlstorage address
   *
   * @schema VlClusterSpec#clusterDomainName
   */
  readonly clusterDomainName?: string;

  /**
   * ClusterVersion defines default images tag for all components.
   * it can be overwritten with component specific image.tag value.
   *
   * @schema VlClusterSpec#clusterVersion
   */
  readonly clusterVersion?: string;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VlClusterSpecImagePullSecrets[];

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VlClusterSpec#managedMetadata
   */
  readonly managedMetadata?: VlClusterSpecManagedMetadata;

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlClusterSpec#paused
   */
  readonly paused?: boolean;

  /**
   * RequestsLoadBalancer configures load-balancing for vlinsert and vlselect requests.
   * It helps to evenly spread load across pods.
   * Usually it's not possible with Kubernetes TCP-based services.
   *
   * @schema VlClusterSpec#requestsLoadBalancer
   */
  readonly requestsLoadBalancer?: VlClusterSpecRequestsLoadBalancer;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the
   * VLSelect, VLInsert and VLStorage Pods.
   *
   * @schema VlClusterSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlClusterSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VLInsert defines vlinsert component configuration at victoria-logs cluster
   *
   * @schema VlClusterSpec#vlinsert
   */
  readonly vlinsert?: VlClusterSpecVlinsert;

  /**
   * VLSelect defines vlselect component configuration at victoria-logs cluster
   *
   * @schema VlClusterSpec#vlselect
   */
  readonly vlselect?: VlClusterSpecVlselect;

  /**
   * VLStorage defines vlstorage component configuration at victoria-logs cluster
   *
   * @schema VlClusterSpec#vlstorage
   */
  readonly vlstorage?: VlClusterSpecVlstorage;

}

/**
 * Converts an object of type 'VlClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpec(obj: VlClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterDomainName': obj.clusterDomainName,
    'clusterVersion': obj.clusterVersion,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlClusterSpecImagePullSecrets(y)),
    'managedMetadata': toJson_VlClusterSpecManagedMetadata(obj.managedMetadata),
    'paused': obj.paused,
    'requestsLoadBalancer': toJson_VlClusterSpecRequestsLoadBalancer(obj.requestsLoadBalancer),
    'serviceAccountName': obj.serviceAccountName,
    'useStrictSecurity': obj.useStrictSecurity,
    'vlinsert': toJson_VlClusterSpecVlinsert(obj.vlinsert),
    'vlselect': toJson_VlClusterSpecVlselect(obj.vlselect),
    'vlstorage': toJson_VlClusterSpecVlstorage(obj.vlstorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlClusterSpecImagePullSecrets
 */
export interface VlClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecImagePullSecrets(obj: VlClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VlClusterSpecManagedMetadata
 */
export interface VlClusterSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlClusterSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecManagedMetadata(obj: VlClusterSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestsLoadBalancer configures load-balancing for vlinsert and vlselect requests.
 * It helps to evenly spread load across pods.
 * Usually it's not possible with Kubernetes TCP-based services.
 *
 * @schema VlClusterSpecRequestsLoadBalancer
 */
export interface VlClusterSpecRequestsLoadBalancer {
  /**
   * @schema VlClusterSpecRequestsLoadBalancer#disableInsertBalancing
   */
  readonly disableInsertBalancing?: boolean;

  /**
   * @schema VlClusterSpecRequestsLoadBalancer#disableSelectBalancing
   */
  readonly disableSelectBalancing?: boolean;

  /**
   * @schema VlClusterSpecRequestsLoadBalancer#enabled
   */
  readonly enabled?: boolean;

  /**
   * VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer
   * for VMCluster component
   *
   * @schema VlClusterSpecRequestsLoadBalancer#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'VlClusterSpecRequestsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecRequestsLoadBalancer(obj: VlClusterSpecRequestsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableInsertBalancing': obj.disableInsertBalancing,
    'disableSelectBalancing': obj.disableSelectBalancing,
    'enabled': obj.enabled,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLInsert defines vlinsert component configuration at victoria-logs cluster
 *
 * @schema VlClusterSpecVlinsert
 */
export interface VlClusterSpecVlinsert {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VlClusterSpecVlinsert#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VlClusterSpecVlinsert#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VlClusterSpecVlinsert#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VlClusterSpecVlinsert#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VlClusterSpecVlinsert#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VlClusterSpecVlinsert#dnsConfig
   */
  readonly dnsConfig?: VlClusterSpecVlinsertDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VlClusterSpecVlinsert#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VlClusterSpecVlinsert#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VlClusterSpecVlinsert#extraEnvs
   */
  readonly extraEnvs?: VlClusterSpecVlinsertExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VlClusterSpecVlinsert#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VlClusterSpecVlinsertExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VlClusterSpecVlinsert#hostAliases
   */
  readonly hostAliases?: VlClusterSpecVlinsertHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VlClusterSpecVlinsert#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Configures horizontal pod autoscaling.
   *
   * @schema VlClusterSpecVlinsert#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VlClusterSpecVlinsert#image
   */
  readonly image?: VlClusterSpecVlinsertImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlClusterSpecVlinsert#imagePullSecrets
   */
  readonly imagePullSecrets?: VlClusterSpecVlinsertImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VlClusterSpecVlinsert#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlinsert#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VLSelect to be configured with.
   * default or json
   *
   * @schema VlClusterSpecVlinsert#logFormat
   */
  readonly logFormat?: VlClusterSpecVlinsertLogFormat;

  /**
   * LogLevel for VLSelect to be configured with.
   *
   * @schema VlClusterSpecVlinsert#logLevel
   */
  readonly logLevel?: VlClusterSpecVlinsertLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VlClusterSpecVlinsert#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VlClusterSpecVlinsert#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlClusterSpecVlinsert#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VlClusterSpecVlinsert#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VlClusterSpecVlinsertPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
   *
   * @schema VlClusterSpecVlinsert#podMetadata
   */
  readonly podMetadata?: VlClusterSpecVlinsertPodMetadata;

  /**
   * Port listen address
   *
   * @schema VlClusterSpecVlinsert#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VlClusterSpecVlinsert#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VlClusterSpecVlinsert#readinessGates
   */
  readonly readinessGates?: VlClusterSpecVlinsertReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlinsert#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VlClusterSpecVlinsert#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VlClusterSpecVlinsert#resources
   */
  readonly resources?: VlClusterSpecVlinsertResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VlClusterSpecVlinsert#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VlClusterSpecVlinsert#rollingUpdate
   */
  readonly rollingUpdate?: VlClusterSpecVlinsertRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VlClusterSpecVlinsert#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VlClusterSpecVlinsert#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VlClusterSpecVlinsert#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VlClusterSpecVlinsert#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
   *
   * @schema VlClusterSpecVlinsert#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vlselect service spec
   *
   * @schema VlClusterSpecVlinsert#serviceSpec
   */
  readonly serviceSpec?: VlClusterSpecVlinsertServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VlClusterSpecVlinsert#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * SyslogSpec defines syslog listener configuration
   *
   * @schema VlClusterSpecVlinsert#syslogSpec
   */
  readonly syslogSpec?: VlClusterSpecVlinsertSyslogSpec;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VlClusterSpecVlinsert#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VlClusterSpecVlinsert#tolerations
   */
  readonly tolerations?: VlClusterSpecVlinsertTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VlClusterSpecVlinsert#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VlClusterSpecVlinsert#updateStrategy
   */
  readonly updateStrategy?: VlClusterSpecVlinsertUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VlClusterSpecVlinsert#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlClusterSpecVlinsert#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VlClusterSpecVlinsert#volumeMounts
   */
  readonly volumeMounts?: VlClusterSpecVlinsertVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VlClusterSpecVlinsert#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VlClusterSpecVlinsert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsert(obj: VlClusterSpecVlinsert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VlClusterSpecVlinsertDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VlClusterSpecVlinsertExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VlClusterSpecVlinsertExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VlClusterSpecVlinsertHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VlClusterSpecVlinsertImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlClusterSpecVlinsertImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VlClusterSpecVlinsertPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VlClusterSpecVlinsertPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VlClusterSpecVlinsertReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VlClusterSpecVlinsertResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VlClusterSpecVlinsertRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VlClusterSpecVlinsertServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'syslogSpec': toJson_VlClusterSpecVlinsertSyslogSpec(obj.syslogSpec),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VlClusterSpecVlinsertTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VlClusterSpecVlinsertVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLSelect defines vlselect component configuration at victoria-logs cluster
 *
 * @schema VlClusterSpecVlselect
 */
export interface VlClusterSpecVlselect {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VlClusterSpecVlselect#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VlClusterSpecVlselect#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VlClusterSpecVlselect#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VlClusterSpecVlselect#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VlClusterSpecVlselect#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VlClusterSpecVlselect#dnsConfig
   */
  readonly dnsConfig?: VlClusterSpecVlselectDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VlClusterSpecVlselect#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VlClusterSpecVlselect#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VlClusterSpecVlselect#extraEnvs
   */
  readonly extraEnvs?: VlClusterSpecVlselectExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VlClusterSpecVlselect#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VlClusterSpecVlselectExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VlClusterSpecVlselect#hostAliases
   */
  readonly hostAliases?: VlClusterSpecVlselectHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VlClusterSpecVlselect#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Configures horizontal pod autoscaling.
   *
   * @schema VlClusterSpecVlselect#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VlClusterSpecVlselect#image
   */
  readonly image?: VlClusterSpecVlselectImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlClusterSpecVlselect#imagePullSecrets
   */
  readonly imagePullSecrets?: VlClusterSpecVlselectImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VlClusterSpecVlselect#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlselect#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VLSelect to be configured with.
   * default or json
   *
   * @schema VlClusterSpecVlselect#logFormat
   */
  readonly logFormat?: VlClusterSpecVlselectLogFormat;

  /**
   * LogLevel for VLSelect to be configured with.
   *
   * @schema VlClusterSpecVlselect#logLevel
   */
  readonly logLevel?: VlClusterSpecVlselectLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VlClusterSpecVlselect#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VlClusterSpecVlselect#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlClusterSpecVlselect#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VlClusterSpecVlselect#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VlClusterSpecVlselectPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
   *
   * @schema VlClusterSpecVlselect#podMetadata
   */
  readonly podMetadata?: VlClusterSpecVlselectPodMetadata;

  /**
   * Port listen address
   *
   * @schema VlClusterSpecVlselect#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VlClusterSpecVlselect#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VlClusterSpecVlselect#readinessGates
   */
  readonly readinessGates?: VlClusterSpecVlselectReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlselect#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VlClusterSpecVlselect#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VlClusterSpecVlselect#resources
   */
  readonly resources?: VlClusterSpecVlselectResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VlClusterSpecVlselect#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VlClusterSpecVlselect#rollingUpdate
   */
  readonly rollingUpdate?: VlClusterSpecVlselectRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VlClusterSpecVlselect#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VlClusterSpecVlselect#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VlClusterSpecVlselect#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VlClusterSpecVlselect#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
   *
   * @schema VlClusterSpecVlselect#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vlselect service spec
   *
   * @schema VlClusterSpecVlselect#serviceSpec
   */
  readonly serviceSpec?: VlClusterSpecVlselectServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VlClusterSpecVlselect#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VlClusterSpecVlselect#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VlClusterSpecVlselect#tolerations
   */
  readonly tolerations?: VlClusterSpecVlselectTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VlClusterSpecVlselect#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VlClusterSpecVlselect#updateStrategy
   */
  readonly updateStrategy?: VlClusterSpecVlselectUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VlClusterSpecVlselect#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlClusterSpecVlselect#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VlClusterSpecVlselect#volumeMounts
   */
  readonly volumeMounts?: VlClusterSpecVlselectVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VlClusterSpecVlselect#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VlClusterSpecVlselect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselect(obj: VlClusterSpecVlselect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VlClusterSpecVlselectDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VlClusterSpecVlselectExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VlClusterSpecVlselectExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VlClusterSpecVlselectHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VlClusterSpecVlselectImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlClusterSpecVlselectImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VlClusterSpecVlselectPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VlClusterSpecVlselectPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VlClusterSpecVlselectReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VlClusterSpecVlselectResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VlClusterSpecVlselectRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VlClusterSpecVlselectServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VlClusterSpecVlselectTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VlClusterSpecVlselectVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLStorage defines vlstorage component configuration at victoria-logs cluster
 *
 * @schema VlClusterSpecVlstorage
 */
export interface VlClusterSpecVlstorage {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VlClusterSpecVlstorage#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
   *
   * @schema VlClusterSpecVlstorage#claimTemplates
   */
  readonly claimTemplates?: any[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VlClusterSpecVlstorage#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VlClusterSpecVlstorage#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VlClusterSpecVlstorage#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VlClusterSpecVlstorage#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VlClusterSpecVlstorage#dnsConfig
   */
  readonly dnsConfig?: VlClusterSpecVlstorageDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VlClusterSpecVlstorage#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VlClusterSpecVlstorage#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VlClusterSpecVlstorage#extraEnvs
   */
  readonly extraEnvs?: VlClusterSpecVlstorageExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VlClusterSpecVlstorage#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VlClusterSpecVlstorageExtraEnvsFrom[];

  /**
   * FutureRetention for the stored logs
   * Log entries with timestamps bigger than now+futureRetention are rejected during data ingestion; see https://docs.victoriametrics.com/victorialogs/#retention
   *
   * @schema VlClusterSpecVlstorage#futureRetention
   */
  readonly futureRetention?: string;

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VlClusterSpecVlstorage#hostAliases
   */
  readonly hostAliases?: VlClusterSpecVlstorageHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VlClusterSpecVlstorage#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VlClusterSpecVlstorage#image
   */
  readonly image?: VlClusterSpecVlstorageImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlClusterSpecVlstorage#imagePullSecrets
   */
  readonly imagePullSecrets?: VlClusterSpecVlstorageImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VlClusterSpecVlstorage#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlstorage#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VLStorage to be configured with.
   * default or json
   *
   * @schema VlClusterSpecVlstorage#logFormat
   */
  readonly logFormat?: VlClusterSpecVlstorageLogFormat;

  /**
   * Whether to log all the ingested log entries; this can be useful for debugging of data ingestion; see https://docs.victoriametrics.com/victorialogs/data-ingestion/
   *
   * @schema VlClusterSpecVlstorage#logIngestedRows
   */
  readonly logIngestedRows?: boolean;

  /**
   * LogLevel for VLStorage to be configured with.
   *
   * @schema VlClusterSpecVlstorage#logLevel
   */
  readonly logLevel?: VlClusterSpecVlstorageLogLevel;

  /**
   * LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams; see https://docs.victoriametrics.com/victorialogs/keyconcepts/#stream-fields
   *
   * @schema VlClusterSpecVlstorage#logNewStreams
   */
  readonly logNewStreams?: boolean;

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   * lets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].
   * Useful at storage expanding, when you want to rebalance some data at cluster.
   *
   * @schema VlClusterSpecVlstorage#maintenanceInsertNodeIDs
   */
  readonly maintenanceInsertNodeIDs?: number[];

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   *
   * @schema VlClusterSpecVlstorage#maintenanceSelectNodeIDs
   */
  readonly maintenanceSelectNodeIDs?: number[];

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VlClusterSpecVlstorage#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VlClusterSpecVlstorage#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlClusterSpecVlstorage#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VlClusterSpecVlstorage#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VlClusterSpecVlstorage#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VlClusterSpecVlstoragePodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VLStorage pods.
   *
   * @schema VlClusterSpecVlstorage#podMetadata
   */
  readonly podMetadata?: VlClusterSpecVlstoragePodMetadata;

  /**
   * Port listen address
   *
   * @schema VlClusterSpecVlstorage#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VlClusterSpecVlstorage#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VlClusterSpecVlstorage#readinessGates
   */
  readonly readinessGates?: VlClusterSpecVlstorageReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VlClusterSpecVlstorage#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VlClusterSpecVlstorage#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VlClusterSpecVlstorage#resources
   */
  readonly resources?: VlClusterSpecVlstorageResources;

  /**
   * RetentionMaxDiskSpaceUsageBytes for the stored logs
   * VictoriaLogs keeps at least two last days of data in order to guarantee that the logs for the last day can be returned in queries.
   * This means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,
   * if the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.
   * https://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage
   *
   * @schema VlClusterSpecVlstorage#retentionMaxDiskSpaceUsageBytes
   */
  readonly retentionMaxDiskSpaceUsageBytes?: string;

  /**
   * RetentionPeriod for the stored logs
   * https://docs.victoriametrics.com/victorialogs/#retention
   *
   * @schema VlClusterSpecVlstorage#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VlClusterSpecVlstorage#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy defines strategy for application updates
   * Default is OnDelete, in this case operator handles update process
   * Can be changed for RollingUpdate
   *
   * @default OnDelete, in this case operator handles update process
   * @schema VlClusterSpecVlstorage#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
   * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
   *
   * @schema VlClusterSpecVlstorage#rollingUpdateStrategyBehavior
   */
  readonly rollingUpdateStrategyBehavior?: VlClusterSpecVlstorageRollingUpdateStrategyBehavior;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VlClusterSpecVlstorage#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VlClusterSpecVlstorage#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VlClusterSpecVlstorage#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VlClusterSpecVlstorage#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
   *
   * @schema VlClusterSpecVlstorage#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vlselect service spec
   *
   * @schema VlClusterSpecVlstorage#serviceSpec
   */
  readonly serviceSpec?: VlClusterSpecVlstorageServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VlClusterSpecVlstorage#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage configures persistent volume for VLStorage
   *
   * @schema VlClusterSpecVlstorage#storage
   */
  readonly storage?: VlClusterSpecVlstorageStorage;

  /**
   * StorageDataPath - path to storage data
   *
   * @schema VlClusterSpecVlstorage#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VlClusterSpecVlstorage#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VlClusterSpecVlstorage#tolerations
   */
  readonly tolerations?: VlClusterSpecVlstorageTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VlClusterSpecVlstorage#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VlClusterSpecVlstorage#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlClusterSpecVlstorage#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VlClusterSpecVlstorage#volumeMounts
   */
  readonly volumeMounts?: VlClusterSpecVlstorageVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VlClusterSpecVlstorage#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VlClusterSpecVlstorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorage(obj: VlClusterSpecVlstorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => y),
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VlClusterSpecVlstorageDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VlClusterSpecVlstorageExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VlClusterSpecVlstorageExtraEnvsFrom(y)),
    'futureRetention': obj.futureRetention,
    'hostAliases': obj.hostAliases?.map(y => toJson_VlClusterSpecVlstorageHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VlClusterSpecVlstorageImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlClusterSpecVlstorageImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logIngestedRows': obj.logIngestedRows,
    'logLevel': obj.logLevel,
    'logNewStreams': obj.logNewStreams,
    'maintenanceInsertNodeIDs': obj.maintenanceInsertNodeIDs?.map(y => y),
    'maintenanceSelectNodeIDs': obj.maintenanceSelectNodeIDs?.map(y => y),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VlClusterSpecVlstoragePodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VlClusterSpecVlstoragePodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VlClusterSpecVlstorageReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VlClusterSpecVlstorageResources(obj.resources),
    'retentionMaxDiskSpaceUsageBytes': obj.retentionMaxDiskSpaceUsageBytes,
    'retentionPeriod': obj.retentionPeriod,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'rollingUpdateStrategyBehavior': toJson_VlClusterSpecVlstorageRollingUpdateStrategyBehavior(obj.rollingUpdateStrategyBehavior),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VlClusterSpecVlstorageServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VlClusterSpecVlstorageStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VlClusterSpecVlstorageTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VlClusterSpecVlstorageVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VlClusterSpecVlinsertDnsConfig
 */
export interface VlClusterSpecVlinsertDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VlClusterSpecVlinsertDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VlClusterSpecVlinsertDnsConfig#options
   */
  readonly options?: VlClusterSpecVlinsertDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VlClusterSpecVlinsertDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertDnsConfig(obj: VlClusterSpecVlinsertDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VlClusterSpecVlinsertDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VlClusterSpecVlinsertExtraEnvs
 */
export interface VlClusterSpecVlinsertExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlinsertExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VlClusterSpecVlinsertExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertExtraEnvs(obj: VlClusterSpecVlinsertExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VlClusterSpecVlinsertExtraEnvsFrom
 */
export interface VlClusterSpecVlinsertExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VlClusterSpecVlinsertExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VlClusterSpecVlinsertExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertExtraEnvsFrom(obj: VlClusterSpecVlinsertExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VlClusterSpecVlinsertExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VlClusterSpecVlinsertExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VlClusterSpecVlinsertHostAliases
 */
export interface VlClusterSpecVlinsertHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VlClusterSpecVlinsertHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VlClusterSpecVlinsertHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertHostAliases(obj: VlClusterSpecVlinsertHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VlClusterSpecVlinsertImage
 */
export interface VlClusterSpecVlinsertImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VlClusterSpecVlinsertImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VlClusterSpecVlinsertImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VlClusterSpecVlinsertImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertImage(obj: VlClusterSpecVlinsertImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlClusterSpecVlinsertImagePullSecrets
 */
export interface VlClusterSpecVlinsertImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlinsertImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertImagePullSecrets(obj: VlClusterSpecVlinsertImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VLSelect to be configured with.
 * default or json
 *
 * @schema VlClusterSpecVlinsertLogFormat
 */
export enum VlClusterSpecVlinsertLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VLSelect to be configured with.
 *
 * @schema VlClusterSpecVlinsertLogLevel
 */
export enum VlClusterSpecVlinsertLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VlClusterSpecVlinsertPodDisruptionBudget
 */
export interface VlClusterSpecVlinsertPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VlClusterSpecVlinsertPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VlClusterSpecVlinsertPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VlClusterSpecVlinsertPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertPodDisruptionBudget(obj: VlClusterSpecVlinsertPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
 *
 * @schema VlClusterSpecVlinsertPodMetadata
 */
export interface VlClusterSpecVlinsertPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlinsertPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlinsertPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlinsertPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertPodMetadata(obj: VlClusterSpecVlinsertPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VlClusterSpecVlinsertReadinessGates
 */
export interface VlClusterSpecVlinsertReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VlClusterSpecVlinsertReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertReadinessGates(obj: VlClusterSpecVlinsertReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VlClusterSpecVlinsertResources
 */
export interface VlClusterSpecVlinsertResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VlClusterSpecVlinsertResources#claims
   */
  readonly claims?: VlClusterSpecVlinsertResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlinsertResources#limits
   */
  readonly limits?: { [key: string]: VlClusterSpecVlinsertResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlinsertResources#requests
   */
  readonly requests?: { [key: string]: VlClusterSpecVlinsertResourcesRequests };

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertResources(obj: VlClusterSpecVlinsertResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VlClusterSpecVlinsertResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VlClusterSpecVlinsertRollingUpdate
 */
export interface VlClusterSpecVlinsertRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VlClusterSpecVlinsertRollingUpdate#maxSurge
   */
  readonly maxSurge?: VlClusterSpecVlinsertRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VlClusterSpecVlinsertRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlinsertRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertRollingUpdate(obj: VlClusterSpecVlinsertRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vlselect service spec
 *
 * @schema VlClusterSpecVlinsertServiceSpec
 */
export interface VlClusterSpecVlinsertServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VlClusterSpecVlinsertServiceSpec#metadata
   */
  readonly metadata?: VlClusterSpecVlinsertServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VlClusterSpecVlinsertServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VlClusterSpecVlinsertServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertServiceSpec(obj: VlClusterSpecVlinsertServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VlClusterSpecVlinsertServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogSpec defines syslog listener configuration
 *
 * @schema VlClusterSpecVlinsertSyslogSpec
 */
export interface VlClusterSpecVlinsertSyslogSpec {
  /**
   * TCPListeners defines syslog server TCP listener configuration
   *
   * @schema VlClusterSpecVlinsertSyslogSpec#tcpListeners
   */
  readonly tcpListeners?: VlClusterSpecVlinsertSyslogSpecTcpListeners[];

  /**
   * UDPListeners defines syslog server UDP listener configuration
   *
   * @schema VlClusterSpecVlinsertSyslogSpec#udpListeners
   */
  readonly udpListeners?: VlClusterSpecVlinsertSyslogSpecUdpListeners[];

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpec(obj: VlClusterSpecVlinsertSyslogSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tcpListeners': obj.tcpListeners?.map(y => toJson_VlClusterSpecVlinsertSyslogSpecTcpListeners(y)),
    'udpListeners': obj.udpListeners?.map(y => toJson_VlClusterSpecVlinsertSyslogSpecUdpListeners(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VlClusterSpecVlinsertTolerations
 */
export interface VlClusterSpecVlinsertTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VlClusterSpecVlinsertTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VlClusterSpecVlinsertTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VlClusterSpecVlinsertTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VlClusterSpecVlinsertTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VlClusterSpecVlinsertTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertTolerations(obj: VlClusterSpecVlinsertTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VlClusterSpecVlinsertUpdateStrategy
 */
export enum VlClusterSpecVlinsertUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VlClusterSpecVlinsertVolumeMounts
 */
export interface VlClusterSpecVlinsertVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VlClusterSpecVlinsertVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VlClusterSpecVlinsertVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VlClusterSpecVlinsertVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VlClusterSpecVlinsertVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VlClusterSpecVlinsertVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VlClusterSpecVlinsertVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VlClusterSpecVlinsertVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertVolumeMounts(obj: VlClusterSpecVlinsertVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VlClusterSpecVlselectDnsConfig
 */
export interface VlClusterSpecVlselectDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VlClusterSpecVlselectDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VlClusterSpecVlselectDnsConfig#options
   */
  readonly options?: VlClusterSpecVlselectDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VlClusterSpecVlselectDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VlClusterSpecVlselectDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectDnsConfig(obj: VlClusterSpecVlselectDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VlClusterSpecVlselectDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VlClusterSpecVlselectExtraEnvs
 */
export interface VlClusterSpecVlselectExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlselectExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VlClusterSpecVlselectExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectExtraEnvs(obj: VlClusterSpecVlselectExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VlClusterSpecVlselectExtraEnvsFrom
 */
export interface VlClusterSpecVlselectExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VlClusterSpecVlselectExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VlClusterSpecVlselectExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlselectExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VlClusterSpecVlselectExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VlClusterSpecVlselectExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectExtraEnvsFrom(obj: VlClusterSpecVlselectExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VlClusterSpecVlselectExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VlClusterSpecVlselectExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VlClusterSpecVlselectHostAliases
 */
export interface VlClusterSpecVlselectHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VlClusterSpecVlselectHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VlClusterSpecVlselectHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectHostAliases(obj: VlClusterSpecVlselectHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VlClusterSpecVlselectImage
 */
export interface VlClusterSpecVlselectImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VlClusterSpecVlselectImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VlClusterSpecVlselectImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VlClusterSpecVlselectImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectImage(obj: VlClusterSpecVlselectImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlClusterSpecVlselectImagePullSecrets
 */
export interface VlClusterSpecVlselectImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlselectImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectImagePullSecrets(obj: VlClusterSpecVlselectImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VLSelect to be configured with.
 * default or json
 *
 * @schema VlClusterSpecVlselectLogFormat
 */
export enum VlClusterSpecVlselectLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VLSelect to be configured with.
 *
 * @schema VlClusterSpecVlselectLogLevel
 */
export enum VlClusterSpecVlselectLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VlClusterSpecVlselectPodDisruptionBudget
 */
export interface VlClusterSpecVlselectPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VlClusterSpecVlselectPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VlClusterSpecVlselectPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VlClusterSpecVlselectPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VlClusterSpecVlselectPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlClusterSpecVlselectPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectPodDisruptionBudget(obj: VlClusterSpecVlselectPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
 *
 * @schema VlClusterSpecVlselectPodMetadata
 */
export interface VlClusterSpecVlselectPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlselectPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlselectPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlselectPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectPodMetadata(obj: VlClusterSpecVlselectPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VlClusterSpecVlselectReadinessGates
 */
export interface VlClusterSpecVlselectReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VlClusterSpecVlselectReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectReadinessGates(obj: VlClusterSpecVlselectReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VlClusterSpecVlselectResources
 */
export interface VlClusterSpecVlselectResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VlClusterSpecVlselectResources#claims
   */
  readonly claims?: VlClusterSpecVlselectResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlselectResources#limits
   */
  readonly limits?: { [key: string]: VlClusterSpecVlselectResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlselectResources#requests
   */
  readonly requests?: { [key: string]: VlClusterSpecVlselectResourcesRequests };

}

/**
 * Converts an object of type 'VlClusterSpecVlselectResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectResources(obj: VlClusterSpecVlselectResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VlClusterSpecVlselectResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VlClusterSpecVlselectRollingUpdate
 */
export interface VlClusterSpecVlselectRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VlClusterSpecVlselectRollingUpdate#maxSurge
   */
  readonly maxSurge?: VlClusterSpecVlselectRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VlClusterSpecVlselectRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlselectRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectRollingUpdate(obj: VlClusterSpecVlselectRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vlselect service spec
 *
 * @schema VlClusterSpecVlselectServiceSpec
 */
export interface VlClusterSpecVlselectServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VlClusterSpecVlselectServiceSpec#metadata
   */
  readonly metadata?: VlClusterSpecVlselectServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VlClusterSpecVlselectServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VlClusterSpecVlselectServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectServiceSpec(obj: VlClusterSpecVlselectServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VlClusterSpecVlselectServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VlClusterSpecVlselectTolerations
 */
export interface VlClusterSpecVlselectTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VlClusterSpecVlselectTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VlClusterSpecVlselectTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VlClusterSpecVlselectTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VlClusterSpecVlselectTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VlClusterSpecVlselectTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectTolerations(obj: VlClusterSpecVlselectTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VlClusterSpecVlselectUpdateStrategy
 */
export enum VlClusterSpecVlselectUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VlClusterSpecVlselectVolumeMounts
 */
export interface VlClusterSpecVlselectVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VlClusterSpecVlselectVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VlClusterSpecVlselectVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VlClusterSpecVlselectVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VlClusterSpecVlselectVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VlClusterSpecVlselectVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VlClusterSpecVlselectVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VlClusterSpecVlselectVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectVolumeMounts(obj: VlClusterSpecVlselectVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VlClusterSpecVlstorageDnsConfig
 */
export interface VlClusterSpecVlstorageDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VlClusterSpecVlstorageDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VlClusterSpecVlstorageDnsConfig#options
   */
  readonly options?: VlClusterSpecVlstorageDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VlClusterSpecVlstorageDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageDnsConfig(obj: VlClusterSpecVlstorageDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VlClusterSpecVlstorageDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VlClusterSpecVlstorageExtraEnvs
 */
export interface VlClusterSpecVlstorageExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlstorageExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VlClusterSpecVlstorageExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageExtraEnvs(obj: VlClusterSpecVlstorageExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VlClusterSpecVlstorageExtraEnvsFrom
 */
export interface VlClusterSpecVlstorageExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VlClusterSpecVlstorageExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VlClusterSpecVlstorageExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageExtraEnvsFrom(obj: VlClusterSpecVlstorageExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VlClusterSpecVlstorageExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VlClusterSpecVlstorageExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VlClusterSpecVlstorageHostAliases
 */
export interface VlClusterSpecVlstorageHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VlClusterSpecVlstorageHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VlClusterSpecVlstorageHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageHostAliases(obj: VlClusterSpecVlstorageHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VlClusterSpecVlstorageImage
 */
export interface VlClusterSpecVlstorageImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VlClusterSpecVlstorageImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VlClusterSpecVlstorageImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VlClusterSpecVlstorageImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageImage(obj: VlClusterSpecVlstorageImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlClusterSpecVlstorageImagePullSecrets
 */
export interface VlClusterSpecVlstorageImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlstorageImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageImagePullSecrets(obj: VlClusterSpecVlstorageImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VLStorage to be configured with.
 * default or json
 *
 * @schema VlClusterSpecVlstorageLogFormat
 */
export enum VlClusterSpecVlstorageLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VLStorage to be configured with.
 *
 * @schema VlClusterSpecVlstorageLogLevel
 */
export enum VlClusterSpecVlstorageLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy
 */
export interface VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy(obj: VlClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VlClusterSpecVlstoragePodDisruptionBudget
 */
export interface VlClusterSpecVlstoragePodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VlClusterSpecVlstoragePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VlClusterSpecVlstoragePodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VlClusterSpecVlstoragePodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlClusterSpecVlstoragePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstoragePodDisruptionBudget(obj: VlClusterSpecVlstoragePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VLStorage pods.
 *
 * @schema VlClusterSpecVlstoragePodMetadata
 */
export interface VlClusterSpecVlstoragePodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlstoragePodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlstoragePodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlstoragePodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstoragePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstoragePodMetadata(obj: VlClusterSpecVlstoragePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VlClusterSpecVlstorageReadinessGates
 */
export interface VlClusterSpecVlstorageReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VlClusterSpecVlstorageReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageReadinessGates(obj: VlClusterSpecVlstorageReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VlClusterSpecVlstorageResources
 */
export interface VlClusterSpecVlstorageResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VlClusterSpecVlstorageResources#claims
   */
  readonly claims?: VlClusterSpecVlstorageResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlstorageResources#limits
   */
  readonly limits?: { [key: string]: VlClusterSpecVlstorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlClusterSpecVlstorageResources#requests
   */
  readonly requests?: { [key: string]: VlClusterSpecVlstorageResourcesRequests };

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageResources(obj: VlClusterSpecVlstorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VlClusterSpecVlstorageResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
 * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
 *
 * @schema VlClusterSpecVlstorageRollingUpdateStrategyBehavior
 */
export interface VlClusterSpecVlstorageRollingUpdateStrategyBehavior {
  /**
   * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
   * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
   * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
   *
   * @schema VlClusterSpecVlstorageRollingUpdateStrategyBehavior#maxUnavailable
   */
  readonly maxUnavailable?: VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageRollingUpdateStrategyBehavior' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageRollingUpdateStrategyBehavior(obj: VlClusterSpecVlstorageRollingUpdateStrategyBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vlselect service spec
 *
 * @schema VlClusterSpecVlstorageServiceSpec
 */
export interface VlClusterSpecVlstorageServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VlClusterSpecVlstorageServiceSpec#metadata
   */
  readonly metadata?: VlClusterSpecVlstorageServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VlClusterSpecVlstorageServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VlClusterSpecVlstorageServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageServiceSpec(obj: VlClusterSpecVlstorageServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VlClusterSpecVlstorageServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage configures persistent volume for VLStorage
 *
 * @schema VlClusterSpecVlstorageStorage
 */
export interface VlClusterSpecVlstorageStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VlClusterSpecVlstorageStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VlClusterSpecVlstorageStorage#emptyDir
   */
  readonly emptyDir?: VlClusterSpecVlstorageStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VlClusterSpecVlstorageStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: any;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageStorage(obj: VlClusterSpecVlstorageStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VlClusterSpecVlstorageStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': obj.volumeClaimTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VlClusterSpecVlstorageTolerations
 */
export interface VlClusterSpecVlstorageTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VlClusterSpecVlstorageTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VlClusterSpecVlstorageTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VlClusterSpecVlstorageTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VlClusterSpecVlstorageTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VlClusterSpecVlstorageTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageTolerations(obj: VlClusterSpecVlstorageTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VlClusterSpecVlstorageVolumeMounts
 */
export interface VlClusterSpecVlstorageVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VlClusterSpecVlstorageVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VlClusterSpecVlstorageVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VlClusterSpecVlstorageVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VlClusterSpecVlstorageVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VlClusterSpecVlstorageVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VlClusterSpecVlstorageVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VlClusterSpecVlstorageVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageVolumeMounts(obj: VlClusterSpecVlstorageVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VlClusterSpecVlinsertDnsConfigOptions
 */
export interface VlClusterSpecVlinsertDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VlClusterSpecVlinsertDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VlClusterSpecVlinsertDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertDnsConfigOptions(obj: VlClusterSpecVlinsertDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VlClusterSpecVlinsertExtraEnvsFromConfigMapRef
 */
export interface VlClusterSpecVlinsertExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertExtraEnvsFromConfigMapRef(obj: VlClusterSpecVlinsertExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VlClusterSpecVlinsertExtraEnvsFromSecretRef
 */
export interface VlClusterSpecVlinsertExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VlClusterSpecVlinsertExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertExtraEnvsFromSecretRef(obj: VlClusterSpecVlinsertExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable
 */
export class VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlinsertPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable
 */
export class VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlinsertPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VlClusterSpecVlinsertResourcesClaims
 */
export interface VlClusterSpecVlinsertResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VlClusterSpecVlinsertResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VlClusterSpecVlinsertResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertResourcesClaims(obj: VlClusterSpecVlinsertResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlClusterSpecVlinsertResourcesLimits
 */
export class VlClusterSpecVlinsertResourcesLimits {
  public static fromNumber(value: number): VlClusterSpecVlinsertResourcesLimits {
    return new VlClusterSpecVlinsertResourcesLimits(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertResourcesLimits {
    return new VlClusterSpecVlinsertResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlClusterSpecVlinsertResourcesRequests
 */
export class VlClusterSpecVlinsertResourcesRequests {
  public static fromNumber(value: number): VlClusterSpecVlinsertResourcesRequests {
    return new VlClusterSpecVlinsertResourcesRequests(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertResourcesRequests {
    return new VlClusterSpecVlinsertResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VlClusterSpecVlinsertRollingUpdateMaxSurge
 */
export class VlClusterSpecVlinsertRollingUpdateMaxSurge {
  public static fromNumber(value: number): VlClusterSpecVlinsertRollingUpdateMaxSurge {
    return new VlClusterSpecVlinsertRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertRollingUpdateMaxSurge {
    return new VlClusterSpecVlinsertRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VlClusterSpecVlinsertRollingUpdateMaxUnavailable
 */
export class VlClusterSpecVlinsertRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlinsertRollingUpdateMaxUnavailable {
    return new VlClusterSpecVlinsertRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlinsertRollingUpdateMaxUnavailable {
    return new VlClusterSpecVlinsertRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VlClusterSpecVlinsertServiceSpecMetadata
 */
export interface VlClusterSpecVlinsertServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlinsertServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlinsertServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlinsertServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertServiceSpecMetadata(obj: VlClusterSpecVlinsertServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogTCPListener defines configuration for TCP syslog server listen
 *
 * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners
 */
export interface VlClusterSpecVlinsertSyslogSpecTcpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#tenantID
   */
  readonly tenantId?: string;

  /**
   * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListeners#tlsConfig
   */
  readonly tlsConfig?: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpecTcpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpecTcpListeners(obj: VlClusterSpecVlinsertSyslogSpecTcpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
    'tlsConfig': toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogUDPListener defines configuration for UDP syslog server listen
 *
 * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners
 */
export interface VlClusterSpecVlinsertSyslogSpecUdpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlClusterSpecVlinsertSyslogSpecUdpListeners#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpecUdpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpecUdpListeners(obj: VlClusterSpecVlinsertSyslogSpecUdpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VlClusterSpecVlselectDnsConfigOptions
 */
export interface VlClusterSpecVlselectDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VlClusterSpecVlselectDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VlClusterSpecVlselectDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectDnsConfigOptions(obj: VlClusterSpecVlselectDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VlClusterSpecVlselectExtraEnvsFromConfigMapRef
 */
export interface VlClusterSpecVlselectExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlselectExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VlClusterSpecVlselectExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectExtraEnvsFromConfigMapRef(obj: VlClusterSpecVlselectExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VlClusterSpecVlselectExtraEnvsFromSecretRef
 */
export interface VlClusterSpecVlselectExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlselectExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VlClusterSpecVlselectExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectExtraEnvsFromSecretRef(obj: VlClusterSpecVlselectExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable
 */
export class VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlselectPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VlClusterSpecVlselectPodDisruptionBudgetMinAvailable
 */
export class VlClusterSpecVlselectPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VlClusterSpecVlselectPodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlselectPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectPodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlselectPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VlClusterSpecVlselectResourcesClaims
 */
export interface VlClusterSpecVlselectResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VlClusterSpecVlselectResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VlClusterSpecVlselectResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectResourcesClaims(obj: VlClusterSpecVlselectResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlClusterSpecVlselectResourcesLimits
 */
export class VlClusterSpecVlselectResourcesLimits {
  public static fromNumber(value: number): VlClusterSpecVlselectResourcesLimits {
    return new VlClusterSpecVlselectResourcesLimits(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectResourcesLimits {
    return new VlClusterSpecVlselectResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlClusterSpecVlselectResourcesRequests
 */
export class VlClusterSpecVlselectResourcesRequests {
  public static fromNumber(value: number): VlClusterSpecVlselectResourcesRequests {
    return new VlClusterSpecVlselectResourcesRequests(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectResourcesRequests {
    return new VlClusterSpecVlselectResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VlClusterSpecVlselectRollingUpdateMaxSurge
 */
export class VlClusterSpecVlselectRollingUpdateMaxSurge {
  public static fromNumber(value: number): VlClusterSpecVlselectRollingUpdateMaxSurge {
    return new VlClusterSpecVlselectRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectRollingUpdateMaxSurge {
    return new VlClusterSpecVlselectRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VlClusterSpecVlselectRollingUpdateMaxUnavailable
 */
export class VlClusterSpecVlselectRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlselectRollingUpdateMaxUnavailable {
    return new VlClusterSpecVlselectRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlselectRollingUpdateMaxUnavailable {
    return new VlClusterSpecVlselectRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VlClusterSpecVlselectServiceSpecMetadata
 */
export interface VlClusterSpecVlselectServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlselectServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlselectServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlselectServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlselectServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlselectServiceSpecMetadata(obj: VlClusterSpecVlselectServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VlClusterSpecVlstorageDnsConfigOptions
 */
export interface VlClusterSpecVlstorageDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VlClusterSpecVlstorageDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VlClusterSpecVlstorageDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageDnsConfigOptions(obj: VlClusterSpecVlstorageDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VlClusterSpecVlstorageExtraEnvsFromConfigMapRef
 */
export interface VlClusterSpecVlstorageExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageExtraEnvsFromConfigMapRef(obj: VlClusterSpecVlstorageExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VlClusterSpecVlstorageExtraEnvsFromSecretRef
 */
export interface VlClusterSpecVlstorageExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VlClusterSpecVlstorageExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageExtraEnvsFromSecretRef(obj: VlClusterSpecVlstorageExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable
 */
export class VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable {
    return new VlClusterSpecVlstoragePodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable
 */
export class VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable {
    return new VlClusterSpecVlstoragePodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VlClusterSpecVlstorageResourcesClaims
 */
export interface VlClusterSpecVlstorageResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VlClusterSpecVlstorageResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VlClusterSpecVlstorageResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageResourcesClaims(obj: VlClusterSpecVlstorageResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlClusterSpecVlstorageResourcesLimits
 */
export class VlClusterSpecVlstorageResourcesLimits {
  public static fromNumber(value: number): VlClusterSpecVlstorageResourcesLimits {
    return new VlClusterSpecVlstorageResourcesLimits(value);
  }
  public static fromString(value: string): VlClusterSpecVlstorageResourcesLimits {
    return new VlClusterSpecVlstorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlClusterSpecVlstorageResourcesRequests
 */
export class VlClusterSpecVlstorageResourcesRequests {
  public static fromNumber(value: number): VlClusterSpecVlstorageResourcesRequests {
    return new VlClusterSpecVlstorageResourcesRequests(value);
  }
  public static fromString(value: string): VlClusterSpecVlstorageResourcesRequests {
    return new VlClusterSpecVlstorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
 * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
 * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
 *
 * @schema VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable
 */
export class VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable {
  public static fromNumber(value: number): VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  public static fromString(value: string): VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VlClusterSpecVlstorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VlClusterSpecVlstorageServiceSpecMetadata
 */
export interface VlClusterSpecVlstorageServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlClusterSpecVlstorageServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlClusterSpecVlstorageServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlClusterSpecVlstorageServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageServiceSpecMetadata(obj: VlClusterSpecVlstorageServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VlClusterSpecVlstorageStorageEmptyDir
 */
export interface VlClusterSpecVlstorageStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VlClusterSpecVlstorageStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VlClusterSpecVlstorageStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VlClusterSpecVlstorageStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VlClusterSpecVlstorageStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlstorageStorageEmptyDir(obj: VlClusterSpecVlstorageStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
 *
 * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig
 */
export interface VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig {
  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecret
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig#certSecret
   */
  readonly certSecret?: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret;

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig#keySecret
   */
  readonly keySecret?: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig(obj: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certFile': obj.certFile,
    'certSecret': toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret(obj.certSecret),
    'keyFile': obj.keyFile,
    'keySecret': toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret(obj.keySecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VlClusterSpecVlstorageStorageEmptyDirSizeLimit
 */
export class VlClusterSpecVlstorageStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VlClusterSpecVlstorageStorageEmptyDirSizeLimit {
    return new VlClusterSpecVlstorageStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VlClusterSpecVlstorageStorageEmptyDirSizeLimit {
    return new VlClusterSpecVlstorageStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret
 */
export interface VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret(obj: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret
 */
export interface VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret(obj: VlClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VLogs is fast, cost-effective and scalable logs database.
VLogs is the Schema for the vlogs API
 *
 * @schema VLogs
 */
export class VLogs extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VLogs"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VLogs',
  }

  /**
   * Renders a Kubernetes manifest for "VLogs".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VLogsProps = {}): any {
    return {
      ...VLogs.GVK,
      ...toJson_VLogsProps(props),
    };
  }

  /**
   * Defines a "VLogs" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VLogsProps = {}) {
    super(scope, id, {
      ...VLogs.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VLogs.GVK,
      ...toJson_VLogsProps(resolved),
    };
  }
}

/**
 * VLogs is fast, cost-effective and scalable logs database.
 * VLogs is the Schema for the vlogs API
 *
 * @schema VLogs
 */
export interface VLogsProps {
  /**
   * @schema VLogs#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VLogsSpec defines the desired state of VLogs
   * VLogs is deprecated, migrate to the VLSingle
   *
   * @schema VLogs#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'VLogsProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VLogsProps(obj: VLogsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VLSingle is fast, cost-effective and scalable logs database.
VLSingle is the Schema for the API
 *
 * @schema VLSingle
 */
export class VlSingle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VLSingle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VLSingle',
  }

  /**
   * Renders a Kubernetes manifest for "VLSingle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VlSingleProps = {}): any {
    return {
      ...VlSingle.GVK,
      ...toJson_VlSingleProps(props),
    };
  }

  /**
   * Defines a "VLSingle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VlSingleProps = {}) {
    super(scope, id, {
      ...VlSingle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VlSingle.GVK,
      ...toJson_VlSingleProps(resolved),
    };
  }
}

/**
 * VLSingle is fast, cost-effective and scalable logs database.
 * VLSingle is the Schema for the API
 *
 * @schema VLSingle
 */
export interface VlSingleProps {
  /**
   * @schema VLSingle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VLSingleSpec defines the desired state of VLSingle
   *
   * @schema VLSingle#spec
   */
  readonly spec?: VlSingleSpec;

}

/**
 * Converts an object of type 'VlSingleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleProps(obj: VlSingleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VlSingleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VLSingleSpec defines the desired state of VLSingle
 *
 * @schema VlSingleSpec
 */
export interface VlSingleSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VlSingleSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VlSingleSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VlSingleSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VlSingleSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VlSingleSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VlSingleSpec#dnsConfig
   */
  readonly dnsConfig?: VlSingleSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VlSingleSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VlSingleSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VlSingleSpec#extraEnvs
   */
  readonly extraEnvs?: VlSingleSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VlSingleSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VlSingleSpecExtraEnvsFrom[];

  /**
   * FutureRetention for the stored logs
   * Log entries with timestamps bigger than now+futureRetention are rejected during data ingestion; see https://docs.victoriametrics.com/victorialogs/#retention
   *
   * @schema VlSingleSpec#futureRetention
   */
  readonly futureRetention?: string;

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VlSingleSpec#hostAliases
   */
  readonly hostAliases?: VlSingleSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VlSingleSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VlSingleSpec#image
   */
  readonly image?: VlSingleSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VlSingleSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VlSingleSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VlSingleSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VlSingleSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VLSingle to be configured with.
   *
   * @schema VlSingleSpec#logFormat
   */
  readonly logFormat?: VlSingleSpecLogFormat;

  /**
   * Whether to log all the ingested log entries; this can be useful for debugging of data ingestion; see https://docs.victoriametrics.com/victorialogs/data-ingestion/
   *
   * @schema VlSingleSpec#logIngestedRows
   */
  readonly logIngestedRows?: boolean;

  /**
   * LogLevel for VictoriaLogs to be configured with.
   *
   * @schema VlSingleSpec#logLevel
   */
  readonly logLevel?: VlSingleSpecLogLevel;

  /**
   * LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams; see https://docs.victoriametrics.com/victorialogs/keyconcepts/#stream-fields
   *
   * @schema VlSingleSpec#logNewStreams
   */
  readonly logNewStreams?: boolean;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VlSingleSpec#managedMetadata
   */
  readonly managedMetadata?: VlSingleSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VlSingleSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VlSingleSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VlSingleSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VLSingle pods.
   *
   * @schema VlSingleSpec#podMetadata
   */
  readonly podMetadata?: VlSingleSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VlSingleSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VlSingleSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VlSingleSpec#readinessGates
   */
  readonly readinessGates?: VlSingleSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VlSingleSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VlSingleSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VlSingleSpec#resources
   */
  readonly resources?: VlSingleSpecResources;

  /**
   * RetentionMaxDiskSpaceUsageBytes for the stored logs
   * VictoriaLogs keeps at least two last days of data in order to guarantee that the logs for the last day can be returned in queries.
   * This means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,
   * if the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.
   * https://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage
   *
   * @schema VlSingleSpec#retentionMaxDiskSpaceUsageBytes
   */
  readonly retentionMaxDiskSpaceUsageBytes?: string;

  /**
   * RetentionPeriod for the stored logs
   * https://docs.victoriametrics.com/victorialogs/#retention
   *
   * @schema VlSingleSpec#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VlSingleSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VlSingleSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VlSingleSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VlSingleSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VlSingleSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VlSingleSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vlsingle VMServiceScrape spec
   *
   * @schema VlSingleSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vlsingle service spec
   *
   * @schema VlSingleSpec#serviceSpec
   */
  readonly serviceSpec?: VlSingleSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VlSingleSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage is the definition of how storage will be used by the VLSingle
   * by default it`s empty dir
   *
   * @schema VlSingleSpec#storage
   */
  readonly storage?: VlSingleSpecStorage;

  /**
   * StorageDataPath disables spec.storage option and overrides arg for victoria-logs binary --storageDataPath,
   * its users responsibility to mount proper device into given path.
   *
   * @schema VlSingleSpec#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * StorageMeta defines annotations and labels attached to PVC for given vlsingle CR
   *
   * @schema VlSingleSpec#storageMetadata
   */
  readonly storageMetadata?: VlSingleSpecStorageMetadata;

  /**
   * SyslogSpec defines syslog listener configuration
   *
   * @schema VlSingleSpec#syslogSpec
   */
  readonly syslogSpec?: VlSingleSpecSyslogSpec;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VlSingleSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VlSingleSpec#tolerations
   */
  readonly tolerations?: VlSingleSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VlSingleSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VlSingleSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VlSingleSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VlSingleSpec#volumeMounts
   */
  readonly volumeMounts?: VlSingleSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VlSingleSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VlSingleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpec(obj: VlSingleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VlSingleSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VlSingleSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VlSingleSpecExtraEnvsFrom(y)),
    'futureRetention': obj.futureRetention,
    'hostAliases': obj.hostAliases?.map(y => toJson_VlSingleSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VlSingleSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VlSingleSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logIngestedRows': obj.logIngestedRows,
    'logLevel': obj.logLevel,
    'logNewStreams': obj.logNewStreams,
    'managedMetadata': toJson_VlSingleSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podMetadata': toJson_VlSingleSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VlSingleSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VlSingleSpecResources(obj.resources),
    'retentionMaxDiskSpaceUsageBytes': obj.retentionMaxDiskSpaceUsageBytes,
    'retentionPeriod': obj.retentionPeriod,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VlSingleSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VlSingleSpecStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'storageMetadata': toJson_VlSingleSpecStorageMetadata(obj.storageMetadata),
    'syslogSpec': toJson_VlSingleSpecSyslogSpec(obj.syslogSpec),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VlSingleSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VlSingleSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VlSingleSpecDnsConfig
 */
export interface VlSingleSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VlSingleSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VlSingleSpecDnsConfig#options
   */
  readonly options?: VlSingleSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VlSingleSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VlSingleSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecDnsConfig(obj: VlSingleSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VlSingleSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VlSingleSpecExtraEnvs
 */
export interface VlSingleSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VlSingleSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VlSingleSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlSingleSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecExtraEnvs(obj: VlSingleSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VlSingleSpecExtraEnvsFrom
 */
export interface VlSingleSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VlSingleSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VlSingleSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VlSingleSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VlSingleSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VlSingleSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VlSingleSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecExtraEnvsFrom(obj: VlSingleSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VlSingleSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VlSingleSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VlSingleSpecHostAliases
 */
export interface VlSingleSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VlSingleSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VlSingleSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VlSingleSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecHostAliases(obj: VlSingleSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VlSingleSpecImage
 */
export interface VlSingleSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VlSingleSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VlSingleSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VlSingleSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VlSingleSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecImage(obj: VlSingleSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VlSingleSpecImagePullSecrets
 */
export interface VlSingleSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlSingleSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlSingleSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecImagePullSecrets(obj: VlSingleSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VLSingle to be configured with.
 *
 * @schema VlSingleSpecLogFormat
 */
export enum VlSingleSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VictoriaLogs to be configured with.
 *
 * @schema VlSingleSpecLogLevel
 */
export enum VlSingleSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VlSingleSpecManagedMetadata
 */
export interface VlSingleSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlSingleSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlSingleSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlSingleSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecManagedMetadata(obj: VlSingleSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VLSingle pods.
 *
 * @schema VlSingleSpecPodMetadata
 */
export interface VlSingleSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlSingleSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlSingleSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlSingleSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlSingleSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecPodMetadata(obj: VlSingleSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VlSingleSpecReadinessGates
 */
export interface VlSingleSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VlSingleSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VlSingleSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecReadinessGates(obj: VlSingleSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VlSingleSpecResources
 */
export interface VlSingleSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VlSingleSpecResources#claims
   */
  readonly claims?: VlSingleSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlSingleSpecResources#limits
   */
  readonly limits?: { [key: string]: VlSingleSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlSingleSpecResources#requests
   */
  readonly requests?: { [key: string]: VlSingleSpecResourcesRequests };

}

/**
 * Converts an object of type 'VlSingleSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecResources(obj: VlSingleSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VlSingleSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vlsingle service spec
 *
 * @schema VlSingleSpecServiceSpec
 */
export interface VlSingleSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VlSingleSpecServiceSpec#metadata
   */
  readonly metadata?: VlSingleSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VlSingleSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VlSingleSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VlSingleSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecServiceSpec(obj: VlSingleSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VlSingleSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage is the definition of how storage will be used by the VLSingle
 * by default it`s empty dir
 *
 * @schema VlSingleSpecStorage
 */
export interface VlSingleSpecStorage {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VlSingleSpecStorage#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VlSingleSpecStorage#dataSource
   */
  readonly dataSource?: VlSingleSpecStorageDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlSingleSpecStorage#dataSourceRef
   */
  readonly dataSourceRef?: VlSingleSpecStorageDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VlSingleSpecStorage#resources
   */
  readonly resources?: VlSingleSpecStorageResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VlSingleSpecStorage#selector
   */
  readonly selector?: VlSingleSpecStorageSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VlSingleSpecStorage#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VlSingleSpecStorage#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VlSingleSpecStorage#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VlSingleSpecStorage#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VlSingleSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorage(obj: VlSingleSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VlSingleSpecStorageDataSource(obj.dataSource),
    'dataSourceRef': toJson_VlSingleSpecStorageDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VlSingleSpecStorageResources(obj.resources),
    'selector': toJson_VlSingleSpecStorageSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StorageMeta defines annotations and labels attached to PVC for given vlsingle CR
 *
 * @schema VlSingleSpecStorageMetadata
 */
export interface VlSingleSpecStorageMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlSingleSpecStorageMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlSingleSpecStorageMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlSingleSpecStorageMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlSingleSpecStorageMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageMetadata(obj: VlSingleSpecStorageMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogSpec defines syslog listener configuration
 *
 * @schema VlSingleSpecSyslogSpec
 */
export interface VlSingleSpecSyslogSpec {
  /**
   * TCPListeners defines syslog server TCP listener configuration
   *
   * @schema VlSingleSpecSyslogSpec#tcpListeners
   */
  readonly tcpListeners?: VlSingleSpecSyslogSpecTcpListeners[];

  /**
   * UDPListeners defines syslog server UDP listener configuration
   *
   * @schema VlSingleSpecSyslogSpec#udpListeners
   */
  readonly udpListeners?: VlSingleSpecSyslogSpecUdpListeners[];

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpec(obj: VlSingleSpecSyslogSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tcpListeners': obj.tcpListeners?.map(y => toJson_VlSingleSpecSyslogSpecTcpListeners(y)),
    'udpListeners': obj.udpListeners?.map(y => toJson_VlSingleSpecSyslogSpecUdpListeners(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VlSingleSpecTolerations
 */
export interface VlSingleSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VlSingleSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VlSingleSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VlSingleSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VlSingleSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VlSingleSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlSingleSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecTolerations(obj: VlSingleSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VlSingleSpecVolumeMounts
 */
export interface VlSingleSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VlSingleSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VlSingleSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VlSingleSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VlSingleSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VlSingleSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VlSingleSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VlSingleSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VlSingleSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecVolumeMounts(obj: VlSingleSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VlSingleSpecDnsConfigOptions
 */
export interface VlSingleSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VlSingleSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VlSingleSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VlSingleSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecDnsConfigOptions(obj: VlSingleSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VlSingleSpecExtraEnvsFromConfigMapRef
 */
export interface VlSingleSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlSingleSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VlSingleSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlSingleSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecExtraEnvsFromConfigMapRef(obj: VlSingleSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VlSingleSpecExtraEnvsFromSecretRef
 */
export interface VlSingleSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlSingleSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VlSingleSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlSingleSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecExtraEnvsFromSecretRef(obj: VlSingleSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VlSingleSpecResourcesClaims
 */
export interface VlSingleSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VlSingleSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VlSingleSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VlSingleSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecResourcesClaims(obj: VlSingleSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlSingleSpecResourcesLimits
 */
export class VlSingleSpecResourcesLimits {
  public static fromNumber(value: number): VlSingleSpecResourcesLimits {
    return new VlSingleSpecResourcesLimits(value);
  }
  public static fromString(value: string): VlSingleSpecResourcesLimits {
    return new VlSingleSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlSingleSpecResourcesRequests
 */
export class VlSingleSpecResourcesRequests {
  public static fromNumber(value: number): VlSingleSpecResourcesRequests {
    return new VlSingleSpecResourcesRequests(value);
  }
  public static fromString(value: string): VlSingleSpecResourcesRequests {
    return new VlSingleSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VlSingleSpecServiceSpecMetadata
 */
export interface VlSingleSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VlSingleSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VlSingleSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VlSingleSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VlSingleSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecServiceSpecMetadata(obj: VlSingleSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VlSingleSpecStorageDataSource
 */
export interface VlSingleSpecStorageDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlSingleSpecStorageDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlSingleSpecStorageDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlSingleSpecStorageDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VlSingleSpecStorageDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageDataSource(obj: VlSingleSpecStorageDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VlSingleSpecStorageDataSourceRef
 */
export interface VlSingleSpecStorageDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VlSingleSpecStorageDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VlSingleSpecStorageDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VlSingleSpecStorageDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VlSingleSpecStorageDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VlSingleSpecStorageDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageDataSourceRef(obj: VlSingleSpecStorageDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VlSingleSpecStorageResources
 */
export interface VlSingleSpecStorageResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlSingleSpecStorageResources#limits
   */
  readonly limits?: { [key: string]: VlSingleSpecStorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VlSingleSpecStorageResources#requests
   */
  readonly requests?: { [key: string]: VlSingleSpecStorageResourcesRequests };

}

/**
 * Converts an object of type 'VlSingleSpecStorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageResources(obj: VlSingleSpecStorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VlSingleSpecStorageSelector
 */
export interface VlSingleSpecStorageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VlSingleSpecStorageSelector#matchExpressions
   */
  readonly matchExpressions?: VlSingleSpecStorageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VlSingleSpecStorageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VlSingleSpecStorageSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageSelector(obj: VlSingleSpecStorageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VlSingleSpecStorageSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogTCPListener defines configuration for TCP syslog server listen
 *
 * @schema VlSingleSpecSyslogSpecTcpListeners
 */
export interface VlSingleSpecSyslogSpecTcpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#tenantID
   */
  readonly tenantId?: string;

  /**
   * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
   *
   * @schema VlSingleSpecSyslogSpecTcpListeners#tlsConfig
   */
  readonly tlsConfig?: VlSingleSpecSyslogSpecTcpListenersTlsConfig;

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpecTcpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpecTcpListeners(obj: VlSingleSpecSyslogSpecTcpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
    'tlsConfig': toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyslogUDPListener defines configuration for UDP syslog server listen
 *
 * @schema VlSingleSpecSyslogSpecUdpListeners
 */
export interface VlSingleSpecSyslogSpecUdpListeners {
  /**
   * CompressMethod for syslog messages
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#compressMethod
   */
  readonly compressMethod?: string;

  /**
   * DecolorizeFields to remove ANSI color codes across logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#decolorizeFields
   */
  readonly decolorizeFields?: string;

  /**
   * IgnoreFields to ignore at logs
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#ignoreFields
   */
  readonly ignoreFields?: string;

  /**
   * ListenPort defines listen port
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#listenPort
   */
  readonly listenPort: number;

  /**
   * StreamFields to use as log stream labels
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#streamFields
   */
  readonly streamFields?: string;

  /**
   * TenantID for logs ingested in form of accountID:projectID
   * see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
   *
   * @schema VlSingleSpecSyslogSpecUdpListeners#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpecUdpListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpecUdpListeners(obj: VlSingleSpecSyslogSpecUdpListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressMethod': obj.compressMethod,
    'decolorizeFields': obj.decolorizeFields,
    'ignoreFields': obj.ignoreFields,
    'listenPort': obj.listenPort,
    'streamFields': obj.streamFields,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VlSingleSpecStorageResourcesLimits
 */
export class VlSingleSpecStorageResourcesLimits {
  public static fromNumber(value: number): VlSingleSpecStorageResourcesLimits {
    return new VlSingleSpecStorageResourcesLimits(value);
  }
  public static fromString(value: string): VlSingleSpecStorageResourcesLimits {
    return new VlSingleSpecStorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VlSingleSpecStorageResourcesRequests
 */
export class VlSingleSpecStorageResourcesRequests {
  public static fromNumber(value: number): VlSingleSpecStorageResourcesRequests {
    return new VlSingleSpecStorageResourcesRequests(value);
  }
  public static fromString(value: string): VlSingleSpecStorageResourcesRequests {
    return new VlSingleSpecStorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VlSingleSpecStorageSelectorMatchExpressions
 */
export interface VlSingleSpecStorageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VlSingleSpecStorageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VlSingleSpecStorageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VlSingleSpecStorageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VlSingleSpecStorageSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecStorageSelectorMatchExpressions(obj: VlSingleSpecStorageSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
 *
 * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfig
 */
export interface VlSingleSpecSyslogSpecTcpListenersTlsConfig {
  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecret
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfig#certSecret
   */
  readonly certSecret?: VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret;

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfig#keySecret
   */
  readonly keySecret?: VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret;

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpecTcpListenersTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfig(obj: VlSingleSpecSyslogSpecTcpListenersTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certFile': obj.certFile,
    'certSecret': toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret(obj.certSecret),
    'keyFile': obj.keyFile,
    'keySecret': toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret(obj.keySecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret
 */
export interface VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret(obj: VlSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret
 */
export interface VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret(obj: VlSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAgent - is a tiny but brave agent, which helps you collect metrics from various sources and stores them in VictoriaMetrics
or any other Prometheus-compatible storage system that supports the remote_write protocol.
 *
 * @schema VMAgent
 */
export class VmAgent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAgent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMAgent',
  }

  /**
   * Renders a Kubernetes manifest for "VMAgent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAgentProps = {}): any {
    return {
      ...VmAgent.GVK,
      ...toJson_VmAgentProps(props),
    };
  }

  /**
   * Defines a "VMAgent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAgentProps = {}) {
    super(scope, id, {
      ...VmAgent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAgent.GVK,
      ...toJson_VmAgentProps(resolved),
    };
  }
}

/**
 * VMAgent - is a tiny but brave agent, which helps you collect metrics from various sources and stores them in VictoriaMetrics
 * or any other Prometheus-compatible storage system that supports the remote_write protocol.
 *
 * @schema VMAgent
 */
export interface VmAgentProps {
  /**
   * @schema VMAgent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMAgentSpec defines the desired state of VMAgent
   *
   * @schema VMAgent#spec
   */
  readonly spec?: VmAgentSpec;

}

/**
 * Converts an object of type 'VmAgentProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentProps(obj: VmAgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAgentSpec defines the desired state of VMAgent
 *
 * @schema VmAgentSpec
 */
export interface VmAgentSpec {
  /**
   * APIServerConfig allows specifying a host and auth methods to access apiserver.
   * If left empty, VMAgent is assumed to run inside of the cluster
   * and will discover API servers automatically and use the pod's CA certificate
   * and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   * aPIServerConfig is deprecated use apiServerConfig instead
   *
   * @schema VmAgentSpec#aPIServerConfig
   */
  readonly aPiServerConfig?: any;

  /**
   * AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it
   * is valid. Note that using this feature may expose the possibility to
   * break upgrades of VMAgent. It is advised to review VMAgent release
   * notes to ensure that no incompatible scrape configs are going to break
   * VMAgent after the upgrade.
   *
   * @schema VmAgentSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: VmAgentSpecAdditionalScrapeConfigs;

  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmAgentSpec#affinity
   */
  readonly affinity?: any;

  /**
   * APIServerConfig allows specifying a host and auth methods to access apiserver.
   * If left empty, VMAgent is assumed to run inside of the cluster
   * and will discover API servers automatically and use the pod's CA certificate
   * and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema VmAgentSpec#apiServerConfig
   */
  readonly apiServerConfig?: VmAgentSpecApiServerConfig;

  /**
   * ArbitraryFSAccessThroughSMs configures whether configuration
   * based on EndpointAuth can access arbitrary files on the file system
   * of the VMAgent container e.g. bearer token files, basic auth, tls certs
   *
   * @schema VmAgentSpec#arbitraryFSAccessThroughSMs
   */
  readonly arbitraryFsAccessThroughSMs?: VmAgentSpecArbitraryFsAccessThroughSMs;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for VMAgent in StatefulMode
   *
   * @schema VmAgentSpec#claimTemplates
   */
  readonly claimTemplates?: VmAgentSpecClaimTemplates[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmAgentSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
   * Given secret reference will be added to the application and vm-config-reloader as volume
   * available since v0.57.0 version
   *
   * @schema VmAgentSpec#configReloadAuthKeySecret
   */
  readonly configReloadAuthKeySecret?: VmAgentSpecConfigReloadAuthKeySecret;

  /**
   * ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
   * for example resyncInterval: "30s"
   *
   * @schema VmAgentSpec#configReloaderExtraArgs
   */
  readonly configReloaderExtraArgs?: { [key: string]: string };

  /**
   * ConfigReloaderImageTag defines image:tag for config-reloader container
   *
   * @schema VmAgentSpec#configReloaderImageTag
   */
  readonly configReloaderImageTag?: string;

  /**
   * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAgentSpec#configReloaderResources
   */
  readonly configReloaderResources?: VmAgentSpecConfigReloaderResources;

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmAgentSpec#containers
   */
  readonly containers?: any[];

  /**
   * DaemonSetMode enables DaemonSet deployment mode instead of Deployment.
   * Supports only VMPodScrape
   * (available from v0.55.0).
   * Cannot be used with statefulMode
   *
   * @schema VmAgentSpec#daemonSetMode
   */
  readonly daemonSetMode?: boolean;

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmAgentSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmAgentSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmAgentSpec#dnsConfig
   */
  readonly dnsConfig?: VmAgentSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmAgentSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableKubernetesAPISelectors instructs vmagent to use CRD scrape objects spec.selectors for
   * Kubernetes API list and watch requests.
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#list-and-watch-filtering
   * It could be useful to reduce Kubernetes API server resource usage for serving less than 100 CRD scrape objects in total.
   *
   * @schema VmAgentSpec#enableKubernetesAPISelectors
   */
  readonly enableKubernetesApiSelectors?: boolean;

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
   * and metric that is user created. The label value will always be the namespace of the object that is
   * being created.
   *
   * @schema VmAgentSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * ExternalLabels The labels to add to any time series scraped by vmagent.
   * it doesn't affect metrics ingested directly by push API's
   *
   * @schema VmAgentSpec#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmAgentSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmAgentSpec#extraEnvs
   */
  readonly extraEnvs?: VmAgentSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmAgentSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmAgentSpecExtraEnvsFrom[];

  /**
   * GlobalScrapeMetricRelabelConfigs is a global metric relabel configuration, which is applied to each scrape job.
   *
   * @schema VmAgentSpec#globalScrapeMetricRelabelConfigs
   */
  readonly globalScrapeMetricRelabelConfigs?: VmAgentSpecGlobalScrapeMetricRelabelConfigs[];

  /**
   * GlobalScrapeRelabelConfigs is a global relabel configuration, which is applied to each samples of each scrape job during service discovery.
   *
   * @schema VmAgentSpec#globalScrapeRelabelConfigs
   */
  readonly globalScrapeRelabelConfigs?: VmAgentSpecGlobalScrapeRelabelConfigs[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmAgentSpec#hostAliases
   */
  readonly hostAliases?: VmAgentSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmAgentSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from
   * scrape objects, and they will only discover endpoints
   * within their current namespace.  Defaults to false.
   *
   * @default false.
   * @schema VmAgentSpec#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmAgentSpec#image
   */
  readonly image?: VmAgentSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmAgentSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmAgentSpecImagePullSecrets[];

  /**
   * IngestOnlyMode switches vmagent into unmanaged mode
   * it disables any config generation for scraping
   * Currently it prevents vmagent from managing tls and auth options for remote write
   *
   * @schema VmAgentSpec#ingestOnlyMode
   */
  readonly ingestOnlyMode?: boolean;

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmAgentSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * InlineRelabelConfig - defines GlobalRelabelConfig for vmagent, can be defined directly at CRD.
   *
   * @schema VmAgentSpec#inlineRelabelConfig
   */
  readonly inlineRelabelConfig?: VmAgentSpecInlineRelabelConfig[];

  /**
   * InlineScrapeConfig As scrape configs are appended, the user is responsible to make sure it
   * is valid. Note that using this feature may expose the possibility to
   * break upgrades of VMAgent. It is advised to review VMAgent release
   * notes to ensure that no incompatible scrape configs are going to break
   * VMAgent after the upgrade.
   * it should be defined as single yaml file.
   * inlineScrapeConfig: |
   * - job_name: "prometheus"
   * static_configs:
   * - targets: ["localhost:9090"]
   *
   * @schema VmAgentSpec#inlineScrapeConfig
   */
  readonly inlineScrapeConfig?: string;

  /**
   * InsertPorts - additional listen ports for data ingestion.
   *
   * @schema VmAgentSpec#insertPorts
   */
  readonly insertPorts?: VmAgentSpecInsertPorts;

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmAgentSpec#license
   */
  readonly license?: VmAgentSpecLicense;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmAgentSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMAgent to be configured with.
   *
   * @schema VmAgentSpec#logFormat
   */
  readonly logFormat?: VmAgentSpecLogFormat;

  /**
   * LogLevel for VMAgent to be configured with.
   * INFO, WARN, ERROR, FATAL, PANIC
   *
   * @schema VmAgentSpec#logLevel
   */
  readonly logLevel?: VmAgentSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmAgentSpec#managedMetadata
   */
  readonly managedMetadata?: VmAgentSpecManagedMetadata;

  /**
   * MaxScrapeInterval allows limiting maximum scrape interval for VMServiceScrape, VMPodScrape and other scrapes
   * If interval is higher than defined limit, `maxScrapeInterval` will be used.
   *
   * @schema VmAgentSpec#maxScrapeInterval
   */
  readonly maxScrapeInterval?: string;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmAgentSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * MinScrapeInterval allows limiting minimal scrape interval for VMServiceScrape, VMPodScrape and other scrapes
   * If interval is lower than defined limit, `minScrapeInterval` will be used.
   *
   * @schema VmAgentSpec#minScrapeInterval
   */
  readonly minScrapeInterval?: string;

  /**
   * NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#nodeScrapeNamespaceSelector
   */
  readonly nodeScrapeNamespaceSelector?: VmAgentSpecNodeScrapeNamespaceSelector;

  /**
   * NodeScrapeRelabelTemplate defines relabel config, that will be added to each VMNodeScrape.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#nodeScrapeRelabelTemplate
   */
  readonly nodeScrapeRelabelTemplate?: VmAgentSpecNodeScrapeRelabelTemplate[];

  /**
   * NodeScrapeSelector defines VMNodeScrape to be selected for scraping.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#nodeScrapeSelector
   */
  readonly nodeScrapeSelector?: VmAgentSpecNodeScrapeSelector;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmAgentSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * OverrideHonorLabels if set to true overrides all user configured honor_labels.
   * If HonorLabels is set in scrape objects  to true, this overrides honor_labels to false.
   *
   * @schema VmAgentSpec#overrideHonorLabels
   */
  readonly overrideHonorLabels?: boolean;

  /**
   * OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
   *
   * @schema VmAgentSpec#overrideHonorTimestamps
   */
  readonly overrideHonorTimestamps?: boolean;

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmAgentSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VmAgentSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VmAgentSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmAgentSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmAgentSpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.
   *
   * @schema VmAgentSpec#podMetadata
   */
  readonly podMetadata?: VmAgentSpecPodMetadata;

  /**
   * PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#podScrapeNamespaceSelector
   */
  readonly podScrapeNamespaceSelector?: VmAgentSpecPodScrapeNamespaceSelector;

  /**
   * PodScrapeRelabelTemplate defines relabel config, that will be added to each VMPodScrape.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#podScrapeRelabelTemplate
   */
  readonly podScrapeRelabelTemplate?: VmAgentSpecPodScrapeRelabelTemplate[];

  /**
   * PodScrapeSelector defines PodScrapes to be selected for target discovery.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#podScrapeSelector
   */
  readonly podScrapeSelector?: VmAgentSpecPodScrapeSelector;

  /**
   * Port listen address
   *
   * @schema VmAgentSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmAgentSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#probeNamespaceSelector
   */
  readonly probeNamespaceSelector?: VmAgentSpecProbeNamespaceSelector;

  /**
   * ProbeScrapeRelabelTemplate defines relabel config, that will be added to each VMProbeScrape.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#probeScrapeRelabelTemplate
   */
  readonly probeScrapeRelabelTemplate?: VmAgentSpecProbeScrapeRelabelTemplate[];

  /**
   * ProbeSelector defines VMProbe to be selected for target probing.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#probeSelector
   */
  readonly probeSelector?: VmAgentSpecProbeSelector;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmAgentSpec#readinessGates
   */
  readonly readinessGates?: VmAgentSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmAgentSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig
   * This relabeling is applied to all the collected metrics before sending them to remote storage.
   *
   * @schema VmAgentSpec#relabelConfig
   */
  readonly relabelConfig?: VmAgentSpecRelabelConfig;

  /**
   * RemoteWrite list of victoria metrics /some other remote write system
   * for vm it must looks like: http://victoria-metrics-single:8428/api/v1/write
   * or for cluster different url
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#splitting-data-streams-among-multiple-systems
   *
   * @schema VmAgentSpec#remoteWrite
   */
  readonly remoteWrite: VmAgentSpecRemoteWrite[];

  /**
   * RemoteWriteSettings defines global settings for all remoteWrite urls.
   *
   * @schema VmAgentSpec#remoteWriteSettings
   */
  readonly remoteWriteSettings?: VmAgentSpecRemoteWriteSettings;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmAgentSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAgentSpec#resources
   */
  readonly resources?: VmAgentSpecResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmAgentSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VmAgentSpec#rollingUpdate
   */
  readonly rollingUpdate?: VmAgentSpecRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmAgentSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmAgentSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * ScrapeConfigNamespaceSelector defines Namespaces to be selected for VMScrapeConfig discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#scrapeConfigNamespaceSelector
   */
  readonly scrapeConfigNamespaceSelector?: VmAgentSpecScrapeConfigNamespaceSelector;

  /**
   * ScrapeConfigRelabelTemplate defines relabel config, that will be added to each VMScrapeConfig.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#scrapeConfigRelabelTemplate
   */
  readonly scrapeConfigRelabelTemplate?: VmAgentSpecScrapeConfigRelabelTemplate[];

  /**
   * ScrapeConfigSelector defines VMScrapeConfig to be selected for target discovery.
   * Works in combination with NamespaceSelector.
   *
   * @schema VmAgentSpec#scrapeConfigSelector
   */
  readonly scrapeConfigSelector?: VmAgentSpecScrapeConfigSelector;

  /**
   * ScrapeInterval defines how often scrape targets by default
   *
   * @schema VmAgentSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * ScrapeTimeout defines global timeout for targets scrape
   *
   * @schema VmAgentSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmAgentSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmAgentSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * SelectAllByDefault changes default behavior for empty CRD selectors, such ServiceScrapeSelector.
   * with selectAllByDefault: true and empty serviceScrapeSelector and ServiceScrapeNamespaceSelector
   * Operator selects all exist serviceScrapes
   * with selectAllByDefault: false - selects nothing
   *
   * @schema VmAgentSpec#selectAllByDefault
   */
  readonly selectAllByDefault?: boolean;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmAgentSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#serviceScrapeNamespaceSelector
   */
  readonly serviceScrapeNamespaceSelector?: VmAgentSpecServiceScrapeNamespaceSelector;

  /**
   * ServiceScrapeRelabelTemplate defines relabel config, that will be added to each VMServiceScrape.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#serviceScrapeRelabelTemplate
   */
  readonly serviceScrapeRelabelTemplate?: VmAgentSpecServiceScrapeRelabelTemplate[];

  /**
   * ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#serviceScrapeSelector
   */
  readonly serviceScrapeSelector?: VmAgentSpecServiceScrapeSelector;

  /**
   * ServiceScrapeSpec that will be added to vmagent VMServiceScrape spec
   *
   * @schema VmAgentSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmagent service spec
   *
   * @schema VmAgentSpec#serviceSpec
   */
  readonly serviceSpec?: VmAgentSpecServiceSpec;

  /**
   * ShardCount - numbers of shards of VMAgent
   * in this case operator will use 1 deployment/sts per shard with
   * replicas count according to spec.replicas,
   * see [here](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-big-number-of-targets)
   *
   * @schema VmAgentSpec#shardCount
   */
  readonly shardCount?: number;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmAgentSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * StatefulMode enables StatefulSet for `VMAgent` instead of Deployment
   * it allows using persistent storage for vmagent's persistentQueue
   *
   * @schema VmAgentSpec#statefulMode
   */
  readonly statefulMode?: boolean;

  /**
   * StatefulRollingUpdateStrategy allows configuration for strategyType
   * set it to RollingUpdate for disabling operator statefulSet rollingUpdate
   *
   * @schema VmAgentSpec#statefulRollingUpdateStrategy
   */
  readonly statefulRollingUpdateStrategy?: string;

  /**
   * StatefulStorage configures storage for StatefulSet
   *
   * @schema VmAgentSpec#statefulStorage
   */
  readonly statefulStorage?: VmAgentSpecStatefulStorage;

  /**
   * StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAgentSpec#staticScrapeNamespaceSelector
   */
  readonly staticScrapeNamespaceSelector?: VmAgentSpecStaticScrapeNamespaceSelector;

  /**
   * StaticScrapeRelabelTemplate defines relabel config, that will be added to each VMStaticScrape.
   * it's useful for adding specific labels to all targets
   *
   * @schema VmAgentSpec#staticScrapeRelabelTemplate
   */
  readonly staticScrapeRelabelTemplate?: VmAgentSpecStaticScrapeRelabelTemplate[];

  /**
   * StaticScrapeSelector defines VMStaticScrape to be selected for target discovery.
   * Works in combination with NamespaceSelector.
   * If both nil - match everything.
   * NamespaceSelector nil - only objects at VMAgent namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   *
   * @schema VmAgentSpec#staticScrapeSelector
   */
  readonly staticScrapeSelector?: VmAgentSpecStaticScrapeSelector;

  /**
   * StreamAggrConfig defines global stream aggregation configuration for VMAgent
   *
   * @schema VmAgentSpec#streamAggrConfig
   */
  readonly streamAggrConfig?: VmAgentSpecStreamAggrConfig;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmAgentSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmAgentSpec#tolerations
   */
  readonly tolerations?: VmAgentSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmAgentSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   * works only for deployments, statefulset always use OnDelete.
   *
   * @schema VmAgentSpec#updateStrategy
   */
  readonly updateStrategy?: VmAgentSpecUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmAgentSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmAgentSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * UseVMConfigReloader replaces prometheus-like config-reloader
   * with vm one. It uses secrets watch instead of file watch
   * which greatly increases speed of config updates
   *
   * @schema VmAgentSpec#useVMConfigReloader
   */
  readonly useVmConfigReloader?: boolean;

  /**
   * VMAgentExternalLabelName Name of vmAgent external label used to denote vmAgent instance
   * name. Defaults to the value of `prometheus`. External label will
   * _not_ be added when value is set to empty string (`""`).
   *
   * @default the value of `prometheus`. External label will
   * @schema VmAgentSpec#vmAgentExternalLabelName
   */
  readonly vmAgentExternalLabelName?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmAgentSpec#volumeMounts
   */
  readonly volumeMounts?: VmAgentSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmAgentSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmAgentSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpec(obj: VmAgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aPIServerConfig': obj.aPiServerConfig,
    'additionalScrapeConfigs': toJson_VmAgentSpecAdditionalScrapeConfigs(obj.additionalScrapeConfigs),
    'affinity': obj.affinity,
    'apiServerConfig': toJson_VmAgentSpecApiServerConfig(obj.apiServerConfig),
    'arbitraryFSAccessThroughSMs': toJson_VmAgentSpecArbitraryFsAccessThroughSMs(obj.arbitraryFsAccessThroughSMs),
    'claimTemplates': obj.claimTemplates?.map(y => toJson_VmAgentSpecClaimTemplates(y)),
    'configMaps': obj.configMaps?.map(y => y),
    'configReloadAuthKeySecret': toJson_VmAgentSpecConfigReloadAuthKeySecret(obj.configReloadAuthKeySecret),
    'configReloaderExtraArgs': ((obj.configReloaderExtraArgs) === undefined) ? undefined : (Object.entries(obj.configReloaderExtraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configReloaderImageTag': obj.configReloaderImageTag,
    'configReloaderResources': toJson_VmAgentSpecConfigReloaderResources(obj.configReloaderResources),
    'containers': obj.containers?.map(y => y),
    'daemonSetMode': obj.daemonSetMode,
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmAgentSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enableKubernetesAPISelectors': obj.enableKubernetesApiSelectors,
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmAgentSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmAgentSpecExtraEnvsFrom(y)),
    'globalScrapeMetricRelabelConfigs': obj.globalScrapeMetricRelabelConfigs?.map(y => toJson_VmAgentSpecGlobalScrapeMetricRelabelConfigs(y)),
    'globalScrapeRelabelConfigs': obj.globalScrapeRelabelConfigs?.map(y => toJson_VmAgentSpecGlobalScrapeRelabelConfigs(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmAgentSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'ignoreNamespaceSelectors': obj.ignoreNamespaceSelectors,
    'image': toJson_VmAgentSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmAgentSpecImagePullSecrets(y)),
    'ingestOnlyMode': obj.ingestOnlyMode,
    'initContainers': obj.initContainers?.map(y => y),
    'inlineRelabelConfig': obj.inlineRelabelConfig?.map(y => toJson_VmAgentSpecInlineRelabelConfig(y)),
    'inlineScrapeConfig': obj.inlineScrapeConfig,
    'insertPorts': toJson_VmAgentSpecInsertPorts(obj.insertPorts),
    'license': toJson_VmAgentSpecLicense(obj.license),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmAgentSpecManagedMetadata(obj.managedMetadata),
    'maxScrapeInterval': obj.maxScrapeInterval,
    'minReadySeconds': obj.minReadySeconds,
    'minScrapeInterval': obj.minScrapeInterval,
    'nodeScrapeNamespaceSelector': toJson_VmAgentSpecNodeScrapeNamespaceSelector(obj.nodeScrapeNamespaceSelector),
    'nodeScrapeRelabelTemplate': obj.nodeScrapeRelabelTemplate?.map(y => toJson_VmAgentSpecNodeScrapeRelabelTemplate(y)),
    'nodeScrapeSelector': toJson_VmAgentSpecNodeScrapeSelector(obj.nodeScrapeSelector),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'overrideHonorLabels': obj.overrideHonorLabels,
    'overrideHonorTimestamps': obj.overrideHonorTimestamps,
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VmAgentSpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VmAgentSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmAgentSpecPodMetadata(obj.podMetadata),
    'podScrapeNamespaceSelector': toJson_VmAgentSpecPodScrapeNamespaceSelector(obj.podScrapeNamespaceSelector),
    'podScrapeRelabelTemplate': obj.podScrapeRelabelTemplate?.map(y => toJson_VmAgentSpecPodScrapeRelabelTemplate(y)),
    'podScrapeSelector': toJson_VmAgentSpecPodScrapeSelector(obj.podScrapeSelector),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'probeNamespaceSelector': toJson_VmAgentSpecProbeNamespaceSelector(obj.probeNamespaceSelector),
    'probeScrapeRelabelTemplate': obj.probeScrapeRelabelTemplate?.map(y => toJson_VmAgentSpecProbeScrapeRelabelTemplate(y)),
    'probeSelector': toJson_VmAgentSpecProbeSelector(obj.probeSelector),
    'readinessGates': obj.readinessGates?.map(y => toJson_VmAgentSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'relabelConfig': toJson_VmAgentSpecRelabelConfig(obj.relabelConfig),
    'remoteWrite': obj.remoteWrite?.map(y => toJson_VmAgentSpecRemoteWrite(y)),
    'remoteWriteSettings': toJson_VmAgentSpecRemoteWriteSettings(obj.remoteWriteSettings),
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmAgentSpecResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VmAgentSpecRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'scrapeConfigNamespaceSelector': toJson_VmAgentSpecScrapeConfigNamespaceSelector(obj.scrapeConfigNamespaceSelector),
    'scrapeConfigRelabelTemplate': obj.scrapeConfigRelabelTemplate?.map(y => toJson_VmAgentSpecScrapeConfigRelabelTemplate(y)),
    'scrapeConfigSelector': toJson_VmAgentSpecScrapeConfigSelector(obj.scrapeConfigSelector),
    'scrapeInterval': obj.scrapeInterval,
    'scrapeTimeout': obj.scrapeTimeout,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'selectAllByDefault': obj.selectAllByDefault,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeNamespaceSelector': toJson_VmAgentSpecServiceScrapeNamespaceSelector(obj.serviceScrapeNamespaceSelector),
    'serviceScrapeRelabelTemplate': obj.serviceScrapeRelabelTemplate?.map(y => toJson_VmAgentSpecServiceScrapeRelabelTemplate(y)),
    'serviceScrapeSelector': toJson_VmAgentSpecServiceScrapeSelector(obj.serviceScrapeSelector),
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmAgentSpecServiceSpec(obj.serviceSpec),
    'shardCount': obj.shardCount,
    'startupProbe': obj.startupProbe,
    'statefulMode': obj.statefulMode,
    'statefulRollingUpdateStrategy': obj.statefulRollingUpdateStrategy,
    'statefulStorage': toJson_VmAgentSpecStatefulStorage(obj.statefulStorage),
    'staticScrapeNamespaceSelector': toJson_VmAgentSpecStaticScrapeNamespaceSelector(obj.staticScrapeNamespaceSelector),
    'staticScrapeRelabelTemplate': obj.staticScrapeRelabelTemplate?.map(y => toJson_VmAgentSpecStaticScrapeRelabelTemplate(y)),
    'staticScrapeSelector': toJson_VmAgentSpecStaticScrapeSelector(obj.staticScrapeSelector),
    'streamAggrConfig': toJson_VmAgentSpecStreamAggrConfig(obj.streamAggrConfig),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmAgentSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'useVMConfigReloader': obj.useVmConfigReloader,
    'vmAgentExternalLabelName': obj.vmAgentExternalLabelName,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmAgentSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it
 * is valid. Note that using this feature may expose the possibility to
 * break upgrades of VMAgent. It is advised to review VMAgent release
 * notes to ensure that no incompatible scrape configs are going to break
 * VMAgent after the upgrade.
 *
 * @schema VmAgentSpecAdditionalScrapeConfigs
 */
export interface VmAgentSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecAdditionalScrapeConfigs(obj: VmAgentSpecAdditionalScrapeConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIServerConfig allows specifying a host and auth methods to access apiserver.
 * If left empty, VMAgent is assumed to run inside of the cluster
 * and will discover API servers automatically and use the pod's CA certificate
 * and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
 *
 * @schema VmAgentSpecApiServerConfig
 */
export interface VmAgentSpecApiServerConfig {
  /**
   * Authorization configures generic authorization params
   *
   * @schema VmAgentSpecApiServerConfig#authorization
   */
  readonly authorization?: VmAgentSpecApiServerConfigAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAgentSpecApiServerConfig#basicAuth
   */
  readonly basicAuth?: VmAgentSpecApiServerConfigBasicAuth;

  /**
   * Bearer token for accessing apiserver.
   *
   * @schema VmAgentSpecApiServerConfig#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File to read bearer token for accessing apiserver.
   *
   * @schema VmAgentSpecApiServerConfig#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Host of apiserver.
   * A valid string consisting of a hostname or IP followed by an optional port number
   *
   * @schema VmAgentSpecApiServerConfig#host
   */
  readonly host: string;

  /**
   * TLSConfig Config to use for accessing apiserver.
   *
   * @schema VmAgentSpecApiServerConfig#tlsConfig
   */
  readonly tlsConfig?: VmAgentSpecApiServerConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfig(obj: VmAgentSpecApiServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAgentSpecApiServerConfigAuthorization(obj.authorization),
    'basicAuth': toJson_VmAgentSpecApiServerConfigBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'host': obj.host,
    'tlsConfig': toJson_VmAgentSpecApiServerConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ArbitraryFSAccessThroughSMs configures whether configuration
 * based on EndpointAuth can access arbitrary files on the file system
 * of the VMAgent container e.g. bearer token files, basic auth, tls certs
 *
 * @schema VmAgentSpecArbitraryFsAccessThroughSMs
 */
export interface VmAgentSpecArbitraryFsAccessThroughSMs {
  /**
   * @schema VmAgentSpecArbitraryFsAccessThroughSMs#deny
   */
  readonly deny?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecArbitraryFsAccessThroughSMs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecArbitraryFsAccessThroughSMs(obj: VmAgentSpecArbitraryFsAccessThroughSMs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deny': obj.deny,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema VmAgentSpecClaimTemplates
 */
export interface VmAgentSpecClaimTemplates {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAgentSpecClaimTemplates#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAgentSpecClaimTemplates#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema VmAgentSpecClaimTemplates#metadata
   */
  readonly metadata?: any;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAgentSpecClaimTemplates#spec
   */
  readonly spec?: VmAgentSpecClaimTemplatesSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAgentSpecClaimTemplates#status
   */
  readonly status?: VmAgentSpecClaimTemplatesStatus;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplates(obj: VmAgentSpecClaimTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': obj.metadata,
    'spec': toJson_VmAgentSpecClaimTemplatesSpec(obj.spec),
    'status': toJson_VmAgentSpecClaimTemplatesStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
 * Given secret reference will be added to the application and vm-config-reloader as volume
 * available since v0.57.0 version
 *
 * @schema VmAgentSpecConfigReloadAuthKeySecret
 */
export interface VmAgentSpecConfigReloadAuthKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecConfigReloadAuthKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecConfigReloadAuthKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecConfigReloadAuthKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecConfigReloadAuthKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecConfigReloadAuthKeySecret(obj: VmAgentSpecConfigReloadAuthKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAgentSpecConfigReloaderResources
 */
export interface VmAgentSpecConfigReloaderResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAgentSpecConfigReloaderResources#claims
   */
  readonly claims?: VmAgentSpecConfigReloaderResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecConfigReloaderResources#limits
   */
  readonly limits?: { [key: string]: VmAgentSpecConfigReloaderResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecConfigReloaderResources#requests
   */
  readonly requests?: { [key: string]: VmAgentSpecConfigReloaderResourcesRequests };

}

/**
 * Converts an object of type 'VmAgentSpecConfigReloaderResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecConfigReloaderResources(obj: VmAgentSpecConfigReloaderResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAgentSpecConfigReloaderResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmAgentSpecDnsConfig
 */
export interface VmAgentSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmAgentSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmAgentSpecDnsConfig#options
   */
  readonly options?: VmAgentSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmAgentSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecDnsConfig(obj: VmAgentSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmAgentSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmAgentSpecExtraEnvs
 */
export interface VmAgentSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmAgentSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmAgentSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAgentSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecExtraEnvs(obj: VmAgentSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmAgentSpecExtraEnvsFrom
 */
export interface VmAgentSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmAgentSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmAgentSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmAgentSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmAgentSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmAgentSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmAgentSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecExtraEnvsFrom(obj: VmAgentSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmAgentSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmAgentSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs
 */
export interface VmAgentSpecGlobalScrapeMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecGlobalScrapeMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecGlobalScrapeMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecGlobalScrapeMetricRelabelConfigs(obj: VmAgentSpecGlobalScrapeMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecGlobalScrapeRelabelConfigs
 */
export interface VmAgentSpecGlobalScrapeRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecGlobalScrapeRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecGlobalScrapeRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecGlobalScrapeRelabelConfigs(obj: VmAgentSpecGlobalScrapeRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmAgentSpecHostAliases
 */
export interface VmAgentSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmAgentSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmAgentSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmAgentSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecHostAliases(obj: VmAgentSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmAgentSpecImage
 */
export interface VmAgentSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmAgentSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmAgentSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmAgentSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmAgentSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecImage(obj: VmAgentSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmAgentSpecImagePullSecrets
 */
export interface VmAgentSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAgentSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecImagePullSecrets(obj: VmAgentSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecInlineRelabelConfig
 */
export interface VmAgentSpecInlineRelabelConfig {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecInlineRelabelConfig#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecInlineRelabelConfig#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecInlineRelabelConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecInlineRelabelConfig#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecInlineRelabelConfig#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecInlineRelabelConfig#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecInlineRelabelConfig#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecInlineRelabelConfig#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecInlineRelabelConfig#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecInlineRelabelConfig#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecInlineRelabelConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecInlineRelabelConfig(obj: VmAgentSpecInlineRelabelConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InsertPorts - additional listen ports for data ingestion.
 *
 * @schema VmAgentSpecInsertPorts
 */
export interface VmAgentSpecInsertPorts {
  /**
   * GraphitePort listen port
   *
   * @schema VmAgentSpecInsertPorts#graphitePort
   */
  readonly graphitePort?: string;

  /**
   * InfluxPort listen port
   *
   * @schema VmAgentSpecInsertPorts#influxPort
   */
  readonly influxPort?: string;

  /**
   * OpenTSDBHTTPPort for http connections.
   *
   * @schema VmAgentSpecInsertPorts#openTSDBHTTPPort
   */
  readonly openTsdbhttpPort?: string;

  /**
   * OpenTSDBPort for tcp and udp listen
   *
   * @schema VmAgentSpecInsertPorts#openTSDBPort
   */
  readonly openTsdbPort?: string;

}

/**
 * Converts an object of type 'VmAgentSpecInsertPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecInsertPorts(obj: VmAgentSpecInsertPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'graphitePort': obj.graphitePort,
    'influxPort': obj.influxPort,
    'openTSDBHTTPPort': obj.openTsdbhttpPort,
    'openTSDBPort': obj.openTsdbPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmAgentSpecLicense
 */
export interface VmAgentSpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmAgentSpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmAgentSpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmAgentSpecLicense#keyRef
   */
  readonly keyRef?: VmAgentSpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmAgentSpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmAgentSpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecLicense(obj: VmAgentSpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmAgentSpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMAgent to be configured with.
 *
 * @schema VmAgentSpecLogFormat
 */
export enum VmAgentSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMAgent to be configured with.
 * INFO, WARN, ERROR, FATAL, PANIC
 *
 * @schema VmAgentSpecLogLevel
 */
export enum VmAgentSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmAgentSpecManagedMetadata
 */
export interface VmAgentSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAgentSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAgentSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecManagedMetadata(obj: VmAgentSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecNodeScrapeNamespaceSelector
 */
export interface VmAgentSpecNodeScrapeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecNodeScrapeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecNodeScrapeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecNodeScrapeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecNodeScrapeNamespaceSelector(obj: VmAgentSpecNodeScrapeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecNodeScrapeRelabelTemplate
 */
export interface VmAgentSpecNodeScrapeRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecNodeScrapeRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecNodeScrapeRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecNodeScrapeRelabelTemplate(obj: VmAgentSpecNodeScrapeRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeScrapeSelector defines VMNodeScrape to be selected for scraping.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecNodeScrapeSelector
 */
export interface VmAgentSpecNodeScrapeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecNodeScrapeSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecNodeScrapeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecNodeScrapeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecNodeScrapeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecNodeScrapeSelector(obj: VmAgentSpecNodeScrapeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecNodeScrapeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VmAgentSpecPersistentVolumeClaimRetentionPolicy
 */
export interface VmAgentSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VmAgentSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VmAgentSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VmAgentSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPersistentVolumeClaimRetentionPolicy(obj: VmAgentSpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmAgentSpecPodDisruptionBudget
 */
export interface VmAgentSpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmAgentSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmAgentSpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmAgentSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmAgentSpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmAgentSpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodDisruptionBudget(obj: VmAgentSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.
 *
 * @schema VmAgentSpecPodMetadata
 */
export interface VmAgentSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAgentSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAgentSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAgentSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAgentSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodMetadata(obj: VmAgentSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecPodScrapeNamespaceSelector
 */
export interface VmAgentSpecPodScrapeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecPodScrapeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecPodScrapeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecPodScrapeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodScrapeNamespaceSelector(obj: VmAgentSpecPodScrapeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecPodScrapeRelabelTemplate
 */
export interface VmAgentSpecPodScrapeRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecPodScrapeRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecPodScrapeRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecPodScrapeRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecPodScrapeRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecPodScrapeRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodScrapeRelabelTemplate(obj: VmAgentSpecPodScrapeRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodScrapeSelector defines PodScrapes to be selected for target discovery.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecPodScrapeSelector
 */
export interface VmAgentSpecPodScrapeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecPodScrapeSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecPodScrapeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecPodScrapeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecPodScrapeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodScrapeSelector(obj: VmAgentSpecPodScrapeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecPodScrapeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecProbeNamespaceSelector
 */
export interface VmAgentSpecProbeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecProbeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecProbeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecProbeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecProbeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecProbeNamespaceSelector(obj: VmAgentSpecProbeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecProbeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecProbeScrapeRelabelTemplate
 */
export interface VmAgentSpecProbeScrapeRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecProbeScrapeRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecProbeScrapeRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecProbeScrapeRelabelTemplate(obj: VmAgentSpecProbeScrapeRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProbeSelector defines VMProbe to be selected for target probing.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecProbeSelector
 */
export interface VmAgentSpecProbeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecProbeSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecProbeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecProbeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecProbeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecProbeSelector(obj: VmAgentSpecProbeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecProbeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmAgentSpecReadinessGates
 */
export interface VmAgentSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmAgentSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmAgentSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecReadinessGates(obj: VmAgentSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig
 * This relabeling is applied to all the collected metrics before sending them to remote storage.
 *
 * @schema VmAgentSpecRelabelConfig
 */
export interface VmAgentSpecRelabelConfig {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRelabelConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRelabelConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRelabelConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRelabelConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRelabelConfig(obj: VmAgentSpecRelabelConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAgentRemoteWriteSpec defines the remote storage configuration for VmAgent
 *
 * @schema VmAgentSpecRemoteWrite
 */
export interface VmAgentSpecRemoteWrite {
  /**
   * AWS describes params specific to AWS cloud
   *
   * @schema VmAgentSpecRemoteWrite#aws
   */
  readonly aws?: VmAgentSpecRemoteWriteAws;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAgentSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: VmAgentSpecRemoteWriteBasicAuth;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAgentSpecRemoteWrite#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAgentSpecRemoteWriteBearerTokenSecret;

  /**
   * ForceVMProto forces using VictoriaMetrics protocol for sending data to -remoteWrite.url
   *
   * @schema VmAgentSpecRemoteWrite#forceVMProto
   */
  readonly forceVmProto?: boolean;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmAgentSpecRemoteWrite#headers
   */
  readonly headers?: string[];

  /**
   * InlineUrlRelabelConfig defines relabeling config for remoteWriteURL, it can be defined at crd spec.
   *
   * @schema VmAgentSpecRemoteWrite#inlineUrlRelabelConfig
   */
  readonly inlineUrlRelabelConfig?: VmAgentSpecRemoteWriteInlineUrlRelabelConfig[];

  /**
   * MaxDiskUsage defines the maximum file-based buffer size in bytes for the given remoteWrite
   * It overrides global configuration defined at remoteWriteSettings.maxDiskUsagePerURL
   *
   * @schema VmAgentSpecRemoteWrite#maxDiskUsage
   */
  readonly maxDiskUsage?: any;

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmAgentSpecRemoteWrite#oauth2
   */
  readonly oauth2?: VmAgentSpecRemoteWriteOauth2;

  /**
   * ProxyURL for -remoteWrite.url. Supported proxies: http, https, socks5. Example: socks5://proxy:1234
   *
   * @schema VmAgentSpecRemoteWrite#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)
   *
   * @schema VmAgentSpecRemoteWrite#sendTimeout
   */
  readonly sendTimeout?: string;

  /**
   * StreamAggrConfig defines stream aggregation configuration for VMAgent for -remoteWrite.url
   *
   * @schema VmAgentSpecRemoteWrite#streamAggrConfig
   */
  readonly streamAggrConfig?: VmAgentSpecRemoteWriteStreamAggrConfig;

  /**
   * TLSConfig describes tls configuration for remote write target
   *
   * @schema VmAgentSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: VmAgentSpecRemoteWriteTlsConfig;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema VmAgentSpecRemoteWrite#url
   */
  readonly url: string;

  /**
   * ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url
   *
   * @schema VmAgentSpecRemoteWrite#urlRelabelConfig
   */
  readonly urlRelabelConfig?: VmAgentSpecRemoteWriteUrlRelabelConfig;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWrite(obj: VmAgentSpecRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_VmAgentSpecRemoteWriteAws(obj.aws),
    'basicAuth': toJson_VmAgentSpecRemoteWriteBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_VmAgentSpecRemoteWriteBearerTokenSecret(obj.bearerTokenSecret),
    'forceVMProto': obj.forceVmProto,
    'headers': obj.headers?.map(y => y),
    'inlineUrlRelabelConfig': obj.inlineUrlRelabelConfig?.map(y => toJson_VmAgentSpecRemoteWriteInlineUrlRelabelConfig(y)),
    'maxDiskUsage': obj.maxDiskUsage,
    'oauth2': toJson_VmAgentSpecRemoteWriteOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'sendTimeout': obj.sendTimeout,
    'streamAggrConfig': toJson_VmAgentSpecRemoteWriteStreamAggrConfig(obj.streamAggrConfig),
    'tlsConfig': toJson_VmAgentSpecRemoteWriteTlsConfig(obj.tlsConfig),
    'url': obj.url,
    'urlRelabelConfig': toJson_VmAgentSpecRemoteWriteUrlRelabelConfig(obj.urlRelabelConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteWriteSettings defines global settings for all remoteWrite urls.
 *
 * @schema VmAgentSpecRemoteWriteSettings
 */
export interface VmAgentSpecRemoteWriteSettings {
  /**
   * Interval for flushing the data to remote storage. (default 1s)
   *
   * @schema VmAgentSpecRemoteWriteSettings#flushInterval
   */
  readonly flushInterval?: string;

  /**
   * Labels in the form 'name=value' to add to all the metrics before sending them. This overrides the label if it already exists.
   *
   * @schema VmAgentSpecRemoteWriteSettings#label
   */
  readonly label?: { [key: string]: string };

  /**
   * The maximum size in bytes of unpacked request to send to remote storage
   *
   * @schema VmAgentSpecRemoteWriteSettings#maxBlockSize
   */
  readonly maxBlockSize?: number;

  /**
   * The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath
   *
   * @schema VmAgentSpecRemoteWriteSettings#maxDiskUsagePerURL
   */
  readonly maxDiskUsagePerUrl?: any;

  /**
   * The number of concurrent queues
   *
   * @schema VmAgentSpecRemoteWriteSettings#queues
   */
  readonly queues?: number;

  /**
   * Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info
   *
   * @schema VmAgentSpecRemoteWriteSettings#showURL
   */
  readonly showUrl?: boolean;

  /**
   * Path to directory where temporary data for remote write component is stored (default vmagent-remotewrite-data)
   *
   * @schema VmAgentSpecRemoteWriteSettings#tmpDataPath
   */
  readonly tmpDataPath?: string;

  /**
   * Configures vmagent accepting data via the same multitenant endpoints as vminsert at VictoriaMetrics cluster does,
   * see [here](https://docs.victoriametrics.com/victoriametrics/vmagent/#multitenancy).
   * it's global setting and affects all remote storage configurations
   *
   * @schema VmAgentSpecRemoteWriteSettings#useMultiTenantMode
   */
  readonly useMultiTenantMode?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteSettings(obj: VmAgentSpecRemoteWriteSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
    'label': ((obj.label) === undefined) ? undefined : (Object.entries(obj.label).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maxBlockSize': obj.maxBlockSize,
    'maxDiskUsagePerURL': obj.maxDiskUsagePerUrl,
    'queues': obj.queues,
    'showURL': obj.showUrl,
    'tmpDataPath': obj.tmpDataPath,
    'useMultiTenantMode': obj.useMultiTenantMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAgentSpecResources
 */
export interface VmAgentSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAgentSpecResources#claims
   */
  readonly claims?: VmAgentSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAgentSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAgentSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAgentSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecResources(obj: VmAgentSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAgentSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VmAgentSpecRollingUpdate
 */
export interface VmAgentSpecRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VmAgentSpecRollingUpdate#maxSurge
   */
  readonly maxSurge?: VmAgentSpecRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VmAgentSpecRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VmAgentSpecRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VmAgentSpecRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRollingUpdate(obj: VmAgentSpecRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ScrapeConfigNamespaceSelector defines Namespaces to be selected for VMScrapeConfig discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecScrapeConfigNamespaceSelector
 */
export interface VmAgentSpecScrapeConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecScrapeConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecScrapeConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecScrapeConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecScrapeConfigNamespaceSelector(obj: VmAgentSpecScrapeConfigNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecScrapeConfigRelabelTemplate
 */
export interface VmAgentSpecScrapeConfigRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecScrapeConfigRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecScrapeConfigRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecScrapeConfigRelabelTemplate(obj: VmAgentSpecScrapeConfigRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ScrapeConfigSelector defines VMScrapeConfig to be selected for target discovery.
 * Works in combination with NamespaceSelector.
 *
 * @schema VmAgentSpecScrapeConfigSelector
 */
export interface VmAgentSpecScrapeConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecScrapeConfigSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecScrapeConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecScrapeConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecScrapeConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecScrapeConfigSelector(obj: VmAgentSpecScrapeConfigSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecScrapeConfigSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecServiceScrapeNamespaceSelector
 */
export interface VmAgentSpecServiceScrapeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecServiceScrapeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecServiceScrapeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecServiceScrapeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceScrapeNamespaceSelector(obj: VmAgentSpecServiceScrapeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecServiceScrapeRelabelTemplate
 */
export interface VmAgentSpecServiceScrapeRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecServiceScrapeRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecServiceScrapeRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceScrapeRelabelTemplate(obj: VmAgentSpecServiceScrapeRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecServiceScrapeSelector
 */
export interface VmAgentSpecServiceScrapeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecServiceScrapeSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecServiceScrapeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecServiceScrapeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecServiceScrapeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceScrapeSelector(obj: VmAgentSpecServiceScrapeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecServiceScrapeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmagent service spec
 *
 * @schema VmAgentSpecServiceSpec
 */
export interface VmAgentSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmAgentSpecServiceSpec#metadata
   */
  readonly metadata?: VmAgentSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmAgentSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmAgentSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceSpec(obj: VmAgentSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmAgentSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatefulStorage configures storage for StatefulSet
 *
 * @schema VmAgentSpecStatefulStorage
 */
export interface VmAgentSpecStatefulStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmAgentSpecStatefulStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmAgentSpecStatefulStorage#emptyDir
   */
  readonly emptyDir?: VmAgentSpecStatefulStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmAgentSpecStatefulStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: VmAgentSpecStatefulStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorage(obj: VmAgentSpecStatefulStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmAgentSpecStatefulStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAgentSpecStaticScrapeNamespaceSelector
 */
export interface VmAgentSpecStaticScrapeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecStaticScrapeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecStaticScrapeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecStaticScrapeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStaticScrapeNamespaceSelector(obj: VmAgentSpecStaticScrapeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecStaticScrapeRelabelTemplate
 */
export interface VmAgentSpecStaticScrapeRelabelTemplate {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecStaticScrapeRelabelTemplate#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStaticScrapeRelabelTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStaticScrapeRelabelTemplate(obj: VmAgentSpecStaticScrapeRelabelTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StaticScrapeSelector defines VMStaticScrape to be selected for target discovery.
 * Works in combination with NamespaceSelector.
 * If both nil - match everything.
 * NamespaceSelector nil - only objects at VMAgent namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 *
 * @schema VmAgentSpecStaticScrapeSelector
 */
export interface VmAgentSpecStaticScrapeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecStaticScrapeSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecStaticScrapeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecStaticScrapeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecStaticScrapeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStaticScrapeSelector(obj: VmAgentSpecStaticScrapeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecStaticScrapeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrConfig defines global stream aggregation configuration for VMAgent
 *
 * @schema VmAgentSpecStreamAggrConfig
 */
export interface VmAgentSpecStreamAggrConfig {
  /**
   * ConfigMap with stream aggregation rules
   *
   * @schema VmAgentSpecStreamAggrConfig#configmap
   */
  readonly configmap?: VmAgentSpecStreamAggrConfigConfigmap;

  /**
   * Allows setting different de-duplication intervals per each configured remote storage
   *
   * @schema VmAgentSpecStreamAggrConfig#dedupInterval
   */
  readonly dedupInterval?: string;

  /**
   * Allow drop all the input samples after the aggregation
   *
   * @schema VmAgentSpecStreamAggrConfig#dropInput
   */
  readonly dropInput?: boolean;

  /**
   * labels to drop from samples for aggregator before stream de-duplication and aggregation
   *
   * @schema VmAgentSpecStreamAggrConfig#dropInputLabels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows ( available from v0.54.0).
   *
   * @schema VmAgentSpecStreamAggrConfig#enableWindows
   */
  readonly enableWindows?: boolean;

  /**
   * IgnoreFirstIntervals instructs to ignore first interval
   *
   * @schema VmAgentSpecStreamAggrConfig#ignoreFirstIntervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmAgentSpecStreamAggrConfig#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmAgentSpecStreamAggrConfig#ignoreOldSamples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * Allows writing both raw and aggregate data
   *
   * @schema VmAgentSpecStreamAggrConfig#keepInput
   */
  readonly keepInput?: boolean;

  /**
   * Stream aggregation rules
   *
   * @schema VmAgentSpecStreamAggrConfig#rules
   */
  readonly rules?: VmAgentSpecStreamAggrConfigRules[];

}

/**
 * Converts an object of type 'VmAgentSpecStreamAggrConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStreamAggrConfig(obj: VmAgentSpecStreamAggrConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configmap': toJson_VmAgentSpecStreamAggrConfigConfigmap(obj.configmap),
    'dedupInterval': obj.dedupInterval,
    'dropInput': obj.dropInput,
    'dropInputLabels': obj.dropInputLabels?.map(y => y),
    'enableWindows': obj.enableWindows,
    'ignoreFirstIntervals': obj.ignoreFirstIntervals,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignoreOldSamples': obj.ignoreOldSamples,
    'keepInput': obj.keepInput,
    'rules': obj.rules?.map(y => toJson_VmAgentSpecStreamAggrConfigRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmAgentSpecTolerations
 */
export interface VmAgentSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmAgentSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmAgentSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmAgentSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmAgentSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmAgentSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAgentSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecTolerations(obj: VmAgentSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 * works only for deployments, statefulset always use OnDelete.
 *
 * @schema VmAgentSpecUpdateStrategy
 */
export enum VmAgentSpecUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmAgentSpecVolumeMounts
 */
export interface VmAgentSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmAgentSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmAgentSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmAgentSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmAgentSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmAgentSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmAgentSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmAgentSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmAgentSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecVolumeMounts(obj: VmAgentSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization configures generic authorization params
 *
 * @schema VmAgentSpecApiServerConfigAuthorization
 */
export interface VmAgentSpecApiServerConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAgentSpecApiServerConfigAuthorization#credentials
   */
  readonly credentials?: VmAgentSpecApiServerConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAgentSpecApiServerConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAgentSpecApiServerConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigAuthorization(obj: VmAgentSpecApiServerConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAgentSpecApiServerConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAgentSpecApiServerConfigBasicAuth
 */
export interface VmAgentSpecApiServerConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAgentSpecApiServerConfigBasicAuth#password
   */
  readonly password?: VmAgentSpecApiServerConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAgentSpecApiServerConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAgentSpecApiServerConfigBasicAuth#username
   */
  readonly username?: VmAgentSpecApiServerConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigBasicAuth(obj: VmAgentSpecApiServerConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAgentSpecApiServerConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAgentSpecApiServerConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig Config to use for accessing apiserver.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfig
 */
export interface VmAgentSpecApiServerConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#ca
   */
  readonly ca?: VmAgentSpecApiServerConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#cert
   */
  readonly cert?: VmAgentSpecApiServerConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAgentSpecApiServerConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfig(obj: VmAgentSpecApiServerConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAgentSpecApiServerConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAgentSpecApiServerConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAgentSpecApiServerConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAgentSpecClaimTemplatesSpec
 */
export interface VmAgentSpecClaimTemplatesSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAgentSpecClaimTemplatesSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAgentSpecClaimTemplatesSpec#dataSource
   */
  readonly dataSource?: VmAgentSpecClaimTemplatesSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAgentSpecClaimTemplatesSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAgentSpecClaimTemplatesSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAgentSpecClaimTemplatesSpec#resources
   */
  readonly resources?: VmAgentSpecClaimTemplatesSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAgentSpecClaimTemplatesSpec#selector
   */
  readonly selector?: VmAgentSpecClaimTemplatesSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAgentSpecClaimTemplatesSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAgentSpecClaimTemplatesSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAgentSpecClaimTemplatesSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAgentSpecClaimTemplatesSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpec(obj: VmAgentSpecClaimTemplatesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAgentSpecClaimTemplatesSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAgentSpecClaimTemplatesSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAgentSpecClaimTemplatesSpecResources(obj.resources),
    'selector': toJson_VmAgentSpecClaimTemplatesSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAgentSpecClaimTemplatesStatus
 */
export interface VmAgentSpecClaimTemplatesStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAgentSpecClaimTemplatesStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAgentSpecClaimTemplatesStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAgentSpecClaimTemplatesStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAgentSpecClaimTemplatesStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAgentSpecClaimTemplatesStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAgentSpecClaimTemplatesStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAgentSpecClaimTemplatesStatus#conditions
   */
  readonly conditions?: VmAgentSpecClaimTemplatesStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAgentSpecClaimTemplatesStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAgentSpecClaimTemplatesStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAgentSpecClaimTemplatesStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAgentSpecClaimTemplatesStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesStatus(obj: VmAgentSpecClaimTemplatesStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAgentSpecClaimTemplatesStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAgentSpecClaimTemplatesStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAgentSpecConfigReloaderResourcesClaims
 */
export interface VmAgentSpecConfigReloaderResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAgentSpecConfigReloaderResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAgentSpecConfigReloaderResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAgentSpecConfigReloaderResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecConfigReloaderResourcesClaims(obj: VmAgentSpecConfigReloaderResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecConfigReloaderResourcesLimits
 */
export class VmAgentSpecConfigReloaderResourcesLimits {
  public static fromNumber(value: number): VmAgentSpecConfigReloaderResourcesLimits {
    return new VmAgentSpecConfigReloaderResourcesLimits(value);
  }
  public static fromString(value: string): VmAgentSpecConfigReloaderResourcesLimits {
    return new VmAgentSpecConfigReloaderResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecConfigReloaderResourcesRequests
 */
export class VmAgentSpecConfigReloaderResourcesRequests {
  public static fromNumber(value: number): VmAgentSpecConfigReloaderResourcesRequests {
    return new VmAgentSpecConfigReloaderResourcesRequests(value);
  }
  public static fromString(value: string): VmAgentSpecConfigReloaderResourcesRequests {
    return new VmAgentSpecConfigReloaderResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmAgentSpecDnsConfigOptions
 */
export interface VmAgentSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmAgentSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmAgentSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAgentSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecDnsConfigOptions(obj: VmAgentSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmAgentSpecExtraEnvsFromConfigMapRef
 */
export interface VmAgentSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmAgentSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecExtraEnvsFromConfigMapRef(obj: VmAgentSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmAgentSpecExtraEnvsFromSecretRef
 */
export interface VmAgentSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmAgentSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecExtraEnvsFromSecretRef(obj: VmAgentSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmAgentSpecLicenseKeyRef
 */
export interface VmAgentSpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecLicenseKeyRef(obj: VmAgentSpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions(obj: VmAgentSpecNodeScrapeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecNodeScrapeSelectorMatchExpressions
 */
export interface VmAgentSpecNodeScrapeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecNodeScrapeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecNodeScrapeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecNodeScrapeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecNodeScrapeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecNodeScrapeSelectorMatchExpressions(obj: VmAgentSpecNodeScrapeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmAgentSpecPodDisruptionBudgetMaxUnavailable
 */
export class VmAgentSpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmAgentSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAgentSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmAgentSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAgentSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmAgentSpecPodDisruptionBudgetMinAvailable
 */
export class VmAgentSpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmAgentSpecPodDisruptionBudgetMinAvailable {
    return new VmAgentSpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmAgentSpecPodDisruptionBudgetMinAvailable {
    return new VmAgentSpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions(obj: VmAgentSpecPodScrapeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecPodScrapeSelectorMatchExpressions
 */
export interface VmAgentSpecPodScrapeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecPodScrapeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecPodScrapeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecPodScrapeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecPodScrapeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecPodScrapeSelectorMatchExpressions(obj: VmAgentSpecPodScrapeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecProbeNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecProbeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecProbeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecProbeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecProbeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecProbeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecProbeNamespaceSelectorMatchExpressions(obj: VmAgentSpecProbeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecProbeSelectorMatchExpressions
 */
export interface VmAgentSpecProbeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecProbeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecProbeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecProbeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecProbeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecProbeSelectorMatchExpressions(obj: VmAgentSpecProbeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS describes params specific to AWS cloud
 *
 * @schema VmAgentSpecRemoteWriteAws
 */
export interface VmAgentSpecRemoteWriteAws {
  /**
   * EC2Endpoint is an optional AWS EC2 API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
   *
   * @schema VmAgentSpecRemoteWriteAws#ec2Endpoint
   */
  readonly ec2Endpoint?: string;

  /**
   * Region is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
   *
   * @schema VmAgentSpecRemoteWriteAws#region
   */
  readonly region?: string;

  /**
   * RoleARN is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
   *
   * @schema VmAgentSpecRemoteWriteAws#roleARN
   */
  readonly roleArn?: string;

  /**
   * Service is an optional AWS Service to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
   *
   * @schema VmAgentSpecRemoteWriteAws#service
   */
  readonly service?: string;

  /**
   * STSEndpoint is an optional AWS STS API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
   *
   * @schema VmAgentSpecRemoteWriteAws#stsEndpoint
   */
  readonly stsEndpoint?: string;

  /**
   * UseSigv4 enables SigV4 request signing for the corresponding -remoteWrite.url
   *
   * @schema VmAgentSpecRemoteWriteAws#useSigv4
   */
  readonly useSigv4?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteAws(obj: VmAgentSpecRemoteWriteAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2Endpoint': obj.ec2Endpoint,
    'region': obj.region,
    'roleARN': obj.roleArn,
    'service': obj.service,
    'stsEndpoint': obj.stsEndpoint,
    'useSigv4': obj.useSigv4,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAgentSpecRemoteWriteBasicAuth
 */
export interface VmAgentSpecRemoteWriteBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAgentSpecRemoteWriteBasicAuth#password
   */
  readonly password?: VmAgentSpecRemoteWriteBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAgentSpecRemoteWriteBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAgentSpecRemoteWriteBasicAuth#username
   */
  readonly username?: VmAgentSpecRemoteWriteBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteBasicAuth(obj: VmAgentSpecRemoteWriteBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAgentSpecRemoteWriteBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAgentSpecRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAgentSpecRemoteWriteBearerTokenSecret
 */
export interface VmAgentSpecRemoteWriteBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteBearerTokenSecret(obj: VmAgentSpecRemoteWriteBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig
 */
export interface VmAgentSpecRemoteWriteInlineUrlRelabelConfig {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecRemoteWriteInlineUrlRelabelConfig#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteInlineUrlRelabelConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteInlineUrlRelabelConfig(obj: VmAgentSpecRemoteWriteInlineUrlRelabelConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmAgentSpecRemoteWriteOauth2
 */
export interface VmAgentSpecRemoteWriteOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAgentSpecRemoteWriteOauth2#client_id
   */
  readonly clientId: VmAgentSpecRemoteWriteOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAgentSpecRemoteWriteOauth2#client_secret
   */
  readonly clientSecret?: VmAgentSpecRemoteWriteOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAgentSpecRemoteWriteOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAgentSpecRemoteWriteOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAgentSpecRemoteWriteOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAgentSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAgentSpecRemoteWriteOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAgentSpecRemoteWriteOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteOauth2(obj: VmAgentSpecRemoteWriteOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAgentSpecRemoteWriteOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAgentSpecRemoteWriteOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrConfig defines stream aggregation configuration for VMAgent for -remoteWrite.url
 *
 * @schema VmAgentSpecRemoteWriteStreamAggrConfig
 */
export interface VmAgentSpecRemoteWriteStreamAggrConfig {
  /**
   * ConfigMap with stream aggregation rules
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#configmap
   */
  readonly configmap?: VmAgentSpecRemoteWriteStreamAggrConfigConfigmap;

  /**
   * Allows setting different de-duplication intervals per each configured remote storage
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#dedupInterval
   */
  readonly dedupInterval?: string;

  /**
   * Allow drop all the input samples after the aggregation
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#dropInput
   */
  readonly dropInput?: boolean;

  /**
   * labels to drop from samples for aggregator before stream de-duplication and aggregation
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#dropInputLabels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows ( available from v0.54.0).
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#enableWindows
   */
  readonly enableWindows?: boolean;

  /**
   * IgnoreFirstIntervals instructs to ignore first interval
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#ignoreFirstIntervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#ignoreOldSamples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * Allows writing both raw and aggregate data
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#keepInput
   */
  readonly keepInput?: boolean;

  /**
   * Stream aggregation rules
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfig#rules
   */
  readonly rules?: VmAgentSpecRemoteWriteStreamAggrConfigRules[];

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteStreamAggrConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteStreamAggrConfig(obj: VmAgentSpecRemoteWriteStreamAggrConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configmap': toJson_VmAgentSpecRemoteWriteStreamAggrConfigConfigmap(obj.configmap),
    'dedupInterval': obj.dedupInterval,
    'dropInput': obj.dropInput,
    'dropInputLabels': obj.dropInputLabels?.map(y => y),
    'enableWindows': obj.enableWindows,
    'ignoreFirstIntervals': obj.ignoreFirstIntervals,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignoreOldSamples': obj.ignoreOldSamples,
    'keepInput': obj.keepInput,
    'rules': obj.rules?.map(y => toJson_VmAgentSpecRemoteWriteStreamAggrConfigRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig describes tls configuration for remote write target
 *
 * @schema VmAgentSpecRemoteWriteTlsConfig
 */
export interface VmAgentSpecRemoteWriteTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#ca
   */
  readonly ca?: VmAgentSpecRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#cert
   */
  readonly cert?: VmAgentSpecRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: VmAgentSpecRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfig(obj: VmAgentSpecRemoteWriteTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAgentSpecRemoteWriteTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAgentSpecRemoteWriteTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAgentSpecRemoteWriteTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url
 *
 * @schema VmAgentSpecRemoteWriteUrlRelabelConfig
 */
export interface VmAgentSpecRemoteWriteUrlRelabelConfig {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRemoteWriteUrlRelabelConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteUrlRelabelConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteUrlRelabelConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteUrlRelabelConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteUrlRelabelConfig(obj: VmAgentSpecRemoteWriteUrlRelabelConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAgentSpecResourcesClaims
 */
export interface VmAgentSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAgentSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAgentSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAgentSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecResourcesClaims(obj: VmAgentSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecResourcesLimits
 */
export class VmAgentSpecResourcesLimits {
  public static fromNumber(value: number): VmAgentSpecResourcesLimits {
    return new VmAgentSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAgentSpecResourcesLimits {
    return new VmAgentSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecResourcesRequests
 */
export class VmAgentSpecResourcesRequests {
  public static fromNumber(value: number): VmAgentSpecResourcesRequests {
    return new VmAgentSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAgentSpecResourcesRequests {
    return new VmAgentSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VmAgentSpecRollingUpdateMaxSurge
 */
export class VmAgentSpecRollingUpdateMaxSurge {
  public static fromNumber(value: number): VmAgentSpecRollingUpdateMaxSurge {
    return new VmAgentSpecRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VmAgentSpecRollingUpdateMaxSurge {
    return new VmAgentSpecRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VmAgentSpecRollingUpdateMaxUnavailable
 */
export class VmAgentSpecRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VmAgentSpecRollingUpdateMaxUnavailable {
    return new VmAgentSpecRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VmAgentSpecRollingUpdateMaxUnavailable {
    return new VmAgentSpecRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions(obj: VmAgentSpecScrapeConfigNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecScrapeConfigSelectorMatchExpressions
 */
export interface VmAgentSpecScrapeConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecScrapeConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecScrapeConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecScrapeConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecScrapeConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecScrapeConfigSelectorMatchExpressions(obj: VmAgentSpecScrapeConfigSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions(obj: VmAgentSpecServiceScrapeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecServiceScrapeSelectorMatchExpressions
 */
export interface VmAgentSpecServiceScrapeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecServiceScrapeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecServiceScrapeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecServiceScrapeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecServiceScrapeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceScrapeSelectorMatchExpressions(obj: VmAgentSpecServiceScrapeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmAgentSpecServiceSpecMetadata
 */
export interface VmAgentSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAgentSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAgentSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAgentSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAgentSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecServiceSpecMetadata(obj: VmAgentSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmAgentSpecStatefulStorageEmptyDir
 */
export interface VmAgentSpecStatefulStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAgentSpecStatefulStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAgentSpecStatefulStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmAgentSpecStatefulStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageEmptyDir(obj: VmAgentSpecStatefulStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PVC spec to be used by the StatefulSets/Deployments.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate#spec
   */
  readonly spec?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplate#status
   */
  readonly status?: VmAgentSpecStatefulStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplate(obj: VmAgentSpecStatefulStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions
 */
export interface VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions(obj: VmAgentSpecStaticScrapeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecStaticScrapeSelectorMatchExpressions
 */
export interface VmAgentSpecStaticScrapeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecStaticScrapeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecStaticScrapeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecStaticScrapeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecStaticScrapeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStaticScrapeSelectorMatchExpressions(obj: VmAgentSpecStaticScrapeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap with stream aggregation rules
 *
 * @schema VmAgentSpecStreamAggrConfigConfigmap
 */
export interface VmAgentSpecStreamAggrConfigConfigmap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecStreamAggrConfigConfigmap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecStreamAggrConfigConfigmap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecStreamAggrConfigConfigmap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecStreamAggrConfigConfigmap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStreamAggrConfigConfigmap(obj: VmAgentSpecStreamAggrConfigConfigmap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrRule defines the rule in stream aggregation config
 *
 * @schema VmAgentSpecStreamAggrConfigRules
 */
export interface VmAgentSpecStreamAggrConfigRules {
  /**
   * By is an optional list of labels for grouping input series.
   *
   * See also Without.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#by
   */
  readonly by?: string[];

  /**
   * DedupInterval is an optional interval for deduplication.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#dedup_interval
   */
  readonly dedupInterval?: string;

  /**
   * DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
   *
   * Labels are dropped before de-duplication and aggregation.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#drop_input_labels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows
   *
   * @schema VmAgentSpecStreamAggrConfigRules#enable_windows
   */
  readonly enableWindows?: boolean;

  /**
   * FlushOnShutdown defines whether to flush the aggregation state on process termination
   * or config reload. Is `false` by default.
   * It is not recommended changing this setting, unless unfinished aggregations states
   * are preferred to missing data points.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#flush_on_shutdown
   */
  readonly flushOnShutdown?: boolean;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmAgentSpecStreamAggrConfigRules#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * @schema VmAgentSpecStreamAggrConfigRules#ignore_first_intervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#ignore_old_samples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * InputRelabelConfigs is an optional relabeling rules, which are applied on the input
   * before aggregation.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#input_relabel_configs
   */
  readonly inputRelabelConfigs?: VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs[];

  /**
   * Interval is the interval between aggregations.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#interval
   */
  readonly interval: string;

  /**
   * KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#keep_metric_names
   */
  readonly keepMetricNames?: boolean;

  /**
   * Match is a label selector (or list of label selectors) for filtering time series for the given selector.
   *
   * If the match isn't set, then all the input time series are processed.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#match
   */
  readonly match?: any;

  /**
   * NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
   * By default flushes are aligned to Interval.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#no_align_flush_to_interval
   */
  readonly noAlignFlushToInterval?: boolean;

  /**
   * OutputRelabelConfigs is an optional relabeling rules, which are applied
   * on the aggregated output before being sent to remote storage.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#output_relabel_configs
   */
  readonly outputRelabelConfigs?: VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs[];

  /**
   * Outputs is a list of output aggregate functions to produce.
   *
   * The following names are allowed:
   *
   * - total - aggregates input counters
   * - increase - counts the increase over input counters
   * - count_series - counts the input series
   * - count_samples - counts the input samples
   * - sum_samples - sums the input samples
   * - last - the last biggest sample value
   * - min - the minimum sample value
   * - max - the maximum sample value
   * - avg - the average value across all the samples
   * - stddev - standard deviation across all the samples
   * - stdvar - standard variance across all the samples
   * - histogram_bucket - creates VictoriaMetrics histogram for input samples
   * - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
   *
   * The output time series will have the following names:
   *
   * input_name:aggr_<interval>_<output>
   *
   * @schema VmAgentSpecStreamAggrConfigRules#outputs
   */
  readonly outputs: string[];

  /**
   * Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
   * The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#staleness_interval
   */
  readonly stalenessInterval?: string;

  /**
   * Without is an optional list of labels, which must be excluded when grouping input series.
   *
   * See also By.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmAgentSpecStreamAggrConfigRules#without
   */
  readonly without?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecStreamAggrConfigRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStreamAggrConfigRules(obj: VmAgentSpecStreamAggrConfigRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'by': obj.by?.map(y => y),
    'dedup_interval': obj.dedupInterval,
    'drop_input_labels': obj.dropInputLabels?.map(y => y),
    'enable_windows': obj.enableWindows,
    'flush_on_shutdown': obj.flushOnShutdown,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignore_first_intervals': obj.ignoreFirstIntervals,
    'ignore_old_samples': obj.ignoreOldSamples,
    'input_relabel_configs': obj.inputRelabelConfigs?.map(y => toJson_VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs(y)),
    'interval': obj.interval,
    'keep_metric_names': obj.keepMetricNames,
    'match': obj.match,
    'no_align_flush_to_interval': obj.noAlignFlushToInterval,
    'output_relabel_configs': obj.outputRelabelConfigs?.map(y => toJson_VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs(y)),
    'outputs': obj.outputs?.map(y => y),
    'staleness_interval': obj.stalenessInterval,
    'without': obj.without?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAgentSpecApiServerConfigAuthorizationCredentials
 */
export interface VmAgentSpecApiServerConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigAuthorizationCredentials(obj: VmAgentSpecApiServerConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAgentSpecApiServerConfigBasicAuthPassword
 */
export interface VmAgentSpecApiServerConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigBasicAuthPassword(obj: VmAgentSpecApiServerConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAgentSpecApiServerConfigBasicAuthUsername
 */
export interface VmAgentSpecApiServerConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigBasicAuthUsername(obj: VmAgentSpecApiServerConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCa
 */
export interface VmAgentSpecApiServerConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAgentSpecApiServerConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCa#secret
   */
  readonly secret?: VmAgentSpecApiServerConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCa(obj: VmAgentSpecApiServerConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAgentSpecApiServerConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAgentSpecApiServerConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCert
 */
export interface VmAgentSpecApiServerConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAgentSpecApiServerConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCert#secret
   */
  readonly secret?: VmAgentSpecApiServerConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCert(obj: VmAgentSpecApiServerConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAgentSpecApiServerConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAgentSpecApiServerConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigKeySecret
 */
export interface VmAgentSpecApiServerConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigKeySecret(obj: VmAgentSpecApiServerConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAgentSpecClaimTemplatesSpecDataSource
 */
export interface VmAgentSpecClaimTemplatesSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpecDataSource(obj: VmAgentSpecClaimTemplatesSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAgentSpecClaimTemplatesSpecDataSourceRef
 */
export interface VmAgentSpecClaimTemplatesSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAgentSpecClaimTemplatesSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpecDataSourceRef(obj: VmAgentSpecClaimTemplatesSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAgentSpecClaimTemplatesSpecResources
 */
export interface VmAgentSpecClaimTemplatesSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecClaimTemplatesSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAgentSpecClaimTemplatesSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecClaimTemplatesSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAgentSpecClaimTemplatesSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpecResources(obj: VmAgentSpecClaimTemplatesSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAgentSpecClaimTemplatesSpecSelector
 */
export interface VmAgentSpecClaimTemplatesSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecClaimTemplatesSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecClaimTemplatesSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpecSelector(obj: VmAgentSpecClaimTemplatesSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecClaimTemplatesStatusAllocatedResources
 */
export class VmAgentSpecClaimTemplatesStatusAllocatedResources {
  public static fromNumber(value: number): VmAgentSpecClaimTemplatesStatusAllocatedResources {
    return new VmAgentSpecClaimTemplatesStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAgentSpecClaimTemplatesStatusAllocatedResources {
    return new VmAgentSpecClaimTemplatesStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecClaimTemplatesStatusCapacity
 */
export class VmAgentSpecClaimTemplatesStatusCapacity {
  public static fromNumber(value: number): VmAgentSpecClaimTemplatesStatusCapacity {
    return new VmAgentSpecClaimTemplatesStatusCapacity(value);
  }
  public static fromString(value: string): VmAgentSpecClaimTemplatesStatusCapacity {
    return new VmAgentSpecClaimTemplatesStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAgentSpecClaimTemplatesStatusConditions
 */
export interface VmAgentSpecClaimTemplatesStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAgentSpecClaimTemplatesStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesStatusConditions(obj: VmAgentSpecClaimTemplatesStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAgentSpecClaimTemplatesStatusModifyVolumeStatus
 */
export interface VmAgentSpecClaimTemplatesStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAgentSpecClaimTemplatesStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAgentSpecClaimTemplatesStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesStatusModifyVolumeStatus(obj: VmAgentSpecClaimTemplatesStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAgentSpecRemoteWriteBasicAuthPassword
 */
export interface VmAgentSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteBasicAuthPassword(obj: VmAgentSpecRemoteWriteBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAgentSpecRemoteWriteBasicAuthUsername
 */
export interface VmAgentSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteBasicAuthUsername(obj: VmAgentSpecRemoteWriteBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAgentSpecRemoteWriteOauth2ClientId
 */
export interface VmAgentSpecRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: VmAgentSpecRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: VmAgentSpecRemoteWriteOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteOauth2ClientId(obj: VmAgentSpecRemoteWriteOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAgentSpecRemoteWriteOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAgentSpecRemoteWriteOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAgentSpecRemoteWriteOauth2ClientSecret
 */
export interface VmAgentSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteOauth2ClientSecret(obj: VmAgentSpecRemoteWriteOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap with stream aggregation rules
 *
 * @schema VmAgentSpecRemoteWriteStreamAggrConfigConfigmap
 */
export interface VmAgentSpecRemoteWriteStreamAggrConfigConfigmap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigConfigmap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigConfigmap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigConfigmap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteStreamAggrConfigConfigmap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteStreamAggrConfigConfigmap(obj: VmAgentSpecRemoteWriteStreamAggrConfigConfigmap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrRule defines the rule in stream aggregation config
 *
 * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules
 */
export interface VmAgentSpecRemoteWriteStreamAggrConfigRules {
  /**
   * By is an optional list of labels for grouping input series.
   *
   * See also Without.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#by
   */
  readonly by?: string[];

  /**
   * DedupInterval is an optional interval for deduplication.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#dedup_interval
   */
  readonly dedupInterval?: string;

  /**
   * DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
   *
   * Labels are dropped before de-duplication and aggregation.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#drop_input_labels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#enable_windows
   */
  readonly enableWindows?: boolean;

  /**
   * FlushOnShutdown defines whether to flush the aggregation state on process termination
   * or config reload. Is `false` by default.
   * It is not recommended changing this setting, unless unfinished aggregations states
   * are preferred to missing data points.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#flush_on_shutdown
   */
  readonly flushOnShutdown?: boolean;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#ignore_first_intervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#ignore_old_samples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * InputRelabelConfigs is an optional relabeling rules, which are applied on the input
   * before aggregation.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#input_relabel_configs
   */
  readonly inputRelabelConfigs?: VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs[];

  /**
   * Interval is the interval between aggregations.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#interval
   */
  readonly interval: string;

  /**
   * KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#keep_metric_names
   */
  readonly keepMetricNames?: boolean;

  /**
   * Match is a label selector (or list of label selectors) for filtering time series for the given selector.
   *
   * If the match isn't set, then all the input time series are processed.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#match
   */
  readonly match?: any;

  /**
   * NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
   * By default flushes are aligned to Interval.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#no_align_flush_to_interval
   */
  readonly noAlignFlushToInterval?: boolean;

  /**
   * OutputRelabelConfigs is an optional relabeling rules, which are applied
   * on the aggregated output before being sent to remote storage.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#output_relabel_configs
   */
  readonly outputRelabelConfigs?: VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs[];

  /**
   * Outputs is a list of output aggregate functions to produce.
   *
   * The following names are allowed:
   *
   * - total - aggregates input counters
   * - increase - counts the increase over input counters
   * - count_series - counts the input series
   * - count_samples - counts the input samples
   * - sum_samples - sums the input samples
   * - last - the last biggest sample value
   * - min - the minimum sample value
   * - max - the maximum sample value
   * - avg - the average value across all the samples
   * - stddev - standard deviation across all the samples
   * - stdvar - standard variance across all the samples
   * - histogram_bucket - creates VictoriaMetrics histogram for input samples
   * - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
   *
   * The output time series will have the following names:
   *
   * input_name:aggr_<interval>_<output>
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#outputs
   */
  readonly outputs: string[];

  /**
   * Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
   * The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#staleness_interval
   */
  readonly stalenessInterval?: string;

  /**
   * Without is an optional list of labels, which must be excluded when grouping input series.
   *
   * See also By.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRules#without
   */
  readonly without?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteStreamAggrConfigRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteStreamAggrConfigRules(obj: VmAgentSpecRemoteWriteStreamAggrConfigRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'by': obj.by?.map(y => y),
    'dedup_interval': obj.dedupInterval,
    'drop_input_labels': obj.dropInputLabels?.map(y => y),
    'enable_windows': obj.enableWindows,
    'flush_on_shutdown': obj.flushOnShutdown,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignore_first_intervals': obj.ignoreFirstIntervals,
    'ignore_old_samples': obj.ignoreOldSamples,
    'input_relabel_configs': obj.inputRelabelConfigs?.map(y => toJson_VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs(y)),
    'interval': obj.interval,
    'keep_metric_names': obj.keepMetricNames,
    'match': obj.match,
    'no_align_flush_to_interval': obj.noAlignFlushToInterval,
    'output_relabel_configs': obj.outputRelabelConfigs?.map(y => toJson_VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs(y)),
    'outputs': obj.outputs?.map(y => y),
    'staleness_interval': obj.stalenessInterval,
    'without': obj.without?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCa
 */
export interface VmAgentSpecRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: VmAgentSpecRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: VmAgentSpecRemoteWriteTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCa(obj: VmAgentSpecRemoteWriteTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAgentSpecRemoteWriteTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAgentSpecRemoteWriteTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCert
 */
export interface VmAgentSpecRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: VmAgentSpecRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: VmAgentSpecRemoteWriteTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCert(obj: VmAgentSpecRemoteWriteTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAgentSpecRemoteWriteTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAgentSpecRemoteWriteTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigKeySecret
 */
export interface VmAgentSpecRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigKeySecret(obj: VmAgentSpecRemoteWriteTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmAgentSpecStatefulStorageEmptyDirSizeLimit
 */
export class VmAgentSpecStatefulStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VmAgentSpecStatefulStorageEmptyDirSizeLimit {
    return new VmAgentSpecStatefulStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmAgentSpecStatefulStorageEmptyDirSizeLimit {
    return new VmAgentSpecStatefulStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpec(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatus(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs
 */
export interface VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs(obj: VmAgentSpecStreamAggrConfigRulesInputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs
 */
export interface VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs(obj: VmAgentSpecStreamAggrConfigRulesOutputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCaConfigMap
 */
export interface VmAgentSpecApiServerConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCaConfigMap(obj: VmAgentSpecApiServerConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCaSecret
 */
export interface VmAgentSpecApiServerConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCaSecret(obj: VmAgentSpecApiServerConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCertConfigMap
 */
export interface VmAgentSpecApiServerConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCertConfigMap(obj: VmAgentSpecApiServerConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAgentSpecApiServerConfigTlsConfigCertSecret
 */
export interface VmAgentSpecApiServerConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecApiServerConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecApiServerConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecApiServerConfigTlsConfigCertSecret(obj: VmAgentSpecApiServerConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecClaimTemplatesSpecResourcesLimits
 */
export class VmAgentSpecClaimTemplatesSpecResourcesLimits {
  public static fromNumber(value: number): VmAgentSpecClaimTemplatesSpecResourcesLimits {
    return new VmAgentSpecClaimTemplatesSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAgentSpecClaimTemplatesSpecResourcesLimits {
    return new VmAgentSpecClaimTemplatesSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecClaimTemplatesSpecResourcesRequests
 */
export class VmAgentSpecClaimTemplatesSpecResourcesRequests {
  public static fromNumber(value: number): VmAgentSpecClaimTemplatesSpecResourcesRequests {
    return new VmAgentSpecClaimTemplatesSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAgentSpecClaimTemplatesSpecResourcesRequests {
    return new VmAgentSpecClaimTemplatesSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions
 */
export interface VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions(obj: VmAgentSpecClaimTemplatesSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteOauth2ClientIdConfigMap
 */
export interface VmAgentSpecRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteOauth2ClientIdConfigMap(obj: VmAgentSpecRemoteWriteOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteOauth2ClientIdSecret
 */
export interface VmAgentSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteOauth2ClientIdSecret(obj: VmAgentSpecRemoteWriteOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs
 */
export interface VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs(obj: VmAgentSpecRemoteWriteStreamAggrConfigRulesInputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs
 */
export interface VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs(obj: VmAgentSpecRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCaConfigMap
 */
export interface VmAgentSpecRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCaConfigMap(obj: VmAgentSpecRemoteWriteTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCaSecret
 */
export interface VmAgentSpecRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCaSecret(obj: VmAgentSpecRemoteWriteTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCertConfigMap
 */
export interface VmAgentSpecRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCertConfigMap(obj: VmAgentSpecRemoteWriteTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAgentSpecRemoteWriteTlsConfigCertSecret
 */
export interface VmAgentSpecRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAgentSpecRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAgentSpecRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecRemoteWriteTlsConfigCertSecret(obj: VmAgentSpecRemoteWriteTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity
 */
export class VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAgentSpecStatefulStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: VmAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAlert  executes a list of given alerting or recording rules against configured address.
 *
 * @schema VMAlert
 */
export class VmAlert extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAlert"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMAlert',
  }

  /**
   * Renders a Kubernetes manifest for "VMAlert".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAlertProps = {}): any {
    return {
      ...VmAlert.GVK,
      ...toJson_VmAlertProps(props),
    };
  }

  /**
   * Defines a "VMAlert" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAlertProps = {}) {
    super(scope, id, {
      ...VmAlert.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAlert.GVK,
      ...toJson_VmAlertProps(resolved),
    };
  }
}

/**
 * VMAlert  executes a list of given alerting or recording rules against configured address.
 *
 * @schema VMAlert
 */
export interface VmAlertProps {
  /**
   * @schema VMAlert#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMAlertSpec defines the desired state of VMAlert
   *
   * @schema VMAlert#spec
   */
  readonly spec?: VmAlertSpec;

}

/**
 * Converts an object of type 'VmAlertProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertProps(obj: VmAlertProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAlertSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAlertSpec defines the desired state of VMAlert
 *
 * @schema VmAlertSpec
 */
export interface VmAlertSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmAlertSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmAlertSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
   * Given secret reference will be added to the application and vm-config-reloader as volume
   * available since v0.57.0 version
   *
   * @schema VmAlertSpec#configReloadAuthKeySecret
   */
  readonly configReloadAuthKeySecret?: VmAlertSpecConfigReloadAuthKeySecret;

  /**
   * ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
   * for example resyncInterval: "30s"
   *
   * @schema VmAlertSpec#configReloaderExtraArgs
   */
  readonly configReloaderExtraArgs?: { [key: string]: string };

  /**
   * ConfigReloaderImageTag defines image:tag for config-reloader container
   *
   * @schema VmAlertSpec#configReloaderImageTag
   */
  readonly configReloaderImageTag?: string;

  /**
   * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAlertSpec#configReloaderResources
   */
  readonly configReloaderResources?: VmAlertSpecConfigReloaderResources;

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmAlertSpec#containers
   */
  readonly containers?: any[];

  /**
   * Datasource Victoria Metrics or VMSelect url. Required parameter. e.g. http://127.0.0.1:8428
   *
   * @schema VmAlertSpec#datasource
   */
  readonly datasource: VmAlertSpecDatasource;

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmAlertSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmAlertSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmAlertSpec#dnsConfig
   */
  readonly dnsConfig?: VmAlertSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmAlertSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
   * and metric that is user created. The label value will always be the namespace of the object that is
   * being created.
   *
   * @schema VmAlertSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * EvaluationInterval defines how often to evaluate rules by default
   *
   * @schema VmAlertSpec#evaluationInterval
   */
  readonly evaluationInterval?: string;

  /**
   * ExternalLabels in the form 'name: value' to add to all generated recording rules and alerts.
   *
   * @schema VmAlertSpec#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmAlertSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmAlertSpec#extraEnvs
   */
  readonly extraEnvs?: VmAlertSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmAlertSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmAlertSpecExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmAlertSpec#hostAliases
   */
  readonly hostAliases?: VmAlertSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmAlertSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmAlertSpec#image
   */
  readonly image?: VmAlertSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmAlertSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmAlertSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmAlertSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmAlertSpec#license
   */
  readonly license?: VmAlertSpecLicense;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmAlertSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMAlert to be configured with.
   * default or json
   *
   * @schema VmAlertSpec#logFormat
   */
  readonly logFormat?: VmAlertSpecLogFormat;

  /**
   * LogLevel for VMAlert to be configured with.
   *
   * @schema VmAlertSpec#logLevel
   */
  readonly logLevel?: VmAlertSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmAlertSpec#managedMetadata
   */
  readonly managedMetadata?: VmAlertSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmAlertSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmAlertSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Notifier prometheus alertmanager endpoint spec. Required at least one of notifier or notifiers when there are alerting rules. e.g. http://127.0.0.1:9093
   * If specified both notifier and notifiers, notifier will be added as last element to notifiers.
   * only one of notifier options could be chosen: notifierConfigRef or notifiers +  notifier
   *
   * @schema VmAlertSpec#notifier
   */
  readonly notifier?: VmAlertSpecNotifier;

  /**
   * NotifierConfigRef reference for secret with notifier configuration for vmalert
   * only one of notifier options could be chosen: notifierConfigRef or notifiers +  notifier
   *
   * @schema VmAlertSpec#notifierConfigRef
   */
  readonly notifierConfigRef?: VmAlertSpecNotifierConfigRef;

  /**
   * Notifiers prometheus alertmanager endpoints. Required at least one of notifier or notifiers when there are alerting rules. e.g. http://127.0.0.1:9093
   * If specified both notifier and notifiers, notifier will be added as last element to notifiers.
   * only one of notifier options could be chosen: notifierConfigRef or notifiers +  notifier
   *
   * @schema VmAlertSpec#notifiers
   */
  readonly notifiers?: VmAlertSpecNotifiers[];

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmAlertSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmAlertSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmAlertSpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMAlert pods.
   *
   * @schema VmAlertSpec#podMetadata
   */
  readonly podMetadata?: VmAlertSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmAlertSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmAlertSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmAlertSpec#readinessGates
   */
  readonly readinessGates?: VmAlertSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmAlertSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * RemoteRead Optional URL to read vmalert state (persisted via RemoteWrite)
   * This configuration only makes sense if alerts state has been successfully
   * persisted (via RemoteWrite) before.
   * see -remoteRead.url docs in vmalerts for details.
   * E.g. http://127.0.0.1:8428
   *
   * @schema VmAlertSpec#remoteRead
   */
  readonly remoteRead?: VmAlertSpecRemoteRead;

  /**
   * RemoteWrite Optional URL to remote-write compatible storage to persist
   * vmalert state and rule results to.
   * Rule results will be persisted according to each rule.
   * Alerts state will be persisted in the form of time series named ALERTS and ALERTS_FOR_STATE
   * see -remoteWrite.url docs in vmalerts for details.
   * E.g. http://127.0.0.1:8428
   *
   * @schema VmAlertSpec#remoteWrite
   */
  readonly remoteWrite?: VmAlertSpecRemoteWrite;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmAlertSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAlertSpec#resources
   */
  readonly resources?: VmAlertSpecResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmAlertSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VmAlertSpec#rollingUpdate
   */
  readonly rollingUpdate?: VmAlertSpecRollingUpdate;

  /**
   * RuleNamespaceSelector to be selected for VMRules discovery.
   * Works in combination with Selector.
   * If both nil - behaviour controlled by selectAllByDefault
   * NamespaceSelector nil - only objects at VMAlert namespace.
   *
   * @schema VmAlertSpec#ruleNamespaceSelector
   */
  readonly ruleNamespaceSelector?: VmAlertSpecRuleNamespaceSelector;

  /**
   * RulePath to the file with alert rules.
   * Supports patterns. Flag can be specified multiple times.
   * Examples:
   * -rule /path/to/file. Path to a single file with alerting rules
   * -rule dir/*.yaml -rule /*.yaml. Relative path to all .yaml files in folder,
   * absolute path to all .yaml files in root.
   * by default operator adds /etc/vmalert/configs/base/vmalert.yaml
   *
   * @schema VmAlertSpec#rulePath
   */
  readonly rulePath?: string[];

  /**
   * RuleSelector selector to select which VMRules to mount for loading alerting
   * rules from.
   * Works in combination with NamespaceSelector.
   * If both nil - behaviour controlled by selectAllByDefault
   * NamespaceSelector nil - only objects at VMAlert namespace.
   *
   * @schema VmAlertSpec#ruleSelector
   */
  readonly ruleSelector?: VmAlertSpecRuleSelector;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmAlertSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmAlertSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmAlertSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmAlertSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * SelectAllByDefault changes default behavior for empty CRD selectors, such RuleSelector.
   * with selectAllByDefault: true and empty serviceScrapeSelector and RuleNamespaceSelector
   * Operator selects all exist serviceScrapes
   * with selectAllByDefault: false - selects nothing
   *
   * @schema VmAlertSpec#selectAllByDefault
   */
  readonly selectAllByDefault?: boolean;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmAlertSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vmalert VMServiceScrape spec
   *
   * @schema VmAlertSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmalert service spec
   *
   * @schema VmAlertSpec#serviceSpec
   */
  readonly serviceSpec?: VmAlertSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmAlertSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmAlertSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmAlertSpec#tolerations
   */
  readonly tolerations?: VmAlertSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmAlertSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VmAlertSpec#updateStrategy
   */
  readonly updateStrategy?: VmAlertSpecUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmAlertSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmAlertSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * UseVMConfigReloader replaces prometheus-like config-reloader
   * with vm one. It uses secrets watch instead of file watch
   * which greatly increases speed of config updates
   *
   * @schema VmAlertSpec#useVMConfigReloader
   */
  readonly useVmConfigReloader?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmAlertSpec#volumeMounts
   */
  readonly volumeMounts?: VmAlertSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmAlertSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmAlertSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpec(obj: VmAlertSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'configReloadAuthKeySecret': toJson_VmAlertSpecConfigReloadAuthKeySecret(obj.configReloadAuthKeySecret),
    'configReloaderExtraArgs': ((obj.configReloaderExtraArgs) === undefined) ? undefined : (Object.entries(obj.configReloaderExtraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configReloaderImageTag': obj.configReloaderImageTag,
    'configReloaderResources': toJson_VmAlertSpecConfigReloaderResources(obj.configReloaderResources),
    'containers': obj.containers?.map(y => y),
    'datasource': toJson_VmAlertSpecDatasource(obj.datasource),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmAlertSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'evaluationInterval': obj.evaluationInterval,
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmAlertSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmAlertSpecExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmAlertSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmAlertSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmAlertSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'license': toJson_VmAlertSpecLicense(obj.license),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmAlertSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'notifier': toJson_VmAlertSpecNotifier(obj.notifier),
    'notifierConfigRef': toJson_VmAlertSpecNotifierConfigRef(obj.notifierConfigRef),
    'notifiers': obj.notifiers?.map(y => toJson_VmAlertSpecNotifiers(y)),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VmAlertSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmAlertSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmAlertSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'remoteRead': toJson_VmAlertSpecRemoteRead(obj.remoteRead),
    'remoteWrite': toJson_VmAlertSpecRemoteWrite(obj.remoteWrite),
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmAlertSpecResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VmAlertSpecRollingUpdate(obj.rollingUpdate),
    'ruleNamespaceSelector': toJson_VmAlertSpecRuleNamespaceSelector(obj.ruleNamespaceSelector),
    'rulePath': obj.rulePath?.map(y => y),
    'ruleSelector': toJson_VmAlertSpecRuleSelector(obj.ruleSelector),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'selectAllByDefault': obj.selectAllByDefault,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmAlertSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmAlertSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'useVMConfigReloader': obj.useVmConfigReloader,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmAlertSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
 * Given secret reference will be added to the application and vm-config-reloader as volume
 * available since v0.57.0 version
 *
 * @schema VmAlertSpecConfigReloadAuthKeySecret
 */
export interface VmAlertSpecConfigReloadAuthKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecConfigReloadAuthKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecConfigReloadAuthKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecConfigReloadAuthKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecConfigReloadAuthKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecConfigReloadAuthKeySecret(obj: VmAlertSpecConfigReloadAuthKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAlertSpecConfigReloaderResources
 */
export interface VmAlertSpecConfigReloaderResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAlertSpecConfigReloaderResources#claims
   */
  readonly claims?: VmAlertSpecConfigReloaderResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertSpecConfigReloaderResources#limits
   */
  readonly limits?: { [key: string]: VmAlertSpecConfigReloaderResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertSpecConfigReloaderResources#requests
   */
  readonly requests?: { [key: string]: VmAlertSpecConfigReloaderResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertSpecConfigReloaderResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecConfigReloaderResources(obj: VmAlertSpecConfigReloaderResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAlertSpecConfigReloaderResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Datasource Victoria Metrics or VMSelect url. Required parameter. e.g. http://127.0.0.1:8428
 *
 * @schema VmAlertSpecDatasource
 */
export interface VmAlertSpecDatasource {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAlertSpecDatasource#basicAuth
   */
  readonly basicAuth?: VmAlertSpecDatasourceBasicAuth;

  /**
   * Path to bearer token file
   *
   * @schema VmAlertSpecDatasource#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAlertSpecDatasource#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAlertSpecDatasourceBearerTokenSecret;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName:headerValue
   * vmalert supports it since 1.79.0 version
   *
   * @schema VmAlertSpecDatasource#headers
   */
  readonly headers?: string[];

  /**
   * OAuth2 defines OAuth2 configuration
   *
   * @schema VmAlertSpecDatasource#oauth2
   */
  readonly oauth2?: any;

  /**
   * TLSConfig specifies TLSConfig configuration parameters.
   *
   * @schema VmAlertSpecDatasource#tlsConfig
   */
  readonly tlsConfig?: any;

  /**
   * Victoria Metrics or VMSelect url. Required parameter. E.g. http://127.0.0.1:8428
   *
   * @schema VmAlertSpecDatasource#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmAlertSpecDatasource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDatasource(obj: VmAlertSpecDatasource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAlertSpecDatasourceBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAlertSpecDatasourceBearerTokenSecret(obj.bearerTokenSecret),
    'headers': obj.headers?.map(y => y),
    'oauth2': obj.oauth2,
    'tlsConfig': obj.tlsConfig,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmAlertSpecDnsConfig
 */
export interface VmAlertSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmAlertSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmAlertSpecDnsConfig#options
   */
  readonly options?: VmAlertSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmAlertSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDnsConfig(obj: VmAlertSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmAlertSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmAlertSpecExtraEnvs
 */
export interface VmAlertSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmAlertSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmAlertSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecExtraEnvs(obj: VmAlertSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmAlertSpecExtraEnvsFrom
 */
export interface VmAlertSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmAlertSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmAlertSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmAlertSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmAlertSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmAlertSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmAlertSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecExtraEnvsFrom(obj: VmAlertSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmAlertSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmAlertSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmAlertSpecHostAliases
 */
export interface VmAlertSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmAlertSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmAlertSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmAlertSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecHostAliases(obj: VmAlertSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmAlertSpecImage
 */
export interface VmAlertSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmAlertSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmAlertSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmAlertSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmAlertSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecImage(obj: VmAlertSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmAlertSpecImagePullSecrets
 */
export interface VmAlertSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecImagePullSecrets(obj: VmAlertSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmAlertSpecLicense
 */
export interface VmAlertSpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmAlertSpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmAlertSpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmAlertSpecLicense#keyRef
   */
  readonly keyRef?: VmAlertSpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmAlertSpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmAlertSpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecLicense(obj: VmAlertSpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmAlertSpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMAlert to be configured with.
 * default or json
 *
 * @schema VmAlertSpecLogFormat
 */
export enum VmAlertSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMAlert to be configured with.
 *
 * @schema VmAlertSpecLogLevel
 */
export enum VmAlertSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmAlertSpecManagedMetadata
 */
export interface VmAlertSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecManagedMetadata(obj: VmAlertSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Notifier prometheus alertmanager endpoint spec. Required at least one of notifier or notifiers when there are alerting rules. e.g. http://127.0.0.1:9093
 * If specified both notifier and notifiers, notifier will be added as last element to notifiers.
 * only one of notifier options could be chosen: notifierConfigRef or notifiers +  notifier
 *
 * @schema VmAlertSpecNotifier
 */
export interface VmAlertSpecNotifier {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAlertSpecNotifier#basicAuth
   */
  readonly basicAuth?: VmAlertSpecNotifierBasicAuth;

  /**
   * Path to bearer token file
   *
   * @schema VmAlertSpecNotifier#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAlertSpecNotifier#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAlertSpecNotifierBearerTokenSecret;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName:headerValue
   * vmalert supports it since 1.79.0 version
   *
   * @schema VmAlertSpecNotifier#headers
   */
  readonly headers?: string[];

  /**
   * OAuth2 defines OAuth2 configuration
   *
   * @schema VmAlertSpecNotifier#oauth2
   */
  readonly oauth2?: any;

  /**
   * Selector allows service discovery for alertmanager
   * in this case all matched vmalertmanager replicas will be added into vmalert notifier.url
   * as statefulset pod.fqdn
   *
   * @schema VmAlertSpecNotifier#selector
   */
  readonly selector?: VmAlertSpecNotifierSelector;

  /**
   * TLSConfig specifies TLSConfig configuration parameters.
   *
   * @schema VmAlertSpecNotifier#tlsConfig
   */
  readonly tlsConfig?: any;

  /**
   * AlertManager url.  E.g. http://127.0.0.1:9093
   *
   * @schema VmAlertSpecNotifier#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VmAlertSpecNotifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifier(obj: VmAlertSpecNotifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAlertSpecNotifierBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAlertSpecNotifierBearerTokenSecret(obj.bearerTokenSecret),
    'headers': obj.headers?.map(y => y),
    'oauth2': obj.oauth2,
    'selector': toJson_VmAlertSpecNotifierSelector(obj.selector),
    'tlsConfig': obj.tlsConfig,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NotifierConfigRef reference for secret with notifier configuration for vmalert
 * only one of notifier options could be chosen: notifierConfigRef or notifiers +  notifier
 *
 * @schema VmAlertSpecNotifierConfigRef
 */
export interface VmAlertSpecNotifierConfigRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifierConfigRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifierConfigRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifierConfigRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierConfigRef(obj: VmAlertSpecNotifierConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAlertNotifierSpec defines the notifier url for sending information about alerts
 *
 * @schema VmAlertSpecNotifiers
 */
export interface VmAlertSpecNotifiers {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAlertSpecNotifiers#basicAuth
   */
  readonly basicAuth?: VmAlertSpecNotifiersBasicAuth;

  /**
   * Path to bearer token file
   *
   * @schema VmAlertSpecNotifiers#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAlertSpecNotifiers#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAlertSpecNotifiersBearerTokenSecret;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName:headerValue
   * vmalert supports it since 1.79.0 version
   *
   * @schema VmAlertSpecNotifiers#headers
   */
  readonly headers?: string[];

  /**
   * OAuth2 defines OAuth2 configuration
   *
   * @schema VmAlertSpecNotifiers#oauth2
   */
  readonly oauth2?: any;

  /**
   * Selector allows service discovery for alertmanager
   * in this case all matched vmalertmanager replicas will be added into vmalert notifier.url
   * as statefulset pod.fqdn
   *
   * @schema VmAlertSpecNotifiers#selector
   */
  readonly selector?: VmAlertSpecNotifiersSelector;

  /**
   * TLSConfig specifies TLSConfig configuration parameters.
   *
   * @schema VmAlertSpecNotifiers#tlsConfig
   */
  readonly tlsConfig?: any;

  /**
   * AlertManager url.  E.g. http://127.0.0.1:9093
   *
   * @schema VmAlertSpecNotifiers#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiers(obj: VmAlertSpecNotifiers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAlertSpecNotifiersBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAlertSpecNotifiersBearerTokenSecret(obj.bearerTokenSecret),
    'headers': obj.headers?.map(y => y),
    'oauth2': obj.oauth2,
    'selector': toJson_VmAlertSpecNotifiersSelector(obj.selector),
    'tlsConfig': obj.tlsConfig,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmAlertSpecPodDisruptionBudget
 */
export interface VmAlertSpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmAlertSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmAlertSpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmAlertSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmAlertSpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmAlertSpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecPodDisruptionBudget(obj: VmAlertSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMAlert pods.
 *
 * @schema VmAlertSpecPodMetadata
 */
export interface VmAlertSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAlertSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecPodMetadata(obj: VmAlertSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmAlertSpecReadinessGates
 */
export interface VmAlertSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmAlertSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmAlertSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecReadinessGates(obj: VmAlertSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRead Optional URL to read vmalert state (persisted via RemoteWrite)
 * This configuration only makes sense if alerts state has been successfully
 * persisted (via RemoteWrite) before.
 * see -remoteRead.url docs in vmalerts for details.
 * E.g. http://127.0.0.1:8428
 *
 * @schema VmAlertSpecRemoteRead
 */
export interface VmAlertSpecRemoteRead {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAlertSpecRemoteRead#basicAuth
   */
  readonly basicAuth?: VmAlertSpecRemoteReadBasicAuth;

  /**
   * Path to bearer token file
   *
   * @schema VmAlertSpecRemoteRead#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAlertSpecRemoteRead#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAlertSpecRemoteReadBearerTokenSecret;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName:headerValue
   * vmalert supports it since 1.79.0 version
   *
   * @schema VmAlertSpecRemoteRead#headers
   */
  readonly headers?: string[];

  /**
   * Lookback defines how far to look into past for alerts timeseries. For example, if lookback=1h then range from now() to now()-1h will be scanned. (default 1h0m0s)
   * Applied only to RemoteReadSpec
   *
   * @schema VmAlertSpecRemoteRead#lookback
   */
  readonly lookback?: string;

  /**
   * OAuth2 defines OAuth2 configuration
   *
   * @schema VmAlertSpecRemoteRead#oauth2
   */
  readonly oauth2?: any;

  /**
   * TLSConfig specifies TLSConfig configuration parameters.
   *
   * @schema VmAlertSpecRemoteRead#tlsConfig
   */
  readonly tlsConfig?: any;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema VmAlertSpecRemoteRead#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteRead' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteRead(obj: VmAlertSpecRemoteRead | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAlertSpecRemoteReadBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAlertSpecRemoteReadBearerTokenSecret(obj.bearerTokenSecret),
    'headers': obj.headers?.map(y => y),
    'lookback': obj.lookback,
    'oauth2': obj.oauth2,
    'tlsConfig': obj.tlsConfig,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteWrite Optional URL to remote-write compatible storage to persist
 * vmalert state and rule results to.
 * Rule results will be persisted according to each rule.
 * Alerts state will be persisted in the form of time series named ALERTS and ALERTS_FOR_STATE
 * see -remoteWrite.url docs in vmalerts for details.
 * E.g. http://127.0.0.1:8428
 *
 * @schema VmAlertSpecRemoteWrite
 */
export interface VmAlertSpecRemoteWrite {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmAlertSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: VmAlertSpecRemoteWriteBasicAuth;

  /**
   * Path to bearer token file
   *
   * @schema VmAlertSpecRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAlertSpecRemoteWrite#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAlertSpecRemoteWriteBearerTokenSecret;

  /**
   * Defines number of readers that concurrently write into remote storage (default 1)
   *
   * @schema VmAlertSpecRemoteWrite#concurrency
   */
  readonly concurrency?: number;

  /**
   * Defines interval of flushes to remote write endpoint (default 5s)
   *
   * @schema VmAlertSpecRemoteWrite#flushInterval
   */
  readonly flushInterval?: string;

  /**
   * Headers allow configuring custom http headers
   * Must be in form of semicolon separated header with value
   * e.g.
   * headerName:headerValue
   * vmalert supports it since 1.79.0 version
   *
   * @schema VmAlertSpecRemoteWrite#headers
   */
  readonly headers?: string[];

  /**
   * Defines defines max number of timeseries to be flushed at once (default 1000)
   *
   * @schema VmAlertSpecRemoteWrite#maxBatchSize
   */
  readonly maxBatchSize?: number;

  /**
   * Defines the max number of pending datapoints to remote write endpoint (default 100000)
   *
   * @schema VmAlertSpecRemoteWrite#maxQueueSize
   */
  readonly maxQueueSize?: number;

  /**
   * OAuth2 defines OAuth2 configuration
   *
   * @schema VmAlertSpecRemoteWrite#oauth2
   */
  readonly oauth2?: any;

  /**
   * TLSConfig specifies TLSConfig configuration parameters.
   *
   * @schema VmAlertSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: any;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema VmAlertSpecRemoteWrite#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteWrite(obj: VmAlertSpecRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAlertSpecRemoteWriteBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAlertSpecRemoteWriteBearerTokenSecret(obj.bearerTokenSecret),
    'concurrency': obj.concurrency,
    'flushInterval': obj.flushInterval,
    'headers': obj.headers?.map(y => y),
    'maxBatchSize': obj.maxBatchSize,
    'maxQueueSize': obj.maxQueueSize,
    'oauth2': obj.oauth2,
    'tlsConfig': obj.tlsConfig,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAlertSpecResources
 */
export interface VmAlertSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAlertSpecResources#claims
   */
  readonly claims?: VmAlertSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAlertSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAlertSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecResources(obj: VmAlertSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAlertSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VmAlertSpecRollingUpdate
 */
export interface VmAlertSpecRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VmAlertSpecRollingUpdate#maxSurge
   */
  readonly maxSurge?: VmAlertSpecRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VmAlertSpecRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VmAlertSpecRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VmAlertSpecRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRollingUpdate(obj: VmAlertSpecRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleNamespaceSelector to be selected for VMRules discovery.
 * Works in combination with Selector.
 * If both nil - behaviour controlled by selectAllByDefault
 * NamespaceSelector nil - only objects at VMAlert namespace.
 *
 * @schema VmAlertSpecRuleNamespaceSelector
 */
export interface VmAlertSpecRuleNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertSpecRuleNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertSpecRuleNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertSpecRuleNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecRuleNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRuleNamespaceSelector(obj: VmAlertSpecRuleNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertSpecRuleNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleSelector selector to select which VMRules to mount for loading alerting
 * rules from.
 * Works in combination with NamespaceSelector.
 * If both nil - behaviour controlled by selectAllByDefault
 * NamespaceSelector nil - only objects at VMAlert namespace.
 *
 * @schema VmAlertSpecRuleSelector
 */
export interface VmAlertSpecRuleSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertSpecRuleSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertSpecRuleSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertSpecRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRuleSelector(obj: VmAlertSpecRuleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertSpecRuleSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmalert service spec
 *
 * @schema VmAlertSpecServiceSpec
 */
export interface VmAlertSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmAlertSpecServiceSpec#metadata
   */
  readonly metadata?: VmAlertSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmAlertSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmAlertSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecServiceSpec(obj: VmAlertSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmAlertSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmAlertSpecTolerations
 */
export interface VmAlertSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmAlertSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmAlertSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmAlertSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmAlertSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmAlertSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecTolerations(obj: VmAlertSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VmAlertSpecUpdateStrategy
 */
export enum VmAlertSpecUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmAlertSpecVolumeMounts
 */
export interface VmAlertSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmAlertSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmAlertSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmAlertSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmAlertSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmAlertSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmAlertSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmAlertSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmAlertSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecVolumeMounts(obj: VmAlertSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAlertSpecConfigReloaderResourcesClaims
 */
export interface VmAlertSpecConfigReloaderResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAlertSpecConfigReloaderResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAlertSpecConfigReloaderResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAlertSpecConfigReloaderResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecConfigReloaderResourcesClaims(obj: VmAlertSpecConfigReloaderResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertSpecConfigReloaderResourcesLimits
 */
export class VmAlertSpecConfigReloaderResourcesLimits {
  public static fromNumber(value: number): VmAlertSpecConfigReloaderResourcesLimits {
    return new VmAlertSpecConfigReloaderResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertSpecConfigReloaderResourcesLimits {
    return new VmAlertSpecConfigReloaderResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertSpecConfigReloaderResourcesRequests
 */
export class VmAlertSpecConfigReloaderResourcesRequests {
  public static fromNumber(value: number): VmAlertSpecConfigReloaderResourcesRequests {
    return new VmAlertSpecConfigReloaderResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertSpecConfigReloaderResourcesRequests {
    return new VmAlertSpecConfigReloaderResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAlertSpecDatasourceBasicAuth
 */
export interface VmAlertSpecDatasourceBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecDatasourceBasicAuth#password
   */
  readonly password?: VmAlertSpecDatasourceBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertSpecDatasourceBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecDatasourceBasicAuth#username
   */
  readonly username?: VmAlertSpecDatasourceBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertSpecDatasourceBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDatasourceBasicAuth(obj: VmAlertSpecDatasourceBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertSpecDatasourceBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertSpecDatasourceBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAlertSpecDatasourceBearerTokenSecret
 */
export interface VmAlertSpecDatasourceBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecDatasourceBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecDatasourceBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecDatasourceBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecDatasourceBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDatasourceBearerTokenSecret(obj: VmAlertSpecDatasourceBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmAlertSpecDnsConfigOptions
 */
export interface VmAlertSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmAlertSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmAlertSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDnsConfigOptions(obj: VmAlertSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmAlertSpecExtraEnvsFromConfigMapRef
 */
export interface VmAlertSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmAlertSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecExtraEnvsFromConfigMapRef(obj: VmAlertSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmAlertSpecExtraEnvsFromSecretRef
 */
export interface VmAlertSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmAlertSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecExtraEnvsFromSecretRef(obj: VmAlertSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmAlertSpecLicenseKeyRef
 */
export interface VmAlertSpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecLicenseKeyRef(obj: VmAlertSpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAlertSpecNotifierBasicAuth
 */
export interface VmAlertSpecNotifierBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecNotifierBasicAuth#password
   */
  readonly password?: VmAlertSpecNotifierBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertSpecNotifierBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecNotifierBasicAuth#username
   */
  readonly username?: VmAlertSpecNotifierBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierBasicAuth(obj: VmAlertSpecNotifierBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertSpecNotifierBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertSpecNotifierBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAlertSpecNotifierBearerTokenSecret
 */
export interface VmAlertSpecNotifierBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifierBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifierBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifierBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierBearerTokenSecret(obj: VmAlertSpecNotifierBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector allows service discovery for alertmanager
 * in this case all matched vmalertmanager replicas will be added into vmalert notifier.url
 * as statefulset pod.fqdn
 *
 * @schema VmAlertSpecNotifierSelector
 */
export interface VmAlertSpecNotifierSelector {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema VmAlertSpecNotifierSelector#labelSelector
   */
  readonly labelSelector?: VmAlertSpecNotifierSelectorLabelSelector;

  /**
   * NamespaceSelector is a selector for selecting either all namespaces or a
   * list of namespaces.
   *
   * @schema VmAlertSpecNotifierSelector#namespaceSelector
   */
  readonly namespaceSelector?: VmAlertSpecNotifierSelectorNamespaceSelector;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierSelector(obj: VmAlertSpecNotifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_VmAlertSpecNotifierSelectorLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_VmAlertSpecNotifierSelectorNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAlertSpecNotifiersBasicAuth
 */
export interface VmAlertSpecNotifiersBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecNotifiersBasicAuth#password
   */
  readonly password?: VmAlertSpecNotifiersBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertSpecNotifiersBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecNotifiersBasicAuth#username
   */
  readonly username?: VmAlertSpecNotifiersBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersBasicAuth(obj: VmAlertSpecNotifiersBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertSpecNotifiersBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertSpecNotifiersBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAlertSpecNotifiersBearerTokenSecret
 */
export interface VmAlertSpecNotifiersBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifiersBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifiersBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifiersBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersBearerTokenSecret(obj: VmAlertSpecNotifiersBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector allows service discovery for alertmanager
 * in this case all matched vmalertmanager replicas will be added into vmalert notifier.url
 * as statefulset pod.fqdn
 *
 * @schema VmAlertSpecNotifiersSelector
 */
export interface VmAlertSpecNotifiersSelector {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema VmAlertSpecNotifiersSelector#labelSelector
   */
  readonly labelSelector?: VmAlertSpecNotifiersSelectorLabelSelector;

  /**
   * NamespaceSelector is a selector for selecting either all namespaces or a
   * list of namespaces.
   *
   * @schema VmAlertSpecNotifiersSelector#namespaceSelector
   */
  readonly namespaceSelector?: VmAlertSpecNotifiersSelectorNamespaceSelector;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersSelector(obj: VmAlertSpecNotifiersSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_VmAlertSpecNotifiersSelectorLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_VmAlertSpecNotifiersSelectorNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmAlertSpecPodDisruptionBudgetMaxUnavailable
 */
export class VmAlertSpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmAlertSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAlertSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmAlertSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAlertSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmAlertSpecPodDisruptionBudgetMinAvailable
 */
export class VmAlertSpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmAlertSpecPodDisruptionBudgetMinAvailable {
    return new VmAlertSpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmAlertSpecPodDisruptionBudgetMinAvailable {
    return new VmAlertSpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAlertSpecRemoteReadBasicAuth
 */
export interface VmAlertSpecRemoteReadBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecRemoteReadBasicAuth#password
   */
  readonly password?: VmAlertSpecRemoteReadBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertSpecRemoteReadBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecRemoteReadBasicAuth#username
   */
  readonly username?: VmAlertSpecRemoteReadBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteReadBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteReadBasicAuth(obj: VmAlertSpecRemoteReadBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertSpecRemoteReadBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertSpecRemoteReadBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAlertSpecRemoteReadBearerTokenSecret
 */
export interface VmAlertSpecRemoteReadBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteReadBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteReadBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteReadBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteReadBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteReadBearerTokenSecret(obj: VmAlertSpecRemoteReadBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmAlertSpecRemoteWriteBasicAuth
 */
export interface VmAlertSpecRemoteWriteBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecRemoteWriteBasicAuth#password
   */
  readonly password?: VmAlertSpecRemoteWriteBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertSpecRemoteWriteBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertSpecRemoteWriteBasicAuth#username
   */
  readonly username?: VmAlertSpecRemoteWriteBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteWriteBasicAuth(obj: VmAlertSpecRemoteWriteBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertSpecRemoteWriteBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertSpecRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAlertSpecRemoteWriteBearerTokenSecret
 */
export interface VmAlertSpecRemoteWriteBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteWriteBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteWriteBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteWriteBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteWriteBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteWriteBearerTokenSecret(obj: VmAlertSpecRemoteWriteBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAlertSpecResourcesClaims
 */
export interface VmAlertSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAlertSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAlertSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAlertSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecResourcesClaims(obj: VmAlertSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertSpecResourcesLimits
 */
export class VmAlertSpecResourcesLimits {
  public static fromNumber(value: number): VmAlertSpecResourcesLimits {
    return new VmAlertSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertSpecResourcesLimits {
    return new VmAlertSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertSpecResourcesRequests
 */
export class VmAlertSpecResourcesRequests {
  public static fromNumber(value: number): VmAlertSpecResourcesRequests {
    return new VmAlertSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertSpecResourcesRequests {
    return new VmAlertSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VmAlertSpecRollingUpdateMaxSurge
 */
export class VmAlertSpecRollingUpdateMaxSurge {
  public static fromNumber(value: number): VmAlertSpecRollingUpdateMaxSurge {
    return new VmAlertSpecRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VmAlertSpecRollingUpdateMaxSurge {
    return new VmAlertSpecRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VmAlertSpecRollingUpdateMaxUnavailable
 */
export class VmAlertSpecRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VmAlertSpecRollingUpdateMaxUnavailable {
    return new VmAlertSpecRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VmAlertSpecRollingUpdateMaxUnavailable {
    return new VmAlertSpecRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertSpecRuleNamespaceSelectorMatchExpressions
 */
export interface VmAlertSpecRuleNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertSpecRuleNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertSpecRuleNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertSpecRuleNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecRuleNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRuleNamespaceSelectorMatchExpressions(obj: VmAlertSpecRuleNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertSpecRuleSelectorMatchExpressions
 */
export interface VmAlertSpecRuleSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertSpecRuleSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertSpecRuleSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertSpecRuleSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecRuleSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRuleSelectorMatchExpressions(obj: VmAlertSpecRuleSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmAlertSpecServiceSpecMetadata
 */
export interface VmAlertSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAlertSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecServiceSpecMetadata(obj: VmAlertSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecDatasourceBasicAuthPassword
 */
export interface VmAlertSpecDatasourceBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecDatasourceBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecDatasourceBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecDatasourceBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecDatasourceBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDatasourceBasicAuthPassword(obj: VmAlertSpecDatasourceBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecDatasourceBasicAuthUsername
 */
export interface VmAlertSpecDatasourceBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecDatasourceBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecDatasourceBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecDatasourceBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecDatasourceBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecDatasourceBasicAuthUsername(obj: VmAlertSpecDatasourceBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecNotifierBasicAuthPassword
 */
export interface VmAlertSpecNotifierBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifierBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifierBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifierBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierBasicAuthPassword(obj: VmAlertSpecNotifierBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecNotifierBasicAuthUsername
 */
export interface VmAlertSpecNotifierBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifierBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifierBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifierBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifierBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierBasicAuthUsername(obj: VmAlertSpecNotifierBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema VmAlertSpecNotifierSelectorLabelSelector
 */
export interface VmAlertSpecNotifierSelectorLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertSpecNotifierSelectorLabelSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertSpecNotifierSelectorLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecNotifierSelectorLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierSelectorLabelSelector(obj: VmAlertSpecNotifierSelectorLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector is a selector for selecting either all namespaces or a
 * list of namespaces.
 *
 * @schema VmAlertSpecNotifierSelectorNamespaceSelector
 */
export interface VmAlertSpecNotifierSelectorNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema VmAlertSpecNotifierSelectorNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema VmAlertSpecNotifierSelectorNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecNotifierSelectorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierSelectorNamespaceSelector(obj: VmAlertSpecNotifierSelectorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecNotifiersBasicAuthPassword
 */
export interface VmAlertSpecNotifiersBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifiersBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifiersBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifiersBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersBasicAuthPassword(obj: VmAlertSpecNotifiersBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecNotifiersBasicAuthUsername
 */
export interface VmAlertSpecNotifiersBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecNotifiersBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecNotifiersBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecNotifiersBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersBasicAuthUsername(obj: VmAlertSpecNotifiersBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema VmAlertSpecNotifiersSelectorLabelSelector
 */
export interface VmAlertSpecNotifiersSelectorLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertSpecNotifiersSelectorLabelSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertSpecNotifiersSelectorLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersSelectorLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersSelectorLabelSelector(obj: VmAlertSpecNotifiersSelectorLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector is a selector for selecting either all namespaces or a
 * list of namespaces.
 *
 * @schema VmAlertSpecNotifiersSelectorNamespaceSelector
 */
export interface VmAlertSpecNotifiersSelectorNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema VmAlertSpecNotifiersSelectorNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema VmAlertSpecNotifiersSelectorNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersSelectorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersSelectorNamespaceSelector(obj: VmAlertSpecNotifiersSelectorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecRemoteReadBasicAuthPassword
 */
export interface VmAlertSpecRemoteReadBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteReadBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteReadBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteReadBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteReadBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteReadBasicAuthPassword(obj: VmAlertSpecRemoteReadBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecRemoteReadBasicAuthUsername
 */
export interface VmAlertSpecRemoteReadBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteReadBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteReadBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteReadBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteReadBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteReadBasicAuthUsername(obj: VmAlertSpecRemoteReadBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecRemoteWriteBasicAuthPassword
 */
export interface VmAlertSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteWriteBasicAuthPassword(obj: VmAlertSpecRemoteWriteBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertSpecRemoteWriteBasicAuthUsername
 */
export interface VmAlertSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecRemoteWriteBasicAuthUsername(obj: VmAlertSpecRemoteWriteBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions
 */
export interface VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions(obj: VmAlertSpecNotifierSelectorLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions
 */
export interface VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions(obj: VmAlertSpecNotifiersSelectorLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAlertmanager represents Victoria-Metrics deployment for Alertmanager.
 *
 * @schema VMAlertmanager
 */
export class VmAlertmanager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAlertmanager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMAlertmanager',
  }

  /**
   * Renders a Kubernetes manifest for "VMAlertmanager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAlertmanagerProps): any {
    return {
      ...VmAlertmanager.GVK,
      ...toJson_VmAlertmanagerProps(props),
    };
  }

  /**
   * Defines a "VMAlertmanager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAlertmanagerProps) {
    super(scope, id, {
      ...VmAlertmanager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAlertmanager.GVK,
      ...toJson_VmAlertmanagerProps(resolved),
    };
  }
}

/**
 * VMAlertmanager represents Victoria-Metrics deployment for Alertmanager.
 *
 * @schema VMAlertmanager
 */
export interface VmAlertmanagerProps {
  /**
   * @schema VMAlertmanager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the VMAlertmanager cluster. More info:
   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema VMAlertmanager#spec
   */
  readonly spec: VmAlertmanagerSpec;

}

/**
 * Converts an object of type 'VmAlertmanagerProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerProps(obj: VmAlertmanagerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAlertmanagerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the VMAlertmanager cluster. More info:
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema VmAlertmanagerSpec
 */
export interface VmAlertmanagerSpec {
  /**
   * AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
   *
   * @schema VmAlertmanagerSpec#additionalPeers
   */
  readonly additionalPeers?: string[];

  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmAlertmanagerSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
   *
   * @schema VmAlertmanagerSpec#claimTemplates
   */
  readonly claimTemplates?: VmAlertmanagerSpecClaimTemplates[];

  /**
   * ClusterAdvertiseAddress is the explicit address to advertise in cluster.
   * Needs to be provided for non RFC1918 [1] (public) addresses.
   * [1] RFC1918: https://tools.ietf.org/html/rfc1918
   *
   * @schema VmAlertmanagerSpec#clusterAdvertiseAddress
   */
  readonly clusterAdvertiseAddress?: string;

  /**
   * ClusterDomainName defines domain name suffix for in-cluster dns addresses
   * aka .cluster.local
   * used to build pod peer addresses for in-cluster communication
   *
   * @schema VmAlertmanagerSpec#clusterDomainName
   */
  readonly clusterDomainName?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmAlertmanagerSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigNamespaceSelector defines namespace selector for
   * VMAlertmanagerConfig. Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAlertmanager namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAlertmanagerSpec#configNamespaceSelector
   */
  readonly configNamespaceSelector?: VmAlertmanagerSpecConfigNamespaceSelector;

  /**
   * ConfigRawYaml - raw configuration for alertmanager,
   * it helps it to start without secret.
   * priority -> hardcoded ConfigRaw -> ConfigRaw, provided by user -> ConfigSecret.
   *
   * @schema VmAlertmanagerSpec#configRawYaml
   */
  readonly configRawYaml?: string;

  /**
   * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
   * Given secret reference will be added to the application and vm-config-reloader as volume
   * available since v0.57.0 version
   *
   * @schema VmAlertmanagerSpec#configReloadAuthKeySecret
   */
  readonly configReloadAuthKeySecret?: VmAlertmanagerSpecConfigReloadAuthKeySecret;

  /**
   * ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
   * for example resyncInterval: "30s"
   *
   * @schema VmAlertmanagerSpec#configReloaderExtraArgs
   */
  readonly configReloaderExtraArgs?: { [key: string]: string };

  /**
   * ConfigReloaderImageTag defines image:tag for config-reloader container
   *
   * @schema VmAlertmanagerSpec#configReloaderImageTag
   */
  readonly configReloaderImageTag?: string;

  /**
   * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAlertmanagerSpec#configReloaderResources
   */
  readonly configReloaderResources?: VmAlertmanagerSpecConfigReloaderResources;

  /**
   * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
   * VMAlertmanager object, which contains configuration for this VMAlertmanager,
   * configuration must be inside secret key: alertmanager.yaml.
   * It must be created by user.
   * instance. Defaults to 'vmalertmanager-<alertmanager-name>'
   * The secret is mounted into /etc/alertmanager/config.
   *
   * @default vmalertmanager-<alertmanager-name>'
   * @schema VmAlertmanagerSpec#configSecret
   */
  readonly configSecret?: string;

  /**
   * ConfigSelector defines selector for VMAlertmanagerConfig, result config will be merged with with Raw or Secret config.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAlertmanager namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAlertmanagerSpec#configSelector
   */
  readonly configSelector?: VmAlertmanagerSpecConfigSelector;

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmAlertmanagerSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmAlertmanagerSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableNamespaceMatcher disables adding top route label matcher "namespace = <VMAlertmanagerConfig.namespace>" for VMAlertmanagerConfig
   * It may be useful if alert doesn't have namespace label for some reason
   *
   * @schema VmAlertmanagerSpec#disableNamespaceMatcher
   */
  readonly disableNamespaceMatcher?: boolean;

  /**
   * DisableRouteContinueEnforce cancel the behavior for VMAlertmanagerConfig that always enforce first-level route continue to true
   *
   * @schema VmAlertmanagerSpec#disableRouteContinueEnforce
   */
  readonly disableRouteContinueEnforce?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmAlertmanagerSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmAlertmanagerSpec#dnsConfig
   */
  readonly dnsConfig?: VmAlertmanagerSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmAlertmanagerSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnforcedNamespaceLabel defines the namespace label key for top route matcher for VMAlertmanagerConfig
   * Default is "namespace"
   *
   * @default namespace"
   * @schema VmAlertmanagerSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * EnforcedTopRouteMatchers defines label matchers to be added for the top route
   * of VMAlertmanagerConfig
   * It allows to make some set of labels required for alerts.
   * https://prometheus.io/docs/alerting/latest/configuration/#matcher
   *
   * @schema VmAlertmanagerSpec#enforcedTopRouteMatchers
   */
  readonly enforcedTopRouteMatchers?: string[];

  /**
   * ExternalURL the VMAlertmanager instances will be available under. This is
   * necessary to generate correct URLs. This is necessary if VMAlertmanager is not
   * served from root of a DNS name.
   *
   * @schema VmAlertmanagerSpec#externalURL
   */
  readonly externalUrl?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmAlertmanagerSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmAlertmanagerSpec#extraEnvs
   */
  readonly extraEnvs?: VmAlertmanagerSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmAlertmanagerSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmAlertmanagerSpecExtraEnvsFrom[];

  /**
   * GossipConfig defines gossip TLS configuration for Alertmanager cluster
   *
   * @schema VmAlertmanagerSpec#gossipConfig
   */
  readonly gossipConfig?: VmAlertmanagerSpecGossipConfig;

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmAlertmanagerSpec#hostAliases
   */
  readonly hostAliases?: VmAlertmanagerSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmAlertmanagerSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmAlertmanagerSpec#image
   */
  readonly image?: VmAlertmanagerSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmAlertmanagerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmAlertmanagerSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmAlertmanagerSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * ListenLocal makes the VMAlertmanager server listen on loopback, so that it
   * does not bind against the Pod IP. Note this is only for the VMAlertmanager
   * UI, not the gossip communication.
   *
   * @schema VmAlertmanagerSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmAlertmanagerSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMAlertmanager to be configured with.
   *
   * @schema VmAlertmanagerSpec#logFormat
   */
  readonly logFormat?: VmAlertmanagerSpecLogFormat;

  /**
   * Log level for VMAlertmanager to be configured with.
   *
   * @schema VmAlertmanagerSpec#logLevel
   */
  readonly logLevel?: VmAlertmanagerSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmAlertmanagerSpec#managedMetadata
   */
  readonly managedMetadata?: VmAlertmanagerSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmAlertmanagerSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmAlertmanagerSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmAlertmanagerSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VmAlertmanagerSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmAlertmanagerSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmAlertmanagerSpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.
   *
   * @schema VmAlertmanagerSpec#podMetadata
   */
  readonly podMetadata?: VmAlertmanagerSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmAlertmanagerSpec#port
   */
  readonly port?: string;

  /**
   * PortName used for the pods and governing service.
   * This defaults to web
   *
   * @schema VmAlertmanagerSpec#portName
   */
  readonly portName?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmAlertmanagerSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmAlertmanagerSpec#readinessGates
   */
  readonly readinessGates?: VmAlertmanagerSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmAlertmanagerSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmAlertmanagerSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAlertmanagerSpec#resources
   */
  readonly resources?: VmAlertmanagerSpecResources;

  /**
   * Retention Time duration VMAlertmanager shall retain data for. Default is '120h',
   * and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
   *
   * @default 120h',
   * @schema VmAlertmanagerSpec#retention
   */
  readonly retention?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmAlertmanagerSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy defines strategy for application updates
   * Default is OnDelete, in this case operator handles update process
   * Can be changed for RollingUpdate
   *
   * @default OnDelete, in this case operator handles update process
   * @schema VmAlertmanagerSpec#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RoutePrefix VMAlertmanager registers HTTP handlers for. This is useful,
   * if using ExternalURL and a proxy is rewriting HTTP routes of a request,
   * and the actual ExternalURL is still true, but the server serves requests
   * under a different route prefix. For example for use with `kubectl proxy`.
   *
   * @schema VmAlertmanagerSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmAlertmanagerSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmAlertmanagerSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmAlertmanagerSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmAlertmanagerSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * SelectAllByDefault changes default behavior for empty CRD selectors, such ConfigSelector.
   * with selectAllByDefault: true and undefined ConfigSelector and ConfigNamespaceSelector
   * Operator selects all exist alertManagerConfigs
   * with selectAllByDefault: false - selects nothing
   *
   * @schema VmAlertmanagerSpec#selectAllByDefault
   */
  readonly selectAllByDefault?: boolean;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmAlertmanagerSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vmalertmanager VMServiceScrape spec
   *
   * @schema VmAlertmanagerSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmalertmanager service spec
   *
   * @schema VmAlertmanagerSpec#serviceSpec
   */
  readonly serviceSpec?: VmAlertmanagerSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmAlertmanagerSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage is the definition of how storage will be used by the VMAlertmanager
   * instances.
   *
   * @schema VmAlertmanagerSpec#storage
   */
  readonly storage?: VmAlertmanagerSpecStorage;

  /**
   * Templates is a list of ConfigMap key references for ConfigMaps in the same namespace as the VMAlertmanager
   * object, which shall be mounted into the VMAlertmanager Pods.
   * The Templates are mounted into /etc/vm/templates/<configmap-name>/<configmap-key>.
   *
   * @schema VmAlertmanagerSpec#templates
   */
  readonly templates?: VmAlertmanagerSpecTemplates[];

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmAlertmanagerSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmAlertmanagerSpec#tolerations
   */
  readonly tolerations?: VmAlertmanagerSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmAlertmanagerSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmAlertmanagerSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmAlertmanagerSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * UseVMConfigReloader replaces prometheus-like config-reloader
   * with vm one. It uses secrets watch instead of file watch
   * which greatly increases speed of config updates
   *
   * @schema VmAlertmanagerSpec#useVMConfigReloader
   */
  readonly useVmConfigReloader?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmAlertmanagerSpec#volumeMounts
   */
  readonly volumeMounts?: VmAlertmanagerSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmAlertmanagerSpec#volumes
   */
  readonly volumes?: any[];

  /**
   * WebConfig defines configuration for webserver
   * https://github.com/prometheus/alertmanager/blob/main/docs/https.md
   *
   * @schema VmAlertmanagerSpec#webConfig
   */
  readonly webConfig?: VmAlertmanagerSpecWebConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpec(obj: VmAlertmanagerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPeers': obj.additionalPeers?.map(y => y),
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => toJson_VmAlertmanagerSpecClaimTemplates(y)),
    'clusterAdvertiseAddress': obj.clusterAdvertiseAddress,
    'clusterDomainName': obj.clusterDomainName,
    'configMaps': obj.configMaps?.map(y => y),
    'configNamespaceSelector': toJson_VmAlertmanagerSpecConfigNamespaceSelector(obj.configNamespaceSelector),
    'configRawYaml': obj.configRawYaml,
    'configReloadAuthKeySecret': toJson_VmAlertmanagerSpecConfigReloadAuthKeySecret(obj.configReloadAuthKeySecret),
    'configReloaderExtraArgs': ((obj.configReloaderExtraArgs) === undefined) ? undefined : (Object.entries(obj.configReloaderExtraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configReloaderImageTag': obj.configReloaderImageTag,
    'configReloaderResources': toJson_VmAlertmanagerSpecConfigReloaderResources(obj.configReloaderResources),
    'configSecret': obj.configSecret,
    'configSelector': toJson_VmAlertmanagerSpecConfigSelector(obj.configSelector),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableNamespaceMatcher': obj.disableNamespaceMatcher,
    'disableRouteContinueEnforce': obj.disableRouteContinueEnforce,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmAlertmanagerSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'enforcedTopRouteMatchers': obj.enforcedTopRouteMatchers?.map(y => y),
    'externalURL': obj.externalUrl,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmAlertmanagerSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmAlertmanagerSpecExtraEnvsFrom(y)),
    'gossipConfig': toJson_VmAlertmanagerSpecGossipConfig(obj.gossipConfig),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmAlertmanagerSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmAlertmanagerSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmAlertmanagerSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'listenLocal': obj.listenLocal,
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmAlertmanagerSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VmAlertmanagerSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmAlertmanagerSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'portName': obj.portName,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmAlertmanagerSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmAlertmanagerSpecResources(obj.resources),
    'retention': obj.retention,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'routePrefix': obj.routePrefix,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'selectAllByDefault': obj.selectAllByDefault,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmAlertmanagerSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VmAlertmanagerSpecStorage(obj.storage),
    'templates': obj.templates?.map(y => toJson_VmAlertmanagerSpecTemplates(y)),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmAlertmanagerSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'useVMConfigReloader': obj.useVmConfigReloader,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmAlertmanagerSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
    'webConfig': toJson_VmAlertmanagerSpecWebConfig(obj.webConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema VmAlertmanagerSpecClaimTemplates
 */
export interface VmAlertmanagerSpecClaimTemplates {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAlertmanagerSpecClaimTemplates#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAlertmanagerSpecClaimTemplates#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema VmAlertmanagerSpecClaimTemplates#metadata
   */
  readonly metadata?: any;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAlertmanagerSpecClaimTemplates#spec
   */
  readonly spec?: VmAlertmanagerSpecClaimTemplatesSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAlertmanagerSpecClaimTemplates#status
   */
  readonly status?: VmAlertmanagerSpecClaimTemplatesStatus;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplates(obj: VmAlertmanagerSpecClaimTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': obj.metadata,
    'spec': toJson_VmAlertmanagerSpecClaimTemplatesSpec(obj.spec),
    'status': toJson_VmAlertmanagerSpecClaimTemplatesStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigNamespaceSelector defines namespace selector for
 * VMAlertmanagerConfig. Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAlertmanager namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAlertmanagerSpecConfigNamespaceSelector
 */
export interface VmAlertmanagerSpecConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigNamespaceSelector(obj: VmAlertmanagerSpecConfigNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
 * Given secret reference will be added to the application and vm-config-reloader as volume
 * available since v0.57.0 version
 *
 * @schema VmAlertmanagerSpecConfigReloadAuthKeySecret
 */
export interface VmAlertmanagerSpecConfigReloadAuthKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecConfigReloadAuthKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecConfigReloadAuthKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecConfigReloadAuthKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigReloadAuthKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigReloadAuthKeySecret(obj: VmAlertmanagerSpecConfigReloadAuthKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAlertmanagerSpecConfigReloaderResources
 */
export interface VmAlertmanagerSpecConfigReloaderResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAlertmanagerSpecConfigReloaderResources#claims
   */
  readonly claims?: VmAlertmanagerSpecConfigReloaderResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecConfigReloaderResources#limits
   */
  readonly limits?: { [key: string]: VmAlertmanagerSpecConfigReloaderResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecConfigReloaderResources#requests
   */
  readonly requests?: { [key: string]: VmAlertmanagerSpecConfigReloaderResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigReloaderResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigReloaderResources(obj: VmAlertmanagerSpecConfigReloaderResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAlertmanagerSpecConfigReloaderResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigSelector defines selector for VMAlertmanagerConfig, result config will be merged with with Raw or Secret config.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAlertmanager namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAlertmanagerSpecConfigSelector
 */
export interface VmAlertmanagerSpecConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecConfigSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertmanagerSpecConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigSelector(obj: VmAlertmanagerSpecConfigSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertmanagerSpecConfigSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmAlertmanagerSpecDnsConfig
 */
export interface VmAlertmanagerSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmAlertmanagerSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmAlertmanagerSpecDnsConfig#options
   */
  readonly options?: VmAlertmanagerSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmAlertmanagerSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecDnsConfig(obj: VmAlertmanagerSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmAlertmanagerSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmAlertmanagerSpecExtraEnvs
 */
export interface VmAlertmanagerSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmAlertmanagerSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmAlertmanagerSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecExtraEnvs(obj: VmAlertmanagerSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmAlertmanagerSpecExtraEnvsFrom
 */
export interface VmAlertmanagerSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmAlertmanagerSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmAlertmanagerSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmAlertmanagerSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmAlertmanagerSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmAlertmanagerSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecExtraEnvsFrom(obj: VmAlertmanagerSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmAlertmanagerSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmAlertmanagerSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GossipConfig defines gossip TLS configuration for Alertmanager cluster
 *
 * @schema VmAlertmanagerSpecGossipConfig
 */
export interface VmAlertmanagerSpecGossipConfig {
  /**
   * TLSClientConfig defines client TLS configuration for alertmanager
   *
   * @schema VmAlertmanagerSpecGossipConfig#tls_client_config
   */
  readonly tlsClientConfig?: VmAlertmanagerSpecGossipConfigTlsClientConfig;

  /**
   * TLSServerConfig defines server TLS configuration for alertmanager
   *
   * @schema VmAlertmanagerSpecGossipConfig#tls_server_config
   */
  readonly tlsServerConfig?: VmAlertmanagerSpecGossipConfigTlsServerConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfig(obj: VmAlertmanagerSpecGossipConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tls_client_config': toJson_VmAlertmanagerSpecGossipConfigTlsClientConfig(obj.tlsClientConfig),
    'tls_server_config': toJson_VmAlertmanagerSpecGossipConfigTlsServerConfig(obj.tlsServerConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmAlertmanagerSpecHostAliases
 */
export interface VmAlertmanagerSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmAlertmanagerSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmAlertmanagerSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecHostAliases(obj: VmAlertmanagerSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmAlertmanagerSpecImage
 */
export interface VmAlertmanagerSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmAlertmanagerSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmAlertmanagerSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmAlertmanagerSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecImage(obj: VmAlertmanagerSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmAlertmanagerSpecImagePullSecrets
 */
export interface VmAlertmanagerSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecImagePullSecrets(obj: VmAlertmanagerSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMAlertmanager to be configured with.
 *
 * @schema VmAlertmanagerSpecLogFormat
 */
export enum VmAlertmanagerSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for VMAlertmanager to be configured with.
 *
 * @schema VmAlertmanagerSpecLogLevel
 */
export enum VmAlertmanagerSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmAlertmanagerSpecManagedMetadata
 */
export interface VmAlertmanagerSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertmanagerSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertmanagerSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecManagedMetadata(obj: VmAlertmanagerSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy
 */
export interface VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy(obj: VmAlertmanagerSpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmAlertmanagerSpecPodDisruptionBudget
 */
export interface VmAlertmanagerSpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmAlertmanagerSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmAlertmanagerSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmAlertmanagerSpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmAlertmanagerSpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecPodDisruptionBudget(obj: VmAlertmanagerSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.
 *
 * @schema VmAlertmanagerSpecPodMetadata
 */
export interface VmAlertmanagerSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertmanagerSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertmanagerSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAlertmanagerSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecPodMetadata(obj: VmAlertmanagerSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmAlertmanagerSpecReadinessGates
 */
export interface VmAlertmanagerSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmAlertmanagerSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecReadinessGates(obj: VmAlertmanagerSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAlertmanagerSpecResources
 */
export interface VmAlertmanagerSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAlertmanagerSpecResources#claims
   */
  readonly claims?: VmAlertmanagerSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAlertmanagerSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAlertmanagerSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecResources(obj: VmAlertmanagerSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAlertmanagerSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmalertmanager service spec
 *
 * @schema VmAlertmanagerSpecServiceSpec
 */
export interface VmAlertmanagerSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmAlertmanagerSpecServiceSpec#metadata
   */
  readonly metadata?: VmAlertmanagerSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmAlertmanagerSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmAlertmanagerSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecServiceSpec(obj: VmAlertmanagerSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmAlertmanagerSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage is the definition of how storage will be used by the VMAlertmanager
 * instances.
 *
 * @schema VmAlertmanagerSpecStorage
 */
export interface VmAlertmanagerSpecStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmAlertmanagerSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmAlertmanagerSpecStorage#emptyDir
   */
  readonly emptyDir?: VmAlertmanagerSpecStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmAlertmanagerSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: VmAlertmanagerSpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorage(obj: VmAlertmanagerSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmAlertmanagerSpecStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapKeyReference refers to a key in a ConfigMap.
 *
 * @schema VmAlertmanagerSpecTemplates
 */
export interface VmAlertmanagerSpecTemplates {
  /**
   * The ConfigMap key to refer to.
   *
   * @schema VmAlertmanagerSpecTemplates#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecTemplates#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecTemplates(obj: VmAlertmanagerSpecTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmAlertmanagerSpecTolerations
 */
export interface VmAlertmanagerSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmAlertmanagerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmAlertmanagerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmAlertmanagerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmAlertmanagerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmAlertmanagerSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecTolerations(obj: VmAlertmanagerSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmAlertmanagerSpecVolumeMounts
 */
export interface VmAlertmanagerSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmAlertmanagerSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmAlertmanagerSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmAlertmanagerSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmAlertmanagerSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmAlertmanagerSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmAlertmanagerSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmAlertmanagerSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecVolumeMounts(obj: VmAlertmanagerSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebConfig defines configuration for webserver
 * https://github.com/prometheus/alertmanager/blob/main/docs/https.md
 *
 * @schema VmAlertmanagerSpecWebConfig
 */
export interface VmAlertmanagerSpecWebConfig {
  /**
   * BasicAuthUsers Usernames and hashed passwords that have full access to the web server
   * Passwords must be hashed with bcrypt
   *
   * @schema VmAlertmanagerSpecWebConfig#basic_auth_users
   */
  readonly basicAuthUsers?: { [key: string]: string };

  /**
   * HTTPServerConfig defines http server configuration for alertmanager web server
   *
   * @schema VmAlertmanagerSpecWebConfig#http_server_config
   */
  readonly httpServerConfig?: VmAlertmanagerSpecWebConfigHttpServerConfig;

  /**
   * TLSServerConfig defines server TLS configuration for alertmanager
   *
   * @schema VmAlertmanagerSpecWebConfig#tls_server_config
   */
  readonly tlsServerConfig?: VmAlertmanagerSpecWebConfigTlsServerConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfig(obj: VmAlertmanagerSpecWebConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth_users': ((obj.basicAuthUsers) === undefined) ? undefined : (Object.entries(obj.basicAuthUsers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'http_server_config': toJson_VmAlertmanagerSpecWebConfigHttpServerConfig(obj.httpServerConfig),
    'tls_server_config': toJson_VmAlertmanagerSpecWebConfigTlsServerConfig(obj.tlsServerConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpec
 */
export interface VmAlertmanagerSpecClaimTemplatesSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#dataSource
   */
  readonly dataSource?: VmAlertmanagerSpecClaimTemplatesSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#resources
   */
  readonly resources?: VmAlertmanagerSpecClaimTemplatesSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#selector
   */
  readonly selector?: VmAlertmanagerSpecClaimTemplatesSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpec(obj: VmAlertmanagerSpecClaimTemplatesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAlertmanagerSpecClaimTemplatesSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAlertmanagerSpecClaimTemplatesSpecResources(obj.resources),
    'selector': toJson_VmAlertmanagerSpecClaimTemplatesSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAlertmanagerSpecClaimTemplatesStatus
 */
export interface VmAlertmanagerSpecClaimTemplatesStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAlertmanagerSpecClaimTemplatesStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#conditions
   */
  readonly conditions?: VmAlertmanagerSpecClaimTemplatesStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesStatus(obj: VmAlertmanagerSpecClaimTemplatesStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAlertmanagerSpecClaimTemplatesStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions
 */
export interface VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions(obj: VmAlertmanagerSpecConfigNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAlertmanagerSpecConfigReloaderResourcesClaims
 */
export interface VmAlertmanagerSpecConfigReloaderResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAlertmanagerSpecConfigReloaderResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAlertmanagerSpecConfigReloaderResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigReloaderResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigReloaderResourcesClaims(obj: VmAlertmanagerSpecConfigReloaderResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerSpecConfigReloaderResourcesLimits
 */
export class VmAlertmanagerSpecConfigReloaderResourcesLimits {
  public static fromNumber(value: number): VmAlertmanagerSpecConfigReloaderResourcesLimits {
    return new VmAlertmanagerSpecConfigReloaderResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecConfigReloaderResourcesLimits {
    return new VmAlertmanagerSpecConfigReloaderResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecConfigReloaderResourcesRequests
 */
export class VmAlertmanagerSpecConfigReloaderResourcesRequests {
  public static fromNumber(value: number): VmAlertmanagerSpecConfigReloaderResourcesRequests {
    return new VmAlertmanagerSpecConfigReloaderResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecConfigReloaderResourcesRequests {
    return new VmAlertmanagerSpecConfigReloaderResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertmanagerSpecConfigSelectorMatchExpressions
 */
export interface VmAlertmanagerSpecConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertmanagerSpecConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertmanagerSpecConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertmanagerSpecConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerSpecConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecConfigSelectorMatchExpressions(obj: VmAlertmanagerSpecConfigSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmAlertmanagerSpecDnsConfigOptions
 */
export interface VmAlertmanagerSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmAlertmanagerSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmAlertmanagerSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecDnsConfigOptions(obj: VmAlertmanagerSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmAlertmanagerSpecExtraEnvsFromConfigMapRef
 */
export interface VmAlertmanagerSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmAlertmanagerSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecExtraEnvsFromConfigMapRef(obj: VmAlertmanagerSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmAlertmanagerSpecExtraEnvsFromSecretRef
 */
export interface VmAlertmanagerSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmAlertmanagerSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecExtraEnvsFromSecretRef(obj: VmAlertmanagerSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSClientConfig defines client TLS configuration for alertmanager
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig
 */
export interface VmAlertmanagerSpecGossipConfigTlsClientConfig {
  /**
   * CAFile defines path to the pre-mounted file with CA
   * mutually exclusive with CASecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#ca_file
   */
  readonly caFile?: string;

  /**
   * CA defines reference for secret with CA content under given key
   * mutually exclusive with CAFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#ca_secret_ref
   */
  readonly caSecretRef?: VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef;

  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#cert_file
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#cert_secret_ref
   */
  readonly certSecretRef?: VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef;

  /**
   * Cert defines reference for secret with CA content under given key
   * mutually exclusive with CertFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#insecure_skip_verify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#key_file
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#key_secret_ref
   */
  readonly keySecretRef?: VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef;

  /**
   * ServerName indicates a name of a server
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfig#server_name
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsClientConfig(obj: VmAlertmanagerSpecGossipConfigTlsClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca_file': obj.caFile,
    'ca_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef(obj.caSecretRef),
    'cert_file': obj.certFile,
    'cert_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef(obj.certSecretRef),
    'insecure_skip_verify': obj.insecureSkipVerify,
    'key_file': obj.keyFile,
    'key_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef(obj.keySecretRef),
    'server_name': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSServerConfig defines server TLS configuration for alertmanager
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig
 */
export interface VmAlertmanagerSpecGossipConfigTlsServerConfig {
  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#cert_file
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#cert_secret_ref
   */
  readonly certSecretRef?: VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef;

  /**
   * CipherSuites defines list of supported cipher suites for TLS versions up to TLS 1.2
   * https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#cipher_suites
   */
  readonly cipherSuites?: string[];

  /**
   * Cert defines reference for secret with CA content under given key
   * mutually exclusive with CertFile
   * ClientAuthType defines server policy for client authentication
   * If you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert
   * Note, mTLS is supported only at enterprise version of VictoriaMetrics components
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#client_auth_type
   */
  readonly clientAuthType?: VmAlertmanagerSpecGossipConfigTlsServerConfigClientAuthType;

  /**
   * ClientCAFile defines path to the pre-mounted file with CA
   * mutually exclusive with ClientCASecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#client_ca_file
   */
  readonly clientCaFile?: string;

  /**
   * ClientCASecretRef defines reference for secret with CA content under given key
   * mutually exclusive with ClientCAFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#client_ca_secret_ref
   */
  readonly clientCaSecretRef?: VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef;

  /**
   * CurvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference order.
   * https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#curve_preferences
   */
  readonly curvePreferences?: string[];

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#key_file
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#key_secret_ref
   */
  readonly keySecretRef?: VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef;

  /**
   * MaxVersion maximum TLS version that is acceptable.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#max_version
   */
  readonly maxVersion?: VmAlertmanagerSpecGossipConfigTlsServerConfigMaxVersion;

  /**
   * MinVersion minimum TLS version that is acceptable.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#min_version
   */
  readonly minVersion?: VmAlertmanagerSpecGossipConfigTlsServerConfigMinVersion;

  /**
   * PreferServerCipherSuites controls whether the server selects the
   * client's most preferred ciphersuite
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfig#prefer_server_cipher_suites
   */
  readonly preferServerCipherSuites?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsServerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsServerConfig(obj: VmAlertmanagerSpecGossipConfigTlsServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert_file': obj.certFile,
    'cert_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef(obj.certSecretRef),
    'cipher_suites': obj.cipherSuites?.map(y => y),
    'client_auth_type': obj.clientAuthType,
    'client_ca_file': obj.clientCaFile,
    'client_ca_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef(obj.clientCaSecretRef),
    'curve_preferences': obj.curvePreferences?.map(y => y),
    'key_file': obj.keyFile,
    'key_secret_ref': toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef(obj.keySecretRef),
    'max_version': obj.maxVersion,
    'min_version': obj.minVersion,
    'prefer_server_cipher_suites': obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable
 */
export class VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAlertmanagerSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmAlertmanagerSpecPodDisruptionBudgetMinAvailable
 */
export class VmAlertmanagerSpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmAlertmanagerSpecPodDisruptionBudgetMinAvailable {
    return new VmAlertmanagerSpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecPodDisruptionBudgetMinAvailable {
    return new VmAlertmanagerSpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAlertmanagerSpecResourcesClaims
 */
export interface VmAlertmanagerSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAlertmanagerSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAlertmanagerSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecResourcesClaims(obj: VmAlertmanagerSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerSpecResourcesLimits
 */
export class VmAlertmanagerSpecResourcesLimits {
  public static fromNumber(value: number): VmAlertmanagerSpecResourcesLimits {
    return new VmAlertmanagerSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecResourcesLimits {
    return new VmAlertmanagerSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecResourcesRequests
 */
export class VmAlertmanagerSpecResourcesRequests {
  public static fromNumber(value: number): VmAlertmanagerSpecResourcesRequests {
    return new VmAlertmanagerSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecResourcesRequests {
    return new VmAlertmanagerSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmAlertmanagerSpecServiceSpecMetadata
 */
export interface VmAlertmanagerSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertmanagerSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertmanagerSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAlertmanagerSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecServiceSpecMetadata(obj: VmAlertmanagerSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmAlertmanagerSpecStorageEmptyDir
 */
export interface VmAlertmanagerSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAlertmanagerSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAlertmanagerSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmAlertmanagerSpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageEmptyDir(obj: VmAlertmanagerSpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PVC spec to be used by the StatefulSets/Deployments.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: VmAlertmanagerSpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplate(obj: VmAlertmanagerSpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPServerConfig defines http server configuration for alertmanager web server
 *
 * @schema VmAlertmanagerSpecWebConfigHttpServerConfig
 */
export interface VmAlertmanagerSpecWebConfigHttpServerConfig {
  /**
   * Headers defines list of headers that can be added to HTTP responses.
   *
   * @schema VmAlertmanagerSpecWebConfigHttpServerConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * HTTP2 enables HTTP/2 support. Note that HTTP/2 is only supported with TLS.
   * This can not be changed on the fly.
   *
   * @schema VmAlertmanagerSpecWebConfigHttpServerConfig#http2
   */
  readonly http2?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfigHttpServerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfigHttpServerConfig(obj: VmAlertmanagerSpecWebConfigHttpServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'http2': obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSServerConfig defines server TLS configuration for alertmanager
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfig
 */
export interface VmAlertmanagerSpecWebConfigTlsServerConfig {
  /**
   * CertFile defines path to the pre-mounted file with certificate
   * mutually exclusive with CertSecretRef
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#cert_file
   */
  readonly certFile?: string;

  /**
   * CertSecretRef defines reference for secret with certificate content under given key
   * mutually exclusive with CertFile
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#cert_secret_ref
   */
  readonly certSecretRef?: VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef;

  /**
   * CipherSuites defines list of supported cipher suites for TLS versions up to TLS 1.2
   * https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#cipher_suites
   */
  readonly cipherSuites?: string[];

  /**
   * Cert defines reference for secret with CA content under given key
   * mutually exclusive with CertFile
   * ClientAuthType defines server policy for client authentication
   * If you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert
   * Note, mTLS is supported only at enterprise version of VictoriaMetrics components
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#client_auth_type
   */
  readonly clientAuthType?: VmAlertmanagerSpecWebConfigTlsServerConfigClientAuthType;

  /**
   * ClientCAFile defines path to the pre-mounted file with CA
   * mutually exclusive with ClientCASecretRef
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#client_ca_file
   */
  readonly clientCaFile?: string;

  /**
   * ClientCASecretRef defines reference for secret with CA content under given key
   * mutually exclusive with ClientCAFile
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#client_ca_secret_ref
   */
  readonly clientCaSecretRef?: VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef;

  /**
   * CurvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference order.
   * https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#curve_preferences
   */
  readonly curvePreferences?: string[];

  /**
   * KeyFile defines path to the pre-mounted file with certificate key
   * mutually exclusive with KeySecretRef
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#key_file
   */
  readonly keyFile?: string;

  /**
   * Key defines reference for secret with certificate key content under given key
   * mutually exclusive with KeyFile
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#key_secret_ref
   */
  readonly keySecretRef?: VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef;

  /**
   * MaxVersion maximum TLS version that is acceptable.
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#max_version
   */
  readonly maxVersion?: VmAlertmanagerSpecWebConfigTlsServerConfigMaxVersion;

  /**
   * MinVersion minimum TLS version that is acceptable.
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#min_version
   */
  readonly minVersion?: VmAlertmanagerSpecWebConfigTlsServerConfigMinVersion;

  /**
   * PreferServerCipherSuites controls whether the server selects the
   * client's most preferred ciphersuite
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfig#prefer_server_cipher_suites
   */
  readonly preferServerCipherSuites?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfigTlsServerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfigTlsServerConfig(obj: VmAlertmanagerSpecWebConfigTlsServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert_file': obj.certFile,
    'cert_secret_ref': toJson_VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef(obj.certSecretRef),
    'cipher_suites': obj.cipherSuites?.map(y => y),
    'client_auth_type': obj.clientAuthType,
    'client_ca_file': obj.clientCaFile,
    'client_ca_secret_ref': toJson_VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef(obj.clientCaSecretRef),
    'curve_preferences': obj.curvePreferences?.map(y => y),
    'key_file': obj.keyFile,
    'key_secret_ref': toJson_VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef(obj.keySecretRef),
    'max_version': obj.maxVersion,
    'min_version': obj.minVersion,
    'prefer_server_cipher_suites': obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSource
 */
export interface VmAlertmanagerSpecClaimTemplatesSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpecDataSource(obj: VmAlertmanagerSpecClaimTemplatesSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef
 */
export interface VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef(obj: VmAlertmanagerSpecClaimTemplatesSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpecResources
 */
export interface VmAlertmanagerSpecClaimTemplatesSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpecResources(obj: VmAlertmanagerSpecClaimTemplatesSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpecSelector
 */
export interface VmAlertmanagerSpecClaimTemplatesSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpecSelector(obj: VmAlertmanagerSpecClaimTemplatesSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources
 */
export class VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources {
  public static fromNumber(value: number): VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources {
    return new VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources {
    return new VmAlertmanagerSpecClaimTemplatesStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecClaimTemplatesStatusCapacity
 */
export class VmAlertmanagerSpecClaimTemplatesStatusCapacity {
  public static fromNumber(value: number): VmAlertmanagerSpecClaimTemplatesStatusCapacity {
    return new VmAlertmanagerSpecClaimTemplatesStatusCapacity(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecClaimTemplatesStatusCapacity {
    return new VmAlertmanagerSpecClaimTemplatesStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions
 */
export interface VmAlertmanagerSpecClaimTemplatesStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesStatusConditions(obj: VmAlertmanagerSpecClaimTemplatesStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus
 */
export interface VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus(obj: VmAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CA defines reference for secret with CA content under given key
 * mutually exclusive with CAFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef(obj: VmAlertmanagerSpecGossipConfigTlsClientConfigCaSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef(obj: VmAlertmanagerSpecGossipConfigTlsClientConfigCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef(obj: VmAlertmanagerSpecGossipConfigTlsClientConfigKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef(obj: VmAlertmanagerSpecGossipConfigTlsServerConfigCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert defines reference for secret with CA content under given key
 * mutually exclusive with CertFile
 * ClientAuthType defines server policy for client authentication
 * If you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert
 * Note, mTLS is supported only at enterprise version of VictoriaMetrics components
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigClientAuthType
 */
export enum VmAlertmanagerSpecGossipConfigTlsServerConfigClientAuthType {
  /** NoClientCert */
  NO_CLIENT_CERT = "NoClientCert",
  /** RequireAndVerifyClientCert */
  REQUIRE_AND_VERIFY_CLIENT_CERT = "RequireAndVerifyClientCert",
}

/**
 * ClientCASecretRef defines reference for secret with CA content under given key
 * mutually exclusive with ClientCAFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef(obj: VmAlertmanagerSpecGossipConfigTlsServerConfigClientCaSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef
 */
export interface VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef(obj: VmAlertmanagerSpecGossipConfigTlsServerConfigKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaxVersion maximum TLS version that is acceptable.
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigMaxVersion
 */
export enum VmAlertmanagerSpecGossipConfigTlsServerConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * MinVersion minimum TLS version that is acceptable.
 *
 * @schema VmAlertmanagerSpecGossipConfigTlsServerConfigMinVersion
 */
export enum VmAlertmanagerSpecGossipConfigTlsServerConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmAlertmanagerSpecStorageEmptyDirSizeLimit
 */
export class VmAlertmanagerSpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VmAlertmanagerSpecStorageEmptyDirSizeLimit {
    return new VmAlertmanagerSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecStorageEmptyDirSizeLimit {
    return new VmAlertmanagerSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpec(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatus(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef defines reference for secret with certificate content under given key
 * mutually exclusive with CertFile
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef
 */
export interface VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef(obj: VmAlertmanagerSpecWebConfigTlsServerConfigCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert defines reference for secret with CA content under given key
 * mutually exclusive with CertFile
 * ClientAuthType defines server policy for client authentication
 * If you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert
 * Note, mTLS is supported only at enterprise version of VictoriaMetrics components
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigClientAuthType
 */
export enum VmAlertmanagerSpecWebConfigTlsServerConfigClientAuthType {
  /** NoClientCert */
  NO_CLIENT_CERT = "NoClientCert",
  /** RequireAndVerifyClientCert */
  REQUIRE_AND_VERIFY_CLIENT_CERT = "RequireAndVerifyClientCert",
}

/**
 * ClientCASecretRef defines reference for secret with CA content under given key
 * mutually exclusive with ClientCAFile
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef
 */
export interface VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef(obj: VmAlertmanagerSpecWebConfigTlsServerConfigClientCaSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Key defines reference for secret with certificate key content under given key
 * mutually exclusive with KeyFile
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef
 */
export interface VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef(obj: VmAlertmanagerSpecWebConfigTlsServerConfigKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaxVersion maximum TLS version that is acceptable.
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigMaxVersion
 */
export enum VmAlertmanagerSpecWebConfigTlsServerConfigMaxVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * MinVersion minimum TLS version that is acceptable.
 *
 * @schema VmAlertmanagerSpecWebConfigTlsServerConfigMinVersion
 */
export enum VmAlertmanagerSpecWebConfigTlsServerConfigMinVersion {
  /** TLS10 */
  TLS10 = "TLS10",
  /** TLS11 */
  TLS11 = "TLS11",
  /** TLS12 */
  TLS12 = "TLS12",
  /** TLS13 */
  TLS13 = "TLS13",
}

/**
 * @schema VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits
 */
export class VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits {
  public static fromNumber(value: number): VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits {
    return new VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits {
    return new VmAlertmanagerSpecClaimTemplatesSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests
 */
export class VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests {
  public static fromNumber(value: number): VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests {
    return new VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests {
    return new VmAlertmanagerSpecClaimTemplatesSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions
 */
export interface VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions(obj: VmAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: VmAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAlertmanagerConfig is the Schema for the vmalertmanagerconfigs API
 *
 * @schema VMAlertmanagerConfig
 */
export class VmAlertmanagerConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAlertmanagerConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMAlertmanagerConfig',
  }

  /**
   * Renders a Kubernetes manifest for "VMAlertmanagerConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAlertmanagerConfigProps = {}): any {
    return {
      ...VmAlertmanagerConfig.GVK,
      ...toJson_VmAlertmanagerConfigProps(props),
    };
  }

  /**
   * Defines a "VMAlertmanagerConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAlertmanagerConfigProps = {}) {
    super(scope, id, {
      ...VmAlertmanagerConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAlertmanagerConfig.GVK,
      ...toJson_VmAlertmanagerConfigProps(resolved),
    };
  }
}

/**
 * VMAlertmanagerConfig is the Schema for the vmalertmanagerconfigs API
 *
 * @schema VMAlertmanagerConfig
 */
export interface VmAlertmanagerConfigProps {
  /**
   * @schema VMAlertmanagerConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMAlertmanagerConfigSpec defines configuration for VMAlertmanagerConfig
   * it must reference only locally defined objects
   *
   * @schema VMAlertmanagerConfig#spec
   */
  readonly spec?: VmAlertmanagerConfigSpec;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigProps(obj: VmAlertmanagerConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAlertmanagerConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAlertmanagerConfigSpec defines configuration for VMAlertmanagerConfig
 * it must reference only locally defined objects
 *
 * @schema VmAlertmanagerConfigSpec
 */
export interface VmAlertmanagerConfigSpec {
  /**
   * InhibitRules will only apply for alerts matching
   * the resource's namespace.
   *
   * @schema VmAlertmanagerConfigSpec#inhibit_rules
   */
  readonly inhibitRules?: VmAlertmanagerConfigSpecInhibitRules[];

  /**
   * Receivers defines alert receivers
   *
   * @schema VmAlertmanagerConfigSpec#receivers
   */
  readonly receivers: VmAlertmanagerConfigSpecReceivers[];

  /**
   * Route definition for alertmanager, may include nested routes.
   *
   * @schema VmAlertmanagerConfigSpec#route
   */
  readonly route: VmAlertmanagerConfigSpecRoute;

  /**
   * TimeIntervals defines named interval for active/mute notifications interval
   * See https://prometheus.io/docs/alerting/latest/configuration/#time_interval
   *
   * @schema VmAlertmanagerConfigSpec#time_intervals
   */
  readonly timeIntervals?: VmAlertmanagerConfigSpecTimeIntervals[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpec(obj: VmAlertmanagerConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inhibit_rules': obj.inhibitRules?.map(y => toJson_VmAlertmanagerConfigSpecInhibitRules(y)),
    'receivers': obj.receivers?.map(y => toJson_VmAlertmanagerConfigSpecReceivers(y)),
    'route': toJson_VmAlertmanagerConfigSpecRoute(obj.route),
    'time_intervals': obj.timeIntervals?.map(y => toJson_VmAlertmanagerConfigSpecTimeIntervals(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InhibitRule defines an inhibition rule that allows to mute alerts when other
 * alerts are already firing.
 * Note, it doesn't support deprecated alertmanager config options.
 * See https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule
 *
 * @schema VmAlertmanagerConfigSpecInhibitRules
 */
export interface VmAlertmanagerConfigSpecInhibitRules {
  /**
   * Labels that must have an equal value in the source and target alert for
   * the inhibition to take effect.
   *
   * @schema VmAlertmanagerConfigSpecInhibitRules#equal
   */
  readonly equal?: string[];

  /**
   * SourceMatchers defines a list of matchers for which one or more alerts have
   * to exist for the inhibition to take effect.
   *
   * @schema VmAlertmanagerConfigSpecInhibitRules#source_matchers
   */
  readonly sourceMatchers?: string[];

  /**
   * TargetMatchers defines a list of matchers that have to be fulfilled by the target
   * alerts to be muted.
   *
   * @schema VmAlertmanagerConfigSpecInhibitRules#target_matchers
   */
  readonly targetMatchers?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecInhibitRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecInhibitRules(obj: VmAlertmanagerConfigSpecInhibitRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'equal': obj.equal?.map(y => y),
    'source_matchers': obj.sourceMatchers?.map(y => y),
    'target_matchers': obj.targetMatchers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receiver defines one or more notification integrations.
 *
 * @schema VmAlertmanagerConfigSpecReceivers
 */
export interface VmAlertmanagerConfigSpecReceivers {
  /**
   * @schema VmAlertmanagerConfigSpecReceivers#discord_configs
   */
  readonly discordConfigs?: VmAlertmanagerConfigSpecReceiversDiscordConfigs[];

  /**
   * EmailConfigs defines email notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#email_configs
   */
  readonly emailConfigs?: VmAlertmanagerConfigSpecReceiversEmailConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#jira_configs
   */
  readonly jiraConfigs?: VmAlertmanagerConfigSpecReceiversJiraConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#msteams_configs
   */
  readonly msteamsConfigs?: VmAlertmanagerConfigSpecReceiversMsteamsConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#msteamsv2_configs
   */
  readonly msteamsv2Configs?: VmAlertmanagerConfigSpecReceiversMsteamsv2Configs[];

  /**
   * Name of the receiver. Must be unique across all items from the list.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#name
   */
  readonly name: string;

  /**
   * OpsGenieConfigs defines ops genie notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#opsgenie_configs
   */
  readonly opsgenieConfigs?: VmAlertmanagerConfigSpecReceiversOpsgenieConfigs[];

  /**
   * PagerDutyConfigs defines pager duty notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#pagerduty_configs
   */
  readonly pagerdutyConfigs?: VmAlertmanagerConfigSpecReceiversPagerdutyConfigs[];

  /**
   * PushoverConfigs defines push over notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#pushover_configs
   */
  readonly pushoverConfigs?: VmAlertmanagerConfigSpecReceiversPushoverConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#rocketchat_configs
   */
  readonly rocketchatConfigs?: VmAlertmanagerConfigSpecReceiversRocketchatConfigs[];

  /**
   * SlackConfigs defines slack notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#slack_configs
   */
  readonly slackConfigs?: VmAlertmanagerConfigSpecReceiversSlackConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#sns_configs
   */
  readonly snsConfigs?: VmAlertmanagerConfigSpecReceiversSnsConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#telegram_configs
   */
  readonly telegramConfigs?: VmAlertmanagerConfigSpecReceiversTelegramConfigs[];

  /**
   * VictorOpsConfigs defines victor ops notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#victorops_configs
   */
  readonly victoropsConfigs?: VmAlertmanagerConfigSpecReceiversVictoropsConfigs[];

  /**
   * @schema VmAlertmanagerConfigSpecReceivers#webex_configs
   */
  readonly webexConfigs?: VmAlertmanagerConfigSpecReceiversWebexConfigs[];

  /**
   * WebhookConfigs defines webhook notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#webhook_configs
   */
  readonly webhookConfigs?: VmAlertmanagerConfigSpecReceiversWebhookConfigs[];

  /**
   * WeChatConfigs defines wechat notification configurations.
   *
   * @schema VmAlertmanagerConfigSpecReceivers#wechat_configs
   */
  readonly wechatConfigs?: VmAlertmanagerConfigSpecReceiversWechatConfigs[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceivers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceivers(obj: VmAlertmanagerConfigSpecReceivers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'discord_configs': obj.discordConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigs(y)),
    'email_configs': obj.emailConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversEmailConfigs(y)),
    'jira_configs': obj.jiraConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversJiraConfigs(y)),
    'msteams_configs': obj.msteamsConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigs(y)),
    'msteamsv2_configs': obj.msteamsv2Configs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversMsteamsv2Configs(y)),
    'name': obj.name,
    'opsgenie_configs': obj.opsgenieConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigs(y)),
    'pagerduty_configs': obj.pagerdutyConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigs(y)),
    'pushover_configs': obj.pushoverConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigs(y)),
    'rocketchat_configs': obj.rocketchatConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigs(y)),
    'slack_configs': obj.slackConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversSlackConfigs(y)),
    'sns_configs': obj.snsConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversSnsConfigs(y)),
    'telegram_configs': obj.telegramConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversTelegramConfigs(y)),
    'victorops_configs': obj.victoropsConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigs(y)),
    'webex_configs': obj.webexConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversWebexConfigs(y)),
    'webhook_configs': obj.webhookConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversWebhookConfigs(y)),
    'wechat_configs': obj.wechatConfigs?.map(y => toJson_VmAlertmanagerConfigSpecReceiversWechatConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Route definition for alertmanager, may include nested routes.
 *
 * @schema VmAlertmanagerConfigSpecRoute
 */
export interface VmAlertmanagerConfigSpecRoute {
  /**
   * ActiveTimeIntervals Times when the route should be active
   * These must match the name at time_intervals
   *
   * @schema VmAlertmanagerConfigSpecRoute#active_time_intervals
   */
  readonly activeTimeIntervals?: string[];

  /**
   * Continue indicating whether an alert should continue matching subsequent
   * sibling nodes. It will always be true for the first-level route if disableRouteContinueEnforce for vmalertmanager not set.
   *
   * @schema VmAlertmanagerConfigSpecRoute#continue
   */
  readonly continue?: boolean;

  /**
   * List of labels to group by.
   *
   * @schema VmAlertmanagerConfigSpecRoute#group_by
   */
  readonly groupBy?: string[];

  /**
   * How long to wait before sending an updated notification.
   *
   * @schema VmAlertmanagerConfigSpecRoute#group_interval
   */
  readonly groupInterval?: string;

  /**
   * How long to wait before sending the initial notification.
   *
   * @schema VmAlertmanagerConfigSpecRoute#group_wait
   */
  readonly groupWait?: string;

  /**
   * List of matchers that the alert’s labels should match. For the first
   * level route, the operator adds a namespace: "CRD_NS" matcher.
   * https://prometheus.io/docs/alerting/latest/configuration/#matcher
   *
   * @schema VmAlertmanagerConfigSpecRoute#matchers
   */
  readonly matchers?: string[];

  /**
   * MuteTimeIntervals is a list of interval names that will mute matched alert
   *
   * @schema VmAlertmanagerConfigSpecRoute#mute_time_intervals
   */
  readonly muteTimeIntervals?: string[];

  /**
   * Name of the receiver for this route.
   *
   * @schema VmAlertmanagerConfigSpecRoute#receiver
   */
  readonly receiver: string;

  /**
   * How long to wait before repeating the last notification.
   *
   * @schema VmAlertmanagerConfigSpecRoute#repeat_interval
   */
  readonly repeatInterval?: string;

  /**
   * Child routes.
   * https://prometheus.io/docs/alerting/latest/configuration/#route
   *
   * @schema VmAlertmanagerConfigSpecRoute#routes
   */
  readonly routes?: any[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecRoute(obj: VmAlertmanagerConfigSpecRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active_time_intervals': obj.activeTimeIntervals?.map(y => y),
    'continue': obj.continue,
    'group_by': obj.groupBy?.map(y => y),
    'group_interval': obj.groupInterval,
    'group_wait': obj.groupWait,
    'matchers': obj.matchers?.map(y => y),
    'mute_time_intervals': obj.muteTimeIntervals?.map(y => y),
    'receiver': obj.receiver,
    'repeat_interval': obj.repeatInterval,
    'routes': obj.routes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TimeIntervals for alerts
 *
 * @schema VmAlertmanagerConfigSpecTimeIntervals
 */
export interface VmAlertmanagerConfigSpecTimeIntervals {
  /**
   * Name of interval
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervals#name
   */
  readonly name: string;

  /**
   * TimeIntervals interval configuration
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervals#time_intervals
   */
  readonly timeIntervals: VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecTimeIntervals(obj: VmAlertmanagerConfigSpecTimeIntervals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'time_intervals': obj.timeIntervals?.map(y => toJson_VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigs {
  /**
   * AvatarURL defines message avatar URL
   * Available from operator v0.55.0 and alertmanager v0.28.0
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#avatar_url
   */
  readonly avatarUrl?: string;

  /**
   * Content defines message content template
   * Available from operator v0.55.0 and alertmanager v0.28.0
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#content
   */
  readonly content?: string;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig;

  /**
   * The message body template
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#message
   */
  readonly message?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * The message title template
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#title
   */
  readonly title?: string;

  /**
   * Username defines message username
   * Available from operator v0.55.0 and alertmanager v0.28.0
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#username
   */
  readonly username?: string;

  /**
   * The discord webhook URL
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#webhook_url
   */
  readonly webhookUrl?: string;

  /**
   * URLSecret defines secret name and key at the CRD namespace.
   * It must contain the webhook URL.
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigs#webhook_url_secret
   */
  readonly webhookUrlSecret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigs(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'avatar_url': obj.avatarUrl,
    'content': obj.content,
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'send_resolved': obj.sendResolved,
    'title': obj.title,
    'username': obj.username,
    'webhook_url': obj.webhookUrl,
    'webhook_url_secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret(obj.webhookUrlSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmailConfig configures notifications via Email.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigs {
  /**
   * The identity to use for authentication.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#auth_identity
   */
  readonly authIdentity?: string;

  /**
   * AuthPassword defines secret name and key at CRD namespace.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#auth_password
   */
  readonly authPassword?: VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword;

  /**
   * AuthSecret defines secret name and key at CRD namespace.
   * It must contain the CRAM-MD5 secret.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#auth_secret
   */
  readonly authSecret?: VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret;

  /**
   * The username to use for authentication.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#auth_username
   */
  readonly authUsername?: string;

  /**
   * The sender address.
   * fallback to global setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#from
   */
  readonly from?: string;

  /**
   * Further headers email header key/value pairs. Overrides any headers
   * previously set by the notification implementation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * The hostname to identify to the SMTP server.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#hello
   */
  readonly hello?: string;

  /**
   * The HTML body of the email notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#html
   */
  readonly html?: string;

  /**
   * The SMTP TLS requirement.
   * Note that Go does not support unencrypted connections to remote SMTP endpoints.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#require_tls
   */
  readonly requireTls?: boolean;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * The SMTP host through which emails are sent.
   * fallback to global setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#smarthost
   */
  readonly smarthost?: string;

  /**
   * The text body of the email notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#text
   */
  readonly text?: string;

  /**
   * TLS configuration
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig;

  /**
   * The email address to send notifications to.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigs#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigs(obj: VmAlertmanagerConfigSpecReceiversEmailConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth_identity': obj.authIdentity,
    'auth_password': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(obj.authPassword),
    'auth_secret': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(obj.authSecret),
    'auth_username': obj.authUsername,
    'from': obj.from,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'hello': obj.hello,
    'html': obj.html,
    'require_tls': obj.requireTls,
    'send_resolved': obj.sendResolved,
    'smarthost': obj.smarthost,
    'text': obj.text,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(obj.tlsConfig),
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JiraConfig represent alertmanager's jira_config entry
 * https://prometheus.io/docs/alerting/latest/configuration/#jira_config
 * available from v0.55.0 operator version
 * and v0.28.0 alertmanager version
 *
 * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversJiraConfigs {
  /**
   * The URL to send API requests to. The full API path must be included.
   * Example: https://company.atlassian.net/rest/api/2/
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * Other issue and custom fields.
   * Jira issue field can have multiple types.
   * Depends on the field type, the values must be provided differently.
   * See https://developer.atlassian.com/server/jira/platform/jira-rest-api-examples/#setting-custom-field-data-for-other-field-types for further examples.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#custom_fields
   */
  readonly customFields?: { [key: string]: any };

  /**
   * Issue description template.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#description
   */
  readonly description?: string;

  /**
   * The HTTP client's configuration. You must use this configuration to supply the personal access token (PAT) as part of the HTTP `Authorization` header.
   * For Jira Cloud, use basic_auth with the email address as the username and the PAT as the password.
   * For Jira Data Center, use the 'authorization' field with 'credentials: <PAT value>'.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Type of the issue (e.g. Bug)
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#issue_type
   */
  readonly issueType: string;

  /**
   * Labels to be added to the issue
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#labels
   */
  readonly labels?: string[];

  /**
   * Priority of the issue
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#priority
   */
  readonly priority?: string;

  /**
   * The project key where issues are created
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#project
   */
  readonly project: string;

  /**
   * If reopen_transition is defined, reopen the issue when it is not older than this value (rounded down to the nearest minute).
   * The resolutiondate field is used to determine the age of the issue.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#reopen_duration
   */
  readonly reopenDuration?: string;

  /**
   * Name of the workflow transition to resolve an issue.
   * The target status must have the category "done".
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#reopen_transition
   */
  readonly reopenTransition?: string;

  /**
   * Name of the workflow transition to reopen an issue.
   * The target status should not have the category "done".
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#resolve_transition
   */
  readonly resolveTransition?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Issue summary template
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#summary
   */
  readonly summary?: string;

  /**
   * If reopen_transition is defined, ignore issues with that resolution.
   *
   * @schema VmAlertmanagerConfigSpecReceiversJiraConfigs#wont_fix_resolution
   */
  readonly wontFixResolution?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversJiraConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversJiraConfigs(obj: VmAlertmanagerConfigSpecReceiversJiraConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api_url': obj.apiUrl,
    'custom_fields': ((obj.customFields) === undefined) ? undefined : (Object.entries(obj.customFields).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'http_config': obj.httpConfig,
    'issue_type': obj.issueType,
    'labels': obj.labels?.map(y => y),
    'priority': obj.priority,
    'project': obj.project,
    'reopen_duration': obj.reopenDuration,
    'reopen_transition': obj.reopenTransition,
    'resolve_transition': obj.resolveTransition,
    'send_resolved': obj.sendResolved,
    'summary': obj.summary,
    'wont_fix_resolution': obj.wontFixResolution,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * The text body of the teams notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#text
   */
  readonly text?: string;

  /**
   * The title of the teams notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#title
   */
  readonly title?: string;

  /**
   * The incoming webhook URL
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#webhook_url
   */
  readonly webhookUrl?: string;

  /**
   * URLSecret defines secret name and key at the CRD namespace.
   * It must contain the webhook URL.
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigs#webhook_url_secret
   */
  readonly webhookUrlSecret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigs(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(obj.httpConfig),
    'send_resolved': obj.sendResolved,
    'text': obj.text,
    'title': obj.title,
    'webhook_url': obj.webhookUrl,
    'webhook_url_secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret(obj.webhookUrlSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MSTeamsV2Config sends notifications using the new message format with adaptive cards as required by flows.
 * https://support.microsoft.com/en-gb/office/create-incoming-webhooks-with-workflows-for-microsoft-teams-8ae491c7-0394-4861-ba59-055e33f75498
 * available from v0.55.0 operator version
 * and v0.28.0 alertmanager version
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsv2Configs {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#http_config
   */
  readonly httpConfig?: any;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Message body template.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#text
   */
  readonly text?: string;

  /**
   * Message title template.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#title
   */
  readonly title?: string;

  /**
   * The incoming webhook URL
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#webhook_url
   */
  readonly webhookUrl?: string;

  /**
   * URLSecret defines secret name and key at the CRD namespace.
   * It must contain the webhook URL.
   * one of `webhook_url` or `webhook_url_secret` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2Configs#webhook_url_secret
   */
  readonly webhookUrlSecret?: VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsv2Configs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsv2Configs(obj: VmAlertmanagerConfigSpecReceiversMsteamsv2Configs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http_config': obj.httpConfig,
    'send_resolved': obj.sendResolved,
    'text': obj.text,
    'title': obj.title,
    'webhook_url': obj.webhookUrl,
    'webhook_url_secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret(obj.webhookUrlSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpsGenieConfig configures notifications via OpsGenie.
 * See https://prometheus.io/docs/alerting/latest/configuration/#opsgenie_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversOpsgenieConfigs {
  /**
   * Comma separated list of actions that will be available for the alert.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#actions
   */
  readonly actions?: string;

  /**
   * The URL to send OpsGenie API requests to.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * The secret's key that contains the OpsGenie API key.
   * It must be at them same namespace as CRD
   * fallback to global setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#api_key
   */
  readonly apiKey?: VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey;

  /**
   * Description of the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#description
   */
  readonly description?: string;

  /**
   * A set of arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#details
   */
  readonly details?: { [key: string]: string };

  /**
   * Optional field that can be used to specify which domain alert is related to.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#entity
   */
  readonly entity?: string;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Alert text limited to 130 characters.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#message
   */
  readonly message?: string;

  /**
   * Additional alert note.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#note
   */
  readonly note?: string;

  /**
   * Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#priority
   */
  readonly priority?: string;

  /**
   * List of responders responsible for notifications.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#responders
   */
  readonly responders?: VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders[];

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Backlink to the sender of the notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#source
   */
  readonly source?: string;

  /**
   * Comma separated list of tags attached to the notifications.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#tags
   */
  readonly tags?: string;

  /**
   * Whether to update message and description of the alert in OpsGenie if it already exists
   * By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigs#update_alerts
   */
  readonly updateAlerts?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversOpsgenieConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigs(obj: VmAlertmanagerConfigSpecReceiversOpsgenieConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions,
    'apiURL': obj.apiUrl,
    'api_key': toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(obj.apiKey),
    'description': obj.description,
    'details': ((obj.details) === undefined) ? undefined : (Object.entries(obj.details).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'entity': obj.entity,
    'http_config': obj.httpConfig,
    'message': obj.message,
    'note': obj.note,
    'priority': obj.priority,
    'responders': obj.responders?.map(y => toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(y)),
    'send_resolved': obj.sendResolved,
    'source': obj.source,
    'tags': obj.tags,
    'update_alerts': obj.updateAlerts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PagerDutyConfig configures notifications via PagerDuty.
 * See https://prometheus.io/docs/alerting/latest/configuration/#pagerduty_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversPagerdutyConfigs {
  /**
   * The class/type of the event.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#class
   */
  readonly class?: string;

  /**
   * Client identification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#client
   */
  readonly client?: string;

  /**
   * Backlink to the sender of notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#client_url
   */
  readonly clientUrl?: string;

  /**
   * The part or component of the affected system that is broken.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#component
   */
  readonly component?: string;

  /**
   * Description of the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#description
   */
  readonly description?: string;

  /**
   * Arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#details
   */
  readonly details?: { [key: string]: string };

  /**
   * A cluster or grouping of sources.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#group
   */
  readonly group?: string;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Images to attach to the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#images
   */
  readonly images?: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages[];

  /**
   * Links to attach to the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#links
   */
  readonly links?: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks[];

  /**
   * The secret's key that contains the PagerDuty integration key (when using
   * Events API v2). Either this field or `serviceKey` needs to be defined.
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#routing_key
   */
  readonly routingKey?: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * The secret's key that contains the PagerDuty service key (when using
   * integration type "Prometheus"). Either this field or `routingKey` needs to
   * be defined.
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#service_key
   */
  readonly serviceKey?: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey;

  /**
   * Severity of the incident.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#severity
   */
  readonly severity?: string;

  /**
   * The URL to send requests to.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigs#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPagerdutyConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigs(obj: VmAlertmanagerConfigSpecReceiversPagerdutyConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'client': obj.client,
    'client_url': obj.clientUrl,
    'component': obj.component,
    'description': obj.description,
    'details': ((obj.details) === undefined) ? undefined : (Object.entries(obj.details).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'group': obj.group,
    'http_config': obj.httpConfig,
    'images': obj.images?.map(y => toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages(y)),
    'links': obj.links?.map(y => toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks(y)),
    'routing_key': toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(obj.routingKey),
    'send_resolved': obj.sendResolved,
    'service_key': toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(obj.serviceKey),
    'severity': obj.severity,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PushoverConfig configures notifications via Pushover.
 * See https://prometheus.io/docs/alerting/latest/configuration/#pushover_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversPushoverConfigs {
  /**
   * How long your notification will continue to be retried for, unless the user
   * acknowledges the notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#expire
   */
  readonly expire?: string;

  /**
   * Whether notification message is HTML or plain text.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#html
   */
  readonly html?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Notification message.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#message
   */
  readonly message?: string;

  /**
   * Priority, see https://pushover.net/api#priority
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#priority
   */
  readonly priority?: string;

  /**
   * How often the Pushover servers will send the same notification to the user.
   * Must be at least 30 seconds.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#retry
   */
  readonly retry?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * The name of one of the sounds supported by device clients to override the user's default sound choice
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#sound
   */
  readonly sound?: string;

  /**
   * Notification title.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#title
   */
  readonly title?: string;

  /**
   * The secret's key that contains the registered application’s API token, see https://pushover.net/apps.
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#token
   */
  readonly token?: VmAlertmanagerConfigSpecReceiversPushoverConfigsToken;

  /**
   * A supplementary URL shown alongside the message.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#url
   */
  readonly url?: string;

  /**
   * A title for supplementary URL, otherwise just the URL is shown
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#url_title
   */
  readonly urlTitle?: string;

  /**
   * The secret's key that contains the recipient user’s user key.
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigs#user_key
   */
  readonly userKey?: VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPushoverConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigs(obj: VmAlertmanagerConfigSpecReceiversPushoverConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expire': obj.expire,
    'html': obj.html,
    'http_config': obj.httpConfig,
    'message': obj.message,
    'priority': obj.priority,
    'retry': obj.retry,
    'send_resolved': obj.sendResolved,
    'sound': obj.sound,
    'title': obj.title,
    'token': toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigsToken(obj.token),
    'url': obj.url,
    'url_title': obj.urlTitle,
    'user_key': toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey(obj.userKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RocketchatConfig configures notifications via Rocketchat.
 * https://prometheus.io/docs/alerting/latest/configuration/#rocketchat_config
 * available from v0.55.0 operator version
 * and v0.28.0 alertmanager version
 *
 * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversRocketchatConfigs {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#actions
   */
  readonly actions?: VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions[];

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * RocketChat channel override, (like #other-channel or @username).
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#channel
   */
  readonly channel?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#color
   */
  readonly color?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#emoji
   */
  readonly emoji?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#fields
   */
  readonly fields?: VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields[];

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#icon_url
   */
  readonly iconUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#image_url
   */
  readonly imageUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#link_names
   */
  readonly linkNames?: boolean;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#short_fields
   */
  readonly shortFields?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#text
   */
  readonly text?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#thumb_url
   */
  readonly thumbUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#title
   */
  readonly title?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#title_link
   */
  readonly titleLink?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#token
   */
  readonly token?: VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken;

  /**
   * The sender token and token_id
   * See https://docs.rocket.chat/use-rocket.chat/user-guides/user-panel/my-account#personal-access-tokens
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigs#token_id
   */
  readonly tokenId?: VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversRocketchatConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigs(obj: VmAlertmanagerConfigSpecReceiversRocketchatConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions(y)),
    'api_url': obj.apiUrl,
    'channel': obj.channel,
    'color': obj.color,
    'emoji': obj.emoji,
    'fields': obj.fields?.map(y => toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields(y)),
    'http_config': obj.httpConfig,
    'icon_url': obj.iconUrl,
    'image_url': obj.imageUrl,
    'link_names': obj.linkNames,
    'send_resolved': obj.sendResolved,
    'short_fields': obj.shortFields,
    'text': obj.text,
    'thumb_url': obj.thumbUrl,
    'title': obj.title,
    'title_link': obj.titleLink,
    'token': toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken(obj.token),
    'token_id': toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId(obj.tokenId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlackConfig configures notifications via Slack.
 * See https://prometheus.io/docs/alerting/latest/configuration/#slack_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversSlackConfigs {
  /**
   * A list of Slack actions that are sent with each notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#actions
   */
  readonly actions?: VmAlertmanagerConfigSpecReceiversSlackConfigsActions[];

  /**
   * The secret's key that contains the Slack webhook URL.
   * It must be at them same namespace as CRD
   * fallback to global setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#api_url
   */
  readonly apiUrl?: VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#callback_id
   */
  readonly callbackId?: string;

  /**
   * The channel or user to send notifications to.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#channel
   */
  readonly channel?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#color
   */
  readonly color?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#fallback
   */
  readonly fallback?: string;

  /**
   * A list of Slack fields that are sent with each notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#fields
   */
  readonly fields?: VmAlertmanagerConfigSpecReceiversSlackConfigsFields[];

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#footer
   */
  readonly footer?: string;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#icon_emoji
   */
  readonly iconEmoji?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#icon_url
   */
  readonly iconUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#image_url
   */
  readonly imageUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#link_names
   */
  readonly linkNames?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#mrkdwn_in
   */
  readonly mrkdwnIn?: string[];

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#pretext
   */
  readonly pretext?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#short_fields
   */
  readonly shortFields?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#text
   */
  readonly text?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#thumb_url
   */
  readonly thumbUrl?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#title
   */
  readonly title?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#title_link
   */
  readonly titleLink?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigs#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSlackConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSlackConfigs(obj: VmAlertmanagerConfigSpecReceiversSlackConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsActions(y)),
    'api_url': toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl(obj.apiUrl),
    'callback_id': obj.callbackId,
    'channel': obj.channel,
    'color': obj.color,
    'fallback': obj.fallback,
    'fields': obj.fields?.map(y => toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsFields(y)),
    'footer': obj.footer,
    'http_config': obj.httpConfig,
    'icon_emoji': obj.iconEmoji,
    'icon_url': obj.iconUrl,
    'image_url': obj.imageUrl,
    'link_names': obj.linkNames,
    'mrkdwn_in': obj.mrkdwnIn?.map(y => y),
    'pretext': obj.pretext,
    'send_resolved': obj.sendResolved,
    'short_fields': obj.shortFields,
    'text': obj.text,
    'thumb_url': obj.thumbUrl,
    'title': obj.title,
    'title_link': obj.titleLink,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigs {
  /**
   * The api URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * SNS message attributes
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig;

  /**
   * The message content of the SNS notification.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#message
   */
  readonly message?: string;

  /**
   * Phone number if message is delivered via SMS
   * Specify this, topic_arn or target_arn
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#phone_number
   */
  readonly phoneNumber?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Configure the AWS Signature Verification 4 signing process
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#sigv4
   */
  readonly sigv4?: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4;

  /**
   * The subject line if message is delivered to an email endpoint.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#subject
   */
  readonly subject?: string;

  /**
   * Mobile platform endpoint ARN if message is delivered via mobile notifications
   * Specify this, topic_arn or phone_number
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#target_arn
   */
  readonly targetArn?: string;

  /**
   * SNS topic ARN, either specify this, phone_number or target_arn
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigs#topic_arn
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigs(obj: VmAlertmanagerConfigSpecReceiversSnsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api_url': obj.apiUrl,
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'phone_number': obj.phoneNumber,
    'send_resolved': obj.sendResolved,
    'sigv4': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4(obj.sigv4),
    'subject': obj.subject,
    'target_arn': obj.targetArn,
    'topic_arn': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TelegramConfig configures notification via telegram
 * https://prometheus.io/docs/alerting/latest/configuration/#telegram_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversTelegramConfigs {
  /**
   * APIUrl the Telegram API URL i.e. https://api.telegram.org.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * BotToken token for the bot
   * https://core.telegram.org/bots/api
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#bot_token
   */
  readonly botToken: VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken;

  /**
   * ChatID is ID of the chat where to send the messages.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#chat_id
   */
  readonly chatId: number;

  /**
   * DisableNotifications
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#disable_notifications
   */
  readonly disableNotifications?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Message is templated message
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#message
   */
  readonly message?: string;

  /**
   * MessageThreadID defines ID of the message thread where to send the messages.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#message_thread_id
   */
  readonly messageThreadId?: number;

  /**
   * ParseMode for telegram message,
   * supported values are MarkdownV2, Markdown, Markdown and empty string for plain text.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#parse_mode
   */
  readonly parseMode?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversTelegramConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversTelegramConfigs(obj: VmAlertmanagerConfigSpecReceiversTelegramConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api_url': obj.apiUrl,
    'bot_token': toJson_VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken(obj.botToken),
    'chat_id': obj.chatId,
    'disable_notifications': obj.disableNotifications,
    'http_config': obj.httpConfig,
    'message': obj.message,
    'message_thread_id': obj.messageThreadId,
    'parse_mode': obj.parseMode,
    'send_resolved': obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VictorOpsConfig configures notifications via VictorOps.
 * See https://prometheus.io/docs/alerting/latest/configuration/#victorops_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigs {
  /**
   * The secret's key that contains the API key to use when talking to the VictorOps API.
   * It must be at them same namespace as CRD
   * fallback to global setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#api_key
   */
  readonly apiKey?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey;

  /**
   * The VictorOps API URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * Adds optional custom fields
   * https://github.com/prometheus/alertmanager/blob/v0.24.0/config/notifiers.go#L537
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#custom_fields
   */
  readonly customFields?: { [key: string]: string };

  /**
   * Contains summary of the alerted problem.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#entity_display_name
   */
  readonly entityDisplayName?: string;

  /**
   * The HTTP client's configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig;

  /**
   * Describes the behavior of the alert (CRITICAL, WARNING, INFO).
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#message_type
   */
  readonly messageType?: string;

  /**
   * The monitoring tool the state message is from.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#monitoring_tool
   */
  readonly monitoringTool?: string;

  /**
   * A key used to map the alert to a team.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#routing_key
   */
  readonly routingKey: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Contains long explanation of the alerted problem.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigs#state_message
   */
  readonly stateMessage?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigs(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api_key': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(obj.apiKey),
    'api_url': obj.apiUrl,
    'custom_fields': ((obj.customFields) === undefined) ? undefined : (Object.entries(obj.customFields).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'entity_display_name': obj.entityDisplayName,
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(obj.httpConfig),
    'message_type': obj.messageType,
    'monitoring_tool': obj.monitoringTool,
    'routing_key': obj.routingKey,
    'send_resolved': obj.sendResolved,
    'state_message': obj.stateMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigs {
  /**
   * The Webex Teams API URL, i.e. https://webexapis.com/v1/messages
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * HTTP client configuration. You must use this configuration to supply the bot token as part of the HTTP `Authorization` header.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig;

  /**
   * The message body template
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs#message
   */
  readonly message?: string;

  /**
   * The ID of the Webex Teams room where to send the messages
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs#room_id
   */
  readonly roomId: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigs(obj: VmAlertmanagerConfigSpecReceiversWebexConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api_url': obj.apiUrl,
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'room_id': obj.roomId,
    'send_resolved': obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebhookConfig configures notifications via a generic receiver supporting the webhook payload.
 * See https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversWebhookConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#http_config
   */
  readonly httpConfig?: any;

  /**
   * Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#max_alerts
   */
  readonly maxAlerts?: number;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * Timeout is the maximum time allowed to invoke the webhook
   * available since v0.28.0 alertmanager version
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#timeout
   */
  readonly timeout?: string;

  /**
   * URL to send requests to,
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#url
   */
  readonly url?: string;

  /**
   * URLSecret defines secret name and key at the CRD namespace.
   * It must contain the webhook URL.
   * one of `urlSecret` and `url` must be defined.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigs#url_secret
   */
  readonly urlSecret?: VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebhookConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebhookConfigs(obj: VmAlertmanagerConfigSpecReceiversWebhookConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http_config': obj.httpConfig,
    'max_alerts': obj.maxAlerts,
    'send_resolved': obj.sendResolved,
    'timeout': obj.timeout,
    'url': obj.url,
    'url_secret': toJson_VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(obj.urlSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WeChatConfig configures notifications via WeChat.
 * See https://prometheus.io/docs/alerting/latest/configuration/#wechat_config
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigs {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#agent_id
   */
  readonly agentId?: string;

  /**
   * The secret's key that contains the WeChat API key.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * fallback to global alertmanager setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#api_secret
   */
  readonly apiSecret?: VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret;

  /**
   * The WeChat API URL.
   * fallback to global alertmanager setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#api_url
   */
  readonly apiUrl?: string;

  /**
   * The corp id for authentication.
   * fallback to global alertmanager setting if empty
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#corp_id
   */
  readonly corpId?: string;

  /**
   * HTTP client configuration.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#http_config
   */
  readonly httpConfig?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig;

  /**
   * API request data as defined by the WeChat API.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#message
   */
  readonly message?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#message_type
   */
  readonly messageType?: string;

  /**
   * SendResolved controls notify about resolved alerts.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#send_resolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#to_party
   */
  readonly toParty?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#to_tag
   */
  readonly toTag?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigs#to_user
   */
  readonly toUser?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigs(obj: VmAlertmanagerConfigSpecReceiversWechatConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agent_id': obj.agentId,
    'api_secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret(obj.apiSecret),
    'api_url': obj.apiUrl,
    'corp_id': obj.corpId,
    'http_config': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'message_type': obj.messageType,
    'send_resolved': obj.sendResolved,
    'to_party': obj.toParty,
    'to_tag': obj.toTag,
    'to_user': obj.toUser,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TimeInterval defines intervals of time
 *
 * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals
 */
export interface VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals {
  /**
   * DayOfMonth defines list of numerical days in the month. Days begin at 1. Negative values are also accepted.
   * for example, ['1:5', '-3:-1']
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#days_of_month
   */
  readonly daysOfMonth?: string[];

  /**
   * Location in golang time location form, e.g. UTC
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#location
   */
  readonly location?: string;

  /**
   * Months  defines list of calendar months identified by a case-insensitive name (e.g. ‘January’) or numeric 1.
   * For example, ['1:3', 'may:august', 'december']
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#months
   */
  readonly months?: string[];

  /**
   * Times defines time range for mute
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#times
   */
  readonly times?: VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes[];

  /**
   * Weekdays defines list of days of the week, where the week begins on Sunday and ends on Saturday.
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#weekdays
   */
  readonly weekdays?: string[];

  /**
   * Years defines numerical list of years, ranges are accepted.
   * For example, ['2020:2022', '2030']
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals#years
   */
  readonly years?: string[];

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals(obj: VmAlertmanagerConfigSpecTimeIntervalsTimeIntervals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'days_of_month': obj.daysOfMonth?.map(y => y),
    'location': obj.location,
    'months': obj.months?.map(y => y),
    'times': obj.times?.map(y => toJson_VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes(y)),
    'weekdays': obj.weekdays?.map(y => y),
    'years': obj.years?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP client configuration.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URLSecret defines secret name and key at the CRD namespace.
 * It must contain the webhook URL.
 * one of `urlSecret` and `url` must be defined.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsWebhookUrlSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AuthPassword defines secret name and key at CRD namespace.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AuthSecret defines secret name and key at CRD namespace.
 * It must contain the CRAM-MD5 secret.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsAuthSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP client configuration.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URLSecret defines secret name and key at the CRD namespace.
 * It must contain the webhook URL.
 * one of `urlSecret` and `url` must be defined.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrlSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URLSecret defines secret name and key at the CRD namespace.
 * It must contain the webhook URL.
 * one of `webhook_url` or `webhook_url_secret` must be defined.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsv2ConfigsWebhookUrlSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the OpsGenie API key.
 * It must be at them same namespace as CRD
 * fallback to global setting if empty
 *
 * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey
 */
export interface VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(obj: VmAlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpsGenieConfigResponder defines a responder to an incident.
 * One of `id`, `name` or `username` has to be defined.
 *
 * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders
 */
export interface VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders {
  /**
   * ID of the responder.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#id
   */
  readonly id?: string;

  /**
   * Name of the responder.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#name
   */
  readonly name?: string;

  /**
   * Type of responder.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#type
   */
  readonly type: string;

  /**
   * Username of the responder.
   *
   * @schema VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(obj: VmAlertmanagerConfigSpecReceiversOpsgenieConfigsResponders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageConfig is used to attach images to the incident.
 * See https://developer.pagerduty.com/docs/ZG9jOjExMDI5NTgx-send-an-alert-event#the-images-property
 * for more information.
 *
 * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages
 */
export interface VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages#alt
   */
  readonly alt?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages#href
   */
  readonly href?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages(obj: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alt': obj.alt,
    'href': obj.href,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LinkConfig is used to attach text links to the incident.
 * See https://developer.pagerduty.com/docs/ZG9jOjExMDI5NTgx-send-an-alert-event#the-links-property
 * for more information.
 *
 * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks
 */
export interface VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks#href
   */
  readonly href: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks#text
   */
  readonly text?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks(obj: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsLinks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'href': obj.href,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the PagerDuty integration key (when using
 * Events API v2). Either this field or `serviceKey` needs to be defined.
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey
 */
export interface VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(obj: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the PagerDuty service key (when using
 * integration type "Prometheus"). Either this field or `routingKey` needs to
 * be defined.
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey
 */
export interface VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(obj: VmAlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the registered application’s API token, see https://pushover.net/apps.
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsToken
 */
export interface VmAlertmanagerConfigSpecReceiversPushoverConfigsToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPushoverConfigsToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigsToken(obj: VmAlertmanagerConfigSpecReceiversPushoverConfigsToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the recipient user’s user key.
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey
 */
export interface VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey(obj: VmAlertmanagerConfigSpecReceiversPushoverConfigsUserKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RocketchatAttachmentAction defines message attachments
 * https://github.com/RocketChat/Rocket.Chat.Go.SDK/blob/master/models/message.go
 *
 * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions
 */
export interface VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions#msg
   */
  readonly msg?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions#text
   */
  readonly text?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions#type
   */
  readonly type?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions(obj: VmAlertmanagerConfigSpecReceiversRocketchatConfigsActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'msg': obj.msg,
    'text': obj.text,
    'type': obj.type,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RocketchatAttachmentField defines API fields
 * https://developer.rocket.chat/reference/api/rest-api/endpoints/messaging/chat-endpoints/postmessage#attachment-field-objects
 *
 * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields
 */
export interface VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields#short
   */
  readonly short?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields#title
   */
  readonly title?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields(obj: VmAlertmanagerConfigSpecReceiversRocketchatConfigsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'short': obj.short,
    'title': obj.title,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken
 */
export interface VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken(obj: VmAlertmanagerConfigSpecReceiversRocketchatConfigsToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The sender token and token_id
 * See https://docs.rocket.chat/use-rocket.chat/user-guides/user-panel/my-account#personal-access-tokens
 *
 * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId
 */
export interface VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId(obj: VmAlertmanagerConfigSpecReceiversRocketchatConfigsTokenId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlackAction configures a single Slack action that is sent with each
 * notification.
 * See https://api.slack.com/docs/message-attachments#action_fields and
 * https://api.slack.com/docs/message-buttons for more information.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions
 */
export interface VmAlertmanagerConfigSpecReceiversSlackConfigsActions {
  /**
   * SlackConfirmationField protect users from destructive actions or
   * particularly distinguished decisions by asking them to confirm their button
   * click one more time.
   * See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
   * for more information.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#confirm
   */
  readonly confirm?: VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#name
   */
  readonly name?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#style
   */
  readonly style?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#text
   */
  readonly text: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#type
   */
  readonly type: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#url
   */
  readonly url?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSlackConfigsActions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsActions(obj: VmAlertmanagerConfigSpecReceiversSlackConfigsActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirm': toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(obj.confirm),
    'name': obj.name,
    'style': obj.style,
    'text': obj.text,
    'type': obj.type,
    'url': obj.url,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the Slack webhook URL.
 * It must be at them same namespace as CRD
 * fallback to global setting if empty
 *
 * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl
 */
export interface VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl(obj: VmAlertmanagerConfigSpecReceiversSlackConfigsApiUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlackField configures a single Slack field that is sent with each notification.
 * See https://api.slack.com/docs/message-attachments#fields for more information.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsFields
 */
export interface VmAlertmanagerConfigSpecReceiversSlackConfigsFields {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsFields#short
   */
  readonly short?: boolean;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsFields#title
   */
  readonly title: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsFields#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSlackConfigsFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsFields(obj: VmAlertmanagerConfigSpecReceiversSlackConfigsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'short': obj.short,
    'title': obj.title,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP client configuration.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configure the AWS Signature Verification 4 signing process
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4 {
  /**
   * The AWS API keys. Both access_key and secret_key must be supplied or both must be blank.
   * If blank the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#access_key
   */
  readonly accessKey?: string;

  /**
   * secret key selector to get the keys from a Kubernetes Secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#access_key_selector
   */
  readonly accessKeySelector?: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector;

  /**
   * Named AWS profile used to authenticate
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#profile
   */
  readonly profile?: string;

  /**
   * AWS region, if blank the region from the default credentials chain is used
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#region
   */
  readonly region?: string;

  /**
   * AWS Role ARN, an alternative to using AWS API keys
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#role_arn
   */
  readonly roleArn?: string;

  /**
   * secret key selector to get the keys from a Kubernetes Secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4#secret_key_selector
   */
  readonly secretKeySelector?: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'access_key': obj.accessKey,
    'access_key_selector': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector(obj.accessKeySelector),
    'profile': obj.profile,
    'region': obj.region,
    'role_arn': obj.roleArn,
    'secret_key_selector': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector(obj.secretKeySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BotToken token for the bot
 * https://core.telegram.org/bots/api
 *
 * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken
 */
export interface VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken(obj: VmAlertmanagerConfigSpecReceiversTelegramConfigsBotToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the API key to use when talking to the VictorOps API.
 * It must be at them same namespace as CRD
 * fallback to global setting if empty
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The HTTP client's configuration.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP client configuration. You must use this configuration to supply the bot token as part of the HTTP `Authorization` header.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URLSecret defines secret name and key at the CRD namespace.
 * It must contain the webhook URL.
 * one of `urlSecret` and `url` must be defined.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(obj: VmAlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the WeChat API key.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * fallback to global alertmanager setting if empty
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP client configuration.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#authorization
   */
  readonly authorization?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#basic_auth
   */
  readonly basicAuth?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth;

  /**
   * BearerTokenFile defines filename for bearer token, it must be mounted to pod.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * The secret's key that contains the bearer token
   * It must be at them same namespace as CRD
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#bearer_token_secret
   */
  readonly bearerTokenSecret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#oauth2
   */
  readonly oauth2?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#tls_config
   */
  readonly tlsConfig?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(obj.authorization),
    'basic_auth': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearer_token_file': obj.bearerTokenFile,
    'bearer_token_secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'oauth2': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tls_config': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TimeRange  ranges inclusive of the starting time and exclusive of the end time
 *
 * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes
 */
export interface VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes {
  /**
   * EndTime for example HH:MM
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes#end_time
   */
  readonly endTime: string;

  /**
   * StartTime for example  HH:MM
   *
   * @schema VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes#start_time
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes(obj: VmAlertmanagerConfigSpecTimeIntervalsTimeIntervalsTimes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end_time': obj.endTime,
    'start_time': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlackConfirmationField protect users from destructive actions or
 * particularly distinguished decisions by asking them to confirm their button
 * click one more time.
 * See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
 * for more information.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm
 */
export interface VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm {
  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#dismiss_text
   */
  readonly dismissText?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#ok_text
   */
  readonly okText?: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#text
   */
  readonly text: string;

  /**
   * @schema VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(obj: VmAlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dismiss_text': obj.dismissText,
    'ok_text': obj.okText,
    'text': obj.text,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret key selector to get the keys from a Kubernetes Secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret key selector to get the keys from a Kubernetes Secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#password
   */
  readonly password?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#username
   */
  readonly username?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret's key that contains the bearer token
 * It must be at them same namespace as CRD
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#client_id
   */
  readonly clientId: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#client_secret
   */
  readonly clientSecret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret
 */
export interface VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(obj: VmAlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAnomaly is the Schema for the vmanomalies API.
 *
 * @schema VMAnomaly
 */
export class VmAnomaly extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAnomaly"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VMAnomaly',
  }

  /**
   * Renders a Kubernetes manifest for "VMAnomaly".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAnomalyProps = {}): any {
    return {
      ...VmAnomaly.GVK,
      ...toJson_VmAnomalyProps(props),
    };
  }

  /**
   * Defines a "VMAnomaly" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAnomalyProps = {}) {
    super(scope, id, {
      ...VmAnomaly.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAnomaly.GVK,
      ...toJson_VmAnomalyProps(resolved),
    };
  }
}

/**
 * VMAnomaly is the Schema for the vmanomalies API.
 *
 * @schema VMAnomaly
 */
export interface VmAnomalyProps {
  /**
   * @schema VMAnomaly#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMAnomalySpec defines the desired state of VMAnomaly.
   *
   * @schema VMAnomaly#spec
   */
  readonly spec?: VmAnomalySpec;

}

/**
 * Converts an object of type 'VmAnomalyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalyProps(obj: VmAnomalyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAnomalySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAnomalySpec defines the desired state of VMAnomaly.
 *
 * @schema VmAnomalySpec
 */
export interface VmAnomalySpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmAnomalySpec#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for VMAnomaly
   *
   * @schema VmAnomalySpec#claimTemplates
   */
  readonly claimTemplates?: VmAnomalySpecClaimTemplates[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmAnomalySpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigRawYaml - raw configuration for anomaly,
   * it helps it to start without secret.
   * priority -> hardcoded ConfigRaw -> ConfigRaw, provided by user -> ConfigSecret.
   *
   * @schema VmAnomalySpec#configRawYaml
   */
  readonly configRawYaml?: string;

  /**
   * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
   * VMAnomaly object, which contains configuration for this VMAnomaly,
   * configuration must be inside secret key: anomaly.yaml.
   * It must be created by user.
   * instance. Defaults to 'vmanomaly-<anomaly-name>'
   * The secret is mounted into /etc/anomaly/config.
   *
   * @default vmanomaly-<anomaly-name>'
   * @schema VmAnomalySpec#configSecret
   */
  readonly configSecret?: VmAnomalySpecConfigSecret;

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmAnomalySpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmAnomalySpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmAnomalySpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmAnomalySpec#dnsConfig
   */
  readonly dnsConfig?: VmAnomalySpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmAnomalySpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmAnomalySpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmAnomalySpec#extraEnvs
   */
  readonly extraEnvs?: VmAnomalySpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmAnomalySpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmAnomalySpecExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmAnomalySpec#hostAliases
   */
  readonly hostAliases?: VmAnomalySpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmAnomalySpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmAnomalySpec#image
   */
  readonly image?: VmAnomalySpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmAnomalySpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmAnomalySpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmAnomalySpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmAnomalySpec#license
   */
  readonly license?: VmAnomalySpecLicense;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmAnomalySpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogLevel for VMAnomaly to be configured with.
   * INFO, WARN, ERROR, FATAL, PANIC
   *
   * @schema VmAnomalySpec#logLevel
   */
  readonly logLevel?: VmAnomalySpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmAnomalySpec#managedMetadata
   */
  readonly managedMetadata?: VmAnomalySpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmAnomalySpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Monitoring configures how expose anomaly metrics
   * See https://docs.victoriametrics.com/anomaly-detection/components/monitoring/
   *
   * @schema VmAnomalySpec#monitoring
   */
  readonly monitoring?: VmAnomalySpecMonitoring;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmAnomalySpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmAnomalySpec#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VmAnomalySpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VmAnomalySpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmAnomalySpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmAnomalySpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the vmanomaly pods.
   *
   * @schema VmAnomalySpec#podMetadata
   */
  readonly podMetadata?: VmAnomalySpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmAnomalySpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmAnomalySpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Metrics source for VMAnomaly
   * See https://docs.victoriametrics.com/anomaly-detection/components/reader/
   *
   * @schema VmAnomalySpec#reader
   */
  readonly reader: VmAnomalySpecReader;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmAnomalySpec#readinessGates
   */
  readonly readinessGates?: VmAnomalySpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmAnomalySpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmAnomalySpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAnomalySpec#resources
   */
  readonly resources?: VmAnomalySpecResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmAnomalySpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy allows configuration for strategyType
   * set it to RollingUpdate for disabling operator statefulSet rollingUpdate
   *
   * @schema VmAnomalySpec#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmAnomalySpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmAnomalySpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmAnomalySpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmAnomalySpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmAnomalySpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vmanomaly VMPodScrape spec
   *
   * @schema VmAnomalySpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ShardCount - numbers of shards of VMAnomaly
   * in this case operator will use 1 sts per shard with
   * replicas count according to spec.replicas.
   *
   * @schema VmAnomalySpec#shardCount
   */
  readonly shardCount?: number;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmAnomalySpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage configures storage for StatefulSet
   *
   * @schema VmAnomalySpec#storage
   */
  readonly storage?: VmAnomalySpecStorage;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmAnomalySpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmAnomalySpec#tolerations
   */
  readonly tolerations?: VmAnomalySpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmAnomalySpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmAnomalySpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmAnomalySpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmAnomalySpec#volumeMounts
   */
  readonly volumeMounts?: VmAnomalySpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmAnomalySpec#volumes
   */
  readonly volumes?: any[];

  /**
   * Metrics destination for VMAnomaly
   * See https://docs.victoriametrics.com/anomaly-detection/components/writer/
   *
   * @schema VmAnomalySpec#writer
   */
  readonly writer: VmAnomalySpecWriter;

}

/**
 * Converts an object of type 'VmAnomalySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpec(obj: VmAnomalySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => toJson_VmAnomalySpecClaimTemplates(y)),
    'configMaps': obj.configMaps?.map(y => y),
    'configRawYaml': obj.configRawYaml,
    'configSecret': toJson_VmAnomalySpecConfigSecret(obj.configSecret),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmAnomalySpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmAnomalySpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmAnomalySpecExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmAnomalySpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmAnomalySpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmAnomalySpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'license': toJson_VmAnomalySpecLicense(obj.license),
    'livenessProbe': obj.livenessProbe,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmAnomalySpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'monitoring': toJson_VmAnomalySpecMonitoring(obj.monitoring),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VmAnomalySpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VmAnomalySpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmAnomalySpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'reader': toJson_VmAnomalySpecReader(obj.reader),
    'readinessGates': obj.readinessGates?.map(y => toJson_VmAnomalySpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmAnomalySpecResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'shardCount': obj.shardCount,
    'startupProbe': obj.startupProbe,
    'storage': toJson_VmAnomalySpecStorage(obj.storage),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmAnomalySpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmAnomalySpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
    'writer': toJson_VmAnomalySpecWriter(obj.writer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema VmAnomalySpecClaimTemplates
 */
export interface VmAnomalySpecClaimTemplates {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAnomalySpecClaimTemplates#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAnomalySpecClaimTemplates#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema VmAnomalySpecClaimTemplates#metadata
   */
  readonly metadata?: any;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAnomalySpecClaimTemplates#spec
   */
  readonly spec?: VmAnomalySpecClaimTemplatesSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAnomalySpecClaimTemplates#status
   */
  readonly status?: VmAnomalySpecClaimTemplatesStatus;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplates(obj: VmAnomalySpecClaimTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': obj.metadata,
    'spec': toJson_VmAnomalySpecClaimTemplatesSpec(obj.spec),
    'status': toJson_VmAnomalySpecClaimTemplatesStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
 * VMAnomaly object, which contains configuration for this VMAnomaly,
 * configuration must be inside secret key: anomaly.yaml.
 * It must be created by user.
 * instance. Defaults to 'vmanomaly-<anomaly-name>'
 * The secret is mounted into /etc/anomaly/config.
 *
 * @default vmanomaly-<anomaly-name>'
 * @schema VmAnomalySpecConfigSecret
 */
export interface VmAnomalySpecConfigSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecConfigSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecConfigSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecConfigSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecConfigSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecConfigSecret(obj: VmAnomalySpecConfigSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmAnomalySpecDnsConfig
 */
export interface VmAnomalySpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmAnomalySpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmAnomalySpecDnsConfig#options
   */
  readonly options?: VmAnomalySpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmAnomalySpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmAnomalySpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecDnsConfig(obj: VmAnomalySpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmAnomalySpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmAnomalySpecExtraEnvs
 */
export interface VmAnomalySpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmAnomalySpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmAnomalySpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecExtraEnvs(obj: VmAnomalySpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmAnomalySpecExtraEnvsFrom
 */
export interface VmAnomalySpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmAnomalySpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmAnomalySpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmAnomalySpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmAnomalySpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmAnomalySpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmAnomalySpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecExtraEnvsFrom(obj: VmAnomalySpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmAnomalySpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmAnomalySpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmAnomalySpecHostAliases
 */
export interface VmAnomalySpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmAnomalySpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmAnomalySpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmAnomalySpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecHostAliases(obj: VmAnomalySpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmAnomalySpecImage
 */
export interface VmAnomalySpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmAnomalySpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmAnomalySpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmAnomalySpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecImage(obj: VmAnomalySpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmAnomalySpecImagePullSecrets
 */
export interface VmAnomalySpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecImagePullSecrets(obj: VmAnomalySpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmAnomalySpecLicense
 */
export interface VmAnomalySpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmAnomalySpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmAnomalySpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmAnomalySpecLicense#keyRef
   */
  readonly keyRef?: VmAnomalySpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmAnomalySpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecLicense(obj: VmAnomalySpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmAnomalySpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogLevel for VMAnomaly to be configured with.
 * INFO, WARN, ERROR, FATAL, PANIC
 *
 * @schema VmAnomalySpecLogLevel
 */
export enum VmAnomalySpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmAnomalySpecManagedMetadata
 */
export interface VmAnomalySpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAnomalySpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAnomalySpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAnomalySpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecManagedMetadata(obj: VmAnomalySpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring configures how expose anomaly metrics
 * See https://docs.victoriametrics.com/anomaly-detection/components/monitoring/
 *
 * @schema VmAnomalySpecMonitoring
 */
export interface VmAnomalySpecMonitoring {
  /**
   * VMAnomalyMonitoringPullSpec defines pull monitoring configuration
   * which is enabled by default and served at POD_IP:8490/metrics
   *
   * @schema VmAnomalySpecMonitoring#pull
   */
  readonly pull?: VmAnomalySpecMonitoringPull;

  /**
   * VMAnomalyMonitoringPushSpec defines metrics push configuration
   *
   * VMAnomaly uses prometheus text exposition format
   *
   * @schema VmAnomalySpecMonitoring#push
   */
  readonly push?: VmAnomalySpecMonitoringPush;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoring(obj: VmAnomalySpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pull': toJson_VmAnomalySpecMonitoringPull(obj.pull),
    'push': toJson_VmAnomalySpecMonitoringPush(obj.push),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VmAnomalySpecPersistentVolumeClaimRetentionPolicy
 */
export interface VmAnomalySpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VmAnomalySpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VmAnomalySpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecPersistentVolumeClaimRetentionPolicy(obj: VmAnomalySpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmAnomalySpecPodDisruptionBudget
 */
export interface VmAnomalySpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmAnomalySpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmAnomalySpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmAnomalySpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmAnomalySpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmAnomalySpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAnomalySpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecPodDisruptionBudget(obj: VmAnomalySpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the vmanomaly pods.
 *
 * @schema VmAnomalySpecPodMetadata
 */
export interface VmAnomalySpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAnomalySpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAnomalySpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAnomalySpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecPodMetadata(obj: VmAnomalySpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metrics source for VMAnomaly
 * See https://docs.victoriametrics.com/anomaly-detection/components/reader/
 *
 * @schema VmAnomalySpecReader
 */
export interface VmAnomalySpecReader {
  /**
   * Basic auth defines basic authorization configuration
   *
   * @schema VmAnomalySpecReader#basicAuth
   */
  readonly basicAuth?: VmAnomalySpecReaderBasicAuth;

  /**
   * BearerAuth defines authorization with Authorization: Bearer header
   *
   * @schema VmAnomalySpecReader#bearer
   */
  readonly bearer?: VmAnomalySpecReaderBearer;

  /**
   * Optional argumentallows defining valid data ranges for input of all the queries in queries
   *
   * @schema VmAnomalySpecReader#dataRange
   */
  readonly dataRange?: string[];

  /**
   * DatasourceURL address
   * datasource must serve /api/v1/query and /api/v1/query_range APIs
   *
   * @schema VmAnomalySpecReader#datasourceURL
   */
  readonly datasourceUrl: string;

  /**
   * List of strings with series selector.
   *
   * @schema VmAnomalySpecReader#extraFilters
   */
  readonly extraFilters?: string[];

  /**
   * HealthPath defines absolute or relative URL address where to check availability of the remote webserver
   *
   * @schema VmAnomalySpecReader#healthPath
   */
  readonly healthPath?: string;

  /**
   * It allows overriding the default -search.latencyOffsetflag of VictoriaMetrics
   *
   * @schema VmAnomalySpecReader#latencyOffset
   */
  readonly latencyOffset?: string;

  /**
   * Optional argoverrides how search.maxPointsPerTimeseries flagimpacts vmanomaly on splitting long fitWindow queries into smaller sub-intervals
   *
   * @schema VmAnomalySpecReader#maxPointsPerQuery
   */
  readonly maxPointsPerQuery?: number;

  /**
   * If True, then query will be performed from the last seen timestamp for a given series.
   *
   * @schema VmAnomalySpecReader#queryFromLastSeenTimestamp
   */
  readonly queryFromLastSeenTimestamp?: boolean;

  /**
   * Performs PromQL/MetricsQL range query
   *
   * @schema VmAnomalySpecReader#queryRangePath
   */
  readonly queryRangePath?: string;

  /**
   * Frequency of the points returned
   *
   * @schema VmAnomalySpecReader#samplingPeriod
   */
  readonly samplingPeriod: string;

  /**
   * TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.
   *
   * @schema VmAnomalySpecReader#tenantID
   */
  readonly tenantId?: string;

  /**
   * Timeout for the requests, passed as a string
   *
   * @schema VmAnomalySpecReader#timeout
   */
  readonly timeout?: string;

  /**
   * TLSConfig defines tls connection configuration
   *
   * @schema VmAnomalySpecReader#tlsConfig
   */
  readonly tlsConfig?: VmAnomalySpecReaderTlsConfig;

  /**
   * Optional argumentspecifies the IANA timezone to account for local shifts, like DST, in models sensitive to seasonal patterns
   *
   * @schema VmAnomalySpecReader#tz
   */
  readonly tz?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecReader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReader(obj: VmAnomalySpecReader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAnomalySpecReaderBasicAuth(obj.basicAuth),
    'bearer': toJson_VmAnomalySpecReaderBearer(obj.bearer),
    'dataRange': obj.dataRange?.map(y => y),
    'datasourceURL': obj.datasourceUrl,
    'extraFilters': obj.extraFilters?.map(y => y),
    'healthPath': obj.healthPath,
    'latencyOffset': obj.latencyOffset,
    'maxPointsPerQuery': obj.maxPointsPerQuery,
    'queryFromLastSeenTimestamp': obj.queryFromLastSeenTimestamp,
    'queryRangePath': obj.queryRangePath,
    'samplingPeriod': obj.samplingPeriod,
    'tenantID': obj.tenantId,
    'timeout': obj.timeout,
    'tlsConfig': toJson_VmAnomalySpecReaderTlsConfig(obj.tlsConfig),
    'tz': obj.tz,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmAnomalySpecReadinessGates
 */
export interface VmAnomalySpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmAnomalySpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmAnomalySpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReadinessGates(obj: VmAnomalySpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAnomalySpecResources
 */
export interface VmAnomalySpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAnomalySpecResources#claims
   */
  readonly claims?: VmAnomalySpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecResources#limits
   */
  readonly limits?: { [key: string]: VmAnomalySpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecResources#requests
   */
  readonly requests?: { [key: string]: VmAnomalySpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAnomalySpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecResources(obj: VmAnomalySpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAnomalySpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage configures storage for StatefulSet
 *
 * @schema VmAnomalySpecStorage
 */
export interface VmAnomalySpecStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmAnomalySpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmAnomalySpecStorage#emptyDir
   */
  readonly emptyDir?: VmAnomalySpecStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmAnomalySpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: VmAnomalySpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'VmAnomalySpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorage(obj: VmAnomalySpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmAnomalySpecStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': toJson_VmAnomalySpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmAnomalySpecTolerations
 */
export interface VmAnomalySpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmAnomalySpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmAnomalySpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmAnomalySpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmAnomalySpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmAnomalySpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecTolerations(obj: VmAnomalySpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmAnomalySpecVolumeMounts
 */
export interface VmAnomalySpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmAnomalySpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmAnomalySpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmAnomalySpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmAnomalySpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmAnomalySpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmAnomalySpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmAnomalySpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecVolumeMounts(obj: VmAnomalySpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metrics destination for VMAnomaly
 * See https://docs.victoriametrics.com/anomaly-detection/components/writer/
 *
 * @schema VmAnomalySpecWriter
 */
export interface VmAnomalySpecWriter {
  /**
   * Basic auth defines basic authorization configuration
   *
   * @schema VmAnomalySpecWriter#basicAuth
   */
  readonly basicAuth?: VmAnomalySpecWriterBasicAuth;

  /**
   * BearerAuth defines authorization with Authorization: Bearer header
   *
   * @schema VmAnomalySpecWriter#bearer
   */
  readonly bearer?: VmAnomalySpecWriterBearer;

  /**
   * DatasourceURL defines remote write url for write requests
   * provided endpoint must serve /api/v1/import path
   * vmanomaly joins datasourceURL + "/api/v1/import"
   *
   * @schema VmAnomalySpecWriter#datasourceURL
   */
  readonly datasourceUrl: string;

  /**
   * HealthPath defines absolute or relative URL address where to check availability of the remote webserver
   *
   * @schema VmAnomalySpecWriter#healthPath
   */
  readonly healthPath?: string;

  /**
   * Metrics to save the output (in metric names or labels)
   *
   * @schema VmAnomalySpecWriter#metricFormat
   */
  readonly metricFormat?: VmAnomalySpecWriterMetricFormat;

  /**
   * TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.
   *
   * @schema VmAnomalySpecWriter#tenantID
   */
  readonly tenantId?: string;

  /**
   * Timeout for the requests, passed as a string
   *
   * @schema VmAnomalySpecWriter#timeout
   */
  readonly timeout?: string;

  /**
   * TLSConfig defines tls connection configuration
   *
   * @schema VmAnomalySpecWriter#tlsConfig
   */
  readonly tlsConfig?: VmAnomalySpecWriterTlsConfig;

}

/**
 * Converts an object of type 'VmAnomalySpecWriter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriter(obj: VmAnomalySpecWriter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAnomalySpecWriterBasicAuth(obj.basicAuth),
    'bearer': toJson_VmAnomalySpecWriterBearer(obj.bearer),
    'datasourceURL': obj.datasourceUrl,
    'healthPath': obj.healthPath,
    'metricFormat': toJson_VmAnomalySpecWriterMetricFormat(obj.metricFormat),
    'tenantID': obj.tenantId,
    'timeout': obj.timeout,
    'tlsConfig': toJson_VmAnomalySpecWriterTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAnomalySpecClaimTemplatesSpec
 */
export interface VmAnomalySpecClaimTemplatesSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#dataSource
   */
  readonly dataSource?: VmAnomalySpecClaimTemplatesSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAnomalySpecClaimTemplatesSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#resources
   */
  readonly resources?: VmAnomalySpecClaimTemplatesSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#selector
   */
  readonly selector?: VmAnomalySpecClaimTemplatesSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAnomalySpecClaimTemplatesSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpec(obj: VmAnomalySpecClaimTemplatesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAnomalySpecClaimTemplatesSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAnomalySpecClaimTemplatesSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAnomalySpecClaimTemplatesSpecResources(obj.resources),
    'selector': toJson_VmAnomalySpecClaimTemplatesSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAnomalySpecClaimTemplatesStatus
 */
export interface VmAnomalySpecClaimTemplatesStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAnomalySpecClaimTemplatesStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAnomalySpecClaimTemplatesStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#conditions
   */
  readonly conditions?: VmAnomalySpecClaimTemplatesStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAnomalySpecClaimTemplatesStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesStatus(obj: VmAnomalySpecClaimTemplatesStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAnomalySpecClaimTemplatesStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmAnomalySpecDnsConfigOptions
 */
export interface VmAnomalySpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmAnomalySpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmAnomalySpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecDnsConfigOptions(obj: VmAnomalySpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmAnomalySpecExtraEnvsFromConfigMapRef
 */
export interface VmAnomalySpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmAnomalySpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecExtraEnvsFromConfigMapRef(obj: VmAnomalySpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmAnomalySpecExtraEnvsFromSecretRef
 */
export interface VmAnomalySpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmAnomalySpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecExtraEnvsFromSecretRef(obj: VmAnomalySpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmAnomalySpecLicenseKeyRef
 */
export interface VmAnomalySpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecLicenseKeyRef(obj: VmAnomalySpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAnomalyMonitoringPullSpec defines pull monitoring configuration
 * which is enabled by default and served at POD_IP:8490/metrics
 *
 * @schema VmAnomalySpecMonitoringPull
 */
export interface VmAnomalySpecMonitoringPull {
  /**
   * Addr changes listen addr, default is 0.0.0.0
   *
   * @schema VmAnomalySpecMonitoringPull#addr
   */
  readonly addr?: string;

  /**
   * Port defines a port for metrics scrape
   *
   * @schema VmAnomalySpecMonitoringPull#port
   */
  readonly port: string;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPull' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPull(obj: VmAnomalySpecMonitoringPull | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addr': obj.addr,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAnomalyMonitoringPushSpec defines metrics push configuration
 *
 * VMAnomaly uses prometheus text exposition format
 *
 * @schema VmAnomalySpecMonitoringPush
 */
export interface VmAnomalySpecMonitoringPush {
  /**
   * Basic auth defines basic authorization configuration
   *
   * @schema VmAnomalySpecMonitoringPush#basicAuth
   */
  readonly basicAuth?: VmAnomalySpecMonitoringPushBasicAuth;

  /**
   * BearerAuth defines authorization with Authorization: Bearer header
   *
   * @schema VmAnomalySpecMonitoringPush#bearer
   */
  readonly bearer?: VmAnomalySpecMonitoringPushBearer;

  /**
   * ExtraLabels defines a set of labels to attach to the pushed metrics
   *
   * @schema VmAnomalySpecMonitoringPush#extraLabels
   */
  readonly extraLabels?: { [key: string]: string };

  /**
   * HealthPath defines absolute or relative URL address where to check availability of the remote webserver
   *
   * @schema VmAnomalySpecMonitoringPush#healthPath
   */
  readonly healthPath?: string;

  /**
   * PushFrequency defines push interval
   *
   * @schema VmAnomalySpecMonitoringPush#pushFrequency
   */
  readonly pushFrequency?: string;

  /**
   * TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.
   *
   * @schema VmAnomalySpecMonitoringPush#tenantID
   */
  readonly tenantId?: string;

  /**
   * Timeout for the requests, passed as a string
   *
   * @schema VmAnomalySpecMonitoringPush#timeout
   */
  readonly timeout?: string;

  /**
   * TLSConfig defines tls connection configuration
   *
   * @schema VmAnomalySpecMonitoringPush#tlsConfig
   */
  readonly tlsConfig?: VmAnomalySpecMonitoringPushTlsConfig;

  /**
   * defines target url for push requests
   *
   * @schema VmAnomalySpecMonitoringPush#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPush' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPush(obj: VmAnomalySpecMonitoringPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_VmAnomalySpecMonitoringPushBasicAuth(obj.basicAuth),
    'bearer': toJson_VmAnomalySpecMonitoringPushBearer(obj.bearer),
    'extraLabels': ((obj.extraLabels) === undefined) ? undefined : (Object.entries(obj.extraLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'healthPath': obj.healthPath,
    'pushFrequency': obj.pushFrequency,
    'tenantID': obj.tenantId,
    'timeout': obj.timeout,
    'tlsConfig': toJson_VmAnomalySpecMonitoringPushTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmAnomalySpecPodDisruptionBudgetMaxUnavailable
 */
export class VmAnomalySpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmAnomalySpecPodDisruptionBudgetMaxUnavailable {
    return new VmAnomalySpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmAnomalySpecPodDisruptionBudgetMaxUnavailable {
    return new VmAnomalySpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmAnomalySpecPodDisruptionBudgetMinAvailable
 */
export class VmAnomalySpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmAnomalySpecPodDisruptionBudgetMinAvailable {
    return new VmAnomalySpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmAnomalySpecPodDisruptionBudgetMinAvailable {
    return new VmAnomalySpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Basic auth defines basic authorization configuration
 *
 * @schema VmAnomalySpecReaderBasicAuth
 */
export interface VmAnomalySpecReaderBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecReaderBasicAuth#password
   */
  readonly password?: VmAnomalySpecReaderBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAnomalySpecReaderBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecReaderBasicAuth#username
   */
  readonly username?: VmAnomalySpecReaderBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderBasicAuth(obj: VmAnomalySpecReaderBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAnomalySpecReaderBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAnomalySpecReaderBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BearerAuth defines authorization with Authorization: Bearer header
 *
 * @schema VmAnomalySpecReaderBearer
 */
export interface VmAnomalySpecReaderBearer {
  /**
   * Path to bearer token file
   *
   * @schema VmAnomalySpecReaderBearer#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAnomalySpecReaderBearer#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAnomalySpecReaderBearerBearerTokenSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderBearer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderBearer(obj: VmAnomalySpecReaderBearer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAnomalySpecReaderBearerBearerTokenSecret(obj.bearerTokenSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig defines tls connection configuration
 *
 * @schema VmAnomalySpecReaderTlsConfig
 */
export interface VmAnomalySpecReaderTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#ca
   */
  readonly ca?: VmAnomalySpecReaderTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#cert
   */
  readonly cert?: VmAnomalySpecReaderTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAnomalySpecReaderTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#keySecret
   */
  readonly keySecret?: VmAnomalySpecReaderTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfig(obj: VmAnomalySpecReaderTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAnomalySpecReaderTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAnomalySpecReaderTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAnomalySpecReaderTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAnomalySpecResourcesClaims
 */
export interface VmAnomalySpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAnomalySpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAnomalySpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecResourcesClaims(obj: VmAnomalySpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAnomalySpecResourcesLimits
 */
export class VmAnomalySpecResourcesLimits {
  public static fromNumber(value: number): VmAnomalySpecResourcesLimits {
    return new VmAnomalySpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAnomalySpecResourcesLimits {
    return new VmAnomalySpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAnomalySpecResourcesRequests
 */
export class VmAnomalySpecResourcesRequests {
  public static fromNumber(value: number): VmAnomalySpecResourcesRequests {
    return new VmAnomalySpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAnomalySpecResourcesRequests {
    return new VmAnomalySpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmAnomalySpecStorageEmptyDir
 */
export interface VmAnomalySpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAnomalySpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmAnomalySpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmAnomalySpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageEmptyDir(obj: VmAnomalySpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PVC spec to be used by the StatefulSets/Deployments.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplate
 */
export interface VmAnomalySpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: VmAnomalySpecStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: VmAnomalySpecStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplate#status
   */
  readonly status?: VmAnomalySpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplate(obj: VmAnomalySpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_VmAnomalySpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_VmAnomalySpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_VmAnomalySpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Basic auth defines basic authorization configuration
 *
 * @schema VmAnomalySpecWriterBasicAuth
 */
export interface VmAnomalySpecWriterBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecWriterBasicAuth#password
   */
  readonly password?: VmAnomalySpecWriterBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAnomalySpecWriterBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecWriterBasicAuth#username
   */
  readonly username?: VmAnomalySpecWriterBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterBasicAuth(obj: VmAnomalySpecWriterBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAnomalySpecWriterBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAnomalySpecWriterBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BearerAuth defines authorization with Authorization: Bearer header
 *
 * @schema VmAnomalySpecWriterBearer
 */
export interface VmAnomalySpecWriterBearer {
  /**
   * Path to bearer token file
   *
   * @schema VmAnomalySpecWriterBearer#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAnomalySpecWriterBearer#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAnomalySpecWriterBearerBearerTokenSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterBearer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterBearer(obj: VmAnomalySpecWriterBearer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAnomalySpecWriterBearerBearerTokenSecret(obj.bearerTokenSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metrics to save the output (in metric names or labels)
 *
 * @schema VmAnomalySpecWriterMetricFormat
 */
export interface VmAnomalySpecWriterMetricFormat {
  /**
   * Name of result metric
   * Must have a value with $VAR placeholder in it to distinguish between resulting metrics
   *
   * @schema VmAnomalySpecWriterMetricFormat#__name__
   */
  readonly name: string;

  /**
   * ExtraLabels defines additional labels to be added to the resulting metrics
   *
   * @schema VmAnomalySpecWriterMetricFormat#extraLabels
   */
  readonly extraLabels?: { [key: string]: string };

  /**
   * For is a special label with $QUERY_KEY placeholder
   *
   * @schema VmAnomalySpecWriterMetricFormat#for
   */
  readonly for: string;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterMetricFormat' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterMetricFormat(obj: VmAnomalySpecWriterMetricFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '__name__': obj.name,
    'extraLabels': ((obj.extraLabels) === undefined) ? undefined : (Object.entries(obj.extraLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'for': obj.for,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig defines tls connection configuration
 *
 * @schema VmAnomalySpecWriterTlsConfig
 */
export interface VmAnomalySpecWriterTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#ca
   */
  readonly ca?: VmAnomalySpecWriterTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#cert
   */
  readonly cert?: VmAnomalySpecWriterTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAnomalySpecWriterTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#keySecret
   */
  readonly keySecret?: VmAnomalySpecWriterTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfig(obj: VmAnomalySpecWriterTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAnomalySpecWriterTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAnomalySpecWriterTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAnomalySpecWriterTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAnomalySpecClaimTemplatesSpecDataSource
 */
export interface VmAnomalySpecClaimTemplatesSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpecDataSource(obj: VmAnomalySpecClaimTemplatesSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAnomalySpecClaimTemplatesSpecDataSourceRef
 */
export interface VmAnomalySpecClaimTemplatesSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpecDataSourceRef(obj: VmAnomalySpecClaimTemplatesSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAnomalySpecClaimTemplatesSpecResources
 */
export interface VmAnomalySpecClaimTemplatesSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecClaimTemplatesSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAnomalySpecClaimTemplatesSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecClaimTemplatesSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAnomalySpecClaimTemplatesSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpecResources(obj: VmAnomalySpecClaimTemplatesSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAnomalySpecClaimTemplatesSpecSelector
 */
export interface VmAnomalySpecClaimTemplatesSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpecSelector(obj: VmAnomalySpecClaimTemplatesSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAnomalySpecClaimTemplatesStatusAllocatedResources
 */
export class VmAnomalySpecClaimTemplatesStatusAllocatedResources {
  public static fromNumber(value: number): VmAnomalySpecClaimTemplatesStatusAllocatedResources {
    return new VmAnomalySpecClaimTemplatesStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAnomalySpecClaimTemplatesStatusAllocatedResources {
    return new VmAnomalySpecClaimTemplatesStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAnomalySpecClaimTemplatesStatusCapacity
 */
export class VmAnomalySpecClaimTemplatesStatusCapacity {
  public static fromNumber(value: number): VmAnomalySpecClaimTemplatesStatusCapacity {
    return new VmAnomalySpecClaimTemplatesStatusCapacity(value);
  }
  public static fromString(value: string): VmAnomalySpecClaimTemplatesStatusCapacity {
    return new VmAnomalySpecClaimTemplatesStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAnomalySpecClaimTemplatesStatusConditions
 */
export interface VmAnomalySpecClaimTemplatesStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAnomalySpecClaimTemplatesStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesStatusConditions(obj: VmAnomalySpecClaimTemplatesStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus
 */
export interface VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus(obj: VmAnomalySpecClaimTemplatesStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Basic auth defines basic authorization configuration
 *
 * @schema VmAnomalySpecMonitoringPushBasicAuth
 */
export interface VmAnomalySpecMonitoringPushBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuth#password
   */
  readonly password?: VmAnomalySpecMonitoringPushBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuth#username
   */
  readonly username?: VmAnomalySpecMonitoringPushBasicAuthUsername;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushBasicAuth(obj: VmAnomalySpecMonitoringPushBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmAnomalySpecMonitoringPushBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmAnomalySpecMonitoringPushBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BearerAuth defines authorization with Authorization: Bearer header
 *
 * @schema VmAnomalySpecMonitoringPushBearer
 */
export interface VmAnomalySpecMonitoringPushBearer {
  /**
   * Path to bearer token file
   *
   * @schema VmAnomalySpecMonitoringPushBearer#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Optional bearer auth token to use for -remoteWrite.url
   *
   * @schema VmAnomalySpecMonitoringPushBearer#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmAnomalySpecMonitoringPushBearerBearerTokenSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushBearer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushBearer(obj: VmAnomalySpecMonitoringPushBearer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmAnomalySpecMonitoringPushBearerBearerTokenSecret(obj.bearerTokenSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig defines tls connection configuration
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfig
 */
export interface VmAnomalySpecMonitoringPushTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#ca
   */
  readonly ca?: VmAnomalySpecMonitoringPushTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#cert
   */
  readonly cert?: VmAnomalySpecMonitoringPushTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#keySecret
   */
  readonly keySecret?: VmAnomalySpecMonitoringPushTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfig(obj: VmAnomalySpecMonitoringPushTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAnomalySpecMonitoringPushTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAnomalySpecMonitoringPushTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAnomalySpecMonitoringPushTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecReaderBasicAuthPassword
 */
export interface VmAnomalySpecReaderBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderBasicAuthPassword(obj: VmAnomalySpecReaderBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecReaderBasicAuthUsername
 */
export interface VmAnomalySpecReaderBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderBasicAuthUsername(obj: VmAnomalySpecReaderBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAnomalySpecReaderBearerBearerTokenSecret
 */
export interface VmAnomalySpecReaderBearerBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderBearerBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderBearerBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderBearerBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderBearerBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderBearerBearerTokenSecret(obj: VmAnomalySpecReaderBearerBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCa
 */
export interface VmAnomalySpecReaderTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfigCa#configMap
   */
  readonly configMap?: VmAnomalySpecReaderTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfigCa#secret
   */
  readonly secret?: VmAnomalySpecReaderTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCa(obj: VmAnomalySpecReaderTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecReaderTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecReaderTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCert
 */
export interface VmAnomalySpecReaderTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfigCert#configMap
   */
  readonly configMap?: VmAnomalySpecReaderTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecReaderTlsConfigCert#secret
   */
  readonly secret?: VmAnomalySpecReaderTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCert(obj: VmAnomalySpecReaderTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecReaderTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecReaderTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigKeySecret
 */
export interface VmAnomalySpecReaderTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigKeySecret(obj: VmAnomalySpecReaderTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmAnomalySpecStorageEmptyDirSizeLimit
 */
export class VmAnomalySpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VmAnomalySpecStorageEmptyDirSizeLimit {
    return new VmAnomalySpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmAnomalySpecStorageEmptyDirSizeLimit {
    return new VmAnomalySpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateMetadata
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateMetadata(obj: VmAnomalySpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: VmAnomalySpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: VmAnomalySpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpec(obj: VmAnomalySpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: VmAnomalySpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateStatus(obj: VmAnomalySpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmAnomalySpecStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecWriterBasicAuthPassword
 */
export interface VmAnomalySpecWriterBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterBasicAuthPassword(obj: VmAnomalySpecWriterBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecWriterBasicAuthUsername
 */
export interface VmAnomalySpecWriterBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterBasicAuthUsername(obj: VmAnomalySpecWriterBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAnomalySpecWriterBearerBearerTokenSecret
 */
export interface VmAnomalySpecWriterBearerBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterBearerBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterBearerBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterBearerBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterBearerBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterBearerBearerTokenSecret(obj: VmAnomalySpecWriterBearerBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCa
 */
export interface VmAnomalySpecWriterTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfigCa#configMap
   */
  readonly configMap?: VmAnomalySpecWriterTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfigCa#secret
   */
  readonly secret?: VmAnomalySpecWriterTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCa(obj: VmAnomalySpecWriterTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecWriterTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecWriterTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCert
 */
export interface VmAnomalySpecWriterTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfigCert#configMap
   */
  readonly configMap?: VmAnomalySpecWriterTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecWriterTlsConfigCert#secret
   */
  readonly secret?: VmAnomalySpecWriterTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCert(obj: VmAnomalySpecWriterTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecWriterTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecWriterTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigKeySecret
 */
export interface VmAnomalySpecWriterTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigKeySecret(obj: VmAnomalySpecWriterTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAnomalySpecClaimTemplatesSpecResourcesLimits
 */
export class VmAnomalySpecClaimTemplatesSpecResourcesLimits {
  public static fromNumber(value: number): VmAnomalySpecClaimTemplatesSpecResourcesLimits {
    return new VmAnomalySpecClaimTemplatesSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAnomalySpecClaimTemplatesSpecResourcesLimits {
    return new VmAnomalySpecClaimTemplatesSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAnomalySpecClaimTemplatesSpecResourcesRequests
 */
export class VmAnomalySpecClaimTemplatesSpecResourcesRequests {
  public static fromNumber(value: number): VmAnomalySpecClaimTemplatesSpecResourcesRequests {
    return new VmAnomalySpecClaimTemplatesSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAnomalySpecClaimTemplatesSpecResourcesRequests {
    return new VmAnomalySpecClaimTemplatesSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions
 */
export interface VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions(obj: VmAnomalySpecClaimTemplatesSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecMonitoringPushBasicAuthPassword
 */
export interface VmAnomalySpecMonitoringPushBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushBasicAuthPassword(obj: VmAnomalySpecMonitoringPushBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmAnomalySpecMonitoringPushBasicAuthUsername
 */
export interface VmAnomalySpecMonitoringPushBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushBasicAuthUsername(obj: VmAnomalySpecMonitoringPushBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional bearer auth token to use for -remoteWrite.url
 *
 * @schema VmAnomalySpecMonitoringPushBearerBearerTokenSecret
 */
export interface VmAnomalySpecMonitoringPushBearerBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushBearerBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushBearerBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushBearerBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushBearerBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushBearerBearerTokenSecret(obj: VmAnomalySpecMonitoringPushBearerBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCa
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCa#configMap
   */
  readonly configMap?: VmAnomalySpecMonitoringPushTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCa#secret
   */
  readonly secret?: VmAnomalySpecMonitoringPushTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCa(obj: VmAnomalySpecMonitoringPushTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecMonitoringPushTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecMonitoringPushTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCert
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCert#configMap
   */
  readonly configMap?: VmAnomalySpecMonitoringPushTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCert#secret
   */
  readonly secret?: VmAnomalySpecMonitoringPushTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCert(obj: VmAnomalySpecMonitoringPushTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAnomalySpecMonitoringPushTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAnomalySpecMonitoringPushTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigKeySecret
 */
export interface VmAnomalySpecMonitoringPushTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigKeySecret(obj: VmAnomalySpecMonitoringPushTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCaConfigMap
 */
export interface VmAnomalySpecReaderTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecReaderTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecReaderTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCaConfigMap(obj: VmAnomalySpecReaderTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCaSecret
 */
export interface VmAnomalySpecReaderTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCaSecret(obj: VmAnomalySpecReaderTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCertConfigMap
 */
export interface VmAnomalySpecReaderTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecReaderTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecReaderTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCertConfigMap(obj: VmAnomalySpecReaderTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecReaderTlsConfigCertSecret
 */
export interface VmAnomalySpecReaderTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecReaderTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecReaderTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecReaderTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecReaderTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecReaderTlsConfigCertSecret(obj: VmAnomalySpecReaderTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource(obj: VmAnomalySpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: VmAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecResources
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecResources(obj: VmAnomalySpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelector
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecSelector(obj: VmAnomalySpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmAnomalySpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity
 */
export class VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity {
    return new VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity {
    return new VmAnomalySpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateStatusConditions(obj: VmAnomalySpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: VmAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCaConfigMap
 */
export interface VmAnomalySpecWriterTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecWriterTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecWriterTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCaConfigMap(obj: VmAnomalySpecWriterTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCaSecret
 */
export interface VmAnomalySpecWriterTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCaSecret(obj: VmAnomalySpecWriterTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCertConfigMap
 */
export interface VmAnomalySpecWriterTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecWriterTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecWriterTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCertConfigMap(obj: VmAnomalySpecWriterTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecWriterTlsConfigCertSecret
 */
export interface VmAnomalySpecWriterTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecWriterTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecWriterTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecWriterTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecWriterTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecWriterTlsConfigCertSecret(obj: VmAnomalySpecWriterTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCaConfigMap
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCaConfigMap(obj: VmAnomalySpecMonitoringPushTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCaSecret
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCaSecret(obj: VmAnomalySpecMonitoringPushTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCertConfigMap
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCertConfigMap(obj: VmAnomalySpecMonitoringPushTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAnomalySpecMonitoringPushTlsConfigCertSecret
 */
export interface VmAnomalySpecMonitoringPushTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAnomalySpecMonitoringPushTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAnomalySpecMonitoringPushTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecMonitoringPushTlsConfigCertSecret(obj: VmAnomalySpecMonitoringPushTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmAnomalySpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: VmAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMAuth is the Schema for the vmauths API
 *
 * @schema VMAuth
 */
export class VmAuth extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMAuth"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMAuth',
  }

  /**
   * Renders a Kubernetes manifest for "VMAuth".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmAuthProps = {}): any {
    return {
      ...VmAuth.GVK,
      ...toJson_VmAuthProps(props),
    };
  }

  /**
   * Defines a "VMAuth" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmAuthProps = {}) {
    super(scope, id, {
      ...VmAuth.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmAuth.GVK,
      ...toJson_VmAuthProps(resolved),
    };
  }
}

/**
 * VMAuth is the Schema for the vmauths API
 *
 * @schema VMAuth
 */
export interface VmAuthProps {
  /**
   * @schema VMAuth#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMAuthSpec defines the desired state of VMAuth
   *
   * @schema VMAuth#spec
   */
  readonly spec?: VmAuthSpec;

}

/**
 * Converts an object of type 'VmAuthProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthProps(obj: VmAuthProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmAuthSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMAuthSpec defines the desired state of VMAuth
 *
 * @schema VmAuthSpec
 */
export interface VmAuthSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmAuthSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmAuthSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
   * Given secret reference will be added to the application and vm-config-reloader as volume
   * available since v0.57.0 version
   *
   * @schema VmAuthSpec#configReloadAuthKeySecret
   */
  readonly configReloadAuthKeySecret?: VmAuthSpecConfigReloadAuthKeySecret;

  /**
   * ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
   * for example resyncInterval: "30s"
   *
   * @schema VmAuthSpec#configReloaderExtraArgs
   */
  readonly configReloaderExtraArgs?: { [key: string]: string };

  /**
   * ConfigReloaderImageTag defines image:tag for config-reloader container
   *
   * @schema VmAuthSpec#configReloaderImageTag
   */
  readonly configReloaderImageTag?: string;

  /**
   * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAuthSpec#configReloaderResources
   */
  readonly configReloaderResources?: VmAuthSpecConfigReloaderResources;

  /**
   * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
   * VMAuth object, which contains auth configuration for vmauth,
   * configuration must be inside secret key: config.yaml.
   * It must be created and managed manually.
   * If it's defined, configuration for vmauth becomes unmanaged and operator'll not create any related secrets/config-reloaders
   * Deprecated: use externalConfig.secretRef instead
   *
   * @schema VmAuthSpec#configSecret
   */
  readonly configSecret?: string;

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmAuthSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmAuthSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmAuthSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmAuthSpec#dnsConfig
   */
  readonly dnsConfig?: VmAuthSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmAuthSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExternalConfig defines a source of external VMAuth configuration.
   * If it's defined, configuration for vmauth becomes unmanaged and operator'll not create any related secrets/config-reloaders
   *
   * @schema VmAuthSpec#externalConfig
   */
  readonly externalConfig?: VmAuthSpecExternalConfig;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmAuthSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmAuthSpec#extraEnvs
   */
  readonly extraEnvs?: VmAuthSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmAuthSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmAuthSpecExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmAuthSpec#hostAliases
   */
  readonly hostAliases?: VmAuthSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmAuthSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmAuthSpec#image
   */
  readonly image?: VmAuthSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmAuthSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmAuthSpecImagePullSecrets[];

  /**
   * Ingress enables ingress configuration for VMAuth.
   *
   * @schema VmAuthSpec#ingress
   */
  readonly ingress?: VmAuthSpecIngress;

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmAuthSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * InternalListenPort instructs vmauth to serve internal routes at given port
   * available from v0.56.0 operator
   * and v1.111.0 vmauth version
   * related doc https://docs.victoriametrics.com/victoriametrics/vmauth/#security
   *
   * @schema VmAuthSpec#internalListenPort
   */
  readonly internalListenPort?: string;

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmAuthSpec#license
   */
  readonly license?: VmAuthSpecLicense;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmAuthSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMAuth to be configured with.
   *
   * @schema VmAuthSpec#logFormat
   */
  readonly logFormat?: VmAuthSpecLogFormat;

  /**
   * LogLevel for victoria metrics single to be configured with.
   *
   * @schema VmAuthSpec#logLevel
   */
  readonly logLevel?: VmAuthSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmAuthSpec#managedMetadata
   */
  readonly managedMetadata?: VmAuthSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmAuthSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmAuthSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmAuthSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmAuthSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmAuthSpecPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMAuth pods.
   *
   * @schema VmAuthSpec#podMetadata
   */
  readonly podMetadata?: VmAuthSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmAuthSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmAuthSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmAuthSpec#readinessGates
   */
  readonly readinessGates?: VmAuthSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmAuthSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmAuthSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmAuthSpec#resources
   */
  readonly resources?: VmAuthSpecResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmAuthSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmAuthSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmAuthSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmAuthSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmAuthSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * SelectAllByDefault changes default behavior for empty CRD selectors, such userSelector.
   * with selectAllByDefault: true and empty userSelector and userNamespaceSelector
   * Operator selects all exist users
   * with selectAllByDefault: false - selects nothing
   *
   * @schema VmAuthSpec#selectAllByDefault
   */
  readonly selectAllByDefault?: boolean;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmAuthSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vmauth VMServiceScrape spec
   *
   * @schema VmAuthSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmsingle service spec
   *
   * @schema VmAuthSpec#serviceSpec
   */
  readonly serviceSpec?: VmAuthSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmAuthSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmAuthSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmAuthSpec#tolerations
   */
  readonly tolerations?: VmAuthSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmAuthSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UnauthorizedAccessConfig configures access for un authorized users
   *
   * Deprecated: use unauthorizedUserAccessSpec instead
   * will be removed at v1.0 release
   *
   * @schema VmAuthSpec#unauthorizedAccessConfig
   */
  readonly unauthorizedAccessConfig?: any;

  /**
   * UnauthorizedUserAccessSpec defines unauthorized_user config section of vmauth config
   *
   * @schema VmAuthSpec#unauthorizedUserAccessSpec
   */
  readonly unauthorizedUserAccessSpec?: VmAuthSpecUnauthorizedUserAccessSpec;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmAuthSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseProxyProtocol enables proxy protocol for vmauth
   * https://www.haproxy.org/download/2.3/doc/proxy-protocol.txt
   *
   * @schema VmAuthSpec#useProxyProtocol
   */
  readonly useProxyProtocol?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmAuthSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * UseVMConfigReloader replaces prometheus-like config-reloader
   * with vm one. It uses secrets watch instead of file watch
   * which greatly increases speed of config updates
   *
   * @schema VmAuthSpec#useVMConfigReloader
   */
  readonly useVmConfigReloader?: boolean;

  /**
   * UserNamespaceSelector Namespaces to be selected for  VMAuth discovery.
   * Works in combination with Selector.
   * NamespaceSelector nil - only objects at VMAuth namespace.
   * Selector nil - only objects at NamespaceSelector namespaces.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAuthSpec#userNamespaceSelector
   */
  readonly userNamespaceSelector?: VmAuthSpecUserNamespaceSelector;

  /**
   * UserSelector defines VMUser to be selected for config file generation.
   * Works in combination with NamespaceSelector.
   * NamespaceSelector nil - only objects at VMAuth namespace.
   * If both nil - behaviour controlled by selectAllByDefault
   *
   * @schema VmAuthSpec#userSelector
   */
  readonly userSelector?: VmAuthSpecUserSelector;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmAuthSpec#volumeMounts
   */
  readonly volumeMounts?: VmAuthSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmAuthSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmAuthSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpec(obj: VmAuthSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'configReloadAuthKeySecret': toJson_VmAuthSpecConfigReloadAuthKeySecret(obj.configReloadAuthKeySecret),
    'configReloaderExtraArgs': ((obj.configReloaderExtraArgs) === undefined) ? undefined : (Object.entries(obj.configReloaderExtraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configReloaderImageTag': obj.configReloaderImageTag,
    'configReloaderResources': toJson_VmAuthSpecConfigReloaderResources(obj.configReloaderResources),
    'configSecret': obj.configSecret,
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmAuthSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'externalConfig': toJson_VmAuthSpecExternalConfig(obj.externalConfig),
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmAuthSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmAuthSpecExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmAuthSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmAuthSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmAuthSpecImagePullSecrets(y)),
    'ingress': toJson_VmAuthSpecIngress(obj.ingress),
    'initContainers': obj.initContainers?.map(y => y),
    'internalListenPort': obj.internalListenPort,
    'license': toJson_VmAuthSpecLicense(obj.license),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmAuthSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VmAuthSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmAuthSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmAuthSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmAuthSpecResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'selectAllByDefault': obj.selectAllByDefault,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmAuthSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmAuthSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'unauthorizedAccessConfig': obj.unauthorizedAccessConfig,
    'unauthorizedUserAccessSpec': toJson_VmAuthSpecUnauthorizedUserAccessSpec(obj.unauthorizedUserAccessSpec),
    'useDefaultResources': obj.useDefaultResources,
    'useProxyProtocol': obj.useProxyProtocol,
    'useStrictSecurity': obj.useStrictSecurity,
    'useVMConfigReloader': obj.useVmConfigReloader,
    'userNamespaceSelector': toJson_VmAuthSpecUserNamespaceSelector(obj.userNamespaceSelector),
    'userSelector': toJson_VmAuthSpecUserSelector(obj.userSelector),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmAuthSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
 * Given secret reference will be added to the application and vm-config-reloader as volume
 * available since v0.57.0 version
 *
 * @schema VmAuthSpecConfigReloadAuthKeySecret
 */
export interface VmAuthSpecConfigReloadAuthKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecConfigReloadAuthKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecConfigReloadAuthKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecConfigReloadAuthKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecConfigReloadAuthKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecConfigReloadAuthKeySecret(obj: VmAuthSpecConfigReloadAuthKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAuthSpecConfigReloaderResources
 */
export interface VmAuthSpecConfigReloaderResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAuthSpecConfigReloaderResources#claims
   */
  readonly claims?: VmAuthSpecConfigReloaderResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAuthSpecConfigReloaderResources#limits
   */
  readonly limits?: { [key: string]: VmAuthSpecConfigReloaderResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAuthSpecConfigReloaderResources#requests
   */
  readonly requests?: { [key: string]: VmAuthSpecConfigReloaderResourcesRequests };

}

/**
 * Converts an object of type 'VmAuthSpecConfigReloaderResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecConfigReloaderResources(obj: VmAuthSpecConfigReloaderResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAuthSpecConfigReloaderResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmAuthSpecDnsConfig
 */
export interface VmAuthSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmAuthSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmAuthSpecDnsConfig#options
   */
  readonly options?: VmAuthSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmAuthSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmAuthSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecDnsConfig(obj: VmAuthSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmAuthSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalConfig defines a source of external VMAuth configuration.
 * If it's defined, configuration for vmauth becomes unmanaged and operator'll not create any related secrets/config-reloaders
 *
 * @schema VmAuthSpecExternalConfig
 */
export interface VmAuthSpecExternalConfig {
  /**
   * LocalPath contains static path to a config, which is managed externally for cases
   * when using secrets is not applicable, e.g.: Vault sidecar.
   *
   * @schema VmAuthSpecExternalConfig#localPath
   */
  readonly localPath?: string;

  /**
   * SecretRef defines selector for externally managed secret which contains configuration
   *
   * @schema VmAuthSpecExternalConfig#secretRef
   */
  readonly secretRef?: VmAuthSpecExternalConfigSecretRef;

}

/**
 * Converts an object of type 'VmAuthSpecExternalConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExternalConfig(obj: VmAuthSpecExternalConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localPath': obj.localPath,
    'secretRef': toJson_VmAuthSpecExternalConfigSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmAuthSpecExtraEnvs
 */
export interface VmAuthSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmAuthSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmAuthSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAuthSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExtraEnvs(obj: VmAuthSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmAuthSpecExtraEnvsFrom
 */
export interface VmAuthSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmAuthSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmAuthSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmAuthSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmAuthSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmAuthSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmAuthSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExtraEnvsFrom(obj: VmAuthSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmAuthSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmAuthSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmAuthSpecHostAliases
 */
export interface VmAuthSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmAuthSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmAuthSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmAuthSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecHostAliases(obj: VmAuthSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmAuthSpecImage
 */
export interface VmAuthSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmAuthSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmAuthSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmAuthSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmAuthSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecImage(obj: VmAuthSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmAuthSpecImagePullSecrets
 */
export interface VmAuthSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAuthSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecImagePullSecrets(obj: VmAuthSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ingress enables ingress configuration for VMAuth.
 *
 * @schema VmAuthSpecIngress
 */
export interface VmAuthSpecIngress {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAuthSpecIngress#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ClassName defines ingress class name for VMAuth
   *
   * @schema VmAuthSpecIngress#class_name
   */
  readonly className?: string;

  /**
   * ExtraRules - additional rules for ingress,
   * must be checked for correctness by user.
   *
   * @schema VmAuthSpecIngress#extraRules
   */
  readonly extraRules?: VmAuthSpecIngressExtraRules[];

  /**
   * ExtraTLS - additional TLS configuration for ingress
   * must be checked for correctness by user.
   *
   * @schema VmAuthSpecIngress#extraTls
   */
  readonly extraTls?: VmAuthSpecIngressExtraTls[];

  /**
   * Host defines ingress host parameter for default rule
   * It will be used, only if TlsHosts is empty
   *
   * @schema VmAuthSpecIngress#host
   */
  readonly host?: string;

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAuthSpecIngress#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAuthSpecIngress#name
   */
  readonly name?: string;

  /**
   * TlsHosts configures TLS access for ingress, tlsSecretName must be defined for it.
   *
   * @schema VmAuthSpecIngress#tlsHosts
   */
  readonly tlsHosts?: string[];

  /**
   * TlsSecretName defines secretname at the VMAuth namespace with cert and key
   * https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
   *
   * @schema VmAuthSpecIngress#tlsSecretName
   */
  readonly tlsSecretName?: string;

}

/**
 * Converts an object of type 'VmAuthSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngress(obj: VmAuthSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'class_name': obj.className,
    'extraRules': obj.extraRules?.map(y => toJson_VmAuthSpecIngressExtraRules(y)),
    'extraTls': obj.extraTls?.map(y => toJson_VmAuthSpecIngressExtraTls(y)),
    'host': obj.host,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'tlsHosts': obj.tlsHosts?.map(y => y),
    'tlsSecretName': obj.tlsSecretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmAuthSpecLicense
 */
export interface VmAuthSpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmAuthSpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmAuthSpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmAuthSpecLicense#keyRef
   */
  readonly keyRef?: VmAuthSpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmAuthSpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmAuthSpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecLicense(obj: VmAuthSpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmAuthSpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMAuth to be configured with.
 *
 * @schema VmAuthSpecLogFormat
 */
export enum VmAuthSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for victoria metrics single to be configured with.
 *
 * @schema VmAuthSpecLogLevel
 */
export enum VmAuthSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmAuthSpecManagedMetadata
 */
export interface VmAuthSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAuthSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAuthSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAuthSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecManagedMetadata(obj: VmAuthSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmAuthSpecPodDisruptionBudget
 */
export interface VmAuthSpecPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmAuthSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmAuthSpecPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmAuthSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmAuthSpecPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmAuthSpecPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAuthSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecPodDisruptionBudget(obj: VmAuthSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMAuth pods.
 *
 * @schema VmAuthSpecPodMetadata
 */
export interface VmAuthSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAuthSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAuthSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAuthSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAuthSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecPodMetadata(obj: VmAuthSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmAuthSpecReadinessGates
 */
export interface VmAuthSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmAuthSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmAuthSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecReadinessGates(obj: VmAuthSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmAuthSpecResources
 */
export interface VmAuthSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmAuthSpecResources#claims
   */
  readonly claims?: VmAuthSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAuthSpecResources#limits
   */
  readonly limits?: { [key: string]: VmAuthSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmAuthSpecResources#requests
   */
  readonly requests?: { [key: string]: VmAuthSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmAuthSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecResources(obj: VmAuthSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmAuthSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmsingle service spec
 *
 * @schema VmAuthSpecServiceSpec
 */
export interface VmAuthSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmAuthSpecServiceSpec#metadata
   */
  readonly metadata?: VmAuthSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmAuthSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmAuthSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecServiceSpec(obj: VmAuthSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmAuthSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmAuthSpecTolerations
 */
export interface VmAuthSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmAuthSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmAuthSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmAuthSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmAuthSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmAuthSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAuthSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecTolerations(obj: VmAuthSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UnauthorizedUserAccessSpec defines unauthorized_user config section of vmauth config
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpec
 */
export interface VmAuthSpecUnauthorizedUserAccessSpec {
  /**
   * DefaultURLs backend url for non-matching paths filter
   * usually used for default backend with error message
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#default_url
   */
  readonly defaultUrl?: string[];

  /**
   * DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#discover_backend_ips
   */
  readonly discoverBackendIps?: boolean;

  /**
   * DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#drop_src_path_prefix_parts
   */
  readonly dropSrcPathPrefixParts?: number;

  /**
   * DumpRequestOnErrors instructs vmauth to return detailed request params to the client
   * if routing rules don't allow to forward request to the backends.
   * Useful for debugging `src_hosts` and `src_headers` based routing rules
   *
   * available since v1.107.0 vmauth version
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#dump_request_on_errors
   */
  readonly dumpRequestOnErrors?: boolean;

  /**
   * Headers represent additional http headers, that vmauth uses
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.68.0 version of vmauth
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#headers
   */
  readonly headers?: string[];

  /**
   * IPFilters defines per target src ip filters
   * supported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#ip_filters
   */
  readonly ipFilters?: VmAuthSpecUnauthorizedUserAccessSpecIpFilters;

  /**
   * LoadBalancingPolicy defines load balancing policy to use for backend urls.
   * Supported policies: least_loaded, first_available.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#load_balancing_policy
   */
  readonly loadBalancingPolicy?: VmAuthSpecUnauthorizedUserAccessSpecLoadBalancingPolicy;

  /**
   * MaxConcurrentRequests defines max concurrent requests per user
   * 300 is default value for vmauth
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#max_concurrent_requests
   */
  readonly maxConcurrentRequests?: number;

  /**
   * MetricLabels - additional labels for metrics exported by vmauth for given user.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#metric_labels
   */
  readonly metricLabels?: { [key: string]: string };

  /**
   * ResponseHeaders represent additional http headers, that vmauth adds for request response
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.93.0 version of vmauth
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#response_headers
   */
  readonly responseHeaders?: string[];

  /**
   * RetryStatusCodes defines http status codes in numeric format for request retries
   * e.g. [429,503]
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#retry_status_codes
   */
  readonly retryStatusCodes?: number[];

  /**
   * TLSConfig defines tls configuration for the backend connection
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#tlsConfig
   */
  readonly tlsConfig?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfig;

  /**
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#url_map
   */
  readonly urlMap?: VmAuthSpecUnauthorizedUserAccessSpecUrlMap[];

  /**
   * URLPrefix defines prefix prefix for destination
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpec#url_prefix
   */
  readonly urlPrefix?: any;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpec(obj: VmAuthSpecUnauthorizedUserAccessSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default_url': obj.defaultUrl?.map(y => y),
    'discover_backend_ips': obj.discoverBackendIps,
    'drop_src_path_prefix_parts': obj.dropSrcPathPrefixParts,
    'dump_request_on_errors': obj.dumpRequestOnErrors,
    'headers': obj.headers?.map(y => y),
    'ip_filters': toJson_VmAuthSpecUnauthorizedUserAccessSpecIpFilters(obj.ipFilters),
    'load_balancing_policy': obj.loadBalancingPolicy,
    'max_concurrent_requests': obj.maxConcurrentRequests,
    'metric_labels': ((obj.metricLabels) === undefined) ? undefined : (Object.entries(obj.metricLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'response_headers': obj.responseHeaders?.map(y => y),
    'retry_status_codes': obj.retryStatusCodes?.map(y => y),
    'tlsConfig': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfig(obj.tlsConfig),
    'url_map': obj.urlMap?.map(y => toJson_VmAuthSpecUnauthorizedUserAccessSpecUrlMap(y)),
    'url_prefix': obj.urlPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserNamespaceSelector Namespaces to be selected for  VMAuth discovery.
 * Works in combination with Selector.
 * NamespaceSelector nil - only objects at VMAuth namespace.
 * Selector nil - only objects at NamespaceSelector namespaces.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAuthSpecUserNamespaceSelector
 */
export interface VmAuthSpecUserNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAuthSpecUserNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: VmAuthSpecUserNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAuthSpecUserNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAuthSpecUserNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUserNamespaceSelector(obj: VmAuthSpecUserNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAuthSpecUserNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserSelector defines VMUser to be selected for config file generation.
 * Works in combination with NamespaceSelector.
 * NamespaceSelector nil - only objects at VMAuth namespace.
 * If both nil - behaviour controlled by selectAllByDefault
 *
 * @schema VmAuthSpecUserSelector
 */
export interface VmAuthSpecUserSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmAuthSpecUserSelector#matchExpressions
   */
  readonly matchExpressions?: VmAuthSpecUserSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmAuthSpecUserSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmAuthSpecUserSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUserSelector(obj: VmAuthSpecUserSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmAuthSpecUserSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmAuthSpecVolumeMounts
 */
export interface VmAuthSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmAuthSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmAuthSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmAuthSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmAuthSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmAuthSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmAuthSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmAuthSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmAuthSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecVolumeMounts(obj: VmAuthSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAuthSpecConfigReloaderResourcesClaims
 */
export interface VmAuthSpecConfigReloaderResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAuthSpecConfigReloaderResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAuthSpecConfigReloaderResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAuthSpecConfigReloaderResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecConfigReloaderResourcesClaims(obj: VmAuthSpecConfigReloaderResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAuthSpecConfigReloaderResourcesLimits
 */
export class VmAuthSpecConfigReloaderResourcesLimits {
  public static fromNumber(value: number): VmAuthSpecConfigReloaderResourcesLimits {
    return new VmAuthSpecConfigReloaderResourcesLimits(value);
  }
  public static fromString(value: string): VmAuthSpecConfigReloaderResourcesLimits {
    return new VmAuthSpecConfigReloaderResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAuthSpecConfigReloaderResourcesRequests
 */
export class VmAuthSpecConfigReloaderResourcesRequests {
  public static fromNumber(value: number): VmAuthSpecConfigReloaderResourcesRequests {
    return new VmAuthSpecConfigReloaderResourcesRequests(value);
  }
  public static fromString(value: string): VmAuthSpecConfigReloaderResourcesRequests {
    return new VmAuthSpecConfigReloaderResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmAuthSpecDnsConfigOptions
 */
export interface VmAuthSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmAuthSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmAuthSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmAuthSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecDnsConfigOptions(obj: VmAuthSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef defines selector for externally managed secret which contains configuration
 *
 * @schema VmAuthSpecExternalConfigSecretRef
 */
export interface VmAuthSpecExternalConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecExternalConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecExternalConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecExternalConfigSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecExternalConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExternalConfigSecretRef(obj: VmAuthSpecExternalConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmAuthSpecExtraEnvsFromConfigMapRef
 */
export interface VmAuthSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmAuthSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExtraEnvsFromConfigMapRef(obj: VmAuthSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmAuthSpecExtraEnvsFromSecretRef
 */
export interface VmAuthSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmAuthSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecExtraEnvsFromSecretRef(obj: VmAuthSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IngressRule represents the rules mapping the paths under a specified host to
 * the related backend services. Incoming requests are first evaluated for a host
 * match, then routed to the backend associated with the matching IngressRuleValue.
 *
 * @schema VmAuthSpecIngressExtraRules
 */
export interface VmAuthSpecIngressExtraRules {
  /**
   * host is the fully qualified domain name of a network host, as defined by RFC 3986.
   * Note the following deviations from the "host" part of the
   * URI as defined in RFC 3986:
   * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
   * the IP in the Spec of the parent Ingress.
   * 2. The `:` delimiter is not respected because ports are not allowed.
   * Currently the port of an Ingress is implicitly :80 for http and
   * :443 for https.
   * Both these may change in the future.
   * Incoming requests are matched against the host before the
   * IngressRuleValue. If the host is unspecified, the Ingress routes all
   * traffic based on the specified IngressRuleValue.
   *
   * host can be "precise" which is a domain name without the terminating dot of
   * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
   * prefixed with a single wildcard label (e.g. "*.foo.com").
   * The wildcard character '*' must appear by itself as the first DNS label and
   * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
   * Requests will be matched against the Host field in the following way:
   * 1. If host is precise, the request matches this rule if the http host header is equal to Host.
   * 2. If host is a wildcard, then the request matches this rule if the http host header
   * is to equal to the suffix (removing the first label) of the wildcard rule.
   *
   * @schema VmAuthSpecIngressExtraRules#host
   */
  readonly host?: string;

  /**
   * HTTPIngressRuleValue is a list of http selectors pointing to backends.
   * In the example: http://<host>/<path>?<searchpart> -> backend where
   * where parts of the url correspond to RFC 3986, this resource will be used
   * to match against everything after the last '/' and before the first '?'
   * or '#'.
   *
   * @schema VmAuthSpecIngressExtraRules#http
   */
  readonly http?: VmAuthSpecIngressExtraRulesHttp;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRules(obj: VmAuthSpecIngressExtraRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'http': toJson_VmAuthSpecIngressExtraRulesHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IngressTLS describes the transport layer security associated with an ingress.
 *
 * @schema VmAuthSpecIngressExtraTls
 */
export interface VmAuthSpecIngressExtraTls {
  /**
   * hosts is a list of hosts included in the TLS certificate. The values in
   * this list must match the name/s used in the tlsSecret. Defaults to the
   * wildcard host setting for the loadbalancer controller fulfilling this
   * Ingress, if left unspecified.
   *
   * @default the
   * @schema VmAuthSpecIngressExtraTls#hosts
   */
  readonly hosts?: string[];

  /**
   * secretName is the name of the secret used to terminate TLS traffic on
   * port 443. Field is left optional to allow TLS routing based on SNI
   * hostname alone. If the SNI host in a listener conflicts with the "Host"
   * header field used by an IngressRule, the SNI host is used for termination
   * and value of the "Host" header is used for routing.
   *
   * @schema VmAuthSpecIngressExtraTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraTls(obj: VmAuthSpecIngressExtraTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmAuthSpecLicenseKeyRef
 */
export interface VmAuthSpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecLicenseKeyRef(obj: VmAuthSpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmAuthSpecPodDisruptionBudgetMaxUnavailable
 */
export class VmAuthSpecPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmAuthSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAuthSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmAuthSpecPodDisruptionBudgetMaxUnavailable {
    return new VmAuthSpecPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmAuthSpecPodDisruptionBudgetMinAvailable
 */
export class VmAuthSpecPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmAuthSpecPodDisruptionBudgetMinAvailable {
    return new VmAuthSpecPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmAuthSpecPodDisruptionBudgetMinAvailable {
    return new VmAuthSpecPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmAuthSpecResourcesClaims
 */
export interface VmAuthSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmAuthSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmAuthSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmAuthSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecResourcesClaims(obj: VmAuthSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmAuthSpecResourcesLimits
 */
export class VmAuthSpecResourcesLimits {
  public static fromNumber(value: number): VmAuthSpecResourcesLimits {
    return new VmAuthSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmAuthSpecResourcesLimits {
    return new VmAuthSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmAuthSpecResourcesRequests
 */
export class VmAuthSpecResourcesRequests {
  public static fromNumber(value: number): VmAuthSpecResourcesRequests {
    return new VmAuthSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmAuthSpecResourcesRequests {
    return new VmAuthSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmAuthSpecServiceSpecMetadata
 */
export interface VmAuthSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmAuthSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmAuthSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmAuthSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmAuthSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecServiceSpecMetadata(obj: VmAuthSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IPFilters defines per target src ip filters
 * supported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecIpFilters
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecIpFilters {
  /**
   * @schema VmAuthSpecUnauthorizedUserAccessSpecIpFilters#allow_list
   */
  readonly allowList?: string[];

  /**
   * @schema VmAuthSpecUnauthorizedUserAccessSpecIpFilters#deny_list
   */
  readonly denyList?: string[];

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecIpFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecIpFilters(obj: VmAuthSpecUnauthorizedUserAccessSpecIpFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow_list': obj.allowList?.map(y => y),
    'deny_list': obj.denyList?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancingPolicy defines load balancing policy to use for backend urls.
 * Supported policies: least_loaded, first_available.
 * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecLoadBalancingPolicy
 */
export enum VmAuthSpecUnauthorizedUserAccessSpecLoadBalancingPolicy {
  /** least_loaded */
  LEAST_UNDERSCORE_LOADED = "least_loaded",
  /** first_available */
  FIRST_UNDERSCORE_AVAILABLE = "first_available",
}

/**
 * TLSConfig defines tls configuration for the backend connection
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#ca
   */
  readonly ca?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#cert
   */
  readonly cert?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#keySecret
   */
  readonly keySecret?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfig(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UnauthorizedAccessConfigURLMap defines element of url_map routing configuration
 * For UnauthorizedAccessConfig and VMAuthUnauthorizedUserAccessSpec.URLMap
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecUrlMap {
  /**
   * DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#discover_backend_ips
   */
  readonly discoverBackendIps?: boolean;

  /**
   * DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#drop_src_path_prefix_parts
   */
  readonly dropSrcPathPrefixParts?: number;

  /**
   * RequestHeaders represent additional http headers, that vmauth uses
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.68.0 version of vmauth
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#headers
   */
  readonly headers?: string[];

  /**
   * LoadBalancingPolicy defines load balancing policy to use for backend urls.
   * Supported policies: least_loaded, first_available.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#load_balancing_policy
   */
  readonly loadBalancingPolicy?: VmAuthSpecUnauthorizedUserAccessSpecUrlMapLoadBalancingPolicy;

  /**
   * ResponseHeaders represent additional http headers, that vmauth adds for request response
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.93.0 version of vmauth
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#response_headers
   */
  readonly responseHeaders?: string[];

  /**
   * RetryStatusCodes defines http status codes in numeric format for request retries
   * Can be defined per target or at VMUser.spec level
   * e.g. [429,503]
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#retry_status_codes
   */
  readonly retryStatusCodes?: number[];

  /**
   * SrcHeaders is an optional list of headers, which must match request headers.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#src_headers
   */
  readonly srcHeaders?: string[];

  /**
   * SrcHosts is an optional list of regular expressions, which must match the request hostname.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#src_hosts
   */
  readonly srcHosts?: string[];

  /**
   * SrcPaths is an optional list of regular expressions, which must match the request path.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#src_paths
   */
  readonly srcPaths?: string[];

  /**
   * SrcQueryArgs is an optional list of query args, which must match request URL query args.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#src_query_args
   */
  readonly srcQueryArgs?: string[];

  /**
   * UrlPrefix contains backend url prefixes for the proxied request url.
   * URLPrefix defines prefix prefix for destination
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMap#url_prefix
   */
  readonly urlPrefix?: any;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecUrlMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecUrlMap(obj: VmAuthSpecUnauthorizedUserAccessSpecUrlMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'discover_backend_ips': obj.discoverBackendIps,
    'drop_src_path_prefix_parts': obj.dropSrcPathPrefixParts,
    'headers': obj.headers?.map(y => y),
    'load_balancing_policy': obj.loadBalancingPolicy,
    'response_headers': obj.responseHeaders?.map(y => y),
    'retry_status_codes': obj.retryStatusCodes?.map(y => y),
    'src_headers': obj.srcHeaders?.map(y => y),
    'src_hosts': obj.srcHosts?.map(y => y),
    'src_paths': obj.srcPaths?.map(y => y),
    'src_query_args': obj.srcQueryArgs?.map(y => y),
    'url_prefix': obj.urlPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAuthSpecUserNamespaceSelectorMatchExpressions
 */
export interface VmAuthSpecUserNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAuthSpecUserNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAuthSpecUserNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAuthSpecUserNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAuthSpecUserNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUserNamespaceSelectorMatchExpressions(obj: VmAuthSpecUserNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmAuthSpecUserSelectorMatchExpressions
 */
export interface VmAuthSpecUserSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmAuthSpecUserSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmAuthSpecUserSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmAuthSpecUserSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmAuthSpecUserSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUserSelectorMatchExpressions(obj: VmAuthSpecUserSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPIngressRuleValue is a list of http selectors pointing to backends.
 * In the example: http://<host>/<path>?<searchpart> -> backend where
 * where parts of the url correspond to RFC 3986, this resource will be used
 * to match against everything after the last '/' and before the first '?'
 * or '#'.
 *
 * @schema VmAuthSpecIngressExtraRulesHttp
 */
export interface VmAuthSpecIngressExtraRulesHttp {
  /**
   * paths is a collection of paths that map requests to backends.
   *
   * @schema VmAuthSpecIngressExtraRulesHttp#paths
   */
  readonly paths: VmAuthSpecIngressExtraRulesHttpPaths[];

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttp(obj: VmAuthSpecIngressExtraRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => toJson_VmAuthSpecIngressExtraRulesHttpPaths(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa#configMap
   */
  readonly configMap?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa#secret
   */
  readonly secret?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert#configMap
   */
  readonly configMap?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert#secret
   */
  readonly secret?: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancingPolicy defines load balancing policy to use for backend urls.
 * Supported policies: least_loaded, first_available.
 * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecUrlMapLoadBalancingPolicy
 */
export enum VmAuthSpecUnauthorizedUserAccessSpecUrlMapLoadBalancingPolicy {
  /** least_loaded */
  LEAST_UNDERSCORE_LOADED = "least_loaded",
  /** first_available */
  FIRST_UNDERSCORE_AVAILABLE = "first_available",
}

/**
 * HTTPIngressPath associates a path with a backend. Incoming urls matching the
 * path are forwarded to the backend.
 *
 * @schema VmAuthSpecIngressExtraRulesHttpPaths
 */
export interface VmAuthSpecIngressExtraRulesHttpPaths {
  /**
   * backend defines the referenced service endpoint to which the traffic
   * will be forwarded to.
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPaths#backend
   */
  readonly backend: VmAuthSpecIngressExtraRulesHttpPathsBackend;

  /**
   * path is matched against the path of an incoming request. Currently it can
   * contain characters disallowed from the conventional "path" part of a URL
   * as defined by RFC 3986. Paths must begin with a '/' and must be present
   * when using PathType with value "Exact" or "Prefix".
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPaths#path
   */
  readonly path?: string;

  /**
   * pathType determines the interpretation of the path matching. PathType can
   * be one of the following values:
   * * Exact: Matches the URL path exactly.
   * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
   * done on a path element by element basis. A path element refers is the
   * list of labels in the path split by the '/' separator. A request is a
   * match for path p if every p is an element-wise prefix of p of the
   * request path. Note that if the last element of the path is a substring
   * of the last element in request path, it is not a match (e.g. /foo/bar
   * matches /foo/bar/baz, but does not match /foo/barbaz).
   * * ImplementationSpecific: Interpretation of the Path matching is up to
   * the IngressClass. Implementations can treat this as a separate PathType
   * or treat it identically to Prefix or Exact path types.
   * Implementations are required to support all path types.
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPaths#pathType
   */
  readonly pathType: string;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttpPaths' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttpPaths(obj: VmAuthSpecIngressExtraRulesHttpPaths | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backend': toJson_VmAuthSpecIngressExtraRulesHttpPathsBackend(obj.backend),
    'path': obj.path,
    'pathType': obj.pathType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret
 */
export interface VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret(obj: VmAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * backend defines the referenced service endpoint to which the traffic
 * will be forwarded to.
 *
 * @schema VmAuthSpecIngressExtraRulesHttpPathsBackend
 */
export interface VmAuthSpecIngressExtraRulesHttpPathsBackend {
  /**
   * resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackend#resource
   */
  readonly resource?: VmAuthSpecIngressExtraRulesHttpPathsBackendResource;

  /**
   * service references a service as a backend.
   * This is a mutually exclusive setting with "Resource".
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackend#service
   */
  readonly service?: VmAuthSpecIngressExtraRulesHttpPathsBackendService;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttpPathsBackend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttpPathsBackend(obj: VmAuthSpecIngressExtraRulesHttpPathsBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendResource(obj.resource),
    'service': toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resource is an ObjectRef to another Kubernetes resource in the namespace
 * of the Ingress object. If resource is specified, a service.Name and
 * service.Port must not be specified.
 * This is a mutually exclusive setting with "Service".
 *
 * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendResource
 */
export interface VmAuthSpecIngressExtraRulesHttpPathsBackendResource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendResource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendResource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendResource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttpPathsBackendResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendResource(obj: VmAuthSpecIngressExtraRulesHttpPathsBackendResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * service references a service as a backend.
 * This is a mutually exclusive setting with "Resource".
 *
 * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendService
 */
export interface VmAuthSpecIngressExtraRulesHttpPathsBackendService {
  /**
   * name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendService#name
   */
  readonly name: string;

  /**
   * port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendService#port
   */
  readonly port?: VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttpPathsBackendService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendService(obj: VmAuthSpecIngressExtraRulesHttpPathsBackendService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * port of the referenced service. A port name or port number
 * is required for a IngressServiceBackend.
 *
 * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort
 */
export interface VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort {
  /**
   * name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort#name
   */
  readonly name?: string;

  /**
   * number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   *
   * @schema VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort(obj: VmAuthSpecIngressExtraRulesHttpPathsBackendServicePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMCluster is fast, cost-effective and scalable time-series database.
Cluster version with
 *
 * @schema VMCluster
 */
export class VmCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMCluster',
  }

  /**
   * Renders a Kubernetes manifest for "VMCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmClusterProps): any {
    return {
      ...VmCluster.GVK,
      ...toJson_VmClusterProps(props),
    };
  }

  /**
   * Defines a "VMCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmClusterProps) {
    super(scope, id, {
      ...VmCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmCluster.GVK,
      ...toJson_VmClusterProps(resolved),
    };
  }
}

/**
 * VMCluster is fast, cost-effective and scalable time-series database.
 * Cluster version with
 *
 * @schema VMCluster
 */
export interface VmClusterProps {
  /**
   * @schema VMCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMClusterSpec defines the desired state of VMCluster
   *
   * @schema VMCluster#spec
   */
  readonly spec: VmClusterSpec;

}

/**
 * Converts an object of type 'VmClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterProps(obj: VmClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMClusterSpec defines the desired state of VMCluster
 *
 * @schema VmClusterSpec
 */
export interface VmClusterSpec {
  /**
   * ClusterDomainName defines domain name suffix for in-cluster dns addresses
   * aka .cluster.local
   * used by vminsert and vmselect to build vmstorage address
   *
   * @schema VmClusterSpec#clusterDomainName
   */
  readonly clusterDomainName?: string;

  /**
   * ClusterVersion defines default images tag for all components.
   * it can be overwritten with component specific image.tag value.
   *
   * @schema VmClusterSpec#clusterVersion
   */
  readonly clusterVersion?: string;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmClusterSpecImagePullSecrets[];

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmClusterSpec#license
   */
  readonly license?: VmClusterSpecLicense;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmClusterSpec#managedMetadata
   */
  readonly managedMetadata?: VmClusterSpecManagedMetadata;

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmClusterSpec#paused
   */
  readonly paused?: boolean;

  /**
   * ReplicationFactor defines how many copies of data make among
   * distinct storage nodes
   *
   * @schema VmClusterSpec#replicationFactor
   */
  readonly replicationFactor?: number;

  /**
   * RequestsLoadBalancer configures load-balancing for vminsert and vmselect requests.
   * It helps to evenly spread load across pods.
   * Usually it's not possible with Kubernetes TCP-based services.
   * See more [here](https://docs.victoriametrics.com/operator/resources/vmcluster/#requests-load-balancing)
   *
   * @schema VmClusterSpec#requestsLoadBalancer
   */
  readonly requestsLoadBalancer?: VmClusterSpecRequestsLoadBalancer;

  /**
   * RetentionPeriod defines how long to retain stored metrics, specified as a duration (e.g., "1d", "1w", "1m").
   * Data with timestamps outside the RetentionPeriod is automatically deleted. The minimum allowed value is 1d, or 24h.
   * The default value is 1 (one month).
   * See [retention](https://docs.victoriametrics.com/victoriametrics/single-server-victoriametrics/#retention) docs for details.
   *
   * @schema VmClusterSpec#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the
   * VMSelect, VMStorage and VMInsert Pods.
   *
   * @schema VmClusterSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmClusterSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * @schema VmClusterSpec#vminsert
   */
  readonly vminsert?: VmClusterSpecVminsert;

  /**
   * VMSelect defines configuration section for vmselect components of the victoria-metrics cluster
   *
   * @schema VmClusterSpec#vmselect
   */
  readonly vmselect?: VmClusterSpecVmselect;

  /**
   * @schema VmClusterSpec#vmstorage
   */
  readonly vmstorage?: VmClusterSpecVmstorage;

}

/**
 * Converts an object of type 'VmClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpec(obj: VmClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterDomainName': obj.clusterDomainName,
    'clusterVersion': obj.clusterVersion,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmClusterSpecImagePullSecrets(y)),
    'license': toJson_VmClusterSpecLicense(obj.license),
    'managedMetadata': toJson_VmClusterSpecManagedMetadata(obj.managedMetadata),
    'paused': obj.paused,
    'replicationFactor': obj.replicationFactor,
    'requestsLoadBalancer': toJson_VmClusterSpecRequestsLoadBalancer(obj.requestsLoadBalancer),
    'retentionPeriod': obj.retentionPeriod,
    'serviceAccountName': obj.serviceAccountName,
    'useStrictSecurity': obj.useStrictSecurity,
    'vminsert': toJson_VmClusterSpecVminsert(obj.vminsert),
    'vmselect': toJson_VmClusterSpecVmselect(obj.vmselect),
    'vmstorage': toJson_VmClusterSpecVmstorage(obj.vmstorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmClusterSpecImagePullSecrets
 */
export interface VmClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecImagePullSecrets(obj: VmClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmClusterSpecLicense
 */
export interface VmClusterSpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmClusterSpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmClusterSpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmClusterSpecLicense#keyRef
   */
  readonly keyRef?: VmClusterSpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmClusterSpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmClusterSpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecLicense(obj: VmClusterSpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmClusterSpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmClusterSpecManagedMetadata
 */
export interface VmClusterSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmClusterSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecManagedMetadata(obj: VmClusterSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestsLoadBalancer configures load-balancing for vminsert and vmselect requests.
 * It helps to evenly spread load across pods.
 * Usually it's not possible with Kubernetes TCP-based services.
 * See more [here](https://docs.victoriametrics.com/operator/resources/vmcluster/#requests-load-balancing)
 *
 * @schema VmClusterSpecRequestsLoadBalancer
 */
export interface VmClusterSpecRequestsLoadBalancer {
  /**
   * @schema VmClusterSpecRequestsLoadBalancer#disableInsertBalancing
   */
  readonly disableInsertBalancing?: boolean;

  /**
   * @schema VmClusterSpecRequestsLoadBalancer#disableSelectBalancing
   */
  readonly disableSelectBalancing?: boolean;

  /**
   * @schema VmClusterSpecRequestsLoadBalancer#enabled
   */
  readonly enabled?: boolean;

  /**
   * VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer
   * for VMCluster component
   *
   * @schema VmClusterSpecRequestsLoadBalancer#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'VmClusterSpecRequestsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecRequestsLoadBalancer(obj: VmClusterSpecRequestsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableInsertBalancing': obj.disableInsertBalancing,
    'disableSelectBalancing': obj.disableSelectBalancing,
    'enabled': obj.enabled,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVminsert
 */
export interface VmClusterSpecVminsert {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmClusterSpecVminsert#affinity
   */
  readonly affinity?: any;

  /**
   * ClusterNativePort for multi-level cluster setup.
   * More [details](https://docs.victoriametrics.com/victoriametrics/cluster-victoriametrics/#multi-level-cluster-setup)
   *
   * @schema VmClusterSpecVminsert#clusterNativeListenPort
   */
  readonly clusterNativeListenPort?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmClusterSpecVminsert#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmClusterSpecVminsert#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmClusterSpecVminsert#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmClusterSpecVminsert#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmClusterSpecVminsert#dnsConfig
   */
  readonly dnsConfig?: VmClusterSpecVminsertDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmClusterSpecVminsert#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmClusterSpecVminsert#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmClusterSpecVminsert#extraEnvs
   */
  readonly extraEnvs?: VmClusterSpecVminsertExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmClusterSpecVminsert#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmClusterSpecVminsertExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmClusterSpecVminsert#hostAliases
   */
  readonly hostAliases?: VmClusterSpecVminsertHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmClusterSpecVminsert#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * HPA defines kubernetes PodAutoScaling configuration version 2.
   *
   * @schema VmClusterSpecVminsert#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmClusterSpecVminsert#image
   */
  readonly image?: VmClusterSpecVminsertImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmClusterSpecVminsert#imagePullSecrets
   */
  readonly imagePullSecrets?: VmClusterSpecVminsertImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmClusterSpecVminsert#initContainers
   */
  readonly initContainers?: any[];

  /**
   * InsertPorts - additional listen ports for data ingestion.
   *
   * @schema VmClusterSpecVminsert#insertPorts
   */
  readonly insertPorts?: VmClusterSpecVminsertInsertPorts;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVminsert#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMInsert to be configured with.
   * default or json
   *
   * @schema VmClusterSpecVminsert#logFormat
   */
  readonly logFormat?: VmClusterSpecVminsertLogFormat;

  /**
   * LogLevel for VMInsert to be configured with.
   *
   * @schema VmClusterSpecVminsert#logLevel
   */
  readonly logLevel?: VmClusterSpecVminsertLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmClusterSpecVminsert#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmClusterSpecVminsert#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmClusterSpecVminsert#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmClusterSpecVminsert#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmClusterSpecVminsertPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMInsert pods.
   *
   * @schema VmClusterSpecVminsert#podMetadata
   */
  readonly podMetadata?: VmClusterSpecVminsertPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmClusterSpecVminsert#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmClusterSpecVminsert#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmClusterSpecVminsert#readinessGates
   */
  readonly readinessGates?: VmClusterSpecVminsertReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVminsert#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmClusterSpecVminsert#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmClusterSpecVminsert#resources
   */
  readonly resources?: VmClusterSpecVminsertResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmClusterSpecVminsert#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VmClusterSpecVminsert#rollingUpdate
   */
  readonly rollingUpdate?: VmClusterSpecVminsertRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmClusterSpecVminsert#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmClusterSpecVminsert#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmClusterSpecVminsert#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmClusterSpecVminsert#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vminsert VMServiceScrape spec
   *
   * @schema VmClusterSpecVminsert#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vminsert service spec
   *
   * @schema VmClusterSpecVminsert#serviceSpec
   */
  readonly serviceSpec?: VmClusterSpecVminsertServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmClusterSpecVminsert#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmClusterSpecVminsert#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmClusterSpecVminsert#tolerations
   */
  readonly tolerations?: VmClusterSpecVminsertTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmClusterSpecVminsert#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VmClusterSpecVminsert#updateStrategy
   */
  readonly updateStrategy?: VmClusterSpecVminsertUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmClusterSpecVminsert#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmClusterSpecVminsert#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmClusterSpecVminsert#volumeMounts
   */
  readonly volumeMounts?: VmClusterSpecVminsertVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmClusterSpecVminsert#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmClusterSpecVminsert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsert(obj: VmClusterSpecVminsert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'clusterNativeListenPort': obj.clusterNativeListenPort,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmClusterSpecVminsertDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmClusterSpecVminsertExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmClusterSpecVminsertExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmClusterSpecVminsertHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VmClusterSpecVminsertImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmClusterSpecVminsertImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'insertPorts': toJson_VmClusterSpecVminsertInsertPorts(obj.insertPorts),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VmClusterSpecVminsertPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmClusterSpecVminsertPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmClusterSpecVminsertReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmClusterSpecVminsertResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VmClusterSpecVminsertRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmClusterSpecVminsertServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmClusterSpecVminsertTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmClusterSpecVminsertVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMSelect defines configuration section for vmselect components of the victoria-metrics cluster
 *
 * @schema VmClusterSpecVmselect
 */
export interface VmClusterSpecVmselect {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmClusterSpecVmselect#affinity
   */
  readonly affinity?: any;

  /**
   * CacheMountPath allows to add cache persistent for VMSelect,
   * will use "/cache" as default if not specified.
   *
   * @schema VmClusterSpecVmselect#cacheMountPath
   */
  readonly cacheMountPath?: string;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
   *
   * @schema VmClusterSpecVmselect#claimTemplates
   */
  readonly claimTemplates?: any[];

  /**
   * ClusterNativePort for multi-level cluster setup.
   * More [details](https://docs.victoriametrics.com/victoriametrics/cluster-victoriametrics/#multi-level-cluster-setup)
   *
   * @schema VmClusterSpecVmselect#clusterNativeListenPort
   */
  readonly clusterNativeListenPort?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmClusterSpecVmselect#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmClusterSpecVmselect#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmClusterSpecVmselect#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmClusterSpecVmselect#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmClusterSpecVmselect#dnsConfig
   */
  readonly dnsConfig?: VmClusterSpecVmselectDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmClusterSpecVmselect#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmClusterSpecVmselect#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmClusterSpecVmselect#extraEnvs
   */
  readonly extraEnvs?: VmClusterSpecVmselectExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmClusterSpecVmselect#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmClusterSpecVmselectExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmClusterSpecVmselect#hostAliases
   */
  readonly hostAliases?: VmClusterSpecVmselectHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmClusterSpecVmselect#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Configures horizontal pod autoscaling.
   * Note, enabling this option disables vmselect to vmselect communication. In most cases it's not an issue.
   *
   * @schema VmClusterSpecVmselect#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmClusterSpecVmselect#image
   */
  readonly image?: VmClusterSpecVmselectImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmClusterSpecVmselect#imagePullSecrets
   */
  readonly imagePullSecrets?: VmClusterSpecVmselectImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmClusterSpecVmselect#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVmselect#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMSelect to be configured with.
   * default or json
   *
   * @schema VmClusterSpecVmselect#logFormat
   */
  readonly logFormat?: VmClusterSpecVmselectLogFormat;

  /**
   * LogLevel for VMSelect to be configured with.
   *
   * @schema VmClusterSpecVmselect#logLevel
   */
  readonly logLevel?: VmClusterSpecVmselectLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmClusterSpecVmselect#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmClusterSpecVmselect#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmClusterSpecVmselect#paused
   */
  readonly paused?: boolean;

  /**
   * Storage - add persistent volume for cacheMountPath
   * its useful for persistent cache
   * use storage instead of persistentVolume.
   *
   * @schema VmClusterSpecVmselect#persistentVolume
   */
  readonly persistentVolume?: VmClusterSpecVmselectPersistentVolume;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VmClusterSpecVmselect#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmClusterSpecVmselect#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmClusterSpecVmselectPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMSelect pods.
   *
   * @schema VmClusterSpecVmselect#podMetadata
   */
  readonly podMetadata?: VmClusterSpecVmselectPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmClusterSpecVmselect#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmClusterSpecVmselect#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmClusterSpecVmselect#readinessGates
   */
  readonly readinessGates?: VmClusterSpecVmselectReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVmselect#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmClusterSpecVmselect#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmClusterSpecVmselect#resources
   */
  readonly resources?: VmClusterSpecVmselectResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmClusterSpecVmselect#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy defines strategy for application updates
   * Default is OnDelete, in this case operator handles update process
   * Can be changed for RollingUpdate
   *
   * @default OnDelete, in this case operator handles update process
   * @schema VmClusterSpecVmselect#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
   * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
   *
   * @schema VmClusterSpecVmselect#rollingUpdateStrategyBehavior
   */
  readonly rollingUpdateStrategyBehavior?: VmClusterSpecVmselectRollingUpdateStrategyBehavior;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmClusterSpecVmselect#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmClusterSpecVmselect#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmClusterSpecVmselect#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmClusterSpecVmselect#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vmselect VMServiceScrape spec
   *
   * @schema VmClusterSpecVmselect#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmselect service spec
   *
   * @schema VmClusterSpecVmselect#serviceSpec
   */
  readonly serviceSpec?: VmClusterSpecVmselectServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmClusterSpecVmselect#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * StorageSpec - add persistent volume claim for cacheMountPath
   * its needed for persistent cache
   *
   * @schema VmClusterSpecVmselect#storage
   */
  readonly storage?: VmClusterSpecVmselectStorage;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmClusterSpecVmselect#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmClusterSpecVmselect#tolerations
   */
  readonly tolerations?: VmClusterSpecVmselectTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmClusterSpecVmselect#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmClusterSpecVmselect#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmClusterSpecVmselect#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmClusterSpecVmselect#volumeMounts
   */
  readonly volumeMounts?: VmClusterSpecVmselectVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmClusterSpecVmselect#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmClusterSpecVmselect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselect(obj: VmClusterSpecVmselect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'cacheMountPath': obj.cacheMountPath,
    'claimTemplates': obj.claimTemplates?.map(y => y),
    'clusterNativeListenPort': obj.clusterNativeListenPort,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmClusterSpecVmselectDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmClusterSpecVmselectExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmClusterSpecVmselectExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmClusterSpecVmselectHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VmClusterSpecVmselectImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmClusterSpecVmselectImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolume': toJson_VmClusterSpecVmselectPersistentVolume(obj.persistentVolume),
    'persistentVolumeClaimRetentionPolicy': toJson_VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VmClusterSpecVmselectPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmClusterSpecVmselectPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmClusterSpecVmselectReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmClusterSpecVmselectResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'rollingUpdateStrategyBehavior': toJson_VmClusterSpecVmselectRollingUpdateStrategyBehavior(obj.rollingUpdateStrategyBehavior),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmClusterSpecVmselectServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VmClusterSpecVmselectStorage(obj.storage),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmClusterSpecVmselectTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmClusterSpecVmselectVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmstorage
 */
export interface VmClusterSpecVmstorage {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmClusterSpecVmstorage#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
   *
   * @schema VmClusterSpecVmstorage#claimTemplates
   */
  readonly claimTemplates?: any[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmClusterSpecVmstorage#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmClusterSpecVmstorage#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmClusterSpecVmstorage#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmClusterSpecVmstorage#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmClusterSpecVmstorage#dnsConfig
   */
  readonly dnsConfig?: VmClusterSpecVmstorageDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmClusterSpecVmstorage#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmClusterSpecVmstorage#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmClusterSpecVmstorage#extraEnvs
   */
  readonly extraEnvs?: VmClusterSpecVmstorageExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmClusterSpecVmstorage#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmClusterSpecVmstorageExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmClusterSpecVmstorage#hostAliases
   */
  readonly hostAliases?: VmClusterSpecVmstorageHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmClusterSpecVmstorage#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmClusterSpecVmstorage#image
   */
  readonly image?: VmClusterSpecVmstorageImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmClusterSpecVmstorage#imagePullSecrets
   */
  readonly imagePullSecrets?: VmClusterSpecVmstorageImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmClusterSpecVmstorage#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVmstorage#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMStorage to be configured with.
   * default or json
   *
   * @schema VmClusterSpecVmstorage#logFormat
   */
  readonly logFormat?: VmClusterSpecVmstorageLogFormat;

  /**
   * LogLevel for VMStorage to be configured with.
   *
   * @schema VmClusterSpecVmstorage#logLevel
   */
  readonly logLevel?: VmClusterSpecVmstorageLogLevel;

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   * lets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].
   * Useful at storage expanding, when you want to rebalance some data at cluster.
   *
   * @schema VmClusterSpecVmstorage#maintenanceInsertNodeIDs
   */
  readonly maintenanceInsertNodeIDs?: number[];

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   *
   * @schema VmClusterSpecVmstorage#maintenanceSelectNodeIDs
   */
  readonly maintenanceSelectNodeIDs?: number[];

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmClusterSpecVmstorage#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmClusterSpecVmstorage#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmClusterSpecVmstorage#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VmClusterSpecVmstorage#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VmClusterSpecVmstorage#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VmClusterSpecVmstoragePodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMStorage pods.
   *
   * @schema VmClusterSpecVmstorage#podMetadata
   */
  readonly podMetadata?: VmClusterSpecVmstoragePodMetadata;

  /**
   * Port listen address
   *
   * @schema VmClusterSpecVmstorage#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmClusterSpecVmstorage#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmClusterSpecVmstorage#readinessGates
   */
  readonly readinessGates?: VmClusterSpecVmstorageReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmClusterSpecVmstorage#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmClusterSpecVmstorage#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmClusterSpecVmstorage#resources
   */
  readonly resources?: VmClusterSpecVmstorageResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmClusterSpecVmstorage#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy defines strategy for application updates
   * Default is OnDelete, in this case operator handles update process
   * Can be changed for RollingUpdate
   *
   * @default OnDelete, in this case operator handles update process
   * @schema VmClusterSpecVmstorage#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
   * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
   *
   * @schema VmClusterSpecVmstorage#rollingUpdateStrategyBehavior
   */
  readonly rollingUpdateStrategyBehavior?: VmClusterSpecVmstorageRollingUpdateStrategyBehavior;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmClusterSpecVmstorage#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmClusterSpecVmstorage#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmClusterSpecVmstorage#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmClusterSpecVmstorage#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vmstorage VMServiceScrape spec
   *
   * @schema VmClusterSpecVmstorage#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be create additional service for vmstorage
   *
   * @schema VmClusterSpecVmstorage#serviceSpec
   */
  readonly serviceSpec?: VmClusterSpecVmstorageServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmClusterSpecVmstorage#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage - add persistent volume for StorageDataPath
   * its useful for persistent cache
   *
   * @schema VmClusterSpecVmstorage#storage
   */
  readonly storage?: VmClusterSpecVmstorageStorage;

  /**
   * StorageDataPath - path to storage data
   *
   * @schema VmClusterSpecVmstorage#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmClusterSpecVmstorage#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmClusterSpecVmstorage#tolerations
   */
  readonly tolerations?: VmClusterSpecVmstorageTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmClusterSpecVmstorage#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmClusterSpecVmstorage#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmClusterSpecVmstorage#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VMBackup configuration for backup
   *
   * @schema VmClusterSpecVmstorage#vmBackup
   */
  readonly vmBackup?: VmClusterSpecVmstorageVmBackup;

  /**
   * VMInsertPort for VMInsert connections
   *
   * @schema VmClusterSpecVmstorage#vmInsertPort
   */
  readonly vmInsertPort?: string;

  /**
   * VMSelectPort for VMSelect connections
   *
   * @schema VmClusterSpecVmstorage#vmSelectPort
   */
  readonly vmSelectPort?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmClusterSpecVmstorage#volumeMounts
   */
  readonly volumeMounts?: VmClusterSpecVmstorageVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmClusterSpecVmstorage#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmClusterSpecVmstorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorage(obj: VmClusterSpecVmstorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => y),
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmClusterSpecVmstorageDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmClusterSpecVmstorageExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmClusterSpecVmstorageExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmClusterSpecVmstorageHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmClusterSpecVmstorageImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmClusterSpecVmstorageImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'maintenanceInsertNodeIDs': obj.maintenanceInsertNodeIDs?.map(y => y),
    'maintenanceSelectNodeIDs': obj.maintenanceSelectNodeIDs?.map(y => y),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VmClusterSpecVmstoragePodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VmClusterSpecVmstoragePodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmClusterSpecVmstorageReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmClusterSpecVmstorageResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'rollingUpdateStrategyBehavior': toJson_VmClusterSpecVmstorageRollingUpdateStrategyBehavior(obj.rollingUpdateStrategyBehavior),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmClusterSpecVmstorageServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VmClusterSpecVmstorageStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmClusterSpecVmstorageTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'vmBackup': toJson_VmClusterSpecVmstorageVmBackup(obj.vmBackup),
    'vmInsertPort': obj.vmInsertPort,
    'vmSelectPort': obj.vmSelectPort,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmClusterSpecVmstorageVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmClusterSpecLicenseKeyRef
 */
export interface VmClusterSpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmClusterSpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmClusterSpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecLicenseKeyRef(obj: VmClusterSpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmClusterSpecVminsertDnsConfig
 */
export interface VmClusterSpecVminsertDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmClusterSpecVminsertDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmClusterSpecVminsertDnsConfig#options
   */
  readonly options?: VmClusterSpecVminsertDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmClusterSpecVminsertDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmClusterSpecVminsertDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertDnsConfig(obj: VmClusterSpecVminsertDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmClusterSpecVminsertDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmClusterSpecVminsertExtraEnvs
 */
export interface VmClusterSpecVminsertExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVminsertExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmClusterSpecVminsertExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertExtraEnvs(obj: VmClusterSpecVminsertExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmClusterSpecVminsertExtraEnvsFrom
 */
export interface VmClusterSpecVminsertExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmClusterSpecVminsertExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmClusterSpecVminsertExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVminsertExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmClusterSpecVminsertExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmClusterSpecVminsertExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertExtraEnvsFrom(obj: VmClusterSpecVminsertExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmClusterSpecVminsertExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmClusterSpecVminsertExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmClusterSpecVminsertHostAliases
 */
export interface VmClusterSpecVminsertHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmClusterSpecVminsertHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmClusterSpecVminsertHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertHostAliases(obj: VmClusterSpecVminsertHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmClusterSpecVminsertImage
 */
export interface VmClusterSpecVminsertImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmClusterSpecVminsertImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmClusterSpecVminsertImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmClusterSpecVminsertImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertImage(obj: VmClusterSpecVminsertImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmClusterSpecVminsertImagePullSecrets
 */
export interface VmClusterSpecVminsertImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVminsertImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertImagePullSecrets(obj: VmClusterSpecVminsertImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InsertPorts - additional listen ports for data ingestion.
 *
 * @schema VmClusterSpecVminsertInsertPorts
 */
export interface VmClusterSpecVminsertInsertPorts {
  /**
   * GraphitePort listen port
   *
   * @schema VmClusterSpecVminsertInsertPorts#graphitePort
   */
  readonly graphitePort?: string;

  /**
   * InfluxPort listen port
   *
   * @schema VmClusterSpecVminsertInsertPorts#influxPort
   */
  readonly influxPort?: string;

  /**
   * OpenTSDBHTTPPort for http connections.
   *
   * @schema VmClusterSpecVminsertInsertPorts#openTSDBHTTPPort
   */
  readonly openTsdbhttpPort?: string;

  /**
   * OpenTSDBPort for tcp and udp listen
   *
   * @schema VmClusterSpecVminsertInsertPorts#openTSDBPort
   */
  readonly openTsdbPort?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertInsertPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertInsertPorts(obj: VmClusterSpecVminsertInsertPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'graphitePort': obj.graphitePort,
    'influxPort': obj.influxPort,
    'openTSDBHTTPPort': obj.openTsdbhttpPort,
    'openTSDBPort': obj.openTsdbPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMInsert to be configured with.
 * default or json
 *
 * @schema VmClusterSpecVminsertLogFormat
 */
export enum VmClusterSpecVminsertLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMInsert to be configured with.
 *
 * @schema VmClusterSpecVminsertLogLevel
 */
export enum VmClusterSpecVminsertLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmClusterSpecVminsertPodDisruptionBudget
 */
export interface VmClusterSpecVminsertPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmClusterSpecVminsertPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmClusterSpecVminsertPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmClusterSpecVminsertPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmClusterSpecVminsertPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmClusterSpecVminsertPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertPodDisruptionBudget(obj: VmClusterSpecVminsertPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMInsert pods.
 *
 * @schema VmClusterSpecVminsertPodMetadata
 */
export interface VmClusterSpecVminsertPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVminsertPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVminsertPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVminsertPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertPodMetadata(obj: VmClusterSpecVminsertPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmClusterSpecVminsertReadinessGates
 */
export interface VmClusterSpecVminsertReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmClusterSpecVminsertReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertReadinessGates(obj: VmClusterSpecVminsertReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmClusterSpecVminsertResources
 */
export interface VmClusterSpecVminsertResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmClusterSpecVminsertResources#claims
   */
  readonly claims?: VmClusterSpecVminsertResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVminsertResources#limits
   */
  readonly limits?: { [key: string]: VmClusterSpecVminsertResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVminsertResources#requests
   */
  readonly requests?: { [key: string]: VmClusterSpecVminsertResourcesRequests };

}

/**
 * Converts an object of type 'VmClusterSpecVminsertResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertResources(obj: VmClusterSpecVminsertResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmClusterSpecVminsertResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VmClusterSpecVminsertRollingUpdate
 */
export interface VmClusterSpecVminsertRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VmClusterSpecVminsertRollingUpdate#maxSurge
   */
  readonly maxSurge?: VmClusterSpecVminsertRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VmClusterSpecVminsertRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVminsertRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertRollingUpdate(obj: VmClusterSpecVminsertRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vminsert service spec
 *
 * @schema VmClusterSpecVminsertServiceSpec
 */
export interface VmClusterSpecVminsertServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmClusterSpecVminsertServiceSpec#metadata
   */
  readonly metadata?: VmClusterSpecVminsertServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmClusterSpecVminsertServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmClusterSpecVminsertServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertServiceSpec(obj: VmClusterSpecVminsertServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmClusterSpecVminsertServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmClusterSpecVminsertTolerations
 */
export interface VmClusterSpecVminsertTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmClusterSpecVminsertTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmClusterSpecVminsertTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmClusterSpecVminsertTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmClusterSpecVminsertTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmClusterSpecVminsertTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertTolerations(obj: VmClusterSpecVminsertTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VmClusterSpecVminsertUpdateStrategy
 */
export enum VmClusterSpecVminsertUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmClusterSpecVminsertVolumeMounts
 */
export interface VmClusterSpecVminsertVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmClusterSpecVminsertVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmClusterSpecVminsertVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmClusterSpecVminsertVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmClusterSpecVminsertVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmClusterSpecVminsertVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmClusterSpecVminsertVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmClusterSpecVminsertVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertVolumeMounts(obj: VmClusterSpecVminsertVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmClusterSpecVmselectDnsConfig
 */
export interface VmClusterSpecVmselectDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmClusterSpecVmselectDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmClusterSpecVmselectDnsConfig#options
   */
  readonly options?: VmClusterSpecVmselectDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmClusterSpecVmselectDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmClusterSpecVmselectDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectDnsConfig(obj: VmClusterSpecVmselectDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmClusterSpecVmselectDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmClusterSpecVmselectExtraEnvs
 */
export interface VmClusterSpecVmselectExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmselectExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmClusterSpecVmselectExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectExtraEnvs(obj: VmClusterSpecVmselectExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmClusterSpecVmselectExtraEnvsFrom
 */
export interface VmClusterSpecVmselectExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmClusterSpecVmselectExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmClusterSpecVmselectExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmselectExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmClusterSpecVmselectExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmClusterSpecVmselectExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectExtraEnvsFrom(obj: VmClusterSpecVmselectExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmClusterSpecVmselectExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmClusterSpecVmselectExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmClusterSpecVmselectHostAliases
 */
export interface VmClusterSpecVmselectHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmClusterSpecVmselectHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmClusterSpecVmselectHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectHostAliases(obj: VmClusterSpecVmselectHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmClusterSpecVmselectImage
 */
export interface VmClusterSpecVmselectImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmClusterSpecVmselectImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmClusterSpecVmselectImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmClusterSpecVmselectImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectImage(obj: VmClusterSpecVmselectImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmClusterSpecVmselectImagePullSecrets
 */
export interface VmClusterSpecVmselectImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmselectImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectImagePullSecrets(obj: VmClusterSpecVmselectImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMSelect to be configured with.
 * default or json
 *
 * @schema VmClusterSpecVmselectLogFormat
 */
export enum VmClusterSpecVmselectLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMSelect to be configured with.
 *
 * @schema VmClusterSpecVmselectLogLevel
 */
export enum VmClusterSpecVmselectLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * Storage - add persistent volume for cacheMountPath
 * its useful for persistent cache
 * use storage instead of persistentVolume.
 *
 * @schema VmClusterSpecVmselectPersistentVolume
 */
export interface VmClusterSpecVmselectPersistentVolume {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmClusterSpecVmselectPersistentVolume#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmClusterSpecVmselectPersistentVolume#emptyDir
   */
  readonly emptyDir?: VmClusterSpecVmselectPersistentVolumeEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmClusterSpecVmselectPersistentVolume#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: any;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectPersistentVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectPersistentVolume(obj: VmClusterSpecVmselectPersistentVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmClusterSpecVmselectPersistentVolumeEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': obj.volumeClaimTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy
 */
export interface VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy(obj: VmClusterSpecVmselectPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmClusterSpecVmselectPodDisruptionBudget
 */
export interface VmClusterSpecVmselectPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmClusterSpecVmselectPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmClusterSpecVmselectPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmClusterSpecVmselectPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmClusterSpecVmselectPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmClusterSpecVmselectPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectPodDisruptionBudget(obj: VmClusterSpecVmselectPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMSelect pods.
 *
 * @schema VmClusterSpecVmselectPodMetadata
 */
export interface VmClusterSpecVmselectPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVmselectPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVmselectPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVmselectPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectPodMetadata(obj: VmClusterSpecVmselectPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmClusterSpecVmselectReadinessGates
 */
export interface VmClusterSpecVmselectReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmClusterSpecVmselectReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectReadinessGates(obj: VmClusterSpecVmselectReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmClusterSpecVmselectResources
 */
export interface VmClusterSpecVmselectResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmClusterSpecVmselectResources#claims
   */
  readonly claims?: VmClusterSpecVmselectResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmselectResources#limits
   */
  readonly limits?: { [key: string]: VmClusterSpecVmselectResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmselectResources#requests
   */
  readonly requests?: { [key: string]: VmClusterSpecVmselectResourcesRequests };

}

/**
 * Converts an object of type 'VmClusterSpecVmselectResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectResources(obj: VmClusterSpecVmselectResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmClusterSpecVmselectResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
 * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
 *
 * @schema VmClusterSpecVmselectRollingUpdateStrategyBehavior
 */
export interface VmClusterSpecVmselectRollingUpdateStrategyBehavior {
  /**
   * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
   * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
   * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
   *
   * @schema VmClusterSpecVmselectRollingUpdateStrategyBehavior#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectRollingUpdateStrategyBehavior' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectRollingUpdateStrategyBehavior(obj: VmClusterSpecVmselectRollingUpdateStrategyBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmselect service spec
 *
 * @schema VmClusterSpecVmselectServiceSpec
 */
export interface VmClusterSpecVmselectServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmClusterSpecVmselectServiceSpec#metadata
   */
  readonly metadata?: VmClusterSpecVmselectServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmClusterSpecVmselectServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmClusterSpecVmselectServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectServiceSpec(obj: VmClusterSpecVmselectServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmClusterSpecVmselectServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StorageSpec - add persistent volume claim for cacheMountPath
 * its needed for persistent cache
 *
 * @schema VmClusterSpecVmselectStorage
 */
export interface VmClusterSpecVmselectStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmClusterSpecVmselectStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmClusterSpecVmselectStorage#emptyDir
   */
  readonly emptyDir?: VmClusterSpecVmselectStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmClusterSpecVmselectStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: VmClusterSpecVmselectStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorage(obj: VmClusterSpecVmselectStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmClusterSpecVmselectStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmClusterSpecVmselectTolerations
 */
export interface VmClusterSpecVmselectTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmClusterSpecVmselectTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmClusterSpecVmselectTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmClusterSpecVmselectTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmClusterSpecVmselectTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmClusterSpecVmselectTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectTolerations(obj: VmClusterSpecVmselectTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmClusterSpecVmselectVolumeMounts
 */
export interface VmClusterSpecVmselectVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmClusterSpecVmselectVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmClusterSpecVmselectVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmClusterSpecVmselectVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmClusterSpecVmselectVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmClusterSpecVmselectVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmClusterSpecVmselectVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmClusterSpecVmselectVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectVolumeMounts(obj: VmClusterSpecVmselectVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmClusterSpecVmstorageDnsConfig
 */
export interface VmClusterSpecVmstorageDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmClusterSpecVmstorageDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmClusterSpecVmstorageDnsConfig#options
   */
  readonly options?: VmClusterSpecVmstorageDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmClusterSpecVmstorageDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageDnsConfig(obj: VmClusterSpecVmstorageDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmClusterSpecVmstorageDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmClusterSpecVmstorageExtraEnvs
 */
export interface VmClusterSpecVmstorageExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmstorageExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmClusterSpecVmstorageExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageExtraEnvs(obj: VmClusterSpecVmstorageExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmClusterSpecVmstorageExtraEnvsFrom
 */
export interface VmClusterSpecVmstorageExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmClusterSpecVmstorageExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmClusterSpecVmstorageExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageExtraEnvsFrom(obj: VmClusterSpecVmstorageExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmClusterSpecVmstorageExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmClusterSpecVmstorageExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmClusterSpecVmstorageHostAliases
 */
export interface VmClusterSpecVmstorageHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmClusterSpecVmstorageHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmClusterSpecVmstorageHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageHostAliases(obj: VmClusterSpecVmstorageHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmClusterSpecVmstorageImage
 */
export interface VmClusterSpecVmstorageImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmClusterSpecVmstorageImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmClusterSpecVmstorageImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmClusterSpecVmstorageImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageImage(obj: VmClusterSpecVmstorageImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmClusterSpecVmstorageImagePullSecrets
 */
export interface VmClusterSpecVmstorageImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageImagePullSecrets(obj: VmClusterSpecVmstorageImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMStorage to be configured with.
 * default or json
 *
 * @schema VmClusterSpecVmstorageLogFormat
 */
export enum VmClusterSpecVmstorageLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMStorage to be configured with.
 *
 * @schema VmClusterSpecVmstorageLogLevel
 */
export enum VmClusterSpecVmstorageLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy
 */
export interface VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy(obj: VmClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VmClusterSpecVmstoragePodDisruptionBudget
 */
export interface VmClusterSpecVmstoragePodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VmClusterSpecVmstoragePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VmClusterSpecVmstoragePodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VmClusterSpecVmstoragePodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmClusterSpecVmstoragePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstoragePodDisruptionBudget(obj: VmClusterSpecVmstoragePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMStorage pods.
 *
 * @schema VmClusterSpecVmstoragePodMetadata
 */
export interface VmClusterSpecVmstoragePodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVmstoragePodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVmstoragePodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVmstoragePodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstoragePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstoragePodMetadata(obj: VmClusterSpecVmstoragePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmClusterSpecVmstorageReadinessGates
 */
export interface VmClusterSpecVmstorageReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmClusterSpecVmstorageReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageReadinessGates(obj: VmClusterSpecVmstorageReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmClusterSpecVmstorageResources
 */
export interface VmClusterSpecVmstorageResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmClusterSpecVmstorageResources#claims
   */
  readonly claims?: VmClusterSpecVmstorageResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmstorageResources#limits
   */
  readonly limits?: { [key: string]: VmClusterSpecVmstorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmstorageResources#requests
   */
  readonly requests?: { [key: string]: VmClusterSpecVmstorageResourcesRequests };

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageResources(obj: VmClusterSpecVmstorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmClusterSpecVmstorageResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
 * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
 *
 * @schema VmClusterSpecVmstorageRollingUpdateStrategyBehavior
 */
export interface VmClusterSpecVmstorageRollingUpdateStrategyBehavior {
  /**
   * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
   * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
   * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
   *
   * @schema VmClusterSpecVmstorageRollingUpdateStrategyBehavior#maxUnavailable
   */
  readonly maxUnavailable?: VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageRollingUpdateStrategyBehavior' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageRollingUpdateStrategyBehavior(obj: VmClusterSpecVmstorageRollingUpdateStrategyBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be create additional service for vmstorage
 *
 * @schema VmClusterSpecVmstorageServiceSpec
 */
export interface VmClusterSpecVmstorageServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmClusterSpecVmstorageServiceSpec#metadata
   */
  readonly metadata?: VmClusterSpecVmstorageServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmClusterSpecVmstorageServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmClusterSpecVmstorageServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageServiceSpec(obj: VmClusterSpecVmstorageServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmClusterSpecVmstorageServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage - add persistent volume for StorageDataPath
 * its useful for persistent cache
 *
 * @schema VmClusterSpecVmstorageStorage
 */
export interface VmClusterSpecVmstorageStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VmClusterSpecVmstorageStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VmClusterSpecVmstorageStorage#emptyDir
   */
  readonly emptyDir?: VmClusterSpecVmstorageStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VmClusterSpecVmstorageStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: any;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageStorage(obj: VmClusterSpecVmstorageStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VmClusterSpecVmstorageStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': obj.volumeClaimTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmClusterSpecVmstorageTolerations
 */
export interface VmClusterSpecVmstorageTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmClusterSpecVmstorageTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmClusterSpecVmstorageTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmClusterSpecVmstorageTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmClusterSpecVmstorageTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmClusterSpecVmstorageTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageTolerations(obj: VmClusterSpecVmstorageTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMBackup configuration for backup
 *
 * @schema VmClusterSpecVmstorageVmBackup
 */
export interface VmClusterSpecVmstorageVmBackup {
  /**
   * AcceptEULA accepts enterprise feature usage, must be set to true.
   * otherwise backupmanager cannot be added to single/cluster version.
   * https://victoriametrics.com/legal/esa/
   * Deprecated: use license.key or license.keyRef instead
   *
   * @schema VmClusterSpecVmstorageVmBackup#acceptEULA
   */
  readonly acceptEula?: boolean;

  /**
   * Defines number of concurrent workers. Higher concurrency may reduce backup duration (default 10)
   *
   * @schema VmClusterSpecVmstorageVmBackup#concurrency
   */
  readonly concurrency?: number;

  /**
   * CredentialsSecret is secret in the same namespace for access to remote storage
   * The secret is mounted into /etc/vm/creds.
   *
   * @schema VmClusterSpecVmstorageVmBackup#credentialsSecret
   */
  readonly credentialsSecret?: VmClusterSpecVmstorageVmBackupCredentialsSecret;

  /**
   * Custom S3 endpoint for use with S3-compatible storages (e.g. MinIO). S3 is used if not set
   *
   * @schema VmClusterSpecVmstorageVmBackup#customS3Endpoint
   */
  readonly customS3Endpoint?: string;

  /**
   * Defines destination for backup
   *
   * @schema VmClusterSpecVmstorageVmBackup#destination
   */
  readonly destination?: string;

  /**
   * DestinationDisableSuffixAdd - disables suffix adding for cluster version backups
   * each vmstorage backup must have unique backup folder
   * so operator adds POD_NAME as suffix for backup destination folder.
   *
   * @schema VmClusterSpecVmstorageVmBackup#destinationDisableSuffixAdd
   */
  readonly destinationDisableSuffixAdd?: boolean;

  /**
   * Defines if daily backups disabled (default false)
   *
   * @schema VmClusterSpecVmstorageVmBackup#disableDaily
   */
  readonly disableDaily?: boolean;

  /**
   * Defines if hourly backups disabled (default false)
   *
   * @schema VmClusterSpecVmstorageVmBackup#disableHourly
   */
  readonly disableHourly?: boolean;

  /**
   * Defines if monthly backups disabled (default false)
   *
   * @schema VmClusterSpecVmstorageVmBackup#disableMonthly
   */
  readonly disableMonthly?: boolean;

  /**
   * Defines if weekly backups disabled (default false)
   *
   * @schema VmClusterSpecVmstorageVmBackup#disableWeekly
   */
  readonly disableWeekly?: boolean;

  /**
   * extra args like maxBytesPerSecond default 0
   *
   * @schema VmClusterSpecVmstorageVmBackup#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * @schema VmClusterSpecVmstorageVmBackup#extraEnvs
   */
  readonly extraEnvs?: VmClusterSpecVmstorageVmBackupExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmClusterSpecVmstorageVmBackup#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmClusterSpecVmstorageVmBackupExtraEnvsFrom[];

  /**
   * Image - docker image settings for VMBackuper
   *
   * @schema VmClusterSpecVmstorageVmBackup#image
   */
  readonly image?: VmClusterSpecVmstorageVmBackupImage;

  /**
   * LogFormat for VMBackup to be configured with.
   * default or json
   *
   * @schema VmClusterSpecVmstorageVmBackup#logFormat
   */
  readonly logFormat?: VmClusterSpecVmstorageVmBackupLogFormat;

  /**
   * LogLevel for VMBackup to be configured with.
   *
   * @schema VmClusterSpecVmstorageVmBackup#logLevel
   */
  readonly logLevel?: VmClusterSpecVmstorageVmBackupLogLevel;

  /**
   * Port for health check connections
   *
   * @schema VmClusterSpecVmstorageVmBackup#port
   */
  readonly port?: string;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmClusterSpecVmstorageVmBackup#resources
   */
  readonly resources?: VmClusterSpecVmstorageVmBackupResources;

  /**
   * Restore Allows to enable restore options for pod
   * Read [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)
   *
   * @schema VmClusterSpecVmstorageVmBackup#restore
   */
  readonly restore?: VmClusterSpecVmstorageVmBackupRestore;

  /**
   * SnapshotCreateURL overwrites url for snapshot create
   *
   * @schema VmClusterSpecVmstorageVmBackup#snapshotCreateURL
   */
  readonly snapshotCreateUrl?: string;

  /**
   * SnapShotDeleteURL overwrites url for snapshot delete
   *
   * @schema VmClusterSpecVmstorageVmBackup#snapshotDeleteURL
   */
  readonly snapshotDeleteUrl?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the vmbackupmanager container,
   * that are generated as a result of StorageSpec objects.
   *
   * @schema VmClusterSpecVmstorageVmBackup#volumeMounts
   */
  readonly volumeMounts?: VmClusterSpecVmstorageVmBackupVolumeMounts[];

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackup(obj: VmClusterSpecVmstorageVmBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptEULA': obj.acceptEula,
    'concurrency': obj.concurrency,
    'credentialsSecret': toJson_VmClusterSpecVmstorageVmBackupCredentialsSecret(obj.credentialsSecret),
    'customS3Endpoint': obj.customS3Endpoint,
    'destination': obj.destination,
    'destinationDisableSuffixAdd': obj.destinationDisableSuffixAdd,
    'disableDaily': obj.disableDaily,
    'disableHourly': obj.disableHourly,
    'disableMonthly': obj.disableMonthly,
    'disableWeekly': obj.disableWeekly,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmClusterSpecVmstorageVmBackupExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFrom(y)),
    'image': toJson_VmClusterSpecVmstorageVmBackupImage(obj.image),
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'port': obj.port,
    'resources': toJson_VmClusterSpecVmstorageVmBackupResources(obj.resources),
    'restore': toJson_VmClusterSpecVmstorageVmBackupRestore(obj.restore),
    'snapshotCreateURL': obj.snapshotCreateUrl,
    'snapshotDeleteURL': obj.snapshotDeleteUrl,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmClusterSpecVmstorageVmBackupVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmClusterSpecVmstorageVolumeMounts
 */
export interface VmClusterSpecVmstorageVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmClusterSpecVmstorageVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmClusterSpecVmstorageVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmClusterSpecVmstorageVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmClusterSpecVmstorageVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmClusterSpecVmstorageVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmClusterSpecVmstorageVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmClusterSpecVmstorageVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVolumeMounts(obj: VmClusterSpecVmstorageVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmClusterSpecVminsertDnsConfigOptions
 */
export interface VmClusterSpecVminsertDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmClusterSpecVminsertDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmClusterSpecVminsertDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertDnsConfigOptions(obj: VmClusterSpecVminsertDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmClusterSpecVminsertExtraEnvsFromConfigMapRef
 */
export interface VmClusterSpecVminsertExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVminsertExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmClusterSpecVminsertExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertExtraEnvsFromConfigMapRef(obj: VmClusterSpecVminsertExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmClusterSpecVminsertExtraEnvsFromSecretRef
 */
export interface VmClusterSpecVminsertExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVminsertExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmClusterSpecVminsertExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertExtraEnvsFromSecretRef(obj: VmClusterSpecVminsertExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable
 */
export class VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVminsertPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmClusterSpecVminsertPodDisruptionBudgetMinAvailable
 */
export class VmClusterSpecVminsertPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmClusterSpecVminsertPodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVminsertPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertPodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVminsertPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmClusterSpecVminsertResourcesClaims
 */
export interface VmClusterSpecVminsertResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmClusterSpecVminsertResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmClusterSpecVminsertResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertResourcesClaims(obj: VmClusterSpecVminsertResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVminsertResourcesLimits
 */
export class VmClusterSpecVminsertResourcesLimits {
  public static fromNumber(value: number): VmClusterSpecVminsertResourcesLimits {
    return new VmClusterSpecVminsertResourcesLimits(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertResourcesLimits {
    return new VmClusterSpecVminsertResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVminsertResourcesRequests
 */
export class VmClusterSpecVminsertResourcesRequests {
  public static fromNumber(value: number): VmClusterSpecVminsertResourcesRequests {
    return new VmClusterSpecVminsertResourcesRequests(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertResourcesRequests {
    return new VmClusterSpecVminsertResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VmClusterSpecVminsertRollingUpdateMaxSurge
 */
export class VmClusterSpecVminsertRollingUpdateMaxSurge {
  public static fromNumber(value: number): VmClusterSpecVminsertRollingUpdateMaxSurge {
    return new VmClusterSpecVminsertRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertRollingUpdateMaxSurge {
    return new VmClusterSpecVminsertRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VmClusterSpecVminsertRollingUpdateMaxUnavailable
 */
export class VmClusterSpecVminsertRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVminsertRollingUpdateMaxUnavailable {
    return new VmClusterSpecVminsertRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVminsertRollingUpdateMaxUnavailable {
    return new VmClusterSpecVminsertRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmClusterSpecVminsertServiceSpecMetadata
 */
export interface VmClusterSpecVminsertServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVminsertServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVminsertServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVminsertServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVminsertServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVminsertServiceSpecMetadata(obj: VmClusterSpecVminsertServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmClusterSpecVmselectDnsConfigOptions
 */
export interface VmClusterSpecVmselectDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmClusterSpecVmselectDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmClusterSpecVmselectDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectDnsConfigOptions(obj: VmClusterSpecVmselectDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmClusterSpecVmselectExtraEnvsFromConfigMapRef
 */
export interface VmClusterSpecVmselectExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmselectExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmClusterSpecVmselectExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectExtraEnvsFromConfigMapRef(obj: VmClusterSpecVmselectExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmClusterSpecVmselectExtraEnvsFromSecretRef
 */
export interface VmClusterSpecVmselectExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmselectExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmClusterSpecVmselectExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectExtraEnvsFromSecretRef(obj: VmClusterSpecVmselectExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmClusterSpecVmselectPersistentVolumeEmptyDir
 */
export interface VmClusterSpecVmselectPersistentVolumeEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmselectPersistentVolumeEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmselectPersistentVolumeEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectPersistentVolumeEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectPersistentVolumeEmptyDir(obj: VmClusterSpecVmselectPersistentVolumeEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable
 */
export class VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVmselectPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmClusterSpecVmselectPodDisruptionBudgetMinAvailable
 */
export class VmClusterSpecVmselectPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmClusterSpecVmselectPodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVmselectPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectPodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVmselectPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmClusterSpecVmselectResourcesClaims
 */
export interface VmClusterSpecVmselectResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmClusterSpecVmselectResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmClusterSpecVmselectResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectResourcesClaims(obj: VmClusterSpecVmselectResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmselectResourcesLimits
 */
export class VmClusterSpecVmselectResourcesLimits {
  public static fromNumber(value: number): VmClusterSpecVmselectResourcesLimits {
    return new VmClusterSpecVmselectResourcesLimits(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectResourcesLimits {
    return new VmClusterSpecVmselectResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVmselectResourcesRequests
 */
export class VmClusterSpecVmselectResourcesRequests {
  public static fromNumber(value: number): VmClusterSpecVmselectResourcesRequests {
    return new VmClusterSpecVmselectResourcesRequests(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectResourcesRequests {
    return new VmClusterSpecVmselectResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
 * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
 * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
 *
 * @schema VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable
 */
export class VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VmClusterSpecVmselectRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmClusterSpecVmselectServiceSpecMetadata
 */
export interface VmClusterSpecVmselectServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVmselectServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVmselectServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVmselectServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectServiceSpecMetadata(obj: VmClusterSpecVmselectServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmClusterSpecVmselectStorageEmptyDir
 */
export interface VmClusterSpecVmselectStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmselectStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmselectStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmClusterSpecVmselectStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageEmptyDir(obj: VmClusterSpecVmselectStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PVC spec to be used by the StatefulSets/Deployments.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate#spec
   */
  readonly spec?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplate#status
   */
  readonly status?: VmClusterSpecVmselectStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplate(obj: VmClusterSpecVmselectStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmClusterSpecVmstorageDnsConfigOptions
 */
export interface VmClusterSpecVmstorageDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmClusterSpecVmstorageDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmClusterSpecVmstorageDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageDnsConfigOptions(obj: VmClusterSpecVmstorageDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmClusterSpecVmstorageExtraEnvsFromConfigMapRef
 */
export interface VmClusterSpecVmstorageExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageExtraEnvsFromConfigMapRef(obj: VmClusterSpecVmstorageExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmClusterSpecVmstorageExtraEnvsFromSecretRef
 */
export interface VmClusterSpecVmstorageExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmClusterSpecVmstorageExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageExtraEnvsFromSecretRef(obj: VmClusterSpecVmstorageExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable
 */
export class VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable {
    return new VmClusterSpecVmstoragePodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable
 */
export class VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable {
    return new VmClusterSpecVmstoragePodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmClusterSpecVmstorageResourcesClaims
 */
export interface VmClusterSpecVmstorageResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmClusterSpecVmstorageResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmClusterSpecVmstorageResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageResourcesClaims(obj: VmClusterSpecVmstorageResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmstorageResourcesLimits
 */
export class VmClusterSpecVmstorageResourcesLimits {
  public static fromNumber(value: number): VmClusterSpecVmstorageResourcesLimits {
    return new VmClusterSpecVmstorageResourcesLimits(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageResourcesLimits {
    return new VmClusterSpecVmstorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVmstorageResourcesRequests
 */
export class VmClusterSpecVmstorageResourcesRequests {
  public static fromNumber(value: number): VmClusterSpecVmstorageResourcesRequests {
    return new VmClusterSpecVmstorageResourcesRequests(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageResourcesRequests {
    return new VmClusterSpecVmstorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
 * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
 * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
 *
 * @schema VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable
 */
export class VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable {
  public static fromNumber(value: number): VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VmClusterSpecVmstorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmClusterSpecVmstorageServiceSpecMetadata
 */
export interface VmClusterSpecVmstorageServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVmstorageServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVmstorageServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVmstorageServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageServiceSpecMetadata(obj: VmClusterSpecVmstorageServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VmClusterSpecVmstorageStorageEmptyDir
 */
export interface VmClusterSpecVmstorageStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmstorageStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VmClusterSpecVmstorageStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VmClusterSpecVmstorageStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageStorageEmptyDir(obj: VmClusterSpecVmstorageStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CredentialsSecret is secret in the same namespace for access to remote storage
 * The secret is mounted into /etc/vm/creds.
 *
 * @schema VmClusterSpecVmstorageVmBackupCredentialsSecret
 */
export interface VmClusterSpecVmstorageVmBackupCredentialsSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmClusterSpecVmstorageVmBackupCredentialsSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageVmBackupCredentialsSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmClusterSpecVmstorageVmBackupCredentialsSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupCredentialsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupCredentialsSecret(obj: VmClusterSpecVmstorageVmBackupCredentialsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvs
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvs#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvs#valueFrom
   */
  readonly valueFrom?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvs(obj: VmClusterSpecVmstorageVmBackupExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFrom
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFrom(obj: VmClusterSpecVmstorageVmBackupExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings for VMBackuper
 *
 * @schema VmClusterSpecVmstorageVmBackupImage
 */
export interface VmClusterSpecVmstorageVmBackupImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmClusterSpecVmstorageVmBackupImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmClusterSpecVmstorageVmBackupImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmClusterSpecVmstorageVmBackupImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupImage(obj: VmClusterSpecVmstorageVmBackupImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMBackup to be configured with.
 * default or json
 *
 * @schema VmClusterSpecVmstorageVmBackupLogFormat
 */
export enum VmClusterSpecVmstorageVmBackupLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMBackup to be configured with.
 *
 * @schema VmClusterSpecVmstorageVmBackupLogLevel
 */
export enum VmClusterSpecVmstorageVmBackupLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmClusterSpecVmstorageVmBackupResources
 */
export interface VmClusterSpecVmstorageVmBackupResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmClusterSpecVmstorageVmBackupResources#claims
   */
  readonly claims?: VmClusterSpecVmstorageVmBackupResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmstorageVmBackupResources#limits
   */
  readonly limits?: { [key: string]: VmClusterSpecVmstorageVmBackupResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmstorageVmBackupResources#requests
   */
  readonly requests?: { [key: string]: VmClusterSpecVmstorageVmBackupResourcesRequests };

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupResources(obj: VmClusterSpecVmstorageVmBackupResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmClusterSpecVmstorageVmBackupResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Restore Allows to enable restore options for pod
 * Read [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)
 *
 * @schema VmClusterSpecVmstorageVmBackupRestore
 */
export interface VmClusterSpecVmstorageVmBackupRestore {
  /**
   * OnStart defines configuration for restore on pod start
   *
   * @schema VmClusterSpecVmstorageVmBackupRestore#onStart
   */
  readonly onStart?: VmClusterSpecVmstorageVmBackupRestoreOnStart;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupRestore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupRestore(obj: VmClusterSpecVmstorageVmBackupRestore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onStart': toJson_VmClusterSpecVmstorageVmBackupRestoreOnStart(obj.onStart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmClusterSpecVmstorageVmBackupVolumeMounts
 */
export interface VmClusterSpecVmstorageVmBackupVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmClusterSpecVmstorageVmBackupVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupVolumeMounts(obj: VmClusterSpecVmstorageVmBackupVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit
 */
export class VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit {
  public static fromNumber(value: number): VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit {
    return new VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit {
    return new VmClusterSpecVmselectPersistentVolumeEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmClusterSpecVmselectStorageEmptyDirSizeLimit
 */
export class VmClusterSpecVmselectStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VmClusterSpecVmselectStorageEmptyDirSizeLimit {
    return new VmClusterSpecVmselectStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectStorageEmptyDirSizeLimit {
    return new VmClusterSpecVmselectStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpec(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatus(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VmClusterSpecVmstorageStorageEmptyDirSizeLimit
 */
export class VmClusterSpecVmstorageStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VmClusterSpecVmstorageStorageEmptyDirSizeLimit {
    return new VmClusterSpecVmstorageStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageStorageEmptyDirSizeLimit {
    return new VmClusterSpecVmstorageStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom#fieldRef
   */
  readonly fieldRef?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom(obj: VmClusterSpecVmstorageVmBackupExtraEnvsValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmClusterSpecVmstorageVmBackupResourcesClaims
 */
export interface VmClusterSpecVmstorageVmBackupResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmClusterSpecVmstorageVmBackupResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmClusterSpecVmstorageVmBackupResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupResourcesClaims(obj: VmClusterSpecVmstorageVmBackupResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmstorageVmBackupResourcesLimits
 */
export class VmClusterSpecVmstorageVmBackupResourcesLimits {
  public static fromNumber(value: number): VmClusterSpecVmstorageVmBackupResourcesLimits {
    return new VmClusterSpecVmstorageVmBackupResourcesLimits(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageVmBackupResourcesLimits {
    return new VmClusterSpecVmstorageVmBackupResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVmstorageVmBackupResourcesRequests
 */
export class VmClusterSpecVmstorageVmBackupResourcesRequests {
  public static fromNumber(value: number): VmClusterSpecVmstorageVmBackupResourcesRequests {
    return new VmClusterSpecVmstorageVmBackupResourcesRequests(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageVmBackupResourcesRequests {
    return new VmClusterSpecVmstorageVmBackupResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * OnStart defines configuration for restore on pod start
 *
 * @schema VmClusterSpecVmstorageVmBackupRestoreOnStart
 */
export interface VmClusterSpecVmstorageVmBackupRestoreOnStart {
  /**
   * Enabled defines if restore on start enabled
   *
   * @schema VmClusterSpecVmstorageVmBackupRestoreOnStart#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupRestoreOnStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupRestoreOnStart(obj: VmClusterSpecVmstorageVmBackupRestoreOnStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity
 */
export class VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef#divisor
   */
  readonly divisor?: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef
 */
export interface VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef(obj: VmClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests {
    return new VmClusterSpecVmselectStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: VmClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor
 */
export class VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
    return new VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
    return new VmClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * VMNodeScrape defines discovery for targets placed on kubernetes nodes,
usually its node-exporters and other host services.
InternalIP is used as __address__ for scraping.
 *
 * @schema VMNodeScrape
 */
export class VmNodeScrape extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMNodeScrape"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMNodeScrape',
  }

  /**
   * Renders a Kubernetes manifest for "VMNodeScrape".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmNodeScrapeProps = {}): any {
    return {
      ...VmNodeScrape.GVK,
      ...toJson_VmNodeScrapeProps(props),
    };
  }

  /**
   * Defines a "VMNodeScrape" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmNodeScrapeProps = {}) {
    super(scope, id, {
      ...VmNodeScrape.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmNodeScrape.GVK,
      ...toJson_VmNodeScrapeProps(resolved),
    };
  }
}

/**
 * VMNodeScrape defines discovery for targets placed on kubernetes nodes,
 * usually its node-exporters and other host services.
 * InternalIP is used as __address__ for scraping.
 *
 * @schema VMNodeScrape
 */
export interface VmNodeScrapeProps {
  /**
   * @schema VMNodeScrape#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMNodeScrapeSpec defines specification for VMNodeScrape.
   *
   * @schema VMNodeScrape#spec
   */
  readonly spec?: VmNodeScrapeSpec;

}

/**
 * Converts an object of type 'VmNodeScrapeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeProps(obj: VmNodeScrapeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmNodeScrapeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMNodeScrapeSpec defines specification for VMNodeScrape.
 *
 * @schema VmNodeScrapeSpec
 */
export interface VmNodeScrapeSpec {
  /**
   * Authorization with http header Authorization
   *
   * @schema VmNodeScrapeSpec#authorization
   */
  readonly authorization?: VmNodeScrapeSpecAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmNodeScrapeSpec#basicAuth
   */
  readonly basicAuth?: VmNodeScrapeSpecBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmNodeScrapeSpec#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmNodeScrapeSpec#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmNodeScrapeSpecBearerTokenSecret;

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmNodeScrapeSpec#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmNodeScrapeSpec#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmNodeScrapeSpec#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmNodeScrapeSpec#interval
   */
  readonly interval?: string;

  /**
   * The label to use to retrieve the job name from.
   *
   * @schema VmNodeScrapeSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmNodeScrapeSpec#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmNodeScrapeSpec#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmNodeScrapeSpecMetricRelabelConfigs[];

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmNodeScrapeSpec#oauth2
   */
  readonly oauth2?: VmNodeScrapeSpecOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmNodeScrapeSpec#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmNodeScrapeSpec#path
   */
  readonly path?: string;

  /**
   * Name of the port exposed at Node.
   *
   * @schema VmNodeScrapeSpec#port
   */
  readonly port?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmNodeScrapeSpec#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmNodeScrapeSpec#relabelConfigs
   */
  readonly relabelConfigs?: VmNodeScrapeSpecRelabelConfigs[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmNodeScrapeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmNodeScrapeSpec#scheme
   */
  readonly scheme?: VmNodeScrapeSpecScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmNodeScrapeSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmNodeScrapeSpec#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * Selector to select kubernetes Nodes.
   *
   * @schema VmNodeScrapeSpec#selector
   */
  readonly selector?: VmNodeScrapeSpecSelector;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmNodeScrapeSpec#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * TargetLabels transfers labels on the Kubernetes Node onto the target.
   *
   * @schema VmNodeScrapeSpec#targetLabels
   */
  readonly targetLabels?: string[];

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmNodeScrapeSpec#tlsConfig
   */
  readonly tlsConfig?: VmNodeScrapeSpecTlsConfig;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmNodeScrapeSpec#vm_scrape_params
   */
  readonly vmScrapeParams?: VmNodeScrapeSpecVmScrapeParams;

}

/**
 * Converts an object of type 'VmNodeScrapeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpec(obj: VmNodeScrapeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmNodeScrapeSpecAuthorization(obj.authorization),
    'basicAuth': toJson_VmNodeScrapeSpecBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmNodeScrapeSpecBearerTokenSecret(obj.bearerTokenSecret),
    'follow_redirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'jobLabel': obj.jobLabel,
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmNodeScrapeSpecMetricRelabelConfigs(y)),
    'oauth2': toJson_VmNodeScrapeSpecOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'proxyURL': obj.proxyUrl,
    'relabelConfigs': obj.relabelConfigs?.map(y => toJson_VmNodeScrapeSpecRelabelConfigs(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'selector': toJson_VmNodeScrapeSpecSelector(obj.selector),
    'seriesLimit': obj.seriesLimit,
    'targetLabels': obj.targetLabels?.map(y => y),
    'tlsConfig': toJson_VmNodeScrapeSpecTlsConfig(obj.tlsConfig),
    'vm_scrape_params': toJson_VmNodeScrapeSpecVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmNodeScrapeSpecAuthorization
 */
export interface VmNodeScrapeSpecAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmNodeScrapeSpecAuthorization#credentials
   */
  readonly credentials?: VmNodeScrapeSpecAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmNodeScrapeSpecAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmNodeScrapeSpecAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecAuthorization(obj: VmNodeScrapeSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmNodeScrapeSpecAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmNodeScrapeSpecBasicAuth
 */
export interface VmNodeScrapeSpecBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmNodeScrapeSpecBasicAuth#password
   */
  readonly password?: VmNodeScrapeSpecBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmNodeScrapeSpecBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmNodeScrapeSpecBasicAuth#username
   */
  readonly username?: VmNodeScrapeSpecBasicAuthUsername;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecBasicAuth(obj: VmNodeScrapeSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmNodeScrapeSpecBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmNodeScrapeSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmNodeScrapeSpecBearerTokenSecret
 */
export interface VmNodeScrapeSpecBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecBearerTokenSecret(obj: VmNodeScrapeSpecBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmNodeScrapeSpecMetricRelabelConfigs
 */
export interface VmNodeScrapeSpecMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmNodeScrapeSpecMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecMetricRelabelConfigs(obj: VmNodeScrapeSpecMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmNodeScrapeSpecOauth2
 */
export interface VmNodeScrapeSpecOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmNodeScrapeSpecOauth2#client_id
   */
  readonly clientId: VmNodeScrapeSpecOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmNodeScrapeSpecOauth2#client_secret
   */
  readonly clientSecret?: VmNodeScrapeSpecOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmNodeScrapeSpecOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmNodeScrapeSpecOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmNodeScrapeSpecOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmNodeScrapeSpecOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmNodeScrapeSpecOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmNodeScrapeSpecOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecOauth2(obj: VmNodeScrapeSpecOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmNodeScrapeSpecOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmNodeScrapeSpecOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmNodeScrapeSpecRelabelConfigs
 */
export interface VmNodeScrapeSpecRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmNodeScrapeSpecRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmNodeScrapeSpecRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmNodeScrapeSpecRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmNodeScrapeSpecRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecRelabelConfigs(obj: VmNodeScrapeSpecRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmNodeScrapeSpecScheme
 */
export enum VmNodeScrapeSpecScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Selector to select kubernetes Nodes.
 *
 * @schema VmNodeScrapeSpecSelector
 */
export interface VmNodeScrapeSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmNodeScrapeSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmNodeScrapeSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmNodeScrapeSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmNodeScrapeSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecSelector(obj: VmNodeScrapeSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmNodeScrapeSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmNodeScrapeSpecTlsConfig
 */
export interface VmNodeScrapeSpecTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#ca
   */
  readonly ca?: VmNodeScrapeSpecTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#cert
   */
  readonly cert?: VmNodeScrapeSpecTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmNodeScrapeSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#keySecret
   */
  readonly keySecret?: VmNodeScrapeSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfig(obj: VmNodeScrapeSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmNodeScrapeSpecTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmNodeScrapeSpecTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmNodeScrapeSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmNodeScrapeSpecVmScrapeParams
 */
export interface VmNodeScrapeSpecVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmNodeScrapeSpecVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmNodeScrapeSpecVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmNodeScrapeSpecVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmNodeScrapeSpecVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmNodeScrapeSpecVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmNodeScrapeSpecVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmNodeScrapeSpecVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmNodeScrapeSpecVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmNodeScrapeSpecVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParams(obj: VmNodeScrapeSpecVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmNodeScrapeSpecAuthorizationCredentials
 */
export interface VmNodeScrapeSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecAuthorizationCredentials(obj: VmNodeScrapeSpecAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmNodeScrapeSpecBasicAuthPassword
 */
export interface VmNodeScrapeSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecBasicAuthPassword(obj: VmNodeScrapeSpecBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmNodeScrapeSpecBasicAuthUsername
 */
export interface VmNodeScrapeSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecBasicAuthUsername(obj: VmNodeScrapeSpecBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmNodeScrapeSpecOauth2ClientId
 */
export interface VmNodeScrapeSpecOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecOauth2ClientId#configMap
   */
  readonly configMap?: VmNodeScrapeSpecOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecOauth2ClientId#secret
   */
  readonly secret?: VmNodeScrapeSpecOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecOauth2ClientId(obj: VmNodeScrapeSpecOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmNodeScrapeSpecOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmNodeScrapeSpecOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmNodeScrapeSpecOauth2ClientSecret
 */
export interface VmNodeScrapeSpecOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecOauth2ClientSecret(obj: VmNodeScrapeSpecOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmNodeScrapeSpecSelectorMatchExpressions
 */
export interface VmNodeScrapeSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmNodeScrapeSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmNodeScrapeSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmNodeScrapeSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmNodeScrapeSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecSelectorMatchExpressions(obj: VmNodeScrapeSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCa
 */
export interface VmNodeScrapeSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfigCa#configMap
   */
  readonly configMap?: VmNodeScrapeSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfigCa#secret
   */
  readonly secret?: VmNodeScrapeSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCa(obj: VmNodeScrapeSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmNodeScrapeSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmNodeScrapeSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCert
 */
export interface VmNodeScrapeSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfigCert#configMap
   */
  readonly configMap?: VmNodeScrapeSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmNodeScrapeSpecTlsConfigCert#secret
   */
  readonly secret?: VmNodeScrapeSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCert(obj: VmNodeScrapeSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmNodeScrapeSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmNodeScrapeSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigKeySecret
 */
export interface VmNodeScrapeSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigKeySecret(obj: VmNodeScrapeSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfig
 */
export interface VmNodeScrapeSpecVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfig(obj: VmNodeScrapeSpecVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecOauth2ClientIdConfigMap
 */
export interface VmNodeScrapeSpecOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecOauth2ClientIdConfigMap(obj: VmNodeScrapeSpecOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecOauth2ClientIdSecret
 */
export interface VmNodeScrapeSpecOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecOauth2ClientIdSecret(obj: VmNodeScrapeSpecOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCaConfigMap
 */
export interface VmNodeScrapeSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmNodeScrapeSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmNodeScrapeSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCaConfigMap(obj: VmNodeScrapeSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCaSecret
 */
export interface VmNodeScrapeSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCaSecret(obj: VmNodeScrapeSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCertConfigMap
 */
export interface VmNodeScrapeSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmNodeScrapeSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmNodeScrapeSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCertConfigMap(obj: VmNodeScrapeSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmNodeScrapeSpecTlsConfigCertSecret
 */
export interface VmNodeScrapeSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecTlsConfigCertSecret(obj: VmNodeScrapeSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth(obj: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken(obj: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmNodeScrapeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMPodScrape is scrape configuration for pods,
it generates vmagent's config for scraping pod targets
based on selectors.
 *
 * @schema VMPodScrape
 */
export class VmPodScrape extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMPodScrape"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMPodScrape',
  }

  /**
   * Renders a Kubernetes manifest for "VMPodScrape".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmPodScrapeProps = {}): any {
    return {
      ...VmPodScrape.GVK,
      ...toJson_VmPodScrapeProps(props),
    };
  }

  /**
   * Defines a "VMPodScrape" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmPodScrapeProps = {}) {
    super(scope, id, {
      ...VmPodScrape.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmPodScrape.GVK,
      ...toJson_VmPodScrapeProps(resolved),
    };
  }
}

/**
 * VMPodScrape is scrape configuration for pods,
 * it generates vmagent's config for scraping pod targets
 * based on selectors.
 *
 * @schema VMPodScrape
 */
export interface VmPodScrapeProps {
  /**
   * @schema VMPodScrape#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMPodScrapeSpec defines the desired state of VMPodScrape
   *
   * @schema VMPodScrape#spec
   */
  readonly spec?: VmPodScrapeSpec;

}

/**
 * Converts an object of type 'VmPodScrapeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeProps(obj: VmPodScrapeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmPodScrapeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMPodScrapeSpec defines the desired state of VMPodScrape
 *
 * @schema VmPodScrapeSpec
 */
export interface VmPodScrapeSpec {
  /**
   * AttachMetadata configures metadata attaching from service discovery
   *
   * @schema VmPodScrapeSpec#attach_metadata
   */
  readonly attachMetadata?: VmPodScrapeSpecAttachMetadata;

  /**
   * The label to use to retrieve the job name from.
   *
   * @schema VmPodScrapeSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Selector to select which namespaces the Endpoints objects are discovered from.
   *
   * @schema VmPodScrapeSpec#namespaceSelector
   */
  readonly namespaceSelector?: VmPodScrapeSpecNamespaceSelector;

  /**
   * A list of endpoints allowed as part of this PodMonitor.
   *
   * @schema VmPodScrapeSpec#podMetricsEndpoints
   */
  readonly podMetricsEndpoints: VmPodScrapeSpecPodMetricsEndpoints[];

  /**
   * PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
   *
   * @schema VmPodScrapeSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmPodScrapeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Selector to select Pod objects.
   *
   * @schema VmPodScrapeSpec#selector
   */
  readonly selector?: VmPodScrapeSpecSelector;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmPodScrapeSpec#seriesLimit
   */
  readonly seriesLimit?: number;

}

/**
 * Converts an object of type 'VmPodScrapeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpec(obj: VmPodScrapeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attach_metadata': toJson_VmPodScrapeSpecAttachMetadata(obj.attachMetadata),
    'jobLabel': obj.jobLabel,
    'namespaceSelector': toJson_VmPodScrapeSpecNamespaceSelector(obj.namespaceSelector),
    'podMetricsEndpoints': obj.podMetricsEndpoints?.map(y => toJson_VmPodScrapeSpecPodMetricsEndpoints(y)),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'sampleLimit': obj.sampleLimit,
    'selector': toJson_VmPodScrapeSpecSelector(obj.selector),
    'seriesLimit': obj.seriesLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttachMetadata configures metadata attaching from service discovery
 *
 * @schema VmPodScrapeSpecAttachMetadata
 */
export interface VmPodScrapeSpecAttachMetadata {
  /**
   * Node instructs vmagent to add node specific metadata from service discovery
   * Valid for roles: pod, endpoints, endpointslice.
   *
   * @schema VmPodScrapeSpecAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecAttachMetadata(obj: VmPodScrapeSpecAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector to select which namespaces the Endpoints objects are discovered from.
 *
 * @schema VmPodScrapeSpecNamespaceSelector
 */
export interface VmPodScrapeSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema VmPodScrapeSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema VmPodScrapeSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'VmPodScrapeSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecNamespaceSelector(obj: VmPodScrapeSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetricsEndpoint defines a scrapeable endpoint of a Kubernetes Pod serving metrics.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpoints
 */
export interface VmPodScrapeSpecPodMetricsEndpoints {
  /**
   * AttachMetadata configures metadata attaching from service discovery
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#attach_metadata
   */
  readonly attachMetadata?: VmPodScrapeSpecPodMetricsEndpointsAttachMetadata;

  /**
   * Authorization with http header Authorization
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#authorization
   */
  readonly authorization?: VmPodScrapeSpecPodMetricsEndpointsAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#basicAuth
   */
  readonly basicAuth?: VmPodScrapeSpecPodMetricsEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret;

  /**
   * FilterRunning applies filter with pod status == running
   * it prevents from scrapping metrics at failed or succeed state pods.
   * enabled by default
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#filterRunning
   */
  readonly filterRunning?: boolean;

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#interval
   */
  readonly interval?: string;

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs[];

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#oauth2
   */
  readonly oauth2?: VmPodScrapeSpecPodMetricsEndpointsOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the port exposed at Pod.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#port
   */
  readonly port?: string;

  /**
   * PortNumber defines the `Pod` port number which exposes the endpoint.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#portNumber
   */
  readonly portNumber?: number;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#relabelConfigs
   */
  readonly relabelConfigs?: VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#scheme
   */
  readonly scheme?: VmPodScrapeSpecPodMetricsEndpointsScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * TargetPort defines name or number of the pod port this endpoint refers to.
   * Mutually exclusive with Port and PortNumber.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#targetPort
   */
  readonly targetPort?: VmPodScrapeSpecPodMetricsEndpointsTargetPort;

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#tlsConfig
   */
  readonly tlsConfig?: VmPodScrapeSpecPodMetricsEndpointsTlsConfig;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmPodScrapeSpecPodMetricsEndpoints#vm_scrape_params
   */
  readonly vmScrapeParams?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpoints(obj: VmPodScrapeSpecPodMetricsEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attach_metadata': toJson_VmPodScrapeSpecPodMetricsEndpointsAttachMetadata(obj.attachMetadata),
    'authorization': toJson_VmPodScrapeSpecPodMetricsEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'filterRunning': obj.filterRunning,
    'follow_redirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs(y)),
    'oauth2': toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'portNumber': obj.portNumber,
    'proxyURL': obj.proxyUrl,
    'relabelConfigs': obj.relabelConfigs?.map(y => toJson_VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'seriesLimit': obj.seriesLimit,
    'targetPort': obj.targetPort?.value,
    'tlsConfig': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfig(obj.tlsConfig),
    'vm_scrape_params': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector to select Pod objects.
 *
 * @schema VmPodScrapeSpecSelector
 */
export interface VmPodScrapeSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmPodScrapeSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmPodScrapeSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmPodScrapeSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmPodScrapeSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecSelector(obj: VmPodScrapeSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmPodScrapeSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttachMetadata configures metadata attaching from service discovery
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsAttachMetadata
 */
export interface VmPodScrapeSpecPodMetricsEndpointsAttachMetadata {
  /**
   * Node instructs vmagent to add node specific metadata from service discovery
   * Valid for roles: pod, endpoints, endpointslice.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsAttachMetadata(obj: VmPodScrapeSpecPodMetricsEndpointsAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorization
 */
export interface VmPodScrapeSpecPodMetricsEndpointsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorization#credentials
   */
  readonly credentials?: VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsAuthorization(obj: VmPodScrapeSpecPodMetricsEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuth
 */
export interface VmPodScrapeSpecPodMetricsEndpointsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuth#password
   */
  readonly password?: VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuth#username
   */
  readonly username?: VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuth(obj: VmPodScrapeSpecPodMetricsEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret(obj: VmPodScrapeSpecPodMetricsEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs
 */
export interface VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs(obj: VmPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2
 */
export interface VmPodScrapeSpecPodMetricsEndpointsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#client_id
   */
  readonly clientId: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#client_secret
   */
  readonly clientSecret?: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2(obj: VmPodScrapeSpecPodMetricsEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs
 */
export interface VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs(obj: VmPodScrapeSpecPodMetricsEndpointsRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsScheme
 */
export enum VmPodScrapeSpecPodMetricsEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * TargetPort defines name or number of the pod port this endpoint refers to.
 * Mutually exclusive with Port and PortNumber.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTargetPort
 */
export class VmPodScrapeSpecPodMetricsEndpointsTargetPort {
  public static fromNumber(value: number): VmPodScrapeSpecPodMetricsEndpointsTargetPort {
    return new VmPodScrapeSpecPodMetricsEndpointsTargetPort(value);
  }
  public static fromString(value: string): VmPodScrapeSpecPodMetricsEndpointsTargetPort {
    return new VmPodScrapeSpecPodMetricsEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#ca
   */
  readonly ca?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#cert
   */
  readonly cert?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfig(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmPodScrapeSpecSelectorMatchExpressions
 */
export interface VmPodScrapeSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmPodScrapeSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmPodScrapeSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmPodScrapeSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmPodScrapeSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecSelectorMatchExpressions(obj: VmPodScrapeSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials
 */
export interface VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials(obj: VmPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword
 */
export interface VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword(obj: VmPodScrapeSpecPodMetricsEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername
 */
export interface VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername(obj: VmPodScrapeSpecPodMetricsEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId
 */
export interface VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId#secret
   */
  readonly secret?: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId(obj: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret(obj: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa#secret
   */
  readonly secret?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert#secret
   */
  readonly secret?: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap
 */
export interface VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap(obj: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret(obj: VmPodScrapeSpecPodMetricsEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret
 */
export interface VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret(obj: VmPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmPodScrapeSpecPodMetricsEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMProbe defines a probe for targets, that will be executed with prober,
like blackbox exporter.
It helps to monitor reachability of target with various checks.
 *
 * @schema VMProbe
 */
export class VmProbe extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMProbe"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMProbe',
  }

  /**
   * Renders a Kubernetes manifest for "VMProbe".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmProbeProps): any {
    return {
      ...VmProbe.GVK,
      ...toJson_VmProbeProps(props),
    };
  }

  /**
   * Defines a "VMProbe" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmProbeProps) {
    super(scope, id, {
      ...VmProbe.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmProbe.GVK,
      ...toJson_VmProbeProps(resolved),
    };
  }
}

/**
 * VMProbe defines a probe for targets, that will be executed with prober,
 * like blackbox exporter.
 * It helps to monitor reachability of target with various checks.
 *
 * @schema VMProbe
 */
export interface VmProbeProps {
  /**
   * @schema VMProbe#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMProbeSpec contains specification parameters for a Probe.
   *
   * @schema VMProbe#spec
   */
  readonly spec: VmProbeSpec;

}

/**
 * Converts an object of type 'VmProbeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeProps(obj: VmProbeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmProbeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMProbeSpec contains specification parameters for a Probe.
 *
 * @schema VmProbeSpec
 */
export interface VmProbeSpec {
  /**
   * Authorization with http header Authorization
   *
   * @schema VmProbeSpec#authorization
   */
  readonly authorization?: VmProbeSpecAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmProbeSpec#basicAuth
   */
  readonly basicAuth?: VmProbeSpecBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmProbeSpec#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmProbeSpec#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmProbeSpecBearerTokenSecret;

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmProbeSpec#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmProbeSpec#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmProbeSpec#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmProbeSpec#interval
   */
  readonly interval?: string;

  /**
   * The job name assigned to scraped metrics by default.
   *
   * @schema VmProbeSpec#jobName
   */
  readonly jobName?: string;

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmProbeSpec#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmProbeSpec#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmProbeSpecMetricRelabelConfigs[];

  /**
   * The module to use for probing specifying how to probe the target.
   * Example module configuring in the blackbox exporter:
   * https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
   *
   * @schema VmProbeSpec#module
   */
  readonly module?: string;

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmProbeSpec#oauth2
   */
  readonly oauth2?: VmProbeSpecOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmProbeSpec#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmProbeSpec#path
   */
  readonly path?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmProbeSpec#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmProbeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmProbeSpec#scheme
   */
  readonly scheme?: VmProbeSpecScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmProbeSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmProbeSpec#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmProbeSpec#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.
   *
   * @schema VmProbeSpec#targets
   */
  readonly targets?: VmProbeSpecTargets;

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmProbeSpec#tlsConfig
   */
  readonly tlsConfig?: VmProbeSpecTlsConfig;

  /**
   * Specification for the prober to use for probing targets.
   * The prober.URL parameter is required. Targets cannot be probed if left empty.
   *
   * @schema VmProbeSpec#vmProberSpec
   */
  readonly vmProberSpec: VmProbeSpecVmProberSpec;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmProbeSpec#vm_scrape_params
   */
  readonly vmScrapeParams?: VmProbeSpecVmScrapeParams;

}

/**
 * Converts an object of type 'VmProbeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpec(obj: VmProbeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmProbeSpecAuthorization(obj.authorization),
    'basicAuth': toJson_VmProbeSpecBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmProbeSpecBearerTokenSecret(obj.bearerTokenSecret),
    'follow_redirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'jobName': obj.jobName,
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmProbeSpecMetricRelabelConfigs(y)),
    'module': obj.module,
    'oauth2': toJson_VmProbeSpecOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'proxyURL': obj.proxyUrl,
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'seriesLimit': obj.seriesLimit,
    'targets': toJson_VmProbeSpecTargets(obj.targets),
    'tlsConfig': toJson_VmProbeSpecTlsConfig(obj.tlsConfig),
    'vmProberSpec': toJson_VmProbeSpecVmProberSpec(obj.vmProberSpec),
    'vm_scrape_params': toJson_VmProbeSpecVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmProbeSpecAuthorization
 */
export interface VmProbeSpecAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmProbeSpecAuthorization#credentials
   */
  readonly credentials?: VmProbeSpecAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmProbeSpecAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmProbeSpecAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmProbeSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecAuthorization(obj: VmProbeSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmProbeSpecAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmProbeSpecBasicAuth
 */
export interface VmProbeSpecBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmProbeSpecBasicAuth#password
   */
  readonly password?: VmProbeSpecBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmProbeSpecBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmProbeSpecBasicAuth#username
   */
  readonly username?: VmProbeSpecBasicAuthUsername;

}

/**
 * Converts an object of type 'VmProbeSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecBasicAuth(obj: VmProbeSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmProbeSpecBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmProbeSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmProbeSpecBearerTokenSecret
 */
export interface VmProbeSpecBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecBearerTokenSecret(obj: VmProbeSpecBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmProbeSpecMetricRelabelConfigs
 */
export interface VmProbeSpecMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmProbeSpecMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmProbeSpecMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmProbeSpecMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmProbeSpecMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmProbeSpecMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmProbeSpecMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmProbeSpecMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmProbeSpecMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmProbeSpecMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmProbeSpecMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmProbeSpecMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecMetricRelabelConfigs(obj: VmProbeSpecMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmProbeSpecOauth2
 */
export interface VmProbeSpecOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmProbeSpecOauth2#client_id
   */
  readonly clientId: VmProbeSpecOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmProbeSpecOauth2#client_secret
   */
  readonly clientSecret?: VmProbeSpecOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmProbeSpecOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmProbeSpecOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmProbeSpecOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmProbeSpecOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmProbeSpecOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmProbeSpecOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmProbeSpecOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecOauth2(obj: VmProbeSpecOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmProbeSpecOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmProbeSpecOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmProbeSpecScheme
 */
export enum VmProbeSpecScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.
 *
 * @schema VmProbeSpecTargets
 */
export interface VmProbeSpecTargets {
  /**
   * Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.
   *
   * @schema VmProbeSpecTargets#ingress
   */
  readonly ingress?: VmProbeSpecTargetsIngress;

  /**
   * StaticConfig defines static targets which are considers for probing.
   *
   * @schema VmProbeSpecTargets#staticConfig
   */
  readonly staticConfig?: VmProbeSpecTargetsStaticConfig;

}

/**
 * Converts an object of type 'VmProbeSpecTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargets(obj: VmProbeSpecTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingress': toJson_VmProbeSpecTargetsIngress(obj.ingress),
    'staticConfig': toJson_VmProbeSpecTargetsStaticConfig(obj.staticConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmProbeSpecTlsConfig
 */
export interface VmProbeSpecTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmProbeSpecTlsConfig#ca
   */
  readonly ca?: VmProbeSpecTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmProbeSpecTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmProbeSpecTlsConfig#cert
   */
  readonly cert?: VmProbeSpecTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmProbeSpecTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmProbeSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmProbeSpecTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmProbeSpecTlsConfig#keySecret
   */
  readonly keySecret?: VmProbeSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmProbeSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfig(obj: VmProbeSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmProbeSpecTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmProbeSpecTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmProbeSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification for the prober to use for probing targets.
 * The prober.URL parameter is required. Targets cannot be probed if left empty.
 *
 * @schema VmProbeSpecVmProberSpec
 */
export interface VmProbeSpecVmProberSpec {
  /**
   * Path to collect metrics from.
   * Defaults to `/probe`.
   *
   * @default probe`.
   * @schema VmProbeSpecVmProberSpec#path
   */
  readonly path?: string;

  /**
   * HTTP scheme to use for scraping.
   * Defaults to `http`.
   *
   * @default http`.
   * @schema VmProbeSpecVmProberSpec#scheme
   */
  readonly scheme?: VmProbeSpecVmProberSpecScheme;

  /**
   * Mandatory URL of the prober.
   *
   * @schema VmProbeSpecVmProberSpec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmProbeSpecVmProberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmProberSpec(obj: VmProbeSpecVmProberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'scheme': obj.scheme,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmProbeSpecVmScrapeParams
 */
export interface VmProbeSpecVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmProbeSpecVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmProbeSpecVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmProbeSpecVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmProbeSpecVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmProbeSpecVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmProbeSpecVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmProbeSpecVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmProbeSpecVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmProbeSpecVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParams(obj: VmProbeSpecVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmProbeSpecVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmProbeSpecAuthorizationCredentials
 */
export interface VmProbeSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecAuthorizationCredentials(obj: VmProbeSpecAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmProbeSpecBasicAuthPassword
 */
export interface VmProbeSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecBasicAuthPassword(obj: VmProbeSpecBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmProbeSpecBasicAuthUsername
 */
export interface VmProbeSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecBasicAuthUsername(obj: VmProbeSpecBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmProbeSpecOauth2ClientId
 */
export interface VmProbeSpecOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmProbeSpecOauth2ClientId#configMap
   */
  readonly configMap?: VmProbeSpecOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmProbeSpecOauth2ClientId#secret
   */
  readonly secret?: VmProbeSpecOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmProbeSpecOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecOauth2ClientId(obj: VmProbeSpecOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmProbeSpecOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmProbeSpecOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmProbeSpecOauth2ClientSecret
 */
export interface VmProbeSpecOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecOauth2ClientSecret(obj: VmProbeSpecOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.
 *
 * @schema VmProbeSpecTargetsIngress
 */
export interface VmProbeSpecTargetsIngress {
  /**
   * Select Ingress objects by namespace.
   *
   * @schema VmProbeSpecTargetsIngress#namespaceSelector
   */
  readonly namespaceSelector?: VmProbeSpecTargetsIngressNamespaceSelector;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmProbeSpecTargetsIngress#relabelingConfigs
   */
  readonly relabelingConfigs?: VmProbeSpecTargetsIngressRelabelingConfigs[];

  /**
   * Select Ingress objects by labels.
   *
   * @schema VmProbeSpecTargetsIngress#selector
   */
  readonly selector?: VmProbeSpecTargetsIngressSelector;

}

/**
 * Converts an object of type 'VmProbeSpecTargetsIngress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsIngress(obj: VmProbeSpecTargetsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelector': toJson_VmProbeSpecTargetsIngressNamespaceSelector(obj.namespaceSelector),
    'relabelingConfigs': obj.relabelingConfigs?.map(y => toJson_VmProbeSpecTargetsIngressRelabelingConfigs(y)),
    'selector': toJson_VmProbeSpecTargetsIngressSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StaticConfig defines static targets which are considers for probing.
 *
 * @schema VmProbeSpecTargetsStaticConfig
 */
export interface VmProbeSpecTargetsStaticConfig {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema VmProbeSpecTargetsStaticConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmProbeSpecTargetsStaticConfig#relabelingConfigs
   */
  readonly relabelingConfigs?: VmProbeSpecTargetsStaticConfigRelabelingConfigs[];

  /**
   * Targets is a list of URLs to probe using the configured prober.
   *
   * @schema VmProbeSpecTargetsStaticConfig#targets
   */
  readonly targets: string[];

}

/**
 * Converts an object of type 'VmProbeSpecTargetsStaticConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsStaticConfig(obj: VmProbeSpecTargetsStaticConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'relabelingConfigs': obj.relabelingConfigs?.map(y => toJson_VmProbeSpecTargetsStaticConfigRelabelingConfigs(y)),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmProbeSpecTlsConfigCa
 */
export interface VmProbeSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmProbeSpecTlsConfigCa#configMap
   */
  readonly configMap?: VmProbeSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmProbeSpecTlsConfigCa#secret
   */
  readonly secret?: VmProbeSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCa(obj: VmProbeSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmProbeSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmProbeSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmProbeSpecTlsConfigCert
 */
export interface VmProbeSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmProbeSpecTlsConfigCert#configMap
   */
  readonly configMap?: VmProbeSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmProbeSpecTlsConfigCert#secret
   */
  readonly secret?: VmProbeSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCert(obj: VmProbeSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmProbeSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmProbeSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmProbeSpecTlsConfigKeySecret
 */
export interface VmProbeSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigKeySecret(obj: VmProbeSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 * Defaults to `http`.
 *
 * @default http`.
 * @schema VmProbeSpecVmProberSpecScheme
 */
export enum VmProbeSpecVmProberSpecScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmProbeSpecVmScrapeParamsProxyClientConfig
 */
export interface VmProbeSpecVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParamsProxyClientConfig(obj: VmProbeSpecVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmProbeSpecOauth2ClientIdConfigMap
 */
export interface VmProbeSpecOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmProbeSpecOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmProbeSpecOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecOauth2ClientIdConfigMap(obj: VmProbeSpecOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmProbeSpecOauth2ClientIdSecret
 */
export interface VmProbeSpecOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecOauth2ClientIdSecret(obj: VmProbeSpecOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select Ingress objects by namespace.
 *
 * @schema VmProbeSpecTargetsIngressNamespaceSelector
 */
export interface VmProbeSpecTargetsIngressNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema VmProbeSpecTargetsIngressNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema VmProbeSpecTargetsIngressNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'VmProbeSpecTargetsIngressNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsIngressNamespaceSelector(obj: VmProbeSpecTargetsIngressNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmProbeSpecTargetsIngressRelabelingConfigs
 */
export interface VmProbeSpecTargetsIngressRelabelingConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmProbeSpecTargetsIngressRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmProbeSpecTargetsIngressRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsIngressRelabelingConfigs(obj: VmProbeSpecTargetsIngressRelabelingConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select Ingress objects by labels.
 *
 * @schema VmProbeSpecTargetsIngressSelector
 */
export interface VmProbeSpecTargetsIngressSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmProbeSpecTargetsIngressSelector#matchExpressions
   */
  readonly matchExpressions?: VmProbeSpecTargetsIngressSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmProbeSpecTargetsIngressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmProbeSpecTargetsIngressSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsIngressSelector(obj: VmProbeSpecTargetsIngressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmProbeSpecTargetsIngressSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs
 */
export interface VmProbeSpecTargetsStaticConfigRelabelingConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmProbeSpecTargetsStaticConfigRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmProbeSpecTargetsStaticConfigRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsStaticConfigRelabelingConfigs(obj: VmProbeSpecTargetsStaticConfigRelabelingConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmProbeSpecTlsConfigCaConfigMap
 */
export interface VmProbeSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmProbeSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmProbeSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCaConfigMap(obj: VmProbeSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmProbeSpecTlsConfigCaSecret
 */
export interface VmProbeSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCaSecret(obj: VmProbeSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmProbeSpecTlsConfigCertConfigMap
 */
export interface VmProbeSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmProbeSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmProbeSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCertConfigMap(obj: VmProbeSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmProbeSpecTlsConfigCertSecret
 */
export interface VmProbeSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTlsConfigCertSecret(obj: VmProbeSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth(obj: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken(obj: VmProbeSpecVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmProbeSpecTargetsIngressSelectorMatchExpressions
 */
export interface VmProbeSpecTargetsIngressSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmProbeSpecTargetsIngressSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmProbeSpecTargetsIngressSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmProbeSpecTargetsIngressSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmProbeSpecTargetsIngressSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecTargetsIngressSelectorMatchExpressions(obj: VmProbeSpecTargetsIngressSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmProbeSpecVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMRule defines rule records for vmalert application
 *
 * @schema VMRule
 */
export class VmRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMRule',
  }

  /**
   * Renders a Kubernetes manifest for "VMRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmRuleProps): any {
    return {
      ...VmRule.GVK,
      ...toJson_VmRuleProps(props),
    };
  }

  /**
   * Defines a "VMRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmRuleProps) {
    super(scope, id, {
      ...VmRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmRule.GVK,
      ...toJson_VmRuleProps(resolved),
    };
  }
}

/**
 * VMRule defines rule records for vmalert application
 *
 * @schema VMRule
 */
export interface VmRuleProps {
  /**
   * @schema VMRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMRuleSpec defines the desired state of VMRule
   *
   * @schema VMRule#spec
   */
  readonly spec: VmRuleSpec;

}

/**
 * Converts an object of type 'VmRuleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmRuleProps(obj: VmRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMRuleSpec defines the desired state of VMRule
 *
 * @schema VmRuleSpec
 */
export interface VmRuleSpec {
  /**
   * Groups list of group rules
   *
   * @schema VmRuleSpec#groups
   */
  readonly groups: VmRuleSpecGroups[];

}

/**
 * Converts an object of type 'VmRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmRuleSpec(obj: VmRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groups': obj.groups?.map(y => toJson_VmRuleSpecGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleGroup is a list of sequentially evaluated recording and alerting rules.
 *
 * @schema VmRuleSpecGroups
 */
export interface VmRuleSpecGroups {
  /**
   * Concurrency defines how many rules execute at once.
   *
   * @schema VmRuleSpecGroups#concurrency
   */
  readonly concurrency?: number;

  /**
   * Optional
   * The evaluation timestamp will be aligned with group's interval,
   * instead of using the actual timestamp that evaluation happens at.
   * It is enabled by default to get more predictable results
   * and to visually align with graphs plotted via Grafana or vmui.
   *
   * @schema VmRuleSpecGroups#eval_alignment
   */
  readonly evalAlignment?: boolean;

  /**
   * Optional
   * Adjust the `time` parameter of group evaluation requests to compensate intentional query delay from the datasource.
   *
   * @schema VmRuleSpecGroups#eval_delay
   */
  readonly evalDelay?: string;

  /**
   * Optional
   * Group will be evaluated at the exact offset in the range of [0...interval].
   *
   * @schema VmRuleSpecGroups#eval_offset
   */
  readonly evalOffset?: string;

  /**
   * ExtraFilterLabels optional list of label filters applied to every rule's
   * request within a group. Is compatible only with VM datasource.
   * See more details [here](https://docs.victoriametrics.com/victoriametrics/#prometheus-querying-api-enhancements)
   * Deprecated: use params instead
   *
   * @schema VmRuleSpecGroups#extra_filter_labels
   */
  readonly extraFilterLabels?: { [key: string]: string };

  /**
   * Headers contains optional HTTP headers added to each rule request
   * Must be in form `header-name: value`
   * For example:
   * headers:
   * - "CustomHeader: foo"
   * - "CustomHeader2: bar"
   *
   * @schema VmRuleSpecGroups#headers
   */
  readonly headers?: string[];

  /**
   * evaluation interval for group
   *
   * @schema VmRuleSpecGroups#interval
   */
  readonly interval?: string;

  /**
   * Labels optional list of labels added to every rule within a group.
   * It has priority over the external labels.
   * Labels are commonly used for adding environment
   * or tenant-specific tag.
   *
   * @schema VmRuleSpecGroups#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Limit the number of alerts an alerting rule and series a recording
   * rule can produce
   *
   * @schema VmRuleSpecGroups#limit
   */
  readonly limit?: number;

  /**
   * Name of group
   *
   * @schema VmRuleSpecGroups#name
   */
  readonly name: string;

  /**
   * NotifierHeaders contains optional HTTP headers added to each alert request which will send to notifier
   * Must be in form `header-name: value`
   * For example:
   * headers:
   * - "CustomHeader: foo"
   * - "CustomHeader2: bar"
   *
   * @schema VmRuleSpecGroups#notifier_headers
   */
  readonly notifierHeaders?: string[];

  /**
   * Params optional HTTP URL parameters added to each rule request
   *
   * @schema VmRuleSpecGroups#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * Rules list of alert rules
   *
   * @schema VmRuleSpecGroups#rules
   */
  readonly rules: VmRuleSpecGroupsRules[];

  /**
   * Tenant id for group, can be used only with enterprise version of vmalert.
   * See more details [here](https://docs.victoriametrics.com/victoriametrics/vmalert/#multitenancy).
   *
   * @schema VmRuleSpecGroups#tenant
   */
  readonly tenant?: string;

  /**
   * Type defines datasource type for enterprise version of vmalert
   * possible values - prometheus,graphite,vlogs
   *
   * @schema VmRuleSpecGroups#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmRuleSpecGroups' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmRuleSpecGroups(obj: VmRuleSpecGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrency': obj.concurrency,
    'eval_alignment': obj.evalAlignment,
    'eval_delay': obj.evalDelay,
    'eval_offset': obj.evalOffset,
    'extra_filter_labels': ((obj.extraFilterLabels) === undefined) ? undefined : (Object.entries(obj.extraFilterLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'headers': obj.headers?.map(y => y),
    'interval': obj.interval,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'limit': obj.limit,
    'name': obj.name,
    'notifier_headers': obj.notifierHeaders?.map(y => y),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'rules': obj.rules?.map(y => toJson_VmRuleSpecGroupsRules(y)),
    'tenant': obj.tenant,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rule describes an alerting or recording rule.
 *
 * @schema VmRuleSpecGroupsRules
 */
export interface VmRuleSpecGroupsRules {
  /**
   * Alert is a name for alert
   *
   * @schema VmRuleSpecGroupsRules#alert
   */
  readonly alert?: string;

  /**
   * Annotations will be added to rule configuration
   *
   * @schema VmRuleSpecGroupsRules#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Debug enables logging for rule
   * it useful for tracking
   *
   * @schema VmRuleSpecGroupsRules#debug
   */
  readonly debug?: boolean;

  /**
   * Expr is query, that will be evaluated at dataSource
   *
   * @schema VmRuleSpecGroupsRules#expr
   */
  readonly expr?: string;

  /**
   * For evaluation interval in time.Duration format
   * 30s, 1m, 1h  or nanoseconds
   *
   * @schema VmRuleSpecGroupsRules#for
   */
  readonly for?: string;

  /**
   * KeepFiringFor will make alert continue firing for this long
   * even when the alerting expression no longer has results.
   * Use time.Duration format, 30s, 1m, 1h  or nanoseconds
   *
   * @schema VmRuleSpecGroupsRules#keep_firing_for
   */
  readonly keepFiringFor?: string;

  /**
   * Labels will be added to rule configuration
   *
   * @schema VmRuleSpecGroupsRules#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Record represents a query, that will be recorded to dataSource
   *
   * @schema VmRuleSpecGroupsRules#record
   */
  readonly record?: string;

  /**
   * UpdateEntriesLimit defines max number of rule's state updates stored in memory.
   * Overrides `-rule.updateEntriesLimit` in vmalert.
   *
   * @schema VmRuleSpecGroupsRules#update_entries_limit
   */
  readonly updateEntriesLimit?: number;

}

/**
 * Converts an object of type 'VmRuleSpecGroupsRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmRuleSpecGroupsRules(obj: VmRuleSpecGroupsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alert': obj.alert,
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'debug': obj.debug,
    'expr': obj.expr,
    'for': obj.for,
    'keep_firing_for': obj.keepFiringFor,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'record': obj.record,
    'update_entries_limit': obj.updateEntriesLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMScrapeConfig specifies a set of targets and parameters describing how to scrape them.
 *
 * @schema VMScrapeConfig
 */
export class VmScrapeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMScrapeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMScrapeConfig',
  }

  /**
   * Renders a Kubernetes manifest for "VMScrapeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmScrapeConfigProps = {}): any {
    return {
      ...VmScrapeConfig.GVK,
      ...toJson_VmScrapeConfigProps(props),
    };
  }

  /**
   * Defines a "VMScrapeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmScrapeConfigProps = {}) {
    super(scope, id, {
      ...VmScrapeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmScrapeConfig.GVK,
      ...toJson_VmScrapeConfigProps(resolved),
    };
  }
}

/**
 * VMScrapeConfig specifies a set of targets and parameters describing how to scrape them.
 *
 * @schema VMScrapeConfig
 */
export interface VmScrapeConfigProps {
  /**
   * @schema VMScrapeConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMScrapeConfigSpec defines the desired state of VMScrapeConfig
   *
   * @schema VMScrapeConfig#spec
   */
  readonly spec?: VmScrapeConfigSpec;

}

/**
 * Converts an object of type 'VmScrapeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigProps(obj: VmScrapeConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmScrapeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeConfigSpec defines the desired state of VMScrapeConfig
 *
 * @schema VmScrapeConfigSpec
 */
export interface VmScrapeConfigSpec {
  /**
   * Authorization with http header Authorization
   *
   * @schema VmScrapeConfigSpec#authorization
   */
  readonly authorization?: VmScrapeConfigSpecAuthorization;

  /**
   * AzureSDConfigs defines a list of Azure service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#azureSDConfigs
   */
  readonly azureSdConfigs?: VmScrapeConfigSpecAzureSdConfigs[];

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpec#basicAuth
   */
  readonly basicAuth?: VmScrapeConfigSpecBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmScrapeConfigSpec#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmScrapeConfigSpec#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmScrapeConfigSpecBearerTokenSecret;

  /**
   * ConsulSDConfigs defines a list of Consul service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#consulSDConfigs
   */
  readonly consulSdConfigs?: VmScrapeConfigSpecConsulSdConfigs[];

  /**
   * DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#digitalOceanSDConfigs
   */
  readonly digitalOceanSdConfigs?: VmScrapeConfigSpecDigitalOceanSdConfigs[];

  /**
   * DNSSDConfigs defines a list of DNS service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#dnsSDConfigs
   */
  readonly dnsSdConfigs?: VmScrapeConfigSpecDnsSdConfigs[];

  /**
   * EC2SDConfigs defines a list of EC2 service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#ec2SDConfigs
   */
  readonly ec2SdConfigs?: VmScrapeConfigSpecEc2SdConfigs[];

  /**
   * FileSDConfigs defines a list of file service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#fileSDConfigs
   */
  readonly fileSdConfigs?: VmScrapeConfigSpecFileSdConfigs[];

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmScrapeConfigSpec#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * GCESDConfigs defines a list of GCE service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#gceSDConfigs
   */
  readonly gceSdConfigs?: VmScrapeConfigSpecGceSdConfigs[];

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmScrapeConfigSpec#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmScrapeConfigSpec#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * HTTPSDConfigs defines a list of HTTP service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#httpSDConfigs
   */
  readonly httpSdConfigs?: VmScrapeConfigSpecHttpSdConfigs[];

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmScrapeConfigSpec#interval
   */
  readonly interval?: string;

  /**
   * KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#kubernetesSDConfigs
   */
  readonly kubernetesSdConfigs?: VmScrapeConfigSpecKubernetesSdConfigs[];

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmScrapeConfigSpec#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmScrapeConfigSpec#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmScrapeConfigSpecMetricRelabelConfigs[];

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmScrapeConfigSpec#oauth2
   */
  readonly oauth2?: VmScrapeConfigSpecOauth2;

  /**
   * OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
   *
   * @schema VmScrapeConfigSpec#openstackSDConfigs
   */
  readonly openstackSdConfigs?: VmScrapeConfigSpecOpenstackSdConfigs[];

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmScrapeConfigSpec#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmScrapeConfigSpec#path
   */
  readonly path?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmScrapeConfigSpec#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmScrapeConfigSpec#relabelConfigs
   */
  readonly relabelConfigs?: VmScrapeConfigSpecRelabelConfigs[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmScrapeConfigSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmScrapeConfigSpec#scheme
   */
  readonly scheme?: VmScrapeConfigSpecScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmScrapeConfigSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmScrapeConfigSpec#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmScrapeConfigSpec#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * StaticConfigs defines a list of static targets with a common label set.
   *
   * @schema VmScrapeConfigSpec#staticConfigs
   */
  readonly staticConfigs?: VmScrapeConfigSpecStaticConfigs[];

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmScrapeConfigSpec#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecTlsConfig;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmScrapeConfigSpec#vm_scrape_params
   */
  readonly vmScrapeParams?: VmScrapeConfigSpecVmScrapeParams;

}

/**
 * Converts an object of type 'VmScrapeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpec(obj: VmScrapeConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmScrapeConfigSpecAuthorization(obj.authorization),
    'azureSDConfigs': obj.azureSdConfigs?.map(y => toJson_VmScrapeConfigSpecAzureSdConfigs(y)),
    'basicAuth': toJson_VmScrapeConfigSpecBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmScrapeConfigSpecBearerTokenSecret(obj.bearerTokenSecret),
    'consulSDConfigs': obj.consulSdConfigs?.map(y => toJson_VmScrapeConfigSpecConsulSdConfigs(y)),
    'digitalOceanSDConfigs': obj.digitalOceanSdConfigs?.map(y => toJson_VmScrapeConfigSpecDigitalOceanSdConfigs(y)),
    'dnsSDConfigs': obj.dnsSdConfigs?.map(y => toJson_VmScrapeConfigSpecDnsSdConfigs(y)),
    'ec2SDConfigs': obj.ec2SdConfigs?.map(y => toJson_VmScrapeConfigSpecEc2SdConfigs(y)),
    'fileSDConfigs': obj.fileSdConfigs?.map(y => toJson_VmScrapeConfigSpecFileSdConfigs(y)),
    'follow_redirects': obj.followRedirects,
    'gceSDConfigs': obj.gceSdConfigs?.map(y => toJson_VmScrapeConfigSpecGceSdConfigs(y)),
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'httpSDConfigs': obj.httpSdConfigs?.map(y => toJson_VmScrapeConfigSpecHttpSdConfigs(y)),
    'interval': obj.interval,
    'kubernetesSDConfigs': obj.kubernetesSdConfigs?.map(y => toJson_VmScrapeConfigSpecKubernetesSdConfigs(y)),
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmScrapeConfigSpecMetricRelabelConfigs(y)),
    'oauth2': toJson_VmScrapeConfigSpecOauth2(obj.oauth2),
    'openstackSDConfigs': obj.openstackSdConfigs?.map(y => toJson_VmScrapeConfigSpecOpenstackSdConfigs(y)),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'proxyURL': obj.proxyUrl,
    'relabelConfigs': obj.relabelConfigs?.map(y => toJson_VmScrapeConfigSpecRelabelConfigs(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'seriesLimit': obj.seriesLimit,
    'staticConfigs': obj.staticConfigs?.map(y => toJson_VmScrapeConfigSpecStaticConfigs(y)),
    'tlsConfig': toJson_VmScrapeConfigSpecTlsConfig(obj.tlsConfig),
    'vm_scrape_params': toJson_VmScrapeConfigSpecVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmScrapeConfigSpecAuthorization
 */
export interface VmScrapeConfigSpecAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmScrapeConfigSpecAuthorization#credentials
   */
  readonly credentials?: VmScrapeConfigSpecAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmScrapeConfigSpecAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmScrapeConfigSpecAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecAuthorization(obj: VmScrapeConfigSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmScrapeConfigSpecAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureSDConfig allow retrieving scrape targets from Azure VMs.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#azure_sd_configs)
 *
 * @schema VmScrapeConfigSpecAzureSdConfigs
 */
export interface VmScrapeConfigSpecAzureSdConfigs {
  /**
   * # The authentication method, either OAuth or ManagedIdentity.
   * See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#authenticationMethod
   */
  readonly authenticationMethod?: VmScrapeConfigSpecAzureSdConfigsAuthenticationMethod;

  /**
   * Optional client ID. Only required with the OAuth authentication method.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#clientID
   */
  readonly clientId?: string;

  /**
   * Optional client secret. Only required with the OAuth authentication method.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#clientSecret
   */
  readonly clientSecret?: VmScrapeConfigSpecAzureSdConfigsClientSecret;

  /**
   * The Azure environment.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#environment
   */
  readonly environment?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#port
   */
  readonly port?: number;

  /**
   * Optional resource group name. Limits discovery to this resource group.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#resourceGroup
   */
  readonly resourceGroup?: string;

  /**
   * The subscription ID. Always required.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#subscriptionID
   */
  readonly subscriptionId: string;

  /**
   * Optional tenant ID. Only required with the OAuth authentication method.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigs#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecAzureSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecAzureSdConfigs(obj: VmScrapeConfigSpecAzureSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationMethod': obj.authenticationMethod,
    'clientID': obj.clientId,
    'clientSecret': toJson_VmScrapeConfigSpecAzureSdConfigsClientSecret(obj.clientSecret),
    'environment': obj.environment,
    'port': obj.port,
    'resourceGroup': obj.resourceGroup,
    'subscriptionID': obj.subscriptionId,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecBasicAuth
 */
export interface VmScrapeConfigSpecBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecBasicAuth(obj: VmScrapeConfigSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmScrapeConfigSpecBearerTokenSecret
 */
export interface VmScrapeConfigSpecBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecBearerTokenSecret(obj: VmScrapeConfigSpecBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsulSDConfig defines a Consul service discovery configuration.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#consul_sd_configs)
 *
 * @schema VmScrapeConfigSpecConsulSdConfigs
 */
export interface VmScrapeConfigSpecConsulSdConfigs {
  /**
   * Allow stale Consul results (see https://developer.hashicorp.com/consul/api-docs/features/consistency ). Will reduce load on Consul.
   * If unset, use its default value.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#allowStale
   */
  readonly allowStale?: boolean;

  /**
   * Authorization header to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#authorization
   */
  readonly authorization?: VmScrapeConfigSpecConsulSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#basicAuth
   */
  readonly basicAuth?: VmScrapeConfigSpecConsulSdConfigsBasicAuth;

  /**
   * Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#datacenter
   */
  readonly datacenter?: string;

  /**
   * Filter defines filter for /v1/catalog/services requests
   * See https://developer.hashicorp.com/consul/api-docs/features/filtering
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#filter
   */
  readonly filter?: string;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   * If unset, use its default value.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Namespaces are only supported in Consul Enterprise.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#namespace
   */
  readonly namespace?: string;

  /**
   * Node metadata key/value pairs to filter nodes for a given service.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#nodeMeta
   */
  readonly nodeMeta?: { [key: string]: string };

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#oauth2
   */
  readonly oauth2?: VmScrapeConfigSpecConsulSdConfigsOauth2;

  /**
   * Admin Partitions are only supported in Consul Enterprise.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#partition
   */
  readonly partition?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#proxy_client_config
   */
  readonly proxyClientConfig?: VmScrapeConfigSpecConsulSdConfigsProxyClientConfig;

  /**
   * HTTP Scheme default "http"
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#scheme
   */
  readonly scheme?: VmScrapeConfigSpecConsulSdConfigsScheme;

  /**
   * A valid string consisting of a hostname or IP followed by an optional port number.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#server
   */
  readonly server: string;

  /**
   * A list of services for which targets are retrieved. If omitted, all services are scraped.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#services
   */
  readonly services?: string[];

  /**
   * The string by which Consul tags are joined into the tag label.
   * If unset, use its default value.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#tags
   */
  readonly tags?: string[];

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecConsulSdConfigsTlsConfig;

  /**
   * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigs#tokenRef
   */
  readonly tokenRef?: VmScrapeConfigSpecConsulSdConfigsTokenRef;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigs(obj: VmScrapeConfigSpecConsulSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowStale': obj.allowStale,
    'authorization': toJson_VmScrapeConfigSpecConsulSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuth(obj.basicAuth),
    'datacenter': obj.datacenter,
    'filter': obj.filter,
    'followRedirects': obj.followRedirects,
    'namespace': obj.namespace,
    'nodeMeta': ((obj.nodeMeta) === undefined) ? undefined : (Object.entries(obj.nodeMeta).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'oauth2': toJson_VmScrapeConfigSpecConsulSdConfigsOauth2(obj.oauth2),
    'partition': obj.partition,
    'proxyURL': obj.proxyUrl,
    'proxy_client_config': toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfig(obj.proxyClientConfig),
    'scheme': obj.scheme,
    'server': obj.server,
    'services': obj.services?.map(y => y),
    'tagSeparator': obj.tagSeparator,
    'tags': obj.tags?.map(y => y),
    'tlsConfig': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfig(obj.tlsConfig),
    'tokenRef': toJson_VmScrapeConfigSpecConsulSdConfigsTokenRef(obj.tokenRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DigitalOceanSDConfig allow retrieving scrape targets from DigitalOcean's Droplets API.
 * This service discovery uses the public IPv4 address by default, by that can be changed with relabeling.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#digitalocean_sd_configs)
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigs
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigs {
  /**
   * Authorization header to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#authorization
   */
  readonly authorization?: VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#oauth2
   */
  readonly oauth2?: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2;

  /**
   * The port to scrape metrics from.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#proxy_client_config
   */
  readonly proxyClientConfig?: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigs#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigs(obj: VmScrapeConfigSpecDigitalOceanSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization(obj.authorization),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2(obj.oauth2),
    'port': obj.port,
    'proxyURL': obj.proxyUrl,
    'proxy_client_config': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig(obj.proxyClientConfig),
    'tlsConfig': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
 * The DNS servers to be contacted are read from /etc/resolv.conf.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#dns_sd_configs)
 *
 * @schema VmScrapeConfigSpecDnsSdConfigs
 */
export interface VmScrapeConfigSpecDnsSdConfigs {
  /**
   * A list of DNS domain names to be queried.
   *
   * @schema VmScrapeConfigSpecDnsSdConfigs#names
   */
  readonly names: string[];

  /**
   * The port number used if the query type is not SRV
   * Ignored for SRV records
   *
   * @schema VmScrapeConfigSpecDnsSdConfigs#port
   */
  readonly port?: number;

  /**
   * @schema VmScrapeConfigSpecDnsSdConfigs#type
   */
  readonly type?: VmScrapeConfigSpecDnsSdConfigsType;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDnsSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDnsSdConfigs(obj: VmScrapeConfigSpecDnsSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'names': obj.names?.map(y => y),
    'port': obj.port,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EC2SDConfig allow retrieving scrape targets from AWS EC2 instances.
 * The private IP address is used by default, but may be changed to the public IP address with relabeling.
 * The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#ec2_sd_configs)
 *
 * @schema VmScrapeConfigSpecEc2SdConfigs
 */
export interface VmScrapeConfigSpecEc2SdConfigs {
  /**
   * AccessKey is the AWS API key.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#accessKey
   */
  readonly accessKey?: VmScrapeConfigSpecEc2SdConfigsAccessKey;

  /**
   * Filters can be used optionally to filter the instance list by other criteria.
   * Available filter criteria can be found here:
   * https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html
   * Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#filters
   */
  readonly filters?: VmScrapeConfigSpecEc2SdConfigsFilters[];

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#port
   */
  readonly port?: number;

  /**
   * The AWS region
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#region
   */
  readonly region?: string;

  /**
   * AWS Role ARN, an alternative to using AWS API keys.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#roleARN
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigs#secretKey
   */
  readonly secretKey?: VmScrapeConfigSpecEc2SdConfigsSecretKey;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecEc2SdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecEc2SdConfigs(obj: VmScrapeConfigSpecEc2SdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_VmScrapeConfigSpecEc2SdConfigsAccessKey(obj.accessKey),
    'filters': obj.filters?.map(y => toJson_VmScrapeConfigSpecEc2SdConfigsFilters(y)),
    'port': obj.port,
    'region': obj.region,
    'roleARN': obj.roleArn,
    'secretKey': toJson_VmScrapeConfigSpecEc2SdConfigsSecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FileSDConfig defines a file service discovery configuration.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#file_sd_configs)
 *
 * @schema VmScrapeConfigSpecFileSdConfigs
 */
export interface VmScrapeConfigSpecFileSdConfigs {
  /**
   * List of files to be used for file discovery.
   *
   * @schema VmScrapeConfigSpecFileSdConfigs#files
   */
  readonly files: string[];

}

/**
 * Converts an object of type 'VmScrapeConfigSpecFileSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecFileSdConfigs(obj: VmScrapeConfigSpecFileSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'files': obj.files?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCESDConfig configures scrape targets from GCP GCE instances.
 * The private IP address is used by default, but may be changed to
 * the public IP address with relabeling.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#gce_sd_configs)
 *
 * The GCE service discovery will load the Google Cloud credentials
 * from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.
 * See https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform
 *
 * @schema VmScrapeConfigSpecGceSdConfigs
 */
export interface VmScrapeConfigSpecGceSdConfigs {
  /**
   * Filter can be used optionally to filter the instance list by other criteria
   * Syntax of this filter is described in the filter query parameter section:
   * https://cloud.google.com/compute/docs/reference/latest/instances/list
   *
   * @schema VmScrapeConfigSpecGceSdConfigs#filter
   */
  readonly filter?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema VmScrapeConfigSpecGceSdConfigs#port
   */
  readonly port?: number;

  /**
   * The Google Cloud Project ID
   *
   * @schema VmScrapeConfigSpecGceSdConfigs#project
   */
  readonly project: string;

  /**
   * The tag separator is used to separate the tags on concatenation
   *
   * @schema VmScrapeConfigSpecGceSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
   *
   * @schema VmScrapeConfigSpecGceSdConfigs#zone
   */
  readonly zone: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecGceSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecGceSdConfigs(obj: VmScrapeConfigSpecGceSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'port': obj.port,
    'project': obj.project,
    'tagSeparator': obj.tagSeparator,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPSDConfig defines a HTTP service discovery configuration.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#http_sd_configs)
 *
 * @schema VmScrapeConfigSpecHttpSdConfigs
 */
export interface VmScrapeConfigSpecHttpSdConfigs {
  /**
   * Authorization header to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#authorization
   */
  readonly authorization?: VmScrapeConfigSpecHttpSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#basicAuth
   */
  readonly basicAuth?: VmScrapeConfigSpecHttpSdConfigsBasicAuth;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#proxy_client_config
   */
  readonly proxyClientConfig?: VmScrapeConfigSpecHttpSdConfigsProxyClientConfig;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecHttpSdConfigsTlsConfig;

  /**
   * URL from which the targets are fetched.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigs#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigs(obj: VmScrapeConfigSpecHttpSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmScrapeConfigSpecHttpSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuth(obj.basicAuth),
    'proxyURL': obj.proxyUrl,
    'proxy_client_config': toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfig(obj.proxyClientConfig),
    'tlsConfig': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#kubernetes_sd_configs)
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigs
 */
export interface VmScrapeConfigSpecKubernetesSdConfigs {
  /**
   * The API server address consisting of a hostname or IP address followed
   * by an optional port number.
   * If left empty, assuming process is running inside
   * of the cluster. It will discover API servers automatically and use the pod's
   * CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#apiServer
   */
  readonly apiServer?: string;

  /**
   * AttachMetadata configures metadata attaching from service discovery
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#attach_metadata
   */
  readonly attachMetadata?: VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata;

  /**
   * Authorization header to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#authorization
   */
  readonly authorization?: VmScrapeConfigSpecKubernetesSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#basicAuth
   */
  readonly basicAuth?: VmScrapeConfigSpecKubernetesSdConfigsBasicAuth;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Optional namespace discovery. If omitted, discover targets across all namespaces.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#namespaces
   */
  readonly namespaces?: VmScrapeConfigSpecKubernetesSdConfigsNamespaces;

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#oauth2
   */
  readonly oauth2?: VmScrapeConfigSpecKubernetesSdConfigsOauth2;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#proxy_client_config
   */
  readonly proxyClientConfig?: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig;

  /**
   * Role of the Kubernetes entities that should be discovered.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#role
   */
  readonly role: string;

  /**
   * Selector to select objects.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#selectors
   */
  readonly selectors?: VmScrapeConfigSpecKubernetesSdConfigsSelectors[];

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigs#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigs(obj: VmScrapeConfigSpecKubernetesSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiServer': obj.apiServer,
    'attach_metadata': toJson_VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata(obj.attachMetadata),
    'authorization': toJson_VmScrapeConfigSpecKubernetesSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuth(obj.basicAuth),
    'followRedirects': obj.followRedirects,
    'namespaces': toJson_VmScrapeConfigSpecKubernetesSdConfigsNamespaces(obj.namespaces),
    'oauth2': toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'proxy_client_config': toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig(obj.proxyClientConfig),
    'role': obj.role,
    'selectors': obj.selectors?.map(y => toJson_VmScrapeConfigSpecKubernetesSdConfigsSelectors(y)),
    'tlsConfig': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmScrapeConfigSpecMetricRelabelConfigs
 */
export interface VmScrapeConfigSpecMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmScrapeConfigSpecMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecMetricRelabelConfigs(obj: VmScrapeConfigSpecMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmScrapeConfigSpecOauth2
 */
export interface VmScrapeConfigSpecOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmScrapeConfigSpecOauth2#client_id
   */
  readonly clientId: VmScrapeConfigSpecOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmScrapeConfigSpecOauth2#client_secret
   */
  readonly clientSecret?: VmScrapeConfigSpecOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmScrapeConfigSpecOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmScrapeConfigSpecOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmScrapeConfigSpecOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmScrapeConfigSpecOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOauth2(obj: VmScrapeConfigSpecOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmScrapeConfigSpecOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmScrapeConfigSpecOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#openstack_sd_configs)
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigs
 */
export interface VmScrapeConfigSpecOpenstackSdConfigs {
  /**
   * Whether the service discovery should list all instances for all projects.
   * It is only relevant for the 'instance' role and usually requires admin permissions.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#allTenants
   */
  readonly allTenants?: boolean;

  /**
   * ApplicationCredentialID
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#applicationCredentialId
   */
  readonly applicationCredentialId?: string;

  /**
   * The ApplicationCredentialID or ApplicationCredentialName fields are
   * required if using an application credential to authenticate. Some providers
   * allow you to create an application credential to authenticate rather than a
   * password.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#applicationCredentialName
   */
  readonly applicationCredentialName?: string;

  /**
   * The applicationCredentialSecret field is required if using an application
   * credential to authenticate.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#applicationCredentialSecret
   */
  readonly applicationCredentialSecret?: VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret;

  /**
   * Availability of the endpoint to connect to.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#availability
   */
  readonly availability?: VmScrapeConfigSpecOpenstackSdConfigsAvailability;

  /**
   * DomainID
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#domainID
   */
  readonly domainId?: string;

  /**
   * At most one of domainId and domainName must be provided if using username
   * with Identity V3. Otherwise, either are optional.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#domainName
   */
  readonly domainName?: string;

  /**
   * IdentityEndpoint specifies the HTTP endpoint that is required to work with
   * the Identity API of the appropriate version.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#identityEndpoint
   */
  readonly identityEndpoint?: string;

  /**
   * Password for the Identity V2 and V3 APIs. Consult with your provider's
   * control panel to discover your account's preferred method of authentication.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#password
   */
  readonly password?: VmScrapeConfigSpecOpenstackSdConfigsPassword;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProjectID
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#projectID
   */
  readonly projectId?: string;

  /**
   * The ProjectId and ProjectName fields are optional for the Identity V2 API.
   * Some providers allow you to specify a ProjectName instead of the ProjectId.
   * Some require both. Your provider's authentication policies will determine
   * how these fields influence authentication.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#projectName
   */
  readonly projectName?: string;

  /**
   * The OpenStack Region.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#region
   */
  readonly region: string;

  /**
   * The OpenStack role of entities that should be discovered.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#role
   */
  readonly role: VmScrapeConfigSpecOpenstackSdConfigsRole;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#tlsConfig
   */
  readonly tlsConfig?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfig;

  /**
   * UserID
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#userid
   */
  readonly userid?: string;

  /**
   * Username is required if using Identity V2 API. Consult with your provider's
   * control panel to discover your account's username.
   * In Identity V3, either userid or a combination of username
   * and domainId or domainName are needed
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigs#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigs(obj: VmScrapeConfigSpecOpenstackSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allTenants': obj.allTenants,
    'applicationCredentialId': obj.applicationCredentialId,
    'applicationCredentialName': obj.applicationCredentialName,
    'applicationCredentialSecret': toJson_VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(obj.applicationCredentialSecret),
    'availability': obj.availability,
    'domainID': obj.domainId,
    'domainName': obj.domainName,
    'identityEndpoint': obj.identityEndpoint,
    'password': toJson_VmScrapeConfigSpecOpenstackSdConfigsPassword(obj.password),
    'port': obj.port,
    'projectID': obj.projectId,
    'projectName': obj.projectName,
    'region': obj.region,
    'role': obj.role,
    'tlsConfig': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfig(obj.tlsConfig),
    'userid': obj.userid,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmScrapeConfigSpecRelabelConfigs
 */
export interface VmScrapeConfigSpecRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmScrapeConfigSpecRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmScrapeConfigSpecRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmScrapeConfigSpecRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmScrapeConfigSpecRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecRelabelConfigs(obj: VmScrapeConfigSpecRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmScrapeConfigSpecScheme
 */
export enum VmScrapeConfigSpecScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * StaticConfig defines a static configuration.
 * See [here](https://docs.victoriametrics.com/victoriametrics/sd_configs/#static_configs)
 *
 * @schema VmScrapeConfigSpecStaticConfigs
 */
export interface VmScrapeConfigSpecStaticConfigs {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema VmScrapeConfigSpecStaticConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * List of targets for this static configuration.
   *
   * @schema VmScrapeConfigSpecStaticConfigs#targets
   */
  readonly targets?: string[];

}

/**
 * Converts an object of type 'VmScrapeConfigSpecStaticConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecStaticConfigs(obj: VmScrapeConfigSpecStaticConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmScrapeConfigSpecTlsConfig
 */
export interface VmScrapeConfigSpecTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfig(obj: VmScrapeConfigSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmScrapeConfigSpecVmScrapeParams
 */
export interface VmScrapeConfigSpecVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmScrapeConfigSpecVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmScrapeConfigSpecVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmScrapeConfigSpecVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmScrapeConfigSpecVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmScrapeConfigSpecVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmScrapeConfigSpecVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmScrapeConfigSpecVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmScrapeConfigSpecVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmScrapeConfigSpecVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParams(obj: VmScrapeConfigSpecVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmScrapeConfigSpecAuthorizationCredentials
 */
export interface VmScrapeConfigSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecAuthorizationCredentials(obj: VmScrapeConfigSpecAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * # The authentication method, either OAuth or ManagedIdentity.
 * See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 *
 * @schema VmScrapeConfigSpecAzureSdConfigsAuthenticationMethod
 */
export enum VmScrapeConfigSpecAzureSdConfigsAuthenticationMethod {
  /** OAuth */
  O_AUTH = "OAuth",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
}

/**
 * Optional client secret. Only required with the OAuth authentication method.
 *
 * @schema VmScrapeConfigSpecAzureSdConfigsClientSecret
 */
export interface VmScrapeConfigSpecAzureSdConfigsClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecAzureSdConfigsClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecAzureSdConfigsClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecAzureSdConfigsClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecAzureSdConfigsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecAzureSdConfigsClientSecret(obj: VmScrapeConfigSpecAzureSdConfigsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecBasicAuthPassword
 */
export interface VmScrapeConfigSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecBasicAuthPassword(obj: VmScrapeConfigSpecBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecBasicAuthUsername
 */
export interface VmScrapeConfigSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecBasicAuthUsername(obj: VmScrapeConfigSpecBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsAuthorization
 */
export interface VmScrapeConfigSpecConsulSdConfigsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorization#credentials
   */
  readonly credentials?: VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsAuthorization(obj: VmScrapeConfigSpecConsulSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuth
 */
export interface VmScrapeConfigSpecConsulSdConfigsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuth(obj: VmScrapeConfigSpecConsulSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsOauth2
 */
export interface VmScrapeConfigSpecConsulSdConfigsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#client_id
   */
  readonly clientId: VmScrapeConfigSpecConsulSdConfigsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#client_secret
   */
  readonly clientSecret?: VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsOauth2(obj: VmScrapeConfigSpecConsulSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfig
 */
export interface VmScrapeConfigSpecConsulSdConfigsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken;

  /**
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfig(obj: VmScrapeConfigSpecConsulSdConfigsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Scheme default "http"
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsScheme
 */
export enum VmScrapeConfigSpecConsulSdConfigsScheme {
  /** HTTP */
  HTTP = "HTTP",
  /** HTTPS */
  HTTPS = "HTTPS",
}

/**
 * TLS configuration to use on every scrape request
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfig(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTokenRef
 */
export interface VmScrapeConfigSpecConsulSdConfigsTokenRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTokenRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTokenRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTokenRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTokenRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTokenRef(obj: VmScrapeConfigSpecConsulSdConfigsTokenRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization#credentials
   */
  readonly credentials?: VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization(obj: VmScrapeConfigSpecDigitalOceanSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#client_id
   */
  readonly clientId: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#client_secret
   */
  readonly clientSecret?: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2(obj: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken;

  /**
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig(obj: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmScrapeConfigSpecDnsSdConfigsType
 */
export enum VmScrapeConfigSpecDnsSdConfigsType {
  /** SRV */
  SRV = "SRV",
  /** A */
  A = "A",
  /** AAAA */
  AAAA = "AAAA",
  /** MX */
  MX = "MX",
}

/**
 * AccessKey is the AWS API key.
 *
 * @schema VmScrapeConfigSpecEc2SdConfigsAccessKey
 */
export interface VmScrapeConfigSpecEc2SdConfigsAccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsAccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsAccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecEc2SdConfigsAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecEc2SdConfigsAccessKey(obj: VmScrapeConfigSpecEc2SdConfigsAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EC2Filter is the configuration for filtering EC2 instances.
 *
 * @schema VmScrapeConfigSpecEc2SdConfigsFilters
 */
export interface VmScrapeConfigSpecEc2SdConfigsFilters {
  /**
   * @schema VmScrapeConfigSpecEc2SdConfigsFilters#name
   */
  readonly name: string;

  /**
   * @schema VmScrapeConfigSpecEc2SdConfigsFilters#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'VmScrapeConfigSpecEc2SdConfigsFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecEc2SdConfigsFilters(obj: VmScrapeConfigSpecEc2SdConfigsFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the AWS API secret.
 *
 * @schema VmScrapeConfigSpecEc2SdConfigsSecretKey
 */
export interface VmScrapeConfigSpecEc2SdConfigsSecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsSecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsSecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecEc2SdConfigsSecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecEc2SdConfigsSecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecEc2SdConfigsSecretKey(obj: VmScrapeConfigSpecEc2SdConfigsSecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsAuthorization
 */
export interface VmScrapeConfigSpecHttpSdConfigsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorization#credentials
   */
  readonly credentials?: VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsAuthorization(obj: VmScrapeConfigSpecHttpSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuth
 */
export interface VmScrapeConfigSpecHttpSdConfigsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuth(obj: VmScrapeConfigSpecHttpSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfig
 */
export interface VmScrapeConfigSpecHttpSdConfigsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken;

  /**
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfig(obj: VmScrapeConfigSpecHttpSdConfigsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfig(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttachMetadata configures metadata attaching from service discovery
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata {
  /**
   * Node instructs vmagent to add node specific metadata from service discovery
   * Valid for roles: pod, endpoints, endpointslice.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata(obj: VmScrapeConfigSpecKubernetesSdConfigsAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorization
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorization#credentials
   */
  readonly credentials?: VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsAuthorization(obj: VmScrapeConfigSpecKubernetesSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuth
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuth(obj: VmScrapeConfigSpecKubernetesSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional namespace discovery. If omitted, discover targets across all namespaces.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsNamespaces
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsNamespaces {
  /**
   * List of namespaces where to watch for resources.
   * If empty and `ownNamespace` isn't true, watch for resources in all namespaces.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsNamespaces#names
   */
  readonly names?: string[];

  /**
   * Includes the namespace in which the pod exists to the list of watched namespaces.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsNamespaces#ownNamespace
   */
  readonly ownNamespace?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsNamespaces' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsNamespaces(obj: VmScrapeConfigSpecKubernetesSdConfigsNamespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'names': obj.names?.map(y => y),
    'ownNamespace': obj.ownNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#client_id
   */
  readonly clientId: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#client_secret
   */
  readonly clientSecret?: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2(obj: VmScrapeConfigSpecKubernetesSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken;

  /**
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig(obj: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * K8SSelectorConfig is Kubernetes Selector Config
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsSelectors
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsSelectors {
  /**
   * @schema VmScrapeConfigSpecKubernetesSdConfigsSelectors#field
   */
  readonly field?: string;

  /**
   * @schema VmScrapeConfigSpecKubernetesSdConfigsSelectors#label
   */
  readonly label?: string;

  /**
   * @schema VmScrapeConfigSpecKubernetesSdConfigsSelectors#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsSelectors(obj: VmScrapeConfigSpecKubernetesSdConfigsSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'label': obj.label,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfig(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmScrapeConfigSpecOauth2ClientId
 */
export interface VmScrapeConfigSpecOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOauth2ClientId#configMap
   */
  readonly configMap?: VmScrapeConfigSpecOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOauth2ClientId#secret
   */
  readonly secret?: VmScrapeConfigSpecOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOauth2ClientId(obj: VmScrapeConfigSpecOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmScrapeConfigSpecOauth2ClientSecret
 */
export interface VmScrapeConfigSpecOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOauth2ClientSecret(obj: VmScrapeConfigSpecOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The applicationCredentialSecret field is required if using an application
 * credential to authenticate.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(obj: VmScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Availability of the endpoint to connect to.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsAvailability
 */
export enum VmScrapeConfigSpecOpenstackSdConfigsAvailability {
  /** Public */
  PUBLIC = "Public",
  /** Admin */
  ADMIN = "Admin",
  /** Internal */
  INTERNAL = "Internal",
}

/**
 * Password for the Identity V2 and V3 APIs. Consult with your provider's
 * control panel to discover your account's preferred method of authentication.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsPassword
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsPassword(obj: VmScrapeConfigSpecOpenstackSdConfigsPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The OpenStack role of entities that should be discovered.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsRole
 */
export enum VmScrapeConfigSpecOpenstackSdConfigsRole {
  /** Instance */
  INSTANCE = "Instance",
  /** Hypervisor */
  HYPERVISOR = "Hypervisor",
}

/**
 * TLS configuration to use on every scrape request
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#ca
   */
  readonly ca?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#cert
   */
  readonly cert?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfig(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCa
 */
export interface VmScrapeConfigSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCa(obj: VmScrapeConfigSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCert
 */
export interface VmScrapeConfigSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCert(obj: VmScrapeConfigSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigKeySecret(obj: VmScrapeConfigSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfig
 */
export interface VmScrapeConfigSpecVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfig(obj: VmScrapeConfigSpecVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials
 */
export interface VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(obj: VmScrapeConfigSpecConsulSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword
 */
export interface VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword(obj: VmScrapeConfigSpecConsulSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername
 */
export interface VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername(obj: VmScrapeConfigSpecConsulSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientId
 */
export interface VmScrapeConfigSpecConsulSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientId#secret
   */
  readonly secret?: VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientId(obj: VmScrapeConfigSpecConsulSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret
 */
export interface VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(obj: VmScrapeConfigSpecConsulSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth
 */
export interface VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth(obj: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken
 */
export interface VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken(obj: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCa
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCa(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCert
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCert(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials(obj: VmScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId#secret
   */
  readonly secret?: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId(obj: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret(obj: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth(obj: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken(obj: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials
 */
export interface VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(obj: VmScrapeConfigSpecHttpSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword
 */
export interface VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword(obj: VmScrapeConfigSpecHttpSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername
 */
export interface VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername(obj: VmScrapeConfigSpecHttpSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth
 */
export interface VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth(obj: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken
 */
export interface VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken(obj: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCa
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCa(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCert
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCert(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(obj: VmScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(obj: VmScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(obj: VmScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#secret
   */
  readonly secret?: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(obj: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(obj: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth(obj: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken(obj: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOauth2ClientIdConfigMap
 */
export interface VmScrapeConfigSpecOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOauth2ClientIdConfigMap(obj: VmScrapeConfigSpecOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOauth2ClientIdSecret
 */
export interface VmScrapeConfigSpecOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOauth2ClientIdSecret(obj: VmScrapeConfigSpecOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#secret
   */
  readonly secret?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#secret
   */
  readonly secret?: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCaConfigMap(obj: VmScrapeConfigSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCaSecret(obj: VmScrapeConfigSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCertConfigMap(obj: VmScrapeConfigSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecTlsConfigCertSecret(obj: VmScrapeConfigSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth(obj: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken(obj: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap
 */
export interface VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(obj: VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret
 */
export interface VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(obj: VmScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword
 */
export interface VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword(obj: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername
 */
export interface VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername(obj: VmScrapeConfigSpecConsulSdConfigsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(obj: VmScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap(obj: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret(obj: VmScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword(obj: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername(obj: VmScrapeConfigSpecDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret(obj: VmScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword
 */
export interface VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword(obj: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername
 */
export interface VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername(obj: VmScrapeConfigSpecHttpSdConfigsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(obj: VmScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(obj: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(obj: VmScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword(obj: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername(obj: VmScrapeConfigSpecKubernetesSdConfigsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(obj: VmScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret
 */
export interface VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(obj: VmScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmScrapeConfigSpecVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMServiceScrape is scrape configuration for endpoints associated with
kubernetes service,
it generates scrape configuration for vmagent based on selectors.
result config will scrape service endpoints
 *
 * @schema VMServiceScrape
 */
export class VmServiceScrape extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMServiceScrape"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMServiceScrape',
  }

  /**
   * Renders a Kubernetes manifest for "VMServiceScrape".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmServiceScrapeProps): any {
    return {
      ...VmServiceScrape.GVK,
      ...toJson_VmServiceScrapeProps(props),
    };
  }

  /**
   * Defines a "VMServiceScrape" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmServiceScrapeProps) {
    super(scope, id, {
      ...VmServiceScrape.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmServiceScrape.GVK,
      ...toJson_VmServiceScrapeProps(resolved),
    };
  }
}

/**
 * VMServiceScrape is scrape configuration for endpoints associated with
 * kubernetes service,
 * it generates scrape configuration for vmagent based on selectors.
 * result config will scrape service endpoints
 *
 * @schema VMServiceScrape
 */
export interface VmServiceScrapeProps {
  /**
   * @schema VMServiceScrape#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMServiceScrapeSpec defines the desired state of VMServiceScrape
   *
   * @schema VMServiceScrape#spec
   */
  readonly spec: VmServiceScrapeSpec;

}

/**
 * Converts an object of type 'VmServiceScrapeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeProps(obj: VmServiceScrapeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmServiceScrapeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMServiceScrapeSpec defines the desired state of VMServiceScrape
 *
 * @schema VmServiceScrapeSpec
 */
export interface VmServiceScrapeSpec {
  /**
   * AttachMetadata configures metadata attaching from service discovery
   *
   * @schema VmServiceScrapeSpec#attach_metadata
   */
  readonly attachMetadata?: VmServiceScrapeSpecAttachMetadata;

  /**
   * DiscoveryRole - defines kubernetes_sd role for objects discovery.
   * by default, its endpoints.
   * can be changed to service or endpointslices.
   * note, that with service setting, you have to use port: "name"
   * and cannot use targetPort for endpoints.
   *
   * @schema VmServiceScrapeSpec#discoveryRole
   */
  readonly discoveryRole?: VmServiceScrapeSpecDiscoveryRole;

  /**
   * A list of endpoints allowed as part of this ServiceScrape.
   *
   * @schema VmServiceScrapeSpec#endpoints
   */
  readonly endpoints: VmServiceScrapeSpecEndpoints[];

  /**
   * The label to use to retrieve the job name from.
   *
   * @schema VmServiceScrapeSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Selector to select which namespaces the Endpoints objects are discovered from.
   *
   * @schema VmServiceScrapeSpec#namespaceSelector
   */
  readonly namespaceSelector?: VmServiceScrapeSpecNamespaceSelector;

  /**
   * PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
   *
   * @schema VmServiceScrapeSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmServiceScrapeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Selector to select Endpoints objects by corresponding Service labels.
   *
   * @schema VmServiceScrapeSpec#selector
   */
  readonly selector?: VmServiceScrapeSpecSelector;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmServiceScrapeSpec#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * TargetLabels transfers labels on the Kubernetes Service onto the target.
   *
   * @schema VmServiceScrapeSpec#targetLabels
   */
  readonly targetLabels?: string[];

}

/**
 * Converts an object of type 'VmServiceScrapeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpec(obj: VmServiceScrapeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attach_metadata': toJson_VmServiceScrapeSpecAttachMetadata(obj.attachMetadata),
    'discoveryRole': obj.discoveryRole,
    'endpoints': obj.endpoints?.map(y => toJson_VmServiceScrapeSpecEndpoints(y)),
    'jobLabel': obj.jobLabel,
    'namespaceSelector': toJson_VmServiceScrapeSpecNamespaceSelector(obj.namespaceSelector),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'sampleLimit': obj.sampleLimit,
    'selector': toJson_VmServiceScrapeSpecSelector(obj.selector),
    'seriesLimit': obj.seriesLimit,
    'targetLabels': obj.targetLabels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttachMetadata configures metadata attaching from service discovery
 *
 * @schema VmServiceScrapeSpecAttachMetadata
 */
export interface VmServiceScrapeSpecAttachMetadata {
  /**
   * Node instructs vmagent to add node specific metadata from service discovery
   * Valid for roles: pod, endpoints, endpointslice.
   *
   * @schema VmServiceScrapeSpecAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecAttachMetadata(obj: VmServiceScrapeSpecAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DiscoveryRole - defines kubernetes_sd role for objects discovery.
 * by default, its endpoints.
 * can be changed to service or endpointslices.
 * note, that with service setting, you have to use port: "name"
 * and cannot use targetPort for endpoints.
 *
 * @schema VmServiceScrapeSpecDiscoveryRole
 */
export enum VmServiceScrapeSpecDiscoveryRole {
  /** endpoints */
  ENDPOINTS = "endpoints",
  /** service */
  SERVICE = "service",
  /** endpointslices */
  ENDPOINTSLICES = "endpointslices",
}

/**
 * Endpoint defines a scrapeable endpoint serving metrics.
 *
 * @schema VmServiceScrapeSpecEndpoints
 */
export interface VmServiceScrapeSpecEndpoints {
  /**
   * AttachMetadata configures metadata attaching from service discovery
   *
   * @schema VmServiceScrapeSpecEndpoints#attach_metadata
   */
  readonly attachMetadata?: VmServiceScrapeSpecEndpointsAttachMetadata;

  /**
   * Authorization with http header Authorization
   *
   * @schema VmServiceScrapeSpecEndpoints#authorization
   */
  readonly authorization?: VmServiceScrapeSpecEndpointsAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmServiceScrapeSpecEndpoints#basicAuth
   */
  readonly basicAuth?: VmServiceScrapeSpecEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmServiceScrapeSpecEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmServiceScrapeSpecEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmServiceScrapeSpecEndpointsBearerTokenSecret;

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmServiceScrapeSpecEndpoints#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmServiceScrapeSpecEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmServiceScrapeSpecEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmServiceScrapeSpecEndpoints#interval
   */
  readonly interval?: string;

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmServiceScrapeSpecEndpoints#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmServiceScrapeSpecEndpoints#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmServiceScrapeSpecEndpointsMetricRelabelConfigs[];

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmServiceScrapeSpecEndpoints#oauth2
   */
  readonly oauth2?: VmServiceScrapeSpecEndpointsOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmServiceScrapeSpecEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmServiceScrapeSpecEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the port exposed at Service.
   *
   * @schema VmServiceScrapeSpecEndpoints#port
   */
  readonly port?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmServiceScrapeSpecEndpoints#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmServiceScrapeSpecEndpoints#relabelConfigs
   */
  readonly relabelConfigs?: VmServiceScrapeSpecEndpointsRelabelConfigs[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmServiceScrapeSpecEndpoints#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmServiceScrapeSpecEndpoints#scheme
   */
  readonly scheme?: VmServiceScrapeSpecEndpointsScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmServiceScrapeSpecEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmServiceScrapeSpecEndpoints#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmServiceScrapeSpecEndpoints#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * TargetPort
   * Name or number of the pod port this endpoint refers to. Mutually exclusive with port.
   *
   * @schema VmServiceScrapeSpecEndpoints#targetPort
   */
  readonly targetPort?: VmServiceScrapeSpecEndpointsTargetPort;

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmServiceScrapeSpecEndpoints#tlsConfig
   */
  readonly tlsConfig?: VmServiceScrapeSpecEndpointsTlsConfig;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmServiceScrapeSpecEndpoints#vm_scrape_params
   */
  readonly vmScrapeParams?: VmServiceScrapeSpecEndpointsVmScrapeParams;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpoints(obj: VmServiceScrapeSpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attach_metadata': toJson_VmServiceScrapeSpecEndpointsAttachMetadata(obj.attachMetadata),
    'authorization': toJson_VmServiceScrapeSpecEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_VmServiceScrapeSpecEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmServiceScrapeSpecEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'follow_redirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmServiceScrapeSpecEndpointsMetricRelabelConfigs(y)),
    'oauth2': toJson_VmServiceScrapeSpecEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'proxyURL': obj.proxyUrl,
    'relabelConfigs': obj.relabelConfigs?.map(y => toJson_VmServiceScrapeSpecEndpointsRelabelConfigs(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'seriesLimit': obj.seriesLimit,
    'targetPort': obj.targetPort?.value,
    'tlsConfig': toJson_VmServiceScrapeSpecEndpointsTlsConfig(obj.tlsConfig),
    'vm_scrape_params': toJson_VmServiceScrapeSpecEndpointsVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector to select which namespaces the Endpoints objects are discovered from.
 *
 * @schema VmServiceScrapeSpecNamespaceSelector
 */
export interface VmServiceScrapeSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema VmServiceScrapeSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema VmServiceScrapeSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'VmServiceScrapeSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecNamespaceSelector(obj: VmServiceScrapeSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector to select Endpoints objects by corresponding Service labels.
 *
 * @schema VmServiceScrapeSpecSelector
 */
export interface VmServiceScrapeSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmServiceScrapeSpecSelector#matchExpressions
   */
  readonly matchExpressions?: VmServiceScrapeSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmServiceScrapeSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmServiceScrapeSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecSelector(obj: VmServiceScrapeSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmServiceScrapeSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttachMetadata configures metadata attaching from service discovery
 *
 * @schema VmServiceScrapeSpecEndpointsAttachMetadata
 */
export interface VmServiceScrapeSpecEndpointsAttachMetadata {
  /**
   * Node instructs vmagent to add node specific metadata from service discovery
   * Valid for roles: pod, endpoints, endpointslice.
   *
   * @schema VmServiceScrapeSpecEndpointsAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsAttachMetadata(obj: VmServiceScrapeSpecEndpointsAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmServiceScrapeSpecEndpointsAuthorization
 */
export interface VmServiceScrapeSpecEndpointsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorization#credentials
   */
  readonly credentials?: VmServiceScrapeSpecEndpointsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsAuthorization(obj: VmServiceScrapeSpecEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmServiceScrapeSpecEndpointsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmServiceScrapeSpecEndpointsBasicAuth
 */
export interface VmServiceScrapeSpecEndpointsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuth#password
   */
  readonly password?: VmServiceScrapeSpecEndpointsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuth#username
   */
  readonly username?: VmServiceScrapeSpecEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsBasicAuth(obj: VmServiceScrapeSpecEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmServiceScrapeSpecEndpointsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmServiceScrapeSpecEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmServiceScrapeSpecEndpointsBearerTokenSecret
 */
export interface VmServiceScrapeSpecEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsBearerTokenSecret(obj: VmServiceScrapeSpecEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs
 */
export interface VmServiceScrapeSpecEndpointsMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmServiceScrapeSpecEndpointsMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsMetricRelabelConfigs(obj: VmServiceScrapeSpecEndpointsMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmServiceScrapeSpecEndpointsOauth2
 */
export interface VmServiceScrapeSpecEndpointsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#client_id
   */
  readonly clientId: VmServiceScrapeSpecEndpointsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#client_secret
   */
  readonly clientSecret?: VmServiceScrapeSpecEndpointsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsOauth2(obj: VmServiceScrapeSpecEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmServiceScrapeSpecEndpointsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmServiceScrapeSpecEndpointsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmServiceScrapeSpecEndpointsRelabelConfigs
 */
export interface VmServiceScrapeSpecEndpointsRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmServiceScrapeSpecEndpointsRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsRelabelConfigs(obj: VmServiceScrapeSpecEndpointsRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmServiceScrapeSpecEndpointsScheme
 */
export enum VmServiceScrapeSpecEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * TargetPort
 * Name or number of the pod port this endpoint refers to. Mutually exclusive with port.
 *
 * @schema VmServiceScrapeSpecEndpointsTargetPort
 */
export class VmServiceScrapeSpecEndpointsTargetPort {
  public static fromNumber(value: number): VmServiceScrapeSpecEndpointsTargetPort {
    return new VmServiceScrapeSpecEndpointsTargetPort(value);
  }
  public static fromString(value: string): VmServiceScrapeSpecEndpointsTargetPort {
    return new VmServiceScrapeSpecEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfig
 */
export interface VmServiceScrapeSpecEndpointsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#ca
   */
  readonly ca?: VmServiceScrapeSpecEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#cert
   */
  readonly cert?: VmServiceScrapeSpecEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: VmServiceScrapeSpecEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfig(obj: VmServiceScrapeSpecEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmServiceScrapeSpecEndpointsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmServiceScrapeSpecEndpointsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmServiceScrapeSpecEndpointsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParams
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParams(obj: VmServiceScrapeSpecEndpointsVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmServiceScrapeSpecSelectorMatchExpressions
 */
export interface VmServiceScrapeSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmServiceScrapeSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmServiceScrapeSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmServiceScrapeSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmServiceScrapeSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecSelectorMatchExpressions(obj: VmServiceScrapeSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmServiceScrapeSpecEndpointsAuthorizationCredentials
 */
export interface VmServiceScrapeSpecEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsAuthorizationCredentials(obj: VmServiceScrapeSpecEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmServiceScrapeSpecEndpointsBasicAuthPassword
 */
export interface VmServiceScrapeSpecEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsBasicAuthPassword(obj: VmServiceScrapeSpecEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmServiceScrapeSpecEndpointsBasicAuthUsername
 */
export interface VmServiceScrapeSpecEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsBasicAuthUsername(obj: VmServiceScrapeSpecEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmServiceScrapeSpecEndpointsOauth2ClientId
 */
export interface VmServiceScrapeSpecEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientId#secret
   */
  readonly secret?: VmServiceScrapeSpecEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsOauth2ClientId(obj: VmServiceScrapeSpecEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmServiceScrapeSpecEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmServiceScrapeSpecEndpointsOauth2ClientSecret
 */
export interface VmServiceScrapeSpecEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsOauth2ClientSecret(obj: VmServiceScrapeSpecEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCa
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCa#secret
   */
  readonly secret?: VmServiceScrapeSpecEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCa(obj: VmServiceScrapeSpecEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmServiceScrapeSpecEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCert
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCert#secret
   */
  readonly secret?: VmServiceScrapeSpecEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCert(obj: VmServiceScrapeSpecEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmServiceScrapeSpecEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigKeySecret
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigKeySecret(obj: VmServiceScrapeSpecEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig(obj: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap
 */
export interface VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap(obj: VmServiceScrapeSpecEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdSecret
 */
export interface VmServiceScrapeSpecEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsOauth2ClientIdSecret(obj: VmServiceScrapeSpecEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap(obj: VmServiceScrapeSpecEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCaSecret
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCaSecret(obj: VmServiceScrapeSpecEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap(obj: VmServiceScrapeSpecEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmServiceScrapeSpecEndpointsTlsConfigCertSecret
 */
export interface VmServiceScrapeSpecEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsTlsConfigCertSecret(obj: VmServiceScrapeSpecEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmServiceScrapeSpecEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMSingle  is fast, cost-effective and scalable time-series database.
 *
 * @schema VMSingle
 */
export class VmSingle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMSingle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMSingle',
  }

  /**
   * Renders a Kubernetes manifest for "VMSingle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmSingleProps = {}): any {
    return {
      ...VmSingle.GVK,
      ...toJson_VmSingleProps(props),
    };
  }

  /**
   * Defines a "VMSingle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmSingleProps = {}) {
    super(scope, id, {
      ...VmSingle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmSingle.GVK,
      ...toJson_VmSingleProps(resolved),
    };
  }
}

/**
 * VMSingle  is fast, cost-effective and scalable time-series database.
 *
 * @schema VMSingle
 */
export interface VmSingleProps {
  /**
   * @schema VMSingle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMSingleSpec defines the desired state of VMSingle
   *
   * @schema VMSingle#spec
   */
  readonly spec?: VmSingleSpec;

}

/**
 * Converts an object of type 'VmSingleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleProps(obj: VmSingleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmSingleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMSingleSpec defines the desired state of VMSingle
 *
 * @schema VmSingleSpec
 */
export interface VmSingleSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VmSingleSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VmSingleSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VmSingleSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VmSingleSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VmSingleSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VmSingleSpec#dnsConfig
   */
  readonly dnsConfig?: VmSingleSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VmSingleSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VmSingleSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VmSingleSpec#extraEnvs
   */
  readonly extraEnvs?: VmSingleSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmSingleSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmSingleSpecExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VmSingleSpec#hostAliases
   */
  readonly hostAliases?: VmSingleSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VmSingleSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VmSingleSpec#image
   */
  readonly image?: VmSingleSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VmSingleSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VmSingleSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VmSingleSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * InsertPorts - additional listen ports for data ingestion.
   *
   * @schema VmSingleSpec#insertPorts
   */
  readonly insertPorts?: VmSingleSpecInsertPorts;

  /**
   * License allows to configure license key to be used for enterprise features.
   * Using license key is supported starting from VictoriaMetrics v1.94.0.
   * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
   *
   * @schema VmSingleSpec#license
   */
  readonly license?: VmSingleSpecLicense;

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VmSingleSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VMSingle to be configured with.
   *
   * @schema VmSingleSpec#logFormat
   */
  readonly logFormat?: VmSingleSpecLogFormat;

  /**
   * LogLevel for victoria metrics single to be configured with.
   *
   * @schema VmSingleSpec#logLevel
   */
  readonly logLevel?: VmSingleSpecLogLevel;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VmSingleSpec#managedMetadata
   */
  readonly managedMetadata?: VmSingleSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VmSingleSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VmSingleSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VmSingleSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VMSingle pods.
   *
   * @schema VmSingleSpec#podMetadata
   */
  readonly podMetadata?: VmSingleSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VmSingleSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VmSingleSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VmSingleSpec#readinessGates
   */
  readonly readinessGates?: VmSingleSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VmSingleSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * RemovePvcAfterDelete - if true, controller adds ownership to pvc
   * and after VMSingle object deletion - pvc will be garbage collected
   * by controller manager
   *
   * @schema VmSingleSpec#removePvcAfterDelete
   */
  readonly removePvcAfterDelete?: boolean;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VmSingleSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmSingleSpec#resources
   */
  readonly resources?: VmSingleSpecResources;

  /**
   * RetentionPeriod defines how long to retain stored metrics, specified as a duration (e.g., "1d", "1w", "1m").
   * Data with timestamps outside the RetentionPeriod is automatically deleted. The minimum allowed value is 1d, or 24h.
   * The default value is 1 (one month).
   * See [retention](https://docs.victoriametrics.com/victoriametrics/single-server-victoriametrics/#retention) docs for details.
   *
   * @schema VmSingleSpec#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VmSingleSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VmSingleSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VmSingleSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VmSingleSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VmSingleSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VmSingleSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vmsingle VMServiceScrape spec
   *
   * @schema VmSingleSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vmsingle service spec
   *
   * @schema VmSingleSpec#serviceSpec
   */
  readonly serviceSpec?: VmSingleSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VmSingleSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage is the definition of how storage will be used by the VMSingle
   * by default it`s empty dir
   * this option is ignored if storageDataPath is set
   *
   * @schema VmSingleSpec#storage
   */
  readonly storage?: VmSingleSpecStorage;

  /**
   * StorageDataPath disables spec.storage option and overrides arg for victoria-metrics binary --storageDataPath,
   * its users responsibility to mount proper device into given path.
   * It requires to provide spec.volumes and spec.volumeMounts with at least 1 value
   *
   * @schema VmSingleSpec#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * StorageMeta defines annotations and labels attached to PVC for given vmsingle CR
   *
   * @schema VmSingleSpec#storageMetadata
   */
  readonly storageMetadata?: VmSingleSpecStorageMetadata;

  /**
   * StreamAggrConfig defines stream aggregation configuration for VMSingle
   *
   * @schema VmSingleSpec#streamAggrConfig
   */
  readonly streamAggrConfig?: VmSingleSpecStreamAggrConfig;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VmSingleSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VmSingleSpec#tolerations
   */
  readonly tolerations?: VmSingleSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VmSingleSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VmSingleSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VmSingleSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VMBackup configuration for backup
   *
   * @schema VmSingleSpec#vmBackup
   */
  readonly vmBackup?: VmSingleSpecVmBackup;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VmSingleSpec#volumeMounts
   */
  readonly volumeMounts?: VmSingleSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VmSingleSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VmSingleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpec(obj: VmSingleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VmSingleSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmSingleSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmSingleSpecExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VmSingleSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VmSingleSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VmSingleSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'insertPorts': toJson_VmSingleSpecInsertPorts(obj.insertPorts),
    'license': toJson_VmSingleSpecLicense(obj.license),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'managedMetadata': toJson_VmSingleSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podMetadata': toJson_VmSingleSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VmSingleSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'removePvcAfterDelete': obj.removePvcAfterDelete,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VmSingleSpecResources(obj.resources),
    'retentionPeriod': obj.retentionPeriod,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VmSingleSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VmSingleSpecStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'storageMetadata': toJson_VmSingleSpecStorageMetadata(obj.storageMetadata),
    'streamAggrConfig': toJson_VmSingleSpecStreamAggrConfig(obj.streamAggrConfig),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VmSingleSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'vmBackup': toJson_VmSingleSpecVmBackup(obj.vmBackup),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmSingleSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VmSingleSpecDnsConfig
 */
export interface VmSingleSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VmSingleSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VmSingleSpecDnsConfig#options
   */
  readonly options?: VmSingleSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VmSingleSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VmSingleSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecDnsConfig(obj: VmSingleSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VmSingleSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmSingleSpecExtraEnvs
 */
export interface VmSingleSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmSingleSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmSingleSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmSingleSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecExtraEnvs(obj: VmSingleSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmSingleSpecExtraEnvsFrom
 */
export interface VmSingleSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmSingleSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmSingleSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmSingleSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmSingleSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmSingleSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmSingleSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecExtraEnvsFrom(obj: VmSingleSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmSingleSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmSingleSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VmSingleSpecHostAliases
 */
export interface VmSingleSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VmSingleSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VmSingleSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VmSingleSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecHostAliases(obj: VmSingleSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VmSingleSpecImage
 */
export interface VmSingleSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmSingleSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmSingleSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmSingleSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmSingleSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecImage(obj: VmSingleSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VmSingleSpecImagePullSecrets
 */
export interface VmSingleSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmSingleSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecImagePullSecrets(obj: VmSingleSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InsertPorts - additional listen ports for data ingestion.
 *
 * @schema VmSingleSpecInsertPorts
 */
export interface VmSingleSpecInsertPorts {
  /**
   * GraphitePort listen port
   *
   * @schema VmSingleSpecInsertPorts#graphitePort
   */
  readonly graphitePort?: string;

  /**
   * InfluxPort listen port
   *
   * @schema VmSingleSpecInsertPorts#influxPort
   */
  readonly influxPort?: string;

  /**
   * OpenTSDBHTTPPort for http connections.
   *
   * @schema VmSingleSpecInsertPorts#openTSDBHTTPPort
   */
  readonly openTsdbhttpPort?: string;

  /**
   * OpenTSDBPort for tcp and udp listen
   *
   * @schema VmSingleSpecInsertPorts#openTSDBPort
   */
  readonly openTsdbPort?: string;

}

/**
 * Converts an object of type 'VmSingleSpecInsertPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecInsertPorts(obj: VmSingleSpecInsertPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'graphitePort': obj.graphitePort,
    'influxPort': obj.influxPort,
    'openTSDBHTTPPort': obj.openTsdbhttpPort,
    'openTSDBPort': obj.openTsdbPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * License allows to configure license key to be used for enterprise features.
 * Using license key is supported starting from VictoriaMetrics v1.94.0.
 * See [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)
 *
 * @schema VmSingleSpecLicense
 */
export interface VmSingleSpecLicense {
  /**
   * Enforce offline verification of the license key.
   *
   * @schema VmSingleSpecLicense#forceOffline
   */
  readonly forceOffline?: boolean;

  /**
   * Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).
   * To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
   *
   * @schema VmSingleSpecLicense#key
   */
  readonly key?: string;

  /**
   * KeyRef is reference to secret with license key for enterprise features.
   *
   * @schema VmSingleSpecLicense#keyRef
   */
  readonly keyRef?: VmSingleSpecLicenseKeyRef;

  /**
   * Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
   *
   * @schema VmSingleSpecLicense#reloadInterval
   */
  readonly reloadInterval?: string;

}

/**
 * Converts an object of type 'VmSingleSpecLicense' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecLicense(obj: VmSingleSpecLicense | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceOffline': obj.forceOffline,
    'key': obj.key,
    'keyRef': toJson_VmSingleSpecLicenseKeyRef(obj.keyRef),
    'reloadInterval': obj.reloadInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMSingle to be configured with.
 *
 * @schema VmSingleSpecLogFormat
 */
export enum VmSingleSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for victoria metrics single to be configured with.
 *
 * @schema VmSingleSpecLogLevel
 */
export enum VmSingleSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VmSingleSpecManagedMetadata
 */
export interface VmSingleSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmSingleSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmSingleSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmSingleSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecManagedMetadata(obj: VmSingleSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VMSingle pods.
 *
 * @schema VmSingleSpecPodMetadata
 */
export interface VmSingleSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmSingleSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmSingleSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmSingleSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmSingleSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecPodMetadata(obj: VmSingleSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VmSingleSpecReadinessGates
 */
export interface VmSingleSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VmSingleSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VmSingleSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecReadinessGates(obj: VmSingleSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmSingleSpecResources
 */
export interface VmSingleSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmSingleSpecResources#claims
   */
  readonly claims?: VmSingleSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecResources#limits
   */
  readonly limits?: { [key: string]: VmSingleSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecResources#requests
   */
  readonly requests?: { [key: string]: VmSingleSpecResourcesRequests };

}

/**
 * Converts an object of type 'VmSingleSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecResources(obj: VmSingleSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmSingleSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vmsingle service spec
 *
 * @schema VmSingleSpecServiceSpec
 */
export interface VmSingleSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VmSingleSpecServiceSpec#metadata
   */
  readonly metadata?: VmSingleSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VmSingleSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VmSingleSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecServiceSpec(obj: VmSingleSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VmSingleSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage is the definition of how storage will be used by the VMSingle
 * by default it`s empty dir
 * this option is ignored if storageDataPath is set
 *
 * @schema VmSingleSpecStorage
 */
export interface VmSingleSpecStorage {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VmSingleSpecStorage#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VmSingleSpecStorage#dataSource
   */
  readonly dataSource?: VmSingleSpecStorageDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmSingleSpecStorage#dataSourceRef
   */
  readonly dataSourceRef?: VmSingleSpecStorageDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VmSingleSpecStorage#resources
   */
  readonly resources?: VmSingleSpecStorageResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VmSingleSpecStorage#selector
   */
  readonly selector?: VmSingleSpecStorageSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VmSingleSpecStorage#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VmSingleSpecStorage#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VmSingleSpecStorage#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VmSingleSpecStorage#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VmSingleSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorage(obj: VmSingleSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VmSingleSpecStorageDataSource(obj.dataSource),
    'dataSourceRef': toJson_VmSingleSpecStorageDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VmSingleSpecStorageResources(obj.resources),
    'selector': toJson_VmSingleSpecStorageSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StorageMeta defines annotations and labels attached to PVC for given vmsingle CR
 *
 * @schema VmSingleSpecStorageMetadata
 */
export interface VmSingleSpecStorageMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmSingleSpecStorageMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmSingleSpecStorageMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmSingleSpecStorageMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmSingleSpecStorageMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageMetadata(obj: VmSingleSpecStorageMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrConfig defines stream aggregation configuration for VMSingle
 *
 * @schema VmSingleSpecStreamAggrConfig
 */
export interface VmSingleSpecStreamAggrConfig {
  /**
   * ConfigMap with stream aggregation rules
   *
   * @schema VmSingleSpecStreamAggrConfig#configmap
   */
  readonly configmap?: VmSingleSpecStreamAggrConfigConfigmap;

  /**
   * Allows setting different de-duplication intervals per each configured remote storage
   *
   * @schema VmSingleSpecStreamAggrConfig#dedupInterval
   */
  readonly dedupInterval?: string;

  /**
   * Allow drop all the input samples after the aggregation
   *
   * @schema VmSingleSpecStreamAggrConfig#dropInput
   */
  readonly dropInput?: boolean;

  /**
   * labels to drop from samples for aggregator before stream de-duplication and aggregation
   *
   * @schema VmSingleSpecStreamAggrConfig#dropInputLabels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows ( available from v0.54.0).
   *
   * @schema VmSingleSpecStreamAggrConfig#enableWindows
   */
  readonly enableWindows?: boolean;

  /**
   * IgnoreFirstIntervals instructs to ignore first interval
   *
   * @schema VmSingleSpecStreamAggrConfig#ignoreFirstIntervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmSingleSpecStreamAggrConfig#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmSingleSpecStreamAggrConfig#ignoreOldSamples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * Allows writing both raw and aggregate data
   *
   * @schema VmSingleSpecStreamAggrConfig#keepInput
   */
  readonly keepInput?: boolean;

  /**
   * Stream aggregation rules
   *
   * @schema VmSingleSpecStreamAggrConfig#rules
   */
  readonly rules?: VmSingleSpecStreamAggrConfigRules[];

}

/**
 * Converts an object of type 'VmSingleSpecStreamAggrConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStreamAggrConfig(obj: VmSingleSpecStreamAggrConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configmap': toJson_VmSingleSpecStreamAggrConfigConfigmap(obj.configmap),
    'dedupInterval': obj.dedupInterval,
    'dropInput': obj.dropInput,
    'dropInputLabels': obj.dropInputLabels?.map(y => y),
    'enableWindows': obj.enableWindows,
    'ignoreFirstIntervals': obj.ignoreFirstIntervals,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignoreOldSamples': obj.ignoreOldSamples,
    'keepInput': obj.keepInput,
    'rules': obj.rules?.map(y => toJson_VmSingleSpecStreamAggrConfigRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VmSingleSpecTolerations
 */
export interface VmSingleSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VmSingleSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VmSingleSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VmSingleSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VmSingleSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VmSingleSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmSingleSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecTolerations(obj: VmSingleSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMBackup configuration for backup
 *
 * @schema VmSingleSpecVmBackup
 */
export interface VmSingleSpecVmBackup {
  /**
   * AcceptEULA accepts enterprise feature usage, must be set to true.
   * otherwise backupmanager cannot be added to single/cluster version.
   * https://victoriametrics.com/legal/esa/
   * Deprecated: use license.key or license.keyRef instead
   *
   * @schema VmSingleSpecVmBackup#acceptEULA
   */
  readonly acceptEula?: boolean;

  /**
   * Defines number of concurrent workers. Higher concurrency may reduce backup duration (default 10)
   *
   * @schema VmSingleSpecVmBackup#concurrency
   */
  readonly concurrency?: number;

  /**
   * CredentialsSecret is secret in the same namespace for access to remote storage
   * The secret is mounted into /etc/vm/creds.
   *
   * @schema VmSingleSpecVmBackup#credentialsSecret
   */
  readonly credentialsSecret?: VmSingleSpecVmBackupCredentialsSecret;

  /**
   * Custom S3 endpoint for use with S3-compatible storages (e.g. MinIO). S3 is used if not set
   *
   * @schema VmSingleSpecVmBackup#customS3Endpoint
   */
  readonly customS3Endpoint?: string;

  /**
   * Defines destination for backup
   *
   * @schema VmSingleSpecVmBackup#destination
   */
  readonly destination?: string;

  /**
   * DestinationDisableSuffixAdd - disables suffix adding for cluster version backups
   * each vmstorage backup must have unique backup folder
   * so operator adds POD_NAME as suffix for backup destination folder.
   *
   * @schema VmSingleSpecVmBackup#destinationDisableSuffixAdd
   */
  readonly destinationDisableSuffixAdd?: boolean;

  /**
   * Defines if daily backups disabled (default false)
   *
   * @schema VmSingleSpecVmBackup#disableDaily
   */
  readonly disableDaily?: boolean;

  /**
   * Defines if hourly backups disabled (default false)
   *
   * @schema VmSingleSpecVmBackup#disableHourly
   */
  readonly disableHourly?: boolean;

  /**
   * Defines if monthly backups disabled (default false)
   *
   * @schema VmSingleSpecVmBackup#disableMonthly
   */
  readonly disableMonthly?: boolean;

  /**
   * Defines if weekly backups disabled (default false)
   *
   * @schema VmSingleSpecVmBackup#disableWeekly
   */
  readonly disableWeekly?: boolean;

  /**
   * extra args like maxBytesPerSecond default 0
   *
   * @schema VmSingleSpecVmBackup#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * @schema VmSingleSpecVmBackup#extraEnvs
   */
  readonly extraEnvs?: VmSingleSpecVmBackupExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VmSingleSpecVmBackup#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VmSingleSpecVmBackupExtraEnvsFrom[];

  /**
   * Image - docker image settings for VMBackuper
   *
   * @schema VmSingleSpecVmBackup#image
   */
  readonly image?: VmSingleSpecVmBackupImage;

  /**
   * LogFormat for VMBackup to be configured with.
   * default or json
   *
   * @schema VmSingleSpecVmBackup#logFormat
   */
  readonly logFormat?: VmSingleSpecVmBackupLogFormat;

  /**
   * LogLevel for VMBackup to be configured with.
   *
   * @schema VmSingleSpecVmBackup#logLevel
   */
  readonly logLevel?: VmSingleSpecVmBackupLogLevel;

  /**
   * Port for health check connections
   *
   * @schema VmSingleSpecVmBackup#port
   */
  readonly port?: string;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VmSingleSpecVmBackup#resources
   */
  readonly resources?: VmSingleSpecVmBackupResources;

  /**
   * Restore Allows to enable restore options for pod
   * Read [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)
   *
   * @schema VmSingleSpecVmBackup#restore
   */
  readonly restore?: VmSingleSpecVmBackupRestore;

  /**
   * SnapshotCreateURL overwrites url for snapshot create
   *
   * @schema VmSingleSpecVmBackup#snapshotCreateURL
   */
  readonly snapshotCreateUrl?: string;

  /**
   * SnapShotDeleteURL overwrites url for snapshot delete
   *
   * @schema VmSingleSpecVmBackup#snapshotDeleteURL
   */
  readonly snapshotDeleteUrl?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the vmbackupmanager container,
   * that are generated as a result of StorageSpec objects.
   *
   * @schema VmSingleSpecVmBackup#volumeMounts
   */
  readonly volumeMounts?: VmSingleSpecVmBackupVolumeMounts[];

}

/**
 * Converts an object of type 'VmSingleSpecVmBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackup(obj: VmSingleSpecVmBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptEULA': obj.acceptEula,
    'concurrency': obj.concurrency,
    'credentialsSecret': toJson_VmSingleSpecVmBackupCredentialsSecret(obj.credentialsSecret),
    'customS3Endpoint': obj.customS3Endpoint,
    'destination': obj.destination,
    'destinationDisableSuffixAdd': obj.destinationDisableSuffixAdd,
    'disableDaily': obj.disableDaily,
    'disableHourly': obj.disableHourly,
    'disableMonthly': obj.disableMonthly,
    'disableWeekly': obj.disableWeekly,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VmSingleSpecVmBackupExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VmSingleSpecVmBackupExtraEnvsFrom(y)),
    'image': toJson_VmSingleSpecVmBackupImage(obj.image),
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'port': obj.port,
    'resources': toJson_VmSingleSpecVmBackupResources(obj.resources),
    'restore': toJson_VmSingleSpecVmBackupRestore(obj.restore),
    'snapshotCreateURL': obj.snapshotCreateUrl,
    'snapshotDeleteURL': obj.snapshotDeleteUrl,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VmSingleSpecVmBackupVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmSingleSpecVolumeMounts
 */
export interface VmSingleSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmSingleSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmSingleSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmSingleSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmSingleSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmSingleSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmSingleSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmSingleSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmSingleSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVolumeMounts(obj: VmSingleSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VmSingleSpecDnsConfigOptions
 */
export interface VmSingleSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VmSingleSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VmSingleSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VmSingleSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecDnsConfigOptions(obj: VmSingleSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmSingleSpecExtraEnvsFromConfigMapRef
 */
export interface VmSingleSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmSingleSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecExtraEnvsFromConfigMapRef(obj: VmSingleSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmSingleSpecExtraEnvsFromSecretRef
 */
export interface VmSingleSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmSingleSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecExtraEnvsFromSecretRef(obj: VmSingleSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyRef is reference to secret with license key for enterprise features.
 *
 * @schema VmSingleSpecLicenseKeyRef
 */
export interface VmSingleSpecLicenseKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmSingleSpecLicenseKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecLicenseKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmSingleSpecLicenseKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecLicenseKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecLicenseKeyRef(obj: VmSingleSpecLicenseKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmSingleSpecResourcesClaims
 */
export interface VmSingleSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmSingleSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmSingleSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmSingleSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecResourcesClaims(obj: VmSingleSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmSingleSpecResourcesLimits
 */
export class VmSingleSpecResourcesLimits {
  public static fromNumber(value: number): VmSingleSpecResourcesLimits {
    return new VmSingleSpecResourcesLimits(value);
  }
  public static fromString(value: string): VmSingleSpecResourcesLimits {
    return new VmSingleSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmSingleSpecResourcesRequests
 */
export class VmSingleSpecResourcesRequests {
  public static fromNumber(value: number): VmSingleSpecResourcesRequests {
    return new VmSingleSpecResourcesRequests(value);
  }
  public static fromString(value: string): VmSingleSpecResourcesRequests {
    return new VmSingleSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VmSingleSpecServiceSpecMetadata
 */
export interface VmSingleSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VmSingleSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VmSingleSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VmSingleSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VmSingleSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecServiceSpecMetadata(obj: VmSingleSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VmSingleSpecStorageDataSource
 */
export interface VmSingleSpecStorageDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmSingleSpecStorageDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmSingleSpecStorageDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmSingleSpecStorageDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VmSingleSpecStorageDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageDataSource(obj: VmSingleSpecStorageDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VmSingleSpecStorageDataSourceRef
 */
export interface VmSingleSpecStorageDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VmSingleSpecStorageDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VmSingleSpecStorageDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VmSingleSpecStorageDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VmSingleSpecStorageDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VmSingleSpecStorageDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageDataSourceRef(obj: VmSingleSpecStorageDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VmSingleSpecStorageResources
 */
export interface VmSingleSpecStorageResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecStorageResources#limits
   */
  readonly limits?: { [key: string]: VmSingleSpecStorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecStorageResources#requests
   */
  readonly requests?: { [key: string]: VmSingleSpecStorageResourcesRequests };

}

/**
 * Converts an object of type 'VmSingleSpecStorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageResources(obj: VmSingleSpecStorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VmSingleSpecStorageSelector
 */
export interface VmSingleSpecStorageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VmSingleSpecStorageSelector#matchExpressions
   */
  readonly matchExpressions?: VmSingleSpecStorageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VmSingleSpecStorageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VmSingleSpecStorageSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageSelector(obj: VmSingleSpecStorageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VmSingleSpecStorageSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap with stream aggregation rules
 *
 * @schema VmSingleSpecStreamAggrConfigConfigmap
 */
export interface VmSingleSpecStreamAggrConfigConfigmap {
  /**
   * The key to select.
   *
   * @schema VmSingleSpecStreamAggrConfigConfigmap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecStreamAggrConfigConfigmap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmSingleSpecStreamAggrConfigConfigmap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecStreamAggrConfigConfigmap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStreamAggrConfigConfigmap(obj: VmSingleSpecStreamAggrConfigConfigmap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StreamAggrRule defines the rule in stream aggregation config
 *
 * @schema VmSingleSpecStreamAggrConfigRules
 */
export interface VmSingleSpecStreamAggrConfigRules {
  /**
   * By is an optional list of labels for grouping input series.
   *
   * See also Without.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#by
   */
  readonly by?: string[];

  /**
   * DedupInterval is an optional interval for deduplication.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#dedup_interval
   */
  readonly dedupInterval?: string;

  /**
   * DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
   *
   * Labels are dropped before de-duplication and aggregation.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#drop_input_labels
   */
  readonly dropInputLabels?: string[];

  /**
   * EnableWindows enables aggregating data in separate windows
   *
   * @schema VmSingleSpecStreamAggrConfigRules#enable_windows
   */
  readonly enableWindows?: boolean;

  /**
   * FlushOnShutdown defines whether to flush the aggregation state on process termination
   * or config reload. Is `false` by default.
   * It is not recommended changing this setting, unless unfinished aggregations states
   * are preferred to missing data points.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#flush_on_shutdown
   */
  readonly flushOnShutdown?: boolean;

  /**
   * IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
   *
   * @schema VmSingleSpecStreamAggrConfigRules#ignoreFirstSampleInterval
   */
  readonly ignoreFirstSampleInterval?: string;

  /**
   * @schema VmSingleSpecStreamAggrConfigRules#ignore_first_intervals
   */
  readonly ignoreFirstIntervals?: number;

  /**
   * IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#ignore_old_samples
   */
  readonly ignoreOldSamples?: boolean;

  /**
   * InputRelabelConfigs is an optional relabeling rules, which are applied on the input
   * before aggregation.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#input_relabel_configs
   */
  readonly inputRelabelConfigs?: VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs[];

  /**
   * Interval is the interval between aggregations.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#interval
   */
  readonly interval: string;

  /**
   * KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#keep_metric_names
   */
  readonly keepMetricNames?: boolean;

  /**
   * Match is a label selector (or list of label selectors) for filtering time series for the given selector.
   *
   * If the match isn't set, then all the input time series are processed.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#match
   */
  readonly match?: any;

  /**
   * NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
   * By default flushes are aligned to Interval.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#no_align_flush_to_interval
   */
  readonly noAlignFlushToInterval?: boolean;

  /**
   * OutputRelabelConfigs is an optional relabeling rules, which are applied
   * on the aggregated output before being sent to remote storage.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#output_relabel_configs
   */
  readonly outputRelabelConfigs?: VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs[];

  /**
   * Outputs is a list of output aggregate functions to produce.
   *
   * The following names are allowed:
   *
   * - total - aggregates input counters
   * - increase - counts the increase over input counters
   * - count_series - counts the input series
   * - count_samples - counts the input samples
   * - sum_samples - sums the input samples
   * - last - the last biggest sample value
   * - min - the minimum sample value
   * - max - the maximum sample value
   * - avg - the average value across all the samples
   * - stddev - standard deviation across all the samples
   * - stdvar - standard variance across all the samples
   * - histogram_bucket - creates VictoriaMetrics histogram for input samples
   * - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
   *
   * The output time series will have the following names:
   *
   * input_name:aggr_<interval>_<output>
   *
   * @schema VmSingleSpecStreamAggrConfigRules#outputs
   */
  readonly outputs: string[];

  /**
   * Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
   * The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#staleness_interval
   */
  readonly stalenessInterval?: string;

  /**
   * Without is an optional list of labels, which must be excluded when grouping input series.
   *
   * See also By.
   *
   * If neither By nor Without are set, then the Outputs are calculated
   * individually per each input time series.
   *
   * @schema VmSingleSpecStreamAggrConfigRules#without
   */
  readonly without?: string[];

}

/**
 * Converts an object of type 'VmSingleSpecStreamAggrConfigRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStreamAggrConfigRules(obj: VmSingleSpecStreamAggrConfigRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'by': obj.by?.map(y => y),
    'dedup_interval': obj.dedupInterval,
    'drop_input_labels': obj.dropInputLabels?.map(y => y),
    'enable_windows': obj.enableWindows,
    'flush_on_shutdown': obj.flushOnShutdown,
    'ignoreFirstSampleInterval': obj.ignoreFirstSampleInterval,
    'ignore_first_intervals': obj.ignoreFirstIntervals,
    'ignore_old_samples': obj.ignoreOldSamples,
    'input_relabel_configs': obj.inputRelabelConfigs?.map(y => toJson_VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs(y)),
    'interval': obj.interval,
    'keep_metric_names': obj.keepMetricNames,
    'match': obj.match,
    'no_align_flush_to_interval': obj.noAlignFlushToInterval,
    'output_relabel_configs': obj.outputRelabelConfigs?.map(y => toJson_VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs(y)),
    'outputs': obj.outputs?.map(y => y),
    'staleness_interval': obj.stalenessInterval,
    'without': obj.without?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CredentialsSecret is secret in the same namespace for access to remote storage
 * The secret is mounted into /etc/vm/creds.
 *
 * @schema VmSingleSpecVmBackupCredentialsSecret
 */
export interface VmSingleSpecVmBackupCredentialsSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmSingleSpecVmBackupCredentialsSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecVmBackupCredentialsSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmSingleSpecVmBackupCredentialsSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupCredentialsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupCredentialsSecret(obj: VmSingleSpecVmBackupCredentialsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VmSingleSpecVmBackupExtraEnvs
 */
export interface VmSingleSpecVmBackupExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VmSingleSpecVmBackupExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VmSingleSpecVmBackupExtraEnvs#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema VmSingleSpecVmBackupExtraEnvs#valueFrom
   */
  readonly valueFrom?: VmSingleSpecVmBackupExtraEnvsValueFrom;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvs(obj: VmSingleSpecVmBackupExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_VmSingleSpecVmBackupExtraEnvsValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VmSingleSpecVmBackupExtraEnvsFrom
 */
export interface VmSingleSpecVmBackupExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VmSingleSpecVmBackupExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VmSingleSpecVmBackupExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsFrom(obj: VmSingleSpecVmBackupExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VmSingleSpecVmBackupExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VmSingleSpecVmBackupExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings for VMBackuper
 *
 * @schema VmSingleSpecVmBackupImage
 */
export interface VmSingleSpecVmBackupImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VmSingleSpecVmBackupImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VmSingleSpecVmBackupImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VmSingleSpecVmBackupImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupImage(obj: VmSingleSpecVmBackupImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VMBackup to be configured with.
 * default or json
 *
 * @schema VmSingleSpecVmBackupLogFormat
 */
export enum VmSingleSpecVmBackupLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VMBackup to be configured with.
 *
 * @schema VmSingleSpecVmBackupLogLevel
 */
export enum VmSingleSpecVmBackupLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VmSingleSpecVmBackupResources
 */
export interface VmSingleSpecVmBackupResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VmSingleSpecVmBackupResources#claims
   */
  readonly claims?: VmSingleSpecVmBackupResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecVmBackupResources#limits
   */
  readonly limits?: { [key: string]: VmSingleSpecVmBackupResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VmSingleSpecVmBackupResources#requests
   */
  readonly requests?: { [key: string]: VmSingleSpecVmBackupResourcesRequests };

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupResources(obj: VmSingleSpecVmBackupResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VmSingleSpecVmBackupResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Restore Allows to enable restore options for pod
 * Read [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)
 *
 * @schema VmSingleSpecVmBackupRestore
 */
export interface VmSingleSpecVmBackupRestore {
  /**
   * OnStart defines configuration for restore on pod start
   *
   * @schema VmSingleSpecVmBackupRestore#onStart
   */
  readonly onStart?: VmSingleSpecVmBackupRestoreOnStart;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupRestore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupRestore(obj: VmSingleSpecVmBackupRestore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onStart': toJson_VmSingleSpecVmBackupRestoreOnStart(obj.onStart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VmSingleSpecVmBackupVolumeMounts
 */
export interface VmSingleSpecVmBackupVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VmSingleSpecVmBackupVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VmSingleSpecVmBackupVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VmSingleSpecVmBackupVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VmSingleSpecVmBackupVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VmSingleSpecVmBackupVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VmSingleSpecVmBackupVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VmSingleSpecVmBackupVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupVolumeMounts(obj: VmSingleSpecVmBackupVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmSingleSpecStorageResourcesLimits
 */
export class VmSingleSpecStorageResourcesLimits {
  public static fromNumber(value: number): VmSingleSpecStorageResourcesLimits {
    return new VmSingleSpecStorageResourcesLimits(value);
  }
  public static fromString(value: string): VmSingleSpecStorageResourcesLimits {
    return new VmSingleSpecStorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmSingleSpecStorageResourcesRequests
 */
export class VmSingleSpecStorageResourcesRequests {
  public static fromNumber(value: number): VmSingleSpecStorageResourcesRequests {
    return new VmSingleSpecStorageResourcesRequests(value);
  }
  public static fromString(value: string): VmSingleSpecStorageResourcesRequests {
    return new VmSingleSpecStorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VmSingleSpecStorageSelectorMatchExpressions
 */
export interface VmSingleSpecStorageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VmSingleSpecStorageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VmSingleSpecStorageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VmSingleSpecStorageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VmSingleSpecStorageSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStorageSelectorMatchExpressions(obj: VmSingleSpecStorageSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs
 */
export interface VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs(obj: VmSingleSpecStreamAggrConfigRulesInputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs
 */
export interface VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs(obj: VmSingleSpecStreamAggrConfigRulesOutputRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFrom
 */
export interface VmSingleSpecVmBackupExtraEnvsValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFrom#fieldRef
   */
  readonly fieldRef?: VmSingleSpecVmBackupExtraEnvsValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsValueFrom(obj: VmSingleSpecVmBackupExtraEnvsValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_VmSingleSpecVmBackupExtraEnvsValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VmSingleSpecVmBackupExtraEnvsFromConfigMapRef
 */
export interface VmSingleSpecVmBackupExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsFromConfigMapRef(obj: VmSingleSpecVmBackupExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VmSingleSpecVmBackupExtraEnvsFromSecretRef
 */
export interface VmSingleSpecVmBackupExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VmSingleSpecVmBackupExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsFromSecretRef(obj: VmSingleSpecVmBackupExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VmSingleSpecVmBackupResourcesClaims
 */
export interface VmSingleSpecVmBackupResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VmSingleSpecVmBackupResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VmSingleSpecVmBackupResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupResourcesClaims(obj: VmSingleSpecVmBackupResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VmSingleSpecVmBackupResourcesLimits
 */
export class VmSingleSpecVmBackupResourcesLimits {
  public static fromNumber(value: number): VmSingleSpecVmBackupResourcesLimits {
    return new VmSingleSpecVmBackupResourcesLimits(value);
  }
  public static fromString(value: string): VmSingleSpecVmBackupResourcesLimits {
    return new VmSingleSpecVmBackupResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VmSingleSpecVmBackupResourcesRequests
 */
export class VmSingleSpecVmBackupResourcesRequests {
  public static fromNumber(value: number): VmSingleSpecVmBackupResourcesRequests {
    return new VmSingleSpecVmBackupResourcesRequests(value);
  }
  public static fromString(value: string): VmSingleSpecVmBackupResourcesRequests {
    return new VmSingleSpecVmBackupResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * OnStart defines configuration for restore on pod start
 *
 * @schema VmSingleSpecVmBackupRestoreOnStart
 */
export interface VmSingleSpecVmBackupRestoreOnStart {
  /**
   * Enabled defines if restore on start enabled
   *
   * @schema VmSingleSpecVmBackupRestoreOnStart#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupRestoreOnStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupRestoreOnStart(obj: VmSingleSpecVmBackupRestoreOnStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef
 */
export interface VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef(obj: VmSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFromFieldRef
 */
export interface VmSingleSpecVmBackupExtraEnvsValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsValueFromFieldRef(obj: VmSingleSpecVmBackupExtraEnvsValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef
 */
export interface VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef#divisor
   */
  readonly divisor?: VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef(obj: VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef
 */
export interface VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef(obj: VmSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor
 */
export class VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
    return new VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor {
    return new VmSingleSpecVmBackupExtraEnvsValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * VMStaticScrape  defines static targets configuration for scraping.
 *
 * @schema VMStaticScrape
 */
export class VmStaticScrape extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMStaticScrape"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMStaticScrape',
  }

  /**
   * Renders a Kubernetes manifest for "VMStaticScrape".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmStaticScrapeProps = {}): any {
    return {
      ...VmStaticScrape.GVK,
      ...toJson_VmStaticScrapeProps(props),
    };
  }

  /**
   * Defines a "VMStaticScrape" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmStaticScrapeProps = {}) {
    super(scope, id, {
      ...VmStaticScrape.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmStaticScrape.GVK,
      ...toJson_VmStaticScrapeProps(resolved),
    };
  }
}

/**
 * VMStaticScrape  defines static targets configuration for scraping.
 *
 * @schema VMStaticScrape
 */
export interface VmStaticScrapeProps {
  /**
   * @schema VMStaticScrape#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMStaticScrapeSpec defines the desired state of VMStaticScrape.
   *
   * @schema VMStaticScrape#spec
   */
  readonly spec?: VmStaticScrapeSpec;

}

/**
 * Converts an object of type 'VmStaticScrapeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeProps(obj: VmStaticScrapeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmStaticScrapeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMStaticScrapeSpec defines the desired state of VMStaticScrape.
 *
 * @schema VmStaticScrapeSpec
 */
export interface VmStaticScrapeSpec {
  /**
   * JobName name of job.
   *
   * @schema VmStaticScrapeSpec#jobName
   */
  readonly jobName?: string;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmStaticScrapeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmStaticScrapeSpec#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * A list of target endpoints to scrape metrics from.
   *
   * @schema VmStaticScrapeSpec#targetEndpoints
   */
  readonly targetEndpoints: VmStaticScrapeSpecTargetEndpoints[];

}

/**
 * Converts an object of type 'VmStaticScrapeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpec(obj: VmStaticScrapeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobName': obj.jobName,
    'sampleLimit': obj.sampleLimit,
    'seriesLimit': obj.seriesLimit,
    'targetEndpoints': obj.targetEndpoints?.map(y => toJson_VmStaticScrapeSpecTargetEndpoints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetEndpoint defines single static target endpoint.
 *
 * @schema VmStaticScrapeSpecTargetEndpoints
 */
export interface VmStaticScrapeSpecTargetEndpoints {
  /**
   * Authorization with http header Authorization
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#authorization
   */
  readonly authorization?: VmStaticScrapeSpecTargetEndpointsAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#basicAuth
   */
  readonly basicAuth?: VmStaticScrapeSpecTargetEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the scrape object and accessible by
   * the victoria-metrics operator.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: VmStaticScrapeSpecTargetEndpointsBearerTokenSecret;

  /**
   * FollowRedirects controls redirects for scraping.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#follow_redirects
   */
  readonly followRedirects?: boolean;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#interval
   */
  readonly interval?: string;

  /**
   * Labels static labels for targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * MaxScrapeSize defines a maximum size of scraped data for a job
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#max_scrape_size
   */
  readonly maxScrapeSize?: string;

  /**
   * MetricRelabelConfigs to apply to samples after scrapping.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#metricRelabelConfigs
   */
  readonly metricRelabelConfigs?: VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs[];

  /**
   * OAuth2 defines auth configuration
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#oauth2
   */
  readonly oauth2?: VmStaticScrapeSpecTargetEndpointsOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#path
   */
  readonly path?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples during service discovery.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#relabelConfigs
   */
  readonly relabelConfigs?: VmStaticScrapeSpecTargetEndpointsRelabelConfigs[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#scheme
   */
  readonly scheme?: VmStaticScrapeSpecTargetEndpointsScheme;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * ScrapeInterval is the same as Interval and has priority over it.
   * one of scrape_interval or interval can be used
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#scrape_interval
   */
  readonly scrapeInterval?: string;

  /**
   * SeriesLimit defines per-scrape limit on number of unique time series
   * a single target can expose during all the scrapes on the time window of 24h.
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#seriesLimit
   */
  readonly seriesLimit?: number;

  /**
   * Targets static targets addresses in form of ["192.122.55.55:9100","some-name:9100"].
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#targets
   */
  readonly targets: string[];

  /**
   * TLSConfig configuration to use when scraping the endpoint
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#tlsConfig
   */
  readonly tlsConfig?: VmStaticScrapeSpecTargetEndpointsTlsConfig;

  /**
   * VMScrapeParams defines VictoriaMetrics specific scrape parameters
   *
   * @schema VmStaticScrapeSpecTargetEndpoints#vm_scrape_params
   */
  readonly vmScrapeParams?: VmStaticScrapeSpecTargetEndpointsVmScrapeParams;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpoints(obj: VmStaticScrapeSpecTargetEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_VmStaticScrapeSpecTargetEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_VmStaticScrapeSpecTargetEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_VmStaticScrapeSpecTargetEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'follow_redirects': obj.followRedirects,
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'max_scrape_size': obj.maxScrapeSize,
    'metricRelabelConfigs': obj.metricRelabelConfigs?.map(y => toJson_VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs(y)),
    'oauth2': toJson_VmStaticScrapeSpecTargetEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'proxyURL': obj.proxyUrl,
    'relabelConfigs': obj.relabelConfigs?.map(y => toJson_VmStaticScrapeSpecTargetEndpointsRelabelConfigs(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'scrape_interval': obj.scrapeInterval,
    'seriesLimit': obj.seriesLimit,
    'targets': obj.targets?.map(y => y),
    'tlsConfig': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfig(obj.tlsConfig),
    'vm_scrape_params': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParams(obj.vmScrapeParams),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization with http header Authorization
 *
 * @schema VmStaticScrapeSpecTargetEndpointsAuthorization
 */
export interface VmStaticScrapeSpecTargetEndpointsAuthorization {
  /**
   * Reference to the secret with value for authorization
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorization#credentials
   */
  readonly credentials?: VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials;

  /**
   * File with value for authorization
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Type of authorization, default to bearer
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsAuthorization(obj: VmStaticScrapeSpecTargetEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmStaticScrapeSpecTargetEndpointsBasicAuth
 */
export interface VmStaticScrapeSpecTargetEndpointsBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuth#password
   */
  readonly password?: VmStaticScrapeSpecTargetEndpointsBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuth#username
   */
  readonly username?: VmStaticScrapeSpecTargetEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsBasicAuth(obj: VmStaticScrapeSpecTargetEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmStaticScrapeSpecTargetEndpointsBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmStaticScrapeSpecTargetEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the scrape object and accessible by
 * the victoria-metrics operator.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsBearerTokenSecret
 */
export interface VmStaticScrapeSpecTargetEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsBearerTokenSecret(obj: VmStaticScrapeSpecTargetEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs
 */
export interface VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs(obj: VmStaticScrapeSpecTargetEndpointsMetricRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OAuth2 defines auth configuration
 *
 * @schema VmStaticScrapeSpecTargetEndpointsOauth2
 */
export interface VmStaticScrapeSpecTargetEndpointsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#client_id
   */
  readonly clientId: VmStaticScrapeSpecTargetEndpointsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#client_secret
   */
  readonly clientSecret?: VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret;

  /**
   * ClientSecretFile defines path for client secret file.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#client_secret_file
   */
  readonly clientSecretFile?: string;

  /**
   * Parameters to append to the token URL
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#endpoint_params
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * The proxy URL for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#proxy_url
   */
  readonly proxyUrl?: string;

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * TLSConfig for token_url connection
   * ( available from v0.55.0).
   * Is only supported by Scrape objects family
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#tls_config
   */
  readonly tlsConfig?: any;

  /**
   * The URL to fetch the token from
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2#token_url
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsOauth2(obj: VmStaticScrapeSpecTargetEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'client_id': toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientId(obj.clientId),
    'client_secret': toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret(obj.clientSecret),
    'client_secret_file': obj.clientSecretFile,
    'endpoint_params': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxy_url': obj.proxyUrl,
    'scopes': obj.scopes?.map(y => y),
    'tls_config': obj.tlsConfig,
    'token_url': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set
 * More info: https://docs.victoriametrics.com/victoriametrics/#relabeling
 *
 * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs
 */
export interface VmStaticScrapeSpecTargetEndpointsRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#action
   */
  readonly action?: string;

  /**
   * If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#if
   */
  readonly if?: any;

  /**
   * Labels is used together with Match for `action: graphite`
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is used together with Labels for `action: graphite`
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#match
   */
  readonly match?: string;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   * victoriaMetrics supports multiline regex joined with |
   * https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements
   *
   * @default victoriaMetrics supports multiline regex joined with |
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#regex
   */
  readonly regex?: any;

  /**
   * Replacement value against which a regex replace is performed if the
   * regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated
   * using the configured separator and matched against the configured regular expression
   * for the replace, keep, and drop actions.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action.
   * It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsRelabelConfigs(obj: VmStaticScrapeSpecTargetEndpointsRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'if': obj.if,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': obj.match,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP scheme to use for scraping.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsScheme
 */
export enum VmStaticScrapeSpecTargetEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * TLSConfig configuration to use when scraping the endpoint
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#ca
   */
  readonly ca?: VmStaticScrapeSpecTargetEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#cert
   */
  readonly cert?: VmStaticScrapeSpecTargetEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfig(obj: VmStaticScrapeSpecTargetEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMScrapeParams defines VictoriaMetrics specific scrape parameters
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParams {
  /**
   * DisableCompression
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#disable_compression
   */
  readonly disableCompression?: boolean;

  /**
   * disable_keepalive allows disabling HTTP keep-alive when scraping targets.
   * By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
   * could be reused.
   * See https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#disable_keep_alive
   */
  readonly disableKeepAlive?: boolean;

  /**
   * Headers allows sending custom headers to scrape targets
   * must be in of semicolon separated header with it's value
   * eg:
   * headerName: headerValue
   * vmagent supports since 1.79.0 version
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#no_stale_markers
   */
  readonly noStaleMarkers?: boolean;

  /**
   * ProxyClientConfig configures proxy auth settings for scraping
   * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#proxy_client_config
   */
  readonly proxyClientConfig?: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig;

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#scrape_align_interval
   */
  readonly scrapeAlignInterval?: string;

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#scrape_offset
   */
  readonly scrapeOffset?: string;

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParams#stream_parse
   */
  readonly streamParse?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParams(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable_compression': obj.disableCompression,
    'disable_keep_alive': obj.disableKeepAlive,
    'headers': obj.headers?.map(y => y),
    'no_stale_markers': obj.noStaleMarkers,
    'proxy_client_config': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig(obj.proxyClientConfig),
    'scrape_align_interval': obj.scrapeAlignInterval,
    'scrape_offset': obj.scrapeOffset,
    'stream_parse': obj.streamParse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to the secret with value for authorization
 *
 * @schema VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials
 */
export interface VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials(obj: VmStaticScrapeSpecTargetEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthPassword
 */
export interface VmStaticScrapeSpecTargetEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsBasicAuthPassword(obj: VmStaticScrapeSpecTargetEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthUsername
 */
export interface VmStaticScrapeSpecTargetEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsBasicAuthUsername(obj: VmStaticScrapeSpecTargetEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientId
 */
export interface VmStaticScrapeSpecTargetEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientId#secret
   */
  readonly secret?: VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientId(obj: VmStaticScrapeSpecTargetEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret
 */
export interface VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret(obj: VmStaticScrapeSpecTargetEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCa
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCa#secret
   */
  readonly secret?: VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCa(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCert
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCert#secret
   */
  readonly secret?: VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCert(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyClientConfig configures proxy auth settings for scraping
 * See feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig {
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig#basic_auth
   */
  readonly basicAuth?: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig#bearer_token
   */
  readonly bearerToken?: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken;

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig#bearer_token_file
   */
  readonly bearerTokenFile?: string;

  /**
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig#tls_config
   */
  readonly tlsConfig?: any;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basic_auth': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj.basicAuth),
    'bearer_token': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj.bearerToken),
    'bearer_token_file': obj.bearerTokenFile,
    'tls_config': obj.tlsConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap
 */
export interface VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap(obj: VmStaticScrapeSpecTargetEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret
 */
export interface VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret(obj: VmStaticScrapeSpecTargetEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret
 */
export interface VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret(obj: VmStaticScrapeSpecTargetEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth {
  /**
   * Password defines reference for secret with password value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password
   */
  readonly password?: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword;

  /**
   * PasswordFile defines path to password file at disk
   * must be pre-mounted
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth#password_file
   */
  readonly passwordFile?: string;

  /**
   * Username defines reference for secret with username value
   * The secret needs to be in the same namespace as scrape object
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth#username
   */
  readonly username?: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj.password),
    'password_file': obj.passwordFile,
    'username': toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password defines reference for secret with password value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username defines reference for secret with username value
 * The secret needs to be in the same namespace as scrape object
 *
 * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername
 */
export interface VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername(obj: VmStaticScrapeSpecTargetEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VMUser is the Schema for the vmusers API
 *
 * @schema VMUser
 */
export class VmUser extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VMUser"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1beta1',
    kind: 'VMUser',
  }

  /**
   * Renders a Kubernetes manifest for "VMUser".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VmUserProps = {}): any {
    return {
      ...VmUser.GVK,
      ...toJson_VmUserProps(props),
    };
  }

  /**
   * Defines a "VMUser" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VmUserProps = {}) {
    super(scope, id, {
      ...VmUser.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VmUser.GVK,
      ...toJson_VmUserProps(resolved),
    };
  }
}

/**
 * VMUser is the Schema for the vmusers API
 *
 * @schema VMUser
 */
export interface VmUserProps {
  /**
   * @schema VMUser#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VMUserSpec defines the desired state of VMUser
   *
   * @schema VMUser#spec
   */
  readonly spec?: VmUserSpec;

}

/**
 * Converts an object of type 'VmUserProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserProps(obj: VmUserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VmUserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VMUserSpec defines the desired state of VMUser
 *
 * @schema VmUserSpec
 */
export interface VmUserSpec {
  /**
   * BearerToken Authorization header value for accessing protected endpoint.
   *
   * @schema VmUserSpec#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * DefaultURLs backend url for non-matching paths filter
   * usually used for default backend with error message
   *
   * @schema VmUserSpec#default_url
   */
  readonly defaultUrl?: string[];

  /**
   * DisableSecretCreation skips related secret creation for vmuser
   *
   * @schema VmUserSpec#disable_secret_creation
   */
  readonly disableSecretCreation?: boolean;

  /**
   * DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.
   *
   * @schema VmUserSpec#discover_backend_ips
   */
  readonly discoverBackendIps?: boolean;

  /**
   * DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.
   *
   * @schema VmUserSpec#drop_src_path_prefix_parts
   */
  readonly dropSrcPathPrefixParts?: number;

  /**
   * DumpRequestOnErrors instructs vmauth to return detailed request params to the client
   * if routing rules don't allow to forward request to the backends.
   * Useful for debugging `src_hosts` and `src_headers` based routing rules
   *
   * available since v1.107.0 vmauth version
   *
   * @schema VmUserSpec#dump_request_on_errors
   */
  readonly dumpRequestOnErrors?: boolean;

  /**
   * GeneratePassword instructs operator to generate password for user
   * if spec.password if empty.
   *
   * @schema VmUserSpec#generatePassword
   */
  readonly generatePassword?: boolean;

  /**
   * Headers represent additional http headers, that vmauth uses
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.68.0 version of vmauth
   *
   * @schema VmUserSpec#headers
   */
  readonly headers?: string[];

  /**
   * IPFilters defines per target src ip filters
   * supported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)
   *
   * @schema VmUserSpec#ip_filters
   */
  readonly ipFilters?: VmUserSpecIpFilters;

  /**
   * LoadBalancingPolicy defines load balancing policy to use for backend urls.
   * Supported policies: least_loaded, first_available.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
   *
   * @schema VmUserSpec#load_balancing_policy
   */
  readonly loadBalancingPolicy?: VmUserSpecLoadBalancingPolicy;

  /**
   * MaxConcurrentRequests defines max concurrent requests per user
   * 300 is default value for vmauth
   *
   * @schema VmUserSpec#max_concurrent_requests
   */
  readonly maxConcurrentRequests?: number;

  /**
   * MetricLabels - additional labels for metrics exported by vmauth for given user.
   *
   * @schema VmUserSpec#metric_labels
   */
  readonly metricLabels?: { [key: string]: string };

  /**
   * Name of the VMUser object.
   *
   * @schema VmUserSpec#name
   */
  readonly name?: string;

  /**
   * Password basic auth password for accessing protected endpoint.
   *
   * @schema VmUserSpec#password
   */
  readonly password?: string;

  /**
   * PasswordRef allows fetching password from user-create secret by its name and key.
   *
   * @schema VmUserSpec#passwordRef
   */
  readonly passwordRef?: VmUserSpecPasswordRef;

  /**
   * ResponseHeaders represent additional http headers, that vmauth adds for request response
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.93.0 version of vmauth
   *
   * @schema VmUserSpec#response_headers
   */
  readonly responseHeaders?: string[];

  /**
   * RetryStatusCodes defines http status codes in numeric format for request retries
   * e.g. [429,503]
   *
   * @schema VmUserSpec#retry_status_codes
   */
  readonly retryStatusCodes?: number[];

  /**
   * TargetRefs - reference to endpoints, which user may access.
   *
   * @schema VmUserSpec#targetRefs
   */
  readonly targetRefs: VmUserSpecTargetRefs[];

  /**
   * TLSConfig defines tls configuration for the backend connection
   *
   * @schema VmUserSpec#tlsConfig
   */
  readonly tlsConfig?: VmUserSpecTlsConfig;

  /**
   * TokenRef allows fetching token from user-created secrets by its name and key.
   *
   * @schema VmUserSpec#tokenRef
   */
  readonly tokenRef?: VmUserSpecTokenRef;

  /**
   * UserName basic auth user name for accessing protected endpoint,
   * will be replaced with metadata.name of VMUser if omitted.
   *
   * @schema VmUserSpec#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'VmUserSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpec(obj: VmUserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': obj.bearerToken,
    'default_url': obj.defaultUrl?.map(y => y),
    'disable_secret_creation': obj.disableSecretCreation,
    'discover_backend_ips': obj.discoverBackendIps,
    'drop_src_path_prefix_parts': obj.dropSrcPathPrefixParts,
    'dump_request_on_errors': obj.dumpRequestOnErrors,
    'generatePassword': obj.generatePassword,
    'headers': obj.headers?.map(y => y),
    'ip_filters': toJson_VmUserSpecIpFilters(obj.ipFilters),
    'load_balancing_policy': obj.loadBalancingPolicy,
    'max_concurrent_requests': obj.maxConcurrentRequests,
    'metric_labels': ((obj.metricLabels) === undefined) ? undefined : (Object.entries(obj.metricLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'password': obj.password,
    'passwordRef': toJson_VmUserSpecPasswordRef(obj.passwordRef),
    'response_headers': obj.responseHeaders?.map(y => y),
    'retry_status_codes': obj.retryStatusCodes?.map(y => y),
    'targetRefs': obj.targetRefs?.map(y => toJson_VmUserSpecTargetRefs(y)),
    'tlsConfig': toJson_VmUserSpecTlsConfig(obj.tlsConfig),
    'tokenRef': toJson_VmUserSpecTokenRef(obj.tokenRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IPFilters defines per target src ip filters
 * supported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)
 *
 * @schema VmUserSpecIpFilters
 */
export interface VmUserSpecIpFilters {
  /**
   * @schema VmUserSpecIpFilters#allow_list
   */
  readonly allowList?: string[];

  /**
   * @schema VmUserSpecIpFilters#deny_list
   */
  readonly denyList?: string[];

}

/**
 * Converts an object of type 'VmUserSpecIpFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecIpFilters(obj: VmUserSpecIpFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow_list': obj.allowList?.map(y => y),
    'deny_list': obj.denyList?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancingPolicy defines load balancing policy to use for backend urls.
 * Supported policies: least_loaded, first_available.
 * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
 *
 * @schema VmUserSpecLoadBalancingPolicy
 */
export enum VmUserSpecLoadBalancingPolicy {
  /** least_loaded */
  LEAST_UNDERSCORE_LOADED = "least_loaded",
  /** first_available */
  FIRST_UNDERSCORE_AVAILABLE = "first_available",
}

/**
 * PasswordRef allows fetching password from user-create secret by its name and key.
 *
 * @schema VmUserSpecPasswordRef
 */
export interface VmUserSpecPasswordRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecPasswordRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecPasswordRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecPasswordRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecPasswordRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecPasswordRef(obj: VmUserSpecPasswordRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef describes target for user traffic forwarding.
 * one of target types can be chosen:
 * crd or static per targetRef.
 * user can define multiple targetRefs with different ref Types.
 *
 * @schema VmUserSpecTargetRefs
 */
export interface VmUserSpecTargetRefs {
  /**
   * CRD describes exist operator's CRD object,
   * operator generates access url based on CRD params.
   *
   * @schema VmUserSpecTargetRefs#crd
   */
  readonly crd?: VmUserSpecTargetRefsCrd;

  /**
   * DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.
   *
   * @schema VmUserSpecTargetRefs#discover_backend_ips
   */
  readonly discoverBackendIps?: boolean;

  /**
   * DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.
   *
   * @schema VmUserSpecTargetRefs#drop_src_path_prefix_parts
   */
  readonly dropSrcPathPrefixParts?: number;

  /**
   * RequestHeaders represent additional http headers, that vmauth uses
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.68.0 version of vmauth
   *
   * @schema VmUserSpecTargetRefs#headers
   */
  readonly headers?: string[];

  /**
   * @schema VmUserSpecTargetRefs#hosts
   */
  readonly hosts?: string[];

  /**
   * LoadBalancingPolicy defines load balancing policy to use for backend urls.
   * Supported policies: least_loaded, first_available.
   * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
   *
   * @schema VmUserSpecTargetRefs#load_balancing_policy
   */
  readonly loadBalancingPolicy?: VmUserSpecTargetRefsLoadBalancingPolicy;

  /**
   * Paths - matched path to route.
   *
   * @schema VmUserSpecTargetRefs#paths
   */
  readonly paths?: string[];

  /**
   * ResponseHeaders represent additional http headers, that vmauth adds for request response
   * in form of ["header_key: header_value"]
   * multiple values for header key:
   * ["header_key: value1,value2"]
   * it's available since 1.93.0 version of vmauth
   *
   * @schema VmUserSpecTargetRefs#response_headers
   */
  readonly responseHeaders?: string[];

  /**
   * RetryStatusCodes defines http status codes in numeric format for request retries
   * Can be defined per target or at VMUser.spec level
   * e.g. [429,503]
   *
   * @schema VmUserSpecTargetRefs#retry_status_codes
   */
  readonly retryStatusCodes?: number[];

  /**
   * SrcHeaders is an optional list of headers, which must match request headers.
   *
   * @schema VmUserSpecTargetRefs#src_headers
   */
  readonly srcHeaders?: string[];

  /**
   * SrcQueryArgs is an optional list of query args, which must match request URL query args.
   *
   * @schema VmUserSpecTargetRefs#src_query_args
   */
  readonly srcQueryArgs?: string[];

  /**
   * Static - user defined url for traffic forward,
   * for instance http://vmsingle:8428
   *
   * @schema VmUserSpecTargetRefs#static
   */
  readonly static?: VmUserSpecTargetRefsStatic;

  /**
   * TargetRefBasicAuth allow an target endpoint to authenticate over basic authentication
   *
   * @schema VmUserSpecTargetRefs#targetRefBasicAuth
   */
  readonly targetRefBasicAuth?: VmUserSpecTargetRefsTargetRefBasicAuth;

  /**
   * TargetPathSuffix allows to add some suffix to the target path
   * It allows to hide tenant configuration from user with crd as ref.
   * it also may contain any url encoded params.
   *
   * @schema VmUserSpecTargetRefs#target_path_suffix
   */
  readonly targetPathSuffix?: string;

}

/**
 * Converts an object of type 'VmUserSpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefs(obj: VmUserSpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crd': toJson_VmUserSpecTargetRefsCrd(obj.crd),
    'discover_backend_ips': obj.discoverBackendIps,
    'drop_src_path_prefix_parts': obj.dropSrcPathPrefixParts,
    'headers': obj.headers?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'load_balancing_policy': obj.loadBalancingPolicy,
    'paths': obj.paths?.map(y => y),
    'response_headers': obj.responseHeaders?.map(y => y),
    'retry_status_codes': obj.retryStatusCodes?.map(y => y),
    'src_headers': obj.srcHeaders?.map(y => y),
    'src_query_args': obj.srcQueryArgs?.map(y => y),
    'static': toJson_VmUserSpecTargetRefsStatic(obj.static),
    'targetRefBasicAuth': toJson_VmUserSpecTargetRefsTargetRefBasicAuth(obj.targetRefBasicAuth),
    'target_path_suffix': obj.targetPathSuffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLSConfig defines tls configuration for the backend connection
 *
 * @schema VmUserSpecTlsConfig
 */
export interface VmUserSpecTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema VmUserSpecTlsConfig#ca
   */
  readonly ca?: VmUserSpecTlsConfigCa;

  /**
   * Path to the CA cert in the container to use for the targets.
   *
   * @schema VmUserSpecTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema VmUserSpecTlsConfig#cert
   */
  readonly cert?: VmUserSpecTlsConfigCert;

  /**
   * Path to the client cert file in the container for the targets.
   *
   * @schema VmUserSpecTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema VmUserSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the container for the targets.
   *
   * @schema VmUserSpecTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema VmUserSpecTlsConfig#keySecret
   */
  readonly keySecret?: VmUserSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema VmUserSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfig(obj: VmUserSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_VmUserSpecTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_VmUserSpecTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_VmUserSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenRef allows fetching token from user-created secrets by its name and key.
 *
 * @schema VmUserSpecTokenRef
 */
export interface VmUserSpecTokenRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTokenRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTokenRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTokenRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTokenRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTokenRef(obj: VmUserSpecTokenRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CRD describes exist operator's CRD object,
 * operator generates access url based on CRD params.
 *
 * @schema VmUserSpecTargetRefsCrd
 */
export interface VmUserSpecTargetRefsCrd {
  /**
   * Kind one of:
   * VMAgent,VMAlert, VMSingle, VMCluster/vmselect, VMCluster/vmstorage,VMCluster/vminsert,VMAlertManager, VLSingle, VLCluster/vlinsert, VLCluster/vlselect, VLCluster/vlstorage, VTSingle, VTCluster/vtinsert, VTCluster/vtselect, VTCluster/vtstorage and VLAgent
   *
   * @schema VmUserSpecTargetRefsCrd#kind
   */
  readonly kind: VmUserSpecTargetRefsCrdKind;

  /**
   * Name target CRD object name
   *
   * @schema VmUserSpecTargetRefsCrd#name
   */
  readonly name: string;

  /**
   * Namespace target CRD object namespace.
   *
   * @schema VmUserSpecTargetRefsCrd#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VmUserSpecTargetRefsCrd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefsCrd(obj: VmUserSpecTargetRefsCrd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancingPolicy defines load balancing policy to use for backend urls.
 * Supported policies: least_loaded, first_available.
 * See [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default "least_loaded")
 *
 * @schema VmUserSpecTargetRefsLoadBalancingPolicy
 */
export enum VmUserSpecTargetRefsLoadBalancingPolicy {
  /** least_loaded */
  LEAST_UNDERSCORE_LOADED = "least_loaded",
  /** first_available */
  FIRST_UNDERSCORE_AVAILABLE = "first_available",
}

/**
 * Static - user defined url for traffic forward,
 * for instance http://vmsingle:8428
 *
 * @schema VmUserSpecTargetRefsStatic
 */
export interface VmUserSpecTargetRefsStatic {
  /**
   * URL http url for given staticRef.
   *
   * @schema VmUserSpecTargetRefsStatic#url
   */
  readonly url?: string;

  /**
   * URLs allows setting multiple urls for load-balancing at vmauth-side.
   *
   * @schema VmUserSpecTargetRefsStatic#urls
   */
  readonly urls?: string[];

}

/**
 * Converts an object of type 'VmUserSpecTargetRefsStatic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefsStatic(obj: VmUserSpecTargetRefsStatic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
    'urls': obj.urls?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRefBasicAuth allow an target endpoint to authenticate over basic authentication
 *
 * @schema VmUserSpecTargetRefsTargetRefBasicAuth
 */
export interface VmUserSpecTargetRefsTargetRefBasicAuth {
  /**
   * The secret in the service scrape namespace that contains the password
   * for authentication.
   * It must be at them same namespace as CRD
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuth#password
   */
  readonly password: VmUserSpecTargetRefsTargetRefBasicAuthPassword;

  /**
   * The secret in the service scrape namespace that contains the username
   * for authentication.
   * It must be at them same namespace as CRD
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuth#username
   */
  readonly username: VmUserSpecTargetRefsTargetRefBasicAuthUsername;

}

/**
 * Converts an object of type 'VmUserSpecTargetRefsTargetRefBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefsTargetRefBasicAuth(obj: VmUserSpecTargetRefsTargetRefBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_VmUserSpecTargetRefsTargetRefBasicAuthPassword(obj.password),
    'username': toJson_VmUserSpecTargetRefsTargetRefBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema VmUserSpecTlsConfigCa
 */
export interface VmUserSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmUserSpecTlsConfigCa#configMap
   */
  readonly configMap?: VmUserSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmUserSpecTlsConfigCa#secret
   */
  readonly secret?: VmUserSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCa(obj: VmUserSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmUserSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_VmUserSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema VmUserSpecTlsConfigCert
 */
export interface VmUserSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema VmUserSpecTlsConfigCert#configMap
   */
  readonly configMap?: VmUserSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema VmUserSpecTlsConfigCert#secret
   */
  readonly secret?: VmUserSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCert(obj: VmUserSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_VmUserSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_VmUserSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema VmUserSpecTlsConfigKeySecret
 */
export interface VmUserSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigKeySecret(obj: VmUserSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind one of:
 * VMAgent,VMAlert, VMSingle, VMCluster/vmselect, VMCluster/vmstorage,VMCluster/vminsert,VMAlertManager, VLSingle, VLCluster/vlinsert, VLCluster/vlselect, VLCluster/vlstorage, VTSingle, VTCluster/vtinsert, VTCluster/vtselect, VTCluster/vtstorage and VLAgent
 *
 * @schema VmUserSpecTargetRefsCrdKind
 */
export enum VmUserSpecTargetRefsCrdKind {
  /** VMAgent */
  VM_AGENT = "VMAgent",
  /** VMAlert */
  VM_ALERT = "VMAlert",
  /** VMSingle */
  VM_SINGLE = "VMSingle",
  /** VLogs */
  V_LOGS = "VLogs",
  /** VMAlertManager */
  VM_ALERT_MANAGER = "VMAlertManager",
  /** VMCluster/vmselect */
  VM_CLUSTER_FORWARD_SLASH_VMSELECT = "VMCluster/vmselect",
  /** VMCluster/vmstorage */
  VM_CLUSTER_FORWARD_SLASH_VMSTORAGE = "VMCluster/vmstorage",
  /** VMCluster/vminsert */
  VM_CLUSTER_FORWARD_SLASH_VMINSERT = "VMCluster/vminsert",
  /** VLSingle */
  VL_SINGLE = "VLSingle",
  /** VLCluster/vlinsert */
  VL_CLUSTER_FORWARD_SLASH_VLINSERT = "VLCluster/vlinsert",
  /** VLCluster/vlselect */
  VL_CLUSTER_FORWARD_SLASH_VLSELECT = "VLCluster/vlselect",
  /** VLCluster/vlstorage */
  VL_CLUSTER_FORWARD_SLASH_VLSTORAGE = "VLCluster/vlstorage",
  /** VLAgent */
  VL_AGENT = "VLAgent",
  /** VTCluster/vtinsert */
  VT_CLUSTER_FORWARD_SLASH_VTINSERT = "VTCluster/vtinsert",
  /** VTCluster/vtselect */
  VT_CLUSTER_FORWARD_SLASH_VTSELECT = "VTCluster/vtselect",
  /** VTCluster/vtstorage */
  VT_CLUSTER_FORWARD_SLASH_VTSTORAGE = "VTCluster/vtstorage",
  /** VTSingle */
  VT_SINGLE = "VTSingle",
}

/**
 * The secret in the service scrape namespace that contains the password
 * for authentication.
 * It must be at them same namespace as CRD
 *
 * @schema VmUserSpecTargetRefsTargetRefBasicAuthPassword
 */
export interface VmUserSpecTargetRefsTargetRefBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTargetRefsTargetRefBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefsTargetRefBasicAuthPassword(obj: VmUserSpecTargetRefsTargetRefBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret in the service scrape namespace that contains the username
 * for authentication.
 * It must be at them same namespace as CRD
 *
 * @schema VmUserSpecTargetRefsTargetRefBasicAuthUsername
 */
export interface VmUserSpecTargetRefsTargetRefBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTargetRefsTargetRefBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTargetRefsTargetRefBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTargetRefsTargetRefBasicAuthUsername(obj: VmUserSpecTargetRefsTargetRefBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmUserSpecTlsConfigCaConfigMap
 */
export interface VmUserSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema VmUserSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmUserSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCaConfigMap(obj: VmUserSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmUserSpecTlsConfigCaSecret
 */
export interface VmUserSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCaSecret(obj: VmUserSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema VmUserSpecTlsConfigCertConfigMap
 */
export interface VmUserSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema VmUserSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema VmUserSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCertConfigMap(obj: VmUserSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema VmUserSpecTlsConfigCertSecret
 */
export interface VmUserSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VmUserSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VmUserSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VmUserSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VmUserSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VmUserSpecTlsConfigCertSecret(obj: VmUserSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VTCluster is fast, cost-effective and scalable traces database.
 *
 * @schema VTCluster
 */
export class VtCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VTCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VTCluster',
  }

  /**
   * Renders a Kubernetes manifest for "VTCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VtClusterProps = {}): any {
    return {
      ...VtCluster.GVK,
      ...toJson_VtClusterProps(props),
    };
  }

  /**
   * Defines a "VTCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VtClusterProps = {}) {
    super(scope, id, {
      ...VtCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VtCluster.GVK,
      ...toJson_VtClusterProps(resolved),
    };
  }
}

/**
 * VTCluster is fast, cost-effective and scalable traces database.
 *
 * @schema VTCluster
 */
export interface VtClusterProps {
  /**
   * @schema VTCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VTClusterSpec defines the desired state of VTCluster
   *
   * @schema VTCluster#spec
   */
  readonly spec?: VtClusterSpec;

}

/**
 * Converts an object of type 'VtClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterProps(obj: VtClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VtClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VTClusterSpec defines the desired state of VTCluster
 *
 * @schema VtClusterSpec
 */
export interface VtClusterSpec {
  /**
   * ClusterDomainName defines domain name suffix for in-cluster dns addresses
   * aka .cluster.local
   * used by vtinsert and vtselect to build vtstorage address
   *
   * @schema VtClusterSpec#clusterDomainName
   */
  readonly clusterDomainName?: string;

  /**
   * ClusterVersion defines default images tag for all components.
   * it can be overwritten with component specific image.tag value.
   *
   * @schema VtClusterSpec#clusterVersion
   */
  readonly clusterVersion?: string;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VtClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VtClusterSpecImagePullSecrets[];

  /**
   * VTInsert defines vtinsert component configuration at victoria-traces cluster
   *
   * @schema VtClusterSpec#insert
   */
  readonly insert?: VtClusterSpecInsert;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VtClusterSpec#managedMetadata
   */
  readonly managedMetadata?: VtClusterSpecManagedMetadata;

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VtClusterSpec#paused
   */
  readonly paused?: boolean;

  /**
   * RequestsLoadBalancer configures load-balancing for vtinsert and vtselect requests.
   * It helps to evenly spread load across pods.
   * Usually it's not possible with Kubernetes TCP-based services.
   *
   * @schema VtClusterSpec#requestsLoadBalancer
   */
  readonly requestsLoadBalancer?: VtClusterSpecRequestsLoadBalancer;

  /**
   * VTSelect defines vtselect component configuration at victoria-traces cluster
   *
   * @schema VtClusterSpec#select
   */
  readonly select?: VtClusterSpecSelect;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the
   * VTSelect, VTInsert and VTStorage Pods.
   *
   * @schema VtClusterSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * VTStorage defines vtstorage component configuration at victoria-traces cluster
   *
   * @schema VtClusterSpec#storage
   */
  readonly storage?: VtClusterSpecStorage;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VtClusterSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpec(obj: VtClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterDomainName': obj.clusterDomainName,
    'clusterVersion': obj.clusterVersion,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VtClusterSpecImagePullSecrets(y)),
    'insert': toJson_VtClusterSpecInsert(obj.insert),
    'managedMetadata': toJson_VtClusterSpecManagedMetadata(obj.managedMetadata),
    'paused': obj.paused,
    'requestsLoadBalancer': toJson_VtClusterSpecRequestsLoadBalancer(obj.requestsLoadBalancer),
    'select': toJson_VtClusterSpecSelect(obj.select),
    'serviceAccountName': obj.serviceAccountName,
    'storage': toJson_VtClusterSpecStorage(obj.storage),
    'useStrictSecurity': obj.useStrictSecurity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VtClusterSpecImagePullSecrets
 */
export interface VtClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecImagePullSecrets(obj: VtClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VTInsert defines vtinsert component configuration at victoria-traces cluster
 *
 * @schema VtClusterSpecInsert
 */
export interface VtClusterSpecInsert {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VtClusterSpecInsert#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VtClusterSpecInsert#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VtClusterSpecInsert#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VtClusterSpecInsert#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VtClusterSpecInsert#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VtClusterSpecInsert#dnsConfig
   */
  readonly dnsConfig?: VtClusterSpecInsertDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VtClusterSpecInsert#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VtClusterSpecInsert#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VtClusterSpecInsert#extraEnvs
   */
  readonly extraEnvs?: VtClusterSpecInsertExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VtClusterSpecInsert#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VtClusterSpecInsertExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VtClusterSpecInsert#hostAliases
   */
  readonly hostAliases?: VtClusterSpecInsertHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VtClusterSpecInsert#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Configures horizontal pod autoscaling.
   *
   * @schema VtClusterSpecInsert#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VtClusterSpecInsert#image
   */
  readonly image?: VtClusterSpecInsertImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VtClusterSpecInsert#imagePullSecrets
   */
  readonly imagePullSecrets?: VtClusterSpecInsertImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VtClusterSpecInsert#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecInsert#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VTSelect to be configured with.
   * default or json
   *
   * @schema VtClusterSpecInsert#logFormat
   */
  readonly logFormat?: VtClusterSpecInsertLogFormat;

  /**
   * LogLevel for VTSelect to be configured with.
   *
   * @schema VtClusterSpecInsert#logLevel
   */
  readonly logLevel?: VtClusterSpecInsertLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VtClusterSpecInsert#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VtClusterSpecInsert#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VtClusterSpecInsert#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VtClusterSpecInsert#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VtClusterSpecInsertPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VTSelect pods.
   *
   * @schema VtClusterSpecInsert#podMetadata
   */
  readonly podMetadata?: VtClusterSpecInsertPodMetadata;

  /**
   * Port listen address
   *
   * @schema VtClusterSpecInsert#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VtClusterSpecInsert#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VtClusterSpecInsert#readinessGates
   */
  readonly readinessGates?: VtClusterSpecInsertReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecInsert#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VtClusterSpecInsert#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VtClusterSpecInsert#resources
   */
  readonly resources?: VtClusterSpecInsertResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VtClusterSpecInsert#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VtClusterSpecInsert#rollingUpdate
   */
  readonly rollingUpdate?: VtClusterSpecInsertRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VtClusterSpecInsert#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VtClusterSpecInsert#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VtClusterSpecInsert#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VtClusterSpecInsert#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vtselect VMServiceScrape spec
   *
   * @schema VtClusterSpecInsert#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vtselect service spec
   *
   * @schema VtClusterSpecInsert#serviceSpec
   */
  readonly serviceSpec?: VtClusterSpecInsertServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VtClusterSpecInsert#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VtClusterSpecInsert#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VtClusterSpecInsert#tolerations
   */
  readonly tolerations?: VtClusterSpecInsertTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VtClusterSpecInsert#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VtClusterSpecInsert#updateStrategy
   */
  readonly updateStrategy?: VtClusterSpecInsertUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VtClusterSpecInsert#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VtClusterSpecInsert#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VtClusterSpecInsert#volumeMounts
   */
  readonly volumeMounts?: VtClusterSpecInsertVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VtClusterSpecInsert#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VtClusterSpecInsert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsert(obj: VtClusterSpecInsert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VtClusterSpecInsertDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VtClusterSpecInsertExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VtClusterSpecInsertExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VtClusterSpecInsertHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VtClusterSpecInsertImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VtClusterSpecInsertImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VtClusterSpecInsertPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VtClusterSpecInsertPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VtClusterSpecInsertReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VtClusterSpecInsertResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VtClusterSpecInsertRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VtClusterSpecInsertServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VtClusterSpecInsertTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VtClusterSpecInsertVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VtClusterSpecManagedMetadata
 */
export interface VtClusterSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtClusterSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecManagedMetadata(obj: VtClusterSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestsLoadBalancer configures load-balancing for vtinsert and vtselect requests.
 * It helps to evenly spread load across pods.
 * Usually it's not possible with Kubernetes TCP-based services.
 *
 * @schema VtClusterSpecRequestsLoadBalancer
 */
export interface VtClusterSpecRequestsLoadBalancer {
  /**
   * @schema VtClusterSpecRequestsLoadBalancer#disableInsertBalancing
   */
  readonly disableInsertBalancing?: boolean;

  /**
   * @schema VtClusterSpecRequestsLoadBalancer#disableSelectBalancing
   */
  readonly disableSelectBalancing?: boolean;

  /**
   * @schema VtClusterSpecRequestsLoadBalancer#enabled
   */
  readonly enabled?: boolean;

  /**
   * VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer
   * for VMCluster component
   *
   * @schema VtClusterSpecRequestsLoadBalancer#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'VtClusterSpecRequestsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecRequestsLoadBalancer(obj: VtClusterSpecRequestsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableInsertBalancing': obj.disableInsertBalancing,
    'disableSelectBalancing': obj.disableSelectBalancing,
    'enabled': obj.enabled,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VTSelect defines vtselect component configuration at victoria-traces cluster
 *
 * @schema VtClusterSpecSelect
 */
export interface VtClusterSpecSelect {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VtClusterSpecSelect#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VtClusterSpecSelect#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VtClusterSpecSelect#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VtClusterSpecSelect#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VtClusterSpecSelect#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VtClusterSpecSelect#dnsConfig
   */
  readonly dnsConfig?: VtClusterSpecSelectDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VtClusterSpecSelect#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VtClusterSpecSelect#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VtClusterSpecSelect#extraEnvs
   */
  readonly extraEnvs?: VtClusterSpecSelectExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VtClusterSpecSelect#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VtClusterSpecSelectExtraEnvsFrom[];

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VtClusterSpecSelect#hostAliases
   */
  readonly hostAliases?: VtClusterSpecSelectHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VtClusterSpecSelect#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Configures horizontal pod autoscaling.
   *
   * @schema VtClusterSpecSelect#hpa
   */
  readonly hpa?: any;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VtClusterSpecSelect#image
   */
  readonly image?: VtClusterSpecSelectImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VtClusterSpecSelect#imagePullSecrets
   */
  readonly imagePullSecrets?: VtClusterSpecSelectImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VtClusterSpecSelect#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecSelect#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VTSelect to be configured with.
   * default or json
   *
   * @schema VtClusterSpecSelect#logFormat
   */
  readonly logFormat?: VtClusterSpecSelectLogFormat;

  /**
   * LogLevel for VTSelect to be configured with.
   *
   * @schema VtClusterSpecSelect#logLevel
   */
  readonly logLevel?: VtClusterSpecSelectLogLevel;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VtClusterSpecSelect#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VtClusterSpecSelect#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VtClusterSpecSelect#paused
   */
  readonly paused?: boolean;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VtClusterSpecSelect#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VtClusterSpecSelectPodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VTSelect pods.
   *
   * @schema VtClusterSpecSelect#podMetadata
   */
  readonly podMetadata?: VtClusterSpecSelectPodMetadata;

  /**
   * Port listen address
   *
   * @schema VtClusterSpecSelect#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VtClusterSpecSelect#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VtClusterSpecSelect#readinessGates
   */
  readonly readinessGates?: VtClusterSpecSelectReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecSelect#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VtClusterSpecSelect#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VtClusterSpecSelect#resources
   */
  readonly resources?: VtClusterSpecSelectResources;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VtClusterSpecSelect#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdate - overrides deployment update params.
   *
   * @schema VtClusterSpecSelect#rollingUpdate
   */
  readonly rollingUpdate?: VtClusterSpecSelectRollingUpdate;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VtClusterSpecSelect#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VtClusterSpecSelect#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VtClusterSpecSelect#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VtClusterSpecSelect#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vtselect VMServiceScrape spec
   *
   * @schema VtClusterSpecSelect#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vtselect service spec
   *
   * @schema VtClusterSpecSelect#serviceSpec
   */
  readonly serviceSpec?: VtClusterSpecSelectServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VtClusterSpecSelect#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VtClusterSpecSelect#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VtClusterSpecSelect#tolerations
   */
  readonly tolerations?: VtClusterSpecSelectTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VtClusterSpecSelect#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UpdateStrategy - overrides default update strategy.
   *
   * @schema VtClusterSpecSelect#updateStrategy
   */
  readonly updateStrategy?: VtClusterSpecSelectUpdateStrategy;

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VtClusterSpecSelect#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VtClusterSpecSelect#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VtClusterSpecSelect#volumeMounts
   */
  readonly volumeMounts?: VtClusterSpecSelectVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VtClusterSpecSelect#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VtClusterSpecSelect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelect(obj: VtClusterSpecSelect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VtClusterSpecSelectDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VtClusterSpecSelectExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VtClusterSpecSelectExtraEnvsFrom(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_VtClusterSpecSelectHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'hpa': obj.hpa,
    'image': toJson_VtClusterSpecSelectImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VtClusterSpecSelectImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podDisruptionBudget': toJson_VtClusterSpecSelectPodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VtClusterSpecSelectPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VtClusterSpecSelectReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VtClusterSpecSelectResources(obj.resources),
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdate': toJson_VtClusterSpecSelectRollingUpdate(obj.rollingUpdate),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VtClusterSpecSelectServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VtClusterSpecSelectTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'updateStrategy': obj.updateStrategy,
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VtClusterSpecSelectVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VTStorage defines vtstorage component configuration at victoria-traces cluster
 *
 * @schema VtClusterSpecStorage
 */
export interface VtClusterSpecStorage {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VtClusterSpecStorage#affinity
   */
  readonly affinity?: any;

  /**
   * ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
   *
   * @schema VtClusterSpecStorage#claimTemplates
   */
  readonly claimTemplates?: any[];

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VtClusterSpecStorage#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VtClusterSpecStorage#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VtClusterSpecStorage#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VtClusterSpecStorage#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VtClusterSpecStorage#dnsConfig
   */
  readonly dnsConfig?: VtClusterSpecStorageDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VtClusterSpecStorage#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VtClusterSpecStorage#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VtClusterSpecStorage#extraEnvs
   */
  readonly extraEnvs?: VtClusterSpecStorageExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VtClusterSpecStorage#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VtClusterSpecStorageExtraEnvsFrom[];

  /**
   * FutureRetention for the stored traces
   * Log entries with timestamps bigger than now+futureRetention are rejected during data ingestion
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtClusterSpecStorage#futureRetention
   */
  readonly futureRetention?: string;

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VtClusterSpecStorage#hostAliases
   */
  readonly hostAliases?: VtClusterSpecStorageHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VtClusterSpecStorage#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VtClusterSpecStorage#image
   */
  readonly image?: VtClusterSpecStorageImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VtClusterSpecStorage#imagePullSecrets
   */
  readonly imagePullSecrets?: VtClusterSpecStorageImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VtClusterSpecStorage#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecStorage#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VTStorage to be configured with.
   * default or json
   *
   * @schema VtClusterSpecStorage#logFormat
   */
  readonly logFormat?: VtClusterSpecStorageLogFormat;

  /**
   * Whether to log all the ingested log entries; this can be useful for debugging of data ingestion
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtClusterSpecStorage#logIngestedRows
   */
  readonly logIngestedRows?: boolean;

  /**
   * LogLevel for VTStorage to be configured with.
   *
   * @schema VtClusterSpecStorage#logLevel
   */
  readonly logLevel?: VtClusterSpecStorageLogLevel;

  /**
   * LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtClusterSpecStorage#logNewStreams
   */
  readonly logNewStreams?: boolean;

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   * lets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].
   * Useful at storage expanding, when you want to rebalance some data at cluster.
   *
   * @schema VtClusterSpecStorage#maintenanceInsertNodeIDs
   */
  readonly maintenanceInsertNodeIDs?: number[];

  /**
   * MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
   *
   * @schema VtClusterSpecStorage#maintenanceSelectNodeIDs
   */
  readonly maintenanceSelectNodeIDs?: number[];

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VtClusterSpecStorage#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VtClusterSpecStorage#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VtClusterSpecStorage#paused
   */
  readonly paused?: boolean;

  /**
   * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
   *
   * @schema VtClusterSpecStorage#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy;

  /**
   * PodDisruptionBudget created by operator
   *
   * @schema VtClusterSpecStorage#podDisruptionBudget
   */
  readonly podDisruptionBudget?: VtClusterSpecStoragePodDisruptionBudget;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VTStorage pods.
   *
   * @schema VtClusterSpecStorage#podMetadata
   */
  readonly podMetadata?: VtClusterSpecStoragePodMetadata;

  /**
   * Port listen address
   *
   * @schema VtClusterSpecStorage#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VtClusterSpecStorage#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VtClusterSpecStorage#readinessGates
   */
  readonly readinessGates?: VtClusterSpecStorageReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VtClusterSpecStorage#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VtClusterSpecStorage#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VtClusterSpecStorage#resources
   */
  readonly resources?: VtClusterSpecStorageResources;

  /**
   * RetentionMaxDiskSpaceUsageBytes for the stored traces
   * VictoriaTraces keeps at least two last days of data in order to guarantee that the traces for the last day can be returned in queries.
   * This means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,
   * if the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.
   * https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtClusterSpecStorage#retentionMaxDiskSpaceUsageBytes
   */
  readonly retentionMaxDiskSpaceUsageBytes?: string;

  /**
   * RetentionPeriod for the stored traces
   * https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtClusterSpecStorage#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VtClusterSpecStorage#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RollingUpdateStrategy defines strategy for application updates
   * Default is OnDelete, in this case operator handles update process
   * Can be changed for RollingUpdate
   *
   * @default OnDelete, in this case operator handles update process
   * @schema VtClusterSpecStorage#rollingUpdateStrategy
   */
  readonly rollingUpdateStrategy?: string;

  /**
   * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
   * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
   *
   * @schema VtClusterSpecStorage#rollingUpdateStrategyBehavior
   */
  readonly rollingUpdateStrategyBehavior?: VtClusterSpecStorageRollingUpdateStrategyBehavior;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VtClusterSpecStorage#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VtClusterSpecStorage#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VtClusterSpecStorage#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VtClusterSpecStorage#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceScrapeSpec that will be added to vtselect VMServiceScrape spec
   *
   * @schema VtClusterSpecStorage#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vtselect service spec
   *
   * @schema VtClusterSpecStorage#serviceSpec
   */
  readonly serviceSpec?: VtClusterSpecStorageServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VtClusterSpecStorage#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage configures persistent volume for VTStorage
   *
   * @schema VtClusterSpecStorage#storage
   */
  readonly storage?: VtClusterSpecStorageStorage;

  /**
   * StorageDataPath - path to storage data
   *
   * @schema VtClusterSpecStorage#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VtClusterSpecStorage#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VtClusterSpecStorage#tolerations
   */
  readonly tolerations?: VtClusterSpecStorageTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VtClusterSpecStorage#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VtClusterSpecStorage#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VtClusterSpecStorage#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VtClusterSpecStorage#volumeMounts
   */
  readonly volumeMounts?: VtClusterSpecStorageVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VtClusterSpecStorage#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VtClusterSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorage(obj: VtClusterSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'claimTemplates': obj.claimTemplates?.map(y => y),
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VtClusterSpecStorageDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VtClusterSpecStorageExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VtClusterSpecStorageExtraEnvsFrom(y)),
    'futureRetention': obj.futureRetention,
    'hostAliases': obj.hostAliases?.map(y => toJson_VtClusterSpecStorageHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VtClusterSpecStorageImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VtClusterSpecStorageImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logIngestedRows': obj.logIngestedRows,
    'logLevel': obj.logLevel,
    'logNewStreams': obj.logNewStreams,
    'maintenanceInsertNodeIDs': obj.maintenanceInsertNodeIDs?.map(y => y),
    'maintenanceSelectNodeIDs': obj.maintenanceSelectNodeIDs?.map(y => y),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podDisruptionBudget': toJson_VtClusterSpecStoragePodDisruptionBudget(obj.podDisruptionBudget),
    'podMetadata': toJson_VtClusterSpecStoragePodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VtClusterSpecStorageReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VtClusterSpecStorageResources(obj.resources),
    'retentionMaxDiskSpaceUsageBytes': obj.retentionMaxDiskSpaceUsageBytes,
    'retentionPeriod': obj.retentionPeriod,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'rollingUpdateStrategy': obj.rollingUpdateStrategy,
    'rollingUpdateStrategyBehavior': toJson_VtClusterSpecStorageRollingUpdateStrategyBehavior(obj.rollingUpdateStrategyBehavior),
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VtClusterSpecStorageServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VtClusterSpecStorageStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VtClusterSpecStorageTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VtClusterSpecStorageVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VtClusterSpecInsertDnsConfig
 */
export interface VtClusterSpecInsertDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VtClusterSpecInsertDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VtClusterSpecInsertDnsConfig#options
   */
  readonly options?: VtClusterSpecInsertDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VtClusterSpecInsertDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VtClusterSpecInsertDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertDnsConfig(obj: VtClusterSpecInsertDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VtClusterSpecInsertDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VtClusterSpecInsertExtraEnvs
 */
export interface VtClusterSpecInsertExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecInsertExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VtClusterSpecInsertExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertExtraEnvs(obj: VtClusterSpecInsertExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VtClusterSpecInsertExtraEnvsFrom
 */
export interface VtClusterSpecInsertExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VtClusterSpecInsertExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VtClusterSpecInsertExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecInsertExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VtClusterSpecInsertExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VtClusterSpecInsertExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VtClusterSpecInsertExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertExtraEnvsFrom(obj: VtClusterSpecInsertExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VtClusterSpecInsertExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VtClusterSpecInsertExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VtClusterSpecInsertHostAliases
 */
export interface VtClusterSpecInsertHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VtClusterSpecInsertHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VtClusterSpecInsertHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertHostAliases(obj: VtClusterSpecInsertHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VtClusterSpecInsertImage
 */
export interface VtClusterSpecInsertImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VtClusterSpecInsertImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VtClusterSpecInsertImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VtClusterSpecInsertImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertImage(obj: VtClusterSpecInsertImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VtClusterSpecInsertImagePullSecrets
 */
export interface VtClusterSpecInsertImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecInsertImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertImagePullSecrets(obj: VtClusterSpecInsertImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VTSelect to be configured with.
 * default or json
 *
 * @schema VtClusterSpecInsertLogFormat
 */
export enum VtClusterSpecInsertLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VTSelect to be configured with.
 *
 * @schema VtClusterSpecInsertLogLevel
 */
export enum VtClusterSpecInsertLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VtClusterSpecInsertPodDisruptionBudget
 */
export interface VtClusterSpecInsertPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VtClusterSpecInsertPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VtClusterSpecInsertPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VtClusterSpecInsertPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VtClusterSpecInsertPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtClusterSpecInsertPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertPodDisruptionBudget(obj: VtClusterSpecInsertPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VTSelect pods.
 *
 * @schema VtClusterSpecInsertPodMetadata
 */
export interface VtClusterSpecInsertPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecInsertPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecInsertPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecInsertPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertPodMetadata(obj: VtClusterSpecInsertPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VtClusterSpecInsertReadinessGates
 */
export interface VtClusterSpecInsertReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VtClusterSpecInsertReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertReadinessGates(obj: VtClusterSpecInsertReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VtClusterSpecInsertResources
 */
export interface VtClusterSpecInsertResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VtClusterSpecInsertResources#claims
   */
  readonly claims?: VtClusterSpecInsertResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecInsertResources#limits
   */
  readonly limits?: { [key: string]: VtClusterSpecInsertResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecInsertResources#requests
   */
  readonly requests?: { [key: string]: VtClusterSpecInsertResourcesRequests };

}

/**
 * Converts an object of type 'VtClusterSpecInsertResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertResources(obj: VtClusterSpecInsertResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VtClusterSpecInsertResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VtClusterSpecInsertRollingUpdate
 */
export interface VtClusterSpecInsertRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VtClusterSpecInsertRollingUpdate#maxSurge
   */
  readonly maxSurge?: VtClusterSpecInsertRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VtClusterSpecInsertRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecInsertRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VtClusterSpecInsertRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertRollingUpdate(obj: VtClusterSpecInsertRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vtselect service spec
 *
 * @schema VtClusterSpecInsertServiceSpec
 */
export interface VtClusterSpecInsertServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VtClusterSpecInsertServiceSpec#metadata
   */
  readonly metadata?: VtClusterSpecInsertServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VtClusterSpecInsertServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VtClusterSpecInsertServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecInsertServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertServiceSpec(obj: VtClusterSpecInsertServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VtClusterSpecInsertServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VtClusterSpecInsertTolerations
 */
export interface VtClusterSpecInsertTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VtClusterSpecInsertTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VtClusterSpecInsertTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VtClusterSpecInsertTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VtClusterSpecInsertTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VtClusterSpecInsertTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertTolerations(obj: VtClusterSpecInsertTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VtClusterSpecInsertUpdateStrategy
 */
export enum VtClusterSpecInsertUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VtClusterSpecInsertVolumeMounts
 */
export interface VtClusterSpecInsertVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VtClusterSpecInsertVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VtClusterSpecInsertVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VtClusterSpecInsertVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VtClusterSpecInsertVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VtClusterSpecInsertVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VtClusterSpecInsertVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VtClusterSpecInsertVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertVolumeMounts(obj: VtClusterSpecInsertVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VtClusterSpecSelectDnsConfig
 */
export interface VtClusterSpecSelectDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VtClusterSpecSelectDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VtClusterSpecSelectDnsConfig#options
   */
  readonly options?: VtClusterSpecSelectDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VtClusterSpecSelectDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VtClusterSpecSelectDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectDnsConfig(obj: VtClusterSpecSelectDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VtClusterSpecSelectDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VtClusterSpecSelectExtraEnvs
 */
export interface VtClusterSpecSelectExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecSelectExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VtClusterSpecSelectExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectExtraEnvs(obj: VtClusterSpecSelectExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VtClusterSpecSelectExtraEnvsFrom
 */
export interface VtClusterSpecSelectExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VtClusterSpecSelectExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VtClusterSpecSelectExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecSelectExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VtClusterSpecSelectExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VtClusterSpecSelectExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VtClusterSpecSelectExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectExtraEnvsFrom(obj: VtClusterSpecSelectExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VtClusterSpecSelectExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VtClusterSpecSelectExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VtClusterSpecSelectHostAliases
 */
export interface VtClusterSpecSelectHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VtClusterSpecSelectHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VtClusterSpecSelectHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectHostAliases(obj: VtClusterSpecSelectHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VtClusterSpecSelectImage
 */
export interface VtClusterSpecSelectImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VtClusterSpecSelectImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VtClusterSpecSelectImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VtClusterSpecSelectImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectImage(obj: VtClusterSpecSelectImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VtClusterSpecSelectImagePullSecrets
 */
export interface VtClusterSpecSelectImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecSelectImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectImagePullSecrets(obj: VtClusterSpecSelectImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VTSelect to be configured with.
 * default or json
 *
 * @schema VtClusterSpecSelectLogFormat
 */
export enum VtClusterSpecSelectLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VTSelect to be configured with.
 *
 * @schema VtClusterSpecSelectLogLevel
 */
export enum VtClusterSpecSelectLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VtClusterSpecSelectPodDisruptionBudget
 */
export interface VtClusterSpecSelectPodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VtClusterSpecSelectPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VtClusterSpecSelectPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VtClusterSpecSelectPodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VtClusterSpecSelectPodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtClusterSpecSelectPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectPodDisruptionBudget(obj: VtClusterSpecSelectPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VTSelect pods.
 *
 * @schema VtClusterSpecSelectPodMetadata
 */
export interface VtClusterSpecSelectPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecSelectPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecSelectPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecSelectPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectPodMetadata(obj: VtClusterSpecSelectPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VtClusterSpecSelectReadinessGates
 */
export interface VtClusterSpecSelectReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VtClusterSpecSelectReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectReadinessGates(obj: VtClusterSpecSelectReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VtClusterSpecSelectResources
 */
export interface VtClusterSpecSelectResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VtClusterSpecSelectResources#claims
   */
  readonly claims?: VtClusterSpecSelectResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecSelectResources#limits
   */
  readonly limits?: { [key: string]: VtClusterSpecSelectResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecSelectResources#requests
   */
  readonly requests?: { [key: string]: VtClusterSpecSelectResourcesRequests };

}

/**
 * Converts an object of type 'VtClusterSpecSelectResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectResources(obj: VtClusterSpecSelectResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VtClusterSpecSelectResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdate - overrides deployment update params.
 *
 * @schema VtClusterSpecSelectRollingUpdate
 */
export interface VtClusterSpecSelectRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema VtClusterSpecSelectRollingUpdate#maxSurge
   */
  readonly maxSurge?: VtClusterSpecSelectRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema VtClusterSpecSelectRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecSelectRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'VtClusterSpecSelectRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectRollingUpdate(obj: VtClusterSpecSelectRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vtselect service spec
 *
 * @schema VtClusterSpecSelectServiceSpec
 */
export interface VtClusterSpecSelectServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VtClusterSpecSelectServiceSpec#metadata
   */
  readonly metadata?: VtClusterSpecSelectServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VtClusterSpecSelectServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VtClusterSpecSelectServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecSelectServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectServiceSpec(obj: VtClusterSpecSelectServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VtClusterSpecSelectServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VtClusterSpecSelectTolerations
 */
export interface VtClusterSpecSelectTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VtClusterSpecSelectTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VtClusterSpecSelectTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VtClusterSpecSelectTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VtClusterSpecSelectTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VtClusterSpecSelectTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectTolerations(obj: VtClusterSpecSelectTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy - overrides default update strategy.
 *
 * @schema VtClusterSpecSelectUpdateStrategy
 */
export enum VtClusterSpecSelectUpdateStrategy {
  /** Recreate */
  RECREATE = "Recreate",
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VtClusterSpecSelectVolumeMounts
 */
export interface VtClusterSpecSelectVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VtClusterSpecSelectVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VtClusterSpecSelectVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VtClusterSpecSelectVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VtClusterSpecSelectVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VtClusterSpecSelectVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VtClusterSpecSelectVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VtClusterSpecSelectVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectVolumeMounts(obj: VtClusterSpecSelectVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VtClusterSpecStorageDnsConfig
 */
export interface VtClusterSpecStorageDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VtClusterSpecStorageDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VtClusterSpecStorageDnsConfig#options
   */
  readonly options?: VtClusterSpecStorageDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VtClusterSpecStorageDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VtClusterSpecStorageDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageDnsConfig(obj: VtClusterSpecStorageDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VtClusterSpecStorageDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VtClusterSpecStorageExtraEnvs
 */
export interface VtClusterSpecStorageExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecStorageExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VtClusterSpecStorageExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageExtraEnvs(obj: VtClusterSpecStorageExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VtClusterSpecStorageExtraEnvsFrom
 */
export interface VtClusterSpecStorageExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VtClusterSpecStorageExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VtClusterSpecStorageExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VtClusterSpecStorageExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VtClusterSpecStorageExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VtClusterSpecStorageExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VtClusterSpecStorageExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageExtraEnvsFrom(obj: VtClusterSpecStorageExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VtClusterSpecStorageExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VtClusterSpecStorageExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VtClusterSpecStorageHostAliases
 */
export interface VtClusterSpecStorageHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VtClusterSpecStorageHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VtClusterSpecStorageHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageHostAliases(obj: VtClusterSpecStorageHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VtClusterSpecStorageImage
 */
export interface VtClusterSpecStorageImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VtClusterSpecStorageImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VtClusterSpecStorageImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VtClusterSpecStorageImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageImage(obj: VtClusterSpecStorageImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VtClusterSpecStorageImagePullSecrets
 */
export interface VtClusterSpecStorageImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecStorageImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageImagePullSecrets(obj: VtClusterSpecStorageImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VTStorage to be configured with.
 * default or json
 *
 * @schema VtClusterSpecStorageLogFormat
 */
export enum VtClusterSpecStorageLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VTStorage to be configured with.
 *
 * @schema VtClusterSpecStorageLogLevel
 */
export enum VtClusterSpecStorageLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
 *
 * @schema VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy
 */
export interface VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy(obj: VtClusterSpecStoragePersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget created by operator
 *
 * @schema VtClusterSpecStoragePodDisruptionBudget
 */
export interface VtClusterSpecStoragePodDisruptionBudget {
  /**
   * An eviction is allowed if at most "maxUnavailable" pods selected by
   * "selector" are unavailable after the eviction, i.e. even in absence of
   * the evicted pod. For example, one can prevent all voluntary evictions
   * by specifying 0. This is a mutually exclusive setting with "minAvailable".
   *
   * @schema VtClusterSpecStoragePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable;

  /**
   * An eviction is allowed if at least "minAvailable" pods selected by
   * "selector" will still be available after the eviction, i.e. even in the
   * absence of the evicted pod.  So for example you can prevent all voluntary
   * evictions by specifying "100%".
   *
   * @schema VtClusterSpecStoragePodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: VtClusterSpecStoragePodDisruptionBudgetMinAvailable;

  /**
   * replaces default labels selector generated by operator
   * it's useful when you need to create custom budget
   *
   * @schema VtClusterSpecStoragePodDisruptionBudget#selectorLabels
   */
  readonly selectorLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtClusterSpecStoragePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStoragePodDisruptionBudget(obj: VtClusterSpecStoragePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'selectorLabels': ((obj.selectorLabels) === undefined) ? undefined : (Object.entries(obj.selectorLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VTStorage pods.
 *
 * @schema VtClusterSpecStoragePodMetadata
 */
export interface VtClusterSpecStoragePodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecStoragePodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecStoragePodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecStoragePodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStoragePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStoragePodMetadata(obj: VtClusterSpecStoragePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VtClusterSpecStorageReadinessGates
 */
export interface VtClusterSpecStorageReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VtClusterSpecStorageReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageReadinessGates(obj: VtClusterSpecStorageReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VtClusterSpecStorageResources
 */
export interface VtClusterSpecStorageResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VtClusterSpecStorageResources#claims
   */
  readonly claims?: VtClusterSpecStorageResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecStorageResources#limits
   */
  readonly limits?: { [key: string]: VtClusterSpecStorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtClusterSpecStorageResources#requests
   */
  readonly requests?: { [key: string]: VtClusterSpecStorageResourcesRequests };

}

/**
 * Converts an object of type 'VtClusterSpecStorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageResources(obj: VtClusterSpecStorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VtClusterSpecStorageResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RollingUpdateStrategyBehavior defines customized behavior for rolling updates.
 * It applies if the RollingUpdateStrategy is set to OnDelete, which is the default.
 *
 * @schema VtClusterSpecStorageRollingUpdateStrategyBehavior
 */
export interface VtClusterSpecStorageRollingUpdateStrategyBehavior {
  /**
   * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
   * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
   * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
   *
   * @schema VtClusterSpecStorageRollingUpdateStrategyBehavior#maxUnavailable
   */
  readonly maxUnavailable?: VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable;

}

/**
 * Converts an object of type 'VtClusterSpecStorageRollingUpdateStrategyBehavior' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageRollingUpdateStrategyBehavior(obj: VtClusterSpecStorageRollingUpdateStrategyBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vtselect service spec
 *
 * @schema VtClusterSpecStorageServiceSpec
 */
export interface VtClusterSpecStorageServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VtClusterSpecStorageServiceSpec#metadata
   */
  readonly metadata?: VtClusterSpecStorageServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VtClusterSpecStorageServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VtClusterSpecStorageServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecStorageServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageServiceSpec(obj: VtClusterSpecStorageServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VtClusterSpecStorageServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage configures persistent volume for VTStorage
 *
 * @schema VtClusterSpecStorageStorage
 */
export interface VtClusterSpecStorageStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
   * DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema VtClusterSpecStorageStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
   * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema VtClusterSpecStorageStorage#emptyDir
   */
  readonly emptyDir?: VtClusterSpecStorageStorageEmptyDir;

  /**
   * A PVC spec to be used by the StatefulSets/Deployments.
   *
   * @schema VtClusterSpecStorageStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: any;

}

/**
 * Converts an object of type 'VtClusterSpecStorageStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageStorage(obj: VtClusterSpecStorageStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_VtClusterSpecStorageStorageEmptyDir(obj.emptyDir),
    'volumeClaimTemplate': obj.volumeClaimTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VtClusterSpecStorageTolerations
 */
export interface VtClusterSpecStorageTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VtClusterSpecStorageTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VtClusterSpecStorageTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VtClusterSpecStorageTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VtClusterSpecStorageTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VtClusterSpecStorageTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageTolerations(obj: VtClusterSpecStorageTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VtClusterSpecStorageVolumeMounts
 */
export interface VtClusterSpecStorageVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VtClusterSpecStorageVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VtClusterSpecStorageVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VtClusterSpecStorageVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VtClusterSpecStorageVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VtClusterSpecStorageVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VtClusterSpecStorageVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VtClusterSpecStorageVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageVolumeMounts(obj: VtClusterSpecStorageVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VtClusterSpecInsertDnsConfigOptions
 */
export interface VtClusterSpecInsertDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VtClusterSpecInsertDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VtClusterSpecInsertDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertDnsConfigOptions(obj: VtClusterSpecInsertDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VtClusterSpecInsertExtraEnvsFromConfigMapRef
 */
export interface VtClusterSpecInsertExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecInsertExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VtClusterSpecInsertExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecInsertExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertExtraEnvsFromConfigMapRef(obj: VtClusterSpecInsertExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VtClusterSpecInsertExtraEnvsFromSecretRef
 */
export interface VtClusterSpecInsertExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecInsertExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VtClusterSpecInsertExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecInsertExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertExtraEnvsFromSecretRef(obj: VtClusterSpecInsertExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable
 */
export class VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecInsertPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VtClusterSpecInsertPodDisruptionBudgetMinAvailable
 */
export class VtClusterSpecInsertPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VtClusterSpecInsertPodDisruptionBudgetMinAvailable {
    return new VtClusterSpecInsertPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VtClusterSpecInsertPodDisruptionBudgetMinAvailable {
    return new VtClusterSpecInsertPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VtClusterSpecInsertResourcesClaims
 */
export interface VtClusterSpecInsertResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VtClusterSpecInsertResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VtClusterSpecInsertResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertResourcesClaims(obj: VtClusterSpecInsertResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VtClusterSpecInsertResourcesLimits
 */
export class VtClusterSpecInsertResourcesLimits {
  public static fromNumber(value: number): VtClusterSpecInsertResourcesLimits {
    return new VtClusterSpecInsertResourcesLimits(value);
  }
  public static fromString(value: string): VtClusterSpecInsertResourcesLimits {
    return new VtClusterSpecInsertResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VtClusterSpecInsertResourcesRequests
 */
export class VtClusterSpecInsertResourcesRequests {
  public static fromNumber(value: number): VtClusterSpecInsertResourcesRequests {
    return new VtClusterSpecInsertResourcesRequests(value);
  }
  public static fromString(value: string): VtClusterSpecInsertResourcesRequests {
    return new VtClusterSpecInsertResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VtClusterSpecInsertRollingUpdateMaxSurge
 */
export class VtClusterSpecInsertRollingUpdateMaxSurge {
  public static fromNumber(value: number): VtClusterSpecInsertRollingUpdateMaxSurge {
    return new VtClusterSpecInsertRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VtClusterSpecInsertRollingUpdateMaxSurge {
    return new VtClusterSpecInsertRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VtClusterSpecInsertRollingUpdateMaxUnavailable
 */
export class VtClusterSpecInsertRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecInsertRollingUpdateMaxUnavailable {
    return new VtClusterSpecInsertRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecInsertRollingUpdateMaxUnavailable {
    return new VtClusterSpecInsertRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VtClusterSpecInsertServiceSpecMetadata
 */
export interface VtClusterSpecInsertServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecInsertServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecInsertServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecInsertServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecInsertServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecInsertServiceSpecMetadata(obj: VtClusterSpecInsertServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VtClusterSpecSelectDnsConfigOptions
 */
export interface VtClusterSpecSelectDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VtClusterSpecSelectDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VtClusterSpecSelectDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectDnsConfigOptions(obj: VtClusterSpecSelectDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VtClusterSpecSelectExtraEnvsFromConfigMapRef
 */
export interface VtClusterSpecSelectExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecSelectExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VtClusterSpecSelectExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecSelectExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectExtraEnvsFromConfigMapRef(obj: VtClusterSpecSelectExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VtClusterSpecSelectExtraEnvsFromSecretRef
 */
export interface VtClusterSpecSelectExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecSelectExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VtClusterSpecSelectExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecSelectExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectExtraEnvsFromSecretRef(obj: VtClusterSpecSelectExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable
 */
export class VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecSelectPodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VtClusterSpecSelectPodDisruptionBudgetMinAvailable
 */
export class VtClusterSpecSelectPodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VtClusterSpecSelectPodDisruptionBudgetMinAvailable {
    return new VtClusterSpecSelectPodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VtClusterSpecSelectPodDisruptionBudgetMinAvailable {
    return new VtClusterSpecSelectPodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VtClusterSpecSelectResourcesClaims
 */
export interface VtClusterSpecSelectResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VtClusterSpecSelectResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VtClusterSpecSelectResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectResourcesClaims(obj: VtClusterSpecSelectResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VtClusterSpecSelectResourcesLimits
 */
export class VtClusterSpecSelectResourcesLimits {
  public static fromNumber(value: number): VtClusterSpecSelectResourcesLimits {
    return new VtClusterSpecSelectResourcesLimits(value);
  }
  public static fromString(value: string): VtClusterSpecSelectResourcesLimits {
    return new VtClusterSpecSelectResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VtClusterSpecSelectResourcesRequests
 */
export class VtClusterSpecSelectResourcesRequests {
  public static fromNumber(value: number): VtClusterSpecSelectResourcesRequests {
    return new VtClusterSpecSelectResourcesRequests(value);
  }
  public static fromString(value: string): VtClusterSpecSelectResourcesRequests {
    return new VtClusterSpecSelectResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema VtClusterSpecSelectRollingUpdateMaxSurge
 */
export class VtClusterSpecSelectRollingUpdateMaxSurge {
  public static fromNumber(value: number): VtClusterSpecSelectRollingUpdateMaxSurge {
    return new VtClusterSpecSelectRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): VtClusterSpecSelectRollingUpdateMaxSurge {
    return new VtClusterSpecSelectRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema VtClusterSpecSelectRollingUpdateMaxUnavailable
 */
export class VtClusterSpecSelectRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecSelectRollingUpdateMaxUnavailable {
    return new VtClusterSpecSelectRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecSelectRollingUpdateMaxUnavailable {
    return new VtClusterSpecSelectRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VtClusterSpecSelectServiceSpecMetadata
 */
export interface VtClusterSpecSelectServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecSelectServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecSelectServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecSelectServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecSelectServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecSelectServiceSpecMetadata(obj: VtClusterSpecSelectServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VtClusterSpecStorageDnsConfigOptions
 */
export interface VtClusterSpecStorageDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VtClusterSpecStorageDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VtClusterSpecStorageDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageDnsConfigOptions(obj: VtClusterSpecStorageDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VtClusterSpecStorageExtraEnvsFromConfigMapRef
 */
export interface VtClusterSpecStorageExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecStorageExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VtClusterSpecStorageExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecStorageExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageExtraEnvsFromConfigMapRef(obj: VtClusterSpecStorageExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VtClusterSpecStorageExtraEnvsFromSecretRef
 */
export interface VtClusterSpecStorageExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtClusterSpecStorageExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VtClusterSpecStorageExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtClusterSpecStorageExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageExtraEnvsFromSecretRef(obj: VtClusterSpecStorageExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An eviction is allowed if at most "maxUnavailable" pods selected by
 * "selector" are unavailable after the eviction, i.e. even in absence of
 * the evicted pod. For example, one can prevent all voluntary evictions
 * by specifying 0. This is a mutually exclusive setting with "minAvailable".
 *
 * @schema VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable
 */
export class VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable {
    return new VtClusterSpecStoragePodDisruptionBudgetMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An eviction is allowed if at least "minAvailable" pods selected by
 * "selector" will still be available after the eviction, i.e. even in the
 * absence of the evicted pod.  So for example you can prevent all voluntary
 * evictions by specifying "100%".
 *
 * @schema VtClusterSpecStoragePodDisruptionBudgetMinAvailable
 */
export class VtClusterSpecStoragePodDisruptionBudgetMinAvailable {
  public static fromNumber(value: number): VtClusterSpecStoragePodDisruptionBudgetMinAvailable {
    return new VtClusterSpecStoragePodDisruptionBudgetMinAvailable(value);
  }
  public static fromString(value: string): VtClusterSpecStoragePodDisruptionBudgetMinAvailable {
    return new VtClusterSpecStoragePodDisruptionBudgetMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VtClusterSpecStorageResourcesClaims
 */
export interface VtClusterSpecStorageResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VtClusterSpecStorageResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VtClusterSpecStorageResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageResourcesClaims(obj: VtClusterSpecStorageResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VtClusterSpecStorageResourcesLimits
 */
export class VtClusterSpecStorageResourcesLimits {
  public static fromNumber(value: number): VtClusterSpecStorageResourcesLimits {
    return new VtClusterSpecStorageResourcesLimits(value);
  }
  public static fromString(value: string): VtClusterSpecStorageResourcesLimits {
    return new VtClusterSpecStorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VtClusterSpecStorageResourcesRequests
 */
export class VtClusterSpecStorageResourcesRequests {
  public static fromNumber(value: number): VtClusterSpecStorageResourcesRequests {
    return new VtClusterSpecStorageResourcesRequests(value);
  }
  public static fromString(value: string): VtClusterSpecStorageResourcesRequests {
    return new VtClusterSpecStorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MaxUnavailable defines the maximum number of pods that can be unavailable during the update.
 * It can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. "50%").
 * For example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.
 *
 * @schema VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable
 */
export class VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable {
  public static fromNumber(value: number): VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  public static fromString(value: string): VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable {
    return new VtClusterSpecStorageRollingUpdateStrategyBehaviorMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VtClusterSpecStorageServiceSpecMetadata
 */
export interface VtClusterSpecStorageServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtClusterSpecStorageServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtClusterSpecStorageServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtClusterSpecStorageServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtClusterSpecStorageServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageServiceSpecMetadata(obj: VtClusterSpecStorageServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
 * info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema VtClusterSpecStorageStorageEmptyDir
 */
export interface VtClusterSpecStorageStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VtClusterSpecStorageStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema VtClusterSpecStorageStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: VtClusterSpecStorageStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'VtClusterSpecStorageStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtClusterSpecStorageStorageEmptyDir(obj: VtClusterSpecStorageStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema VtClusterSpecStorageStorageEmptyDirSizeLimit
 */
export class VtClusterSpecStorageStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): VtClusterSpecStorageStorageEmptyDirSizeLimit {
    return new VtClusterSpecStorageStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): VtClusterSpecStorageStorageEmptyDirSizeLimit {
    return new VtClusterSpecStorageStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * VTSingle is fast, cost-effective and scalable traces database.
VTSingle is the Schema for the API
 *
 * @schema VTSingle
 */
export class VtSingle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VTSingle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operator.victoriametrics.com/v1',
    kind: 'VTSingle',
  }

  /**
   * Renders a Kubernetes manifest for "VTSingle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VtSingleProps = {}): any {
    return {
      ...VtSingle.GVK,
      ...toJson_VtSingleProps(props),
    };
  }

  /**
   * Defines a "VTSingle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VtSingleProps = {}) {
    super(scope, id, {
      ...VtSingle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VtSingle.GVK,
      ...toJson_VtSingleProps(resolved),
    };
  }
}

/**
 * VTSingle is fast, cost-effective and scalable traces database.
 * VTSingle is the Schema for the API
 *
 * @schema VTSingle
 */
export interface VtSingleProps {
  /**
   * @schema VTSingle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VTSingleSpec defines the desired state of VTSingle
   *
   * @schema VTSingle#spec
   */
  readonly spec?: VtSingleSpec;

}

/**
 * Converts an object of type 'VtSingleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleProps(obj: VtSingleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VtSingleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VTSingleSpec defines the desired state of VTSingle
 *
 * @schema VtSingleSpec
 */
export interface VtSingleSpec {
  /**
   * Affinity If specified, the pod's scheduling constraints.
   *
   * @schema VtSingleSpec#affinity
   */
  readonly affinity?: any;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/configs/CONFIGMAP_NAME folder
   *
   * @schema VtSingleSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers property allows to inject additions sidecars or to patch existing containers.
   * It can be useful for proxies, backup, etc.
   *
   * @schema VtSingleSpec#containers
   */
  readonly containers?: any[];

  /**
   * DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
   * Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
   * For example, vmagent and vm-config-reloader requires k8s API access.
   * Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
   * And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema VtSingleSpec#disableAutomountServiceAccountToken
   */
  readonly disableAutomountServiceAccountToken?: boolean;

  /**
   * DisableSelfServiceScrape controls creation of VMServiceScrape by operator
   * for the application.
   * Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
   *
   * @schema VtSingleSpec#disableSelfServiceScrape
   */
  readonly disableSelfServiceScrape?: boolean;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema VtSingleSpec#dnsConfig
   */
  readonly dnsConfig?: VtSingleSpecDnsConfig;

  /**
   * DNSPolicy sets DNS policy for the pod
   *
   * @schema VtSingleSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * ExtraArgs that will be passed to the application container
   * for example remoteWrite.tmpDataPath: /tmp
   *
   * @schema VtSingleSpec#extraArgs
   */
  readonly extraArgs?: { [key: string]: string };

  /**
   * ExtraEnvs that will be passed to the application container
   *
   * @schema VtSingleSpec#extraEnvs
   */
  readonly extraEnvs?: VtSingleSpecExtraEnvs[];

  /**
   * ExtraEnvsFrom defines source of env variables for the application container
   * could either be secret or configmap
   *
   * @schema VtSingleSpec#extraEnvsFrom
   */
  readonly extraEnvsFrom?: VtSingleSpecExtraEnvsFrom[];

  /**
   * FutureRetention for the stored traces
   * Log entries with timestamps bigger than now+futureRetention are rejected during data ingestion;
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtSingleSpec#futureRetention
   */
  readonly futureRetention?: string;

  /**
   * HostAliases provides mapping for ip and hostname,
   * that would be propagated to pod,
   * cannot be used with HostNetwork.
   *
   * @schema VtSingleSpec#hostAliases
   */
  readonly hostAliases?: VtSingleSpecHostAliases[];

  /**
   * HostNetwork controls whether the pod may use the node network namespace
   *
   * @schema VtSingleSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Image - docker image settings
   * if no specified operator uses default version from operator config
   *
   * @schema VtSingleSpec#image
   */
  readonly image?: VtSingleSpecImage;

  /**
   * ImagePullSecrets An optional list of references to secrets in the same namespace
   * to use for pulling images from registries
   * see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
   *
   * @schema VtSingleSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: VtSingleSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition.
   * Any errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema VtSingleSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * LivenessProbe that will be added CRD pod
   *
   * @schema VtSingleSpec#livenessProbe
   */
  readonly livenessProbe?: any;

  /**
   * LogFormat for VTSingle to be configured with.
   *
   * @schema VtSingleSpec#logFormat
   */
  readonly logFormat?: VtSingleSpecLogFormat;

  /**
   * Whether to log all the ingested log entries; this can be useful for debugging of data ingestion;
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtSingleSpec#logIngestedRows
   */
  readonly logIngestedRows?: boolean;

  /**
   * LogLevel for VictoriaTraces to be configured with.
   *
   * @schema VtSingleSpec#logLevel
   */
  readonly logLevel?: VtSingleSpecLogLevel;

  /**
   * LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams;
   * see https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtSingleSpec#logNewStreams
   */
  readonly logNewStreams?: boolean;

  /**
   * ManagedMetadata defines metadata that will be added to the all objects
   * created by operator for the given CustomResource
   *
   * @schema VtSingleSpec#managedMetadata
   */
  readonly managedMetadata?: VtSingleSpecManagedMetadata;

  /**
   * MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
   * if previous in healthy state
   * Has no effect for VLogs and VMSingle
   *
   * @schema VtSingleSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * NodeSelector Define which Nodes the Pods are scheduled on.
   *
   * @schema VtSingleSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused If set to true all actions on the underlying managed objects are not
   * going to be performed, except for delete actions.
   *
   * @schema VtSingleSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to the VTSingle pods.
   *
   * @schema VtSingleSpec#podMetadata
   */
  readonly podMetadata?: VtSingleSpecPodMetadata;

  /**
   * Port listen address
   *
   * @schema VtSingleSpec#port
   */
  readonly port?: string;

  /**
   * PriorityClassName class assigned to the Pods
   *
   * @schema VtSingleSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ReadinessGates defines pod readiness gates
   *
   * @schema VtSingleSpec#readinessGates
   */
  readonly readinessGates?: VtSingleSpecReadinessGates[];

  /**
   * ReadinessProbe that will be added CRD pod
   *
   * @schema VtSingleSpec#readinessProbe
   */
  readonly readinessProbe?: any;

  /**
   * ReplicaCount is the expected size of the Application.
   *
   * @schema VtSingleSpec#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * if not defined default resources from operator config will be used
   *
   * @schema VtSingleSpec#resources
   */
  readonly resources?: VtSingleSpecResources;

  /**
   * RetentionMaxDiskSpaceUsageBytes for the stored traces
   * VictoriaTraces keeps at least two last days of data in order to guarantee that the traces for the last day can be returned in queries.
   * This means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,
   * if the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.
   * https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtSingleSpec#retentionMaxDiskSpaceUsageBytes
   */
  readonly retentionMaxDiskSpaceUsageBytes?: string;

  /**
   * RetentionPeriod for the stored traces
   * https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces
   *
   * @schema VtSingleSpec#retentionPeriod
   */
  readonly retentionPeriod?: string;

  /**
   * The number of old ReplicaSets to retain to allow rollback in deployment or
   * maximum number of revisions that will be maintained in the Deployment revision history.
   * Has no effect at StatefulSets
   * Defaults to 10.
   *
   * @default 10.
   * @schema VtSingleSpec#revisionHistoryLimitCount
   */
  readonly revisionHistoryLimitCount?: number;

  /**
   * RuntimeClassName - defines runtime class for kubernetes pod.
   * https://kubernetes.io/docs/concepts/containers/runtime-class/
   *
   * @schema VtSingleSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * SchedulerName - defines kubernetes scheduler name
   *
   * @schema VtSingleSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Application
   * object, which shall be mounted into the Application container
   * at /etc/vm/secrets/SECRET_NAME folder
   *
   * @schema VtSingleSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema VtSingleSpec#securityContext
   */
  readonly securityContext?: any;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the pods
   *
   * @schema VtSingleSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceScrapeSpec that will be added to vtsingle VMServiceScrape spec
   *
   * @schema VtSingleSpec#serviceScrapeSpec
   */
  readonly serviceScrapeSpec?: any;

  /**
   * ServiceSpec that will be added to vtsingle service spec
   *
   * @schema VtSingleSpec#serviceSpec
   */
  readonly serviceSpec?: VtSingleSpecServiceSpec;

  /**
   * StartupProbe that will be added to CRD pod
   *
   * @schema VtSingleSpec#startupProbe
   */
  readonly startupProbe?: any;

  /**
   * Storage is the definition of how storage will be used by the VTSingle
   * by default it`s empty dir
   *
   * @schema VtSingleSpec#storage
   */
  readonly storage?: VtSingleSpecStorage;

  /**
   * StorageDataPath disables spec.storage option and overrides arg for victoria-traces binary --storageDataPath,
   * its users responsibility to mount proper device into given path.
   *
   * @schema VtSingleSpec#storageDataPath
   */
  readonly storageDataPath?: string;

  /**
   * StorageMeta defines annotations and labels attached to PVC for given vtsingle CR
   *
   * @schema VtSingleSpec#storageMetadata
   */
  readonly storageMetadata?: VtSingleSpecStorageMetadata;

  /**
   * TerminationGracePeriodSeconds period for container graceful termination
   *
   * @schema VtSingleSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Tolerations If specified, the pod's tolerations.
   *
   * @schema VtSingleSpec#tolerations
   */
  readonly tolerations?: VtSingleSpecTolerations[];

  /**
   * TopologySpreadConstraints embedded kubernetes pod configuration option,
   * controls how pods are spread across your cluster among failure-domains
   * such as regions, zones, nodes, and other user-defined topology domains
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
   *
   * @schema VtSingleSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: any[];

  /**
   * UseDefaultResources controls resource settings
   * By default, operator sets built-in resource requirements
   *
   * @schema VtSingleSpec#useDefaultResources
   */
  readonly useDefaultResources?: boolean;

  /**
   * UseStrictSecurity enables strict security mode for component
   * it restricts disk writes access
   * uses non-root user out of the box
   * drops not needed security permissions
   *
   * @schema VtSingleSpec#useStrictSecurity
   */
  readonly useStrictSecurity?: boolean;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the Application container
   *
   * @schema VtSingleSpec#volumeMounts
   */
  readonly volumeMounts?: VtSingleSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
   * Volumes specified will be appended to other volumes that are generated.
   * / +optional
   *
   * @schema VtSingleSpec#volumes
   */
  readonly volumes?: any[];

}

/**
 * Converts an object of type 'VtSingleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpec(obj: VtSingleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': obj.affinity,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => y),
    'disableAutomountServiceAccountToken': obj.disableAutomountServiceAccountToken,
    'disableSelfServiceScrape': obj.disableSelfServiceScrape,
    'dnsConfig': toJson_VtSingleSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'extraArgs': ((obj.extraArgs) === undefined) ? undefined : (Object.entries(obj.extraArgs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'extraEnvs': obj.extraEnvs?.map(y => toJson_VtSingleSpecExtraEnvs(y)),
    'extraEnvsFrom': obj.extraEnvsFrom?.map(y => toJson_VtSingleSpecExtraEnvsFrom(y)),
    'futureRetention': obj.futureRetention,
    'hostAliases': obj.hostAliases?.map(y => toJson_VtSingleSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'image': toJson_VtSingleSpecImage(obj.image),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_VtSingleSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => y),
    'livenessProbe': obj.livenessProbe,
    'logFormat': obj.logFormat,
    'logIngestedRows': obj.logIngestedRows,
    'logLevel': obj.logLevel,
    'logNewStreams': obj.logNewStreams,
    'managedMetadata': toJson_VtSingleSpecManagedMetadata(obj.managedMetadata),
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podMetadata': toJson_VtSingleSpecPodMetadata(obj.podMetadata),
    'port': obj.port,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_VtSingleSpecReadinessGates(y)),
    'readinessProbe': obj.readinessProbe,
    'replicaCount': obj.replicaCount,
    'resources': toJson_VtSingleSpecResources(obj.resources),
    'retentionMaxDiskSpaceUsageBytes': obj.retentionMaxDiskSpaceUsageBytes,
    'retentionPeriod': obj.retentionPeriod,
    'revisionHistoryLimitCount': obj.revisionHistoryLimitCount,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': obj.securityContext,
    'serviceAccountName': obj.serviceAccountName,
    'serviceScrapeSpec': obj.serviceScrapeSpec,
    'serviceSpec': toJson_VtSingleSpecServiceSpec(obj.serviceSpec),
    'startupProbe': obj.startupProbe,
    'storage': toJson_VtSingleSpecStorage(obj.storage),
    'storageDataPath': obj.storageDataPath,
    'storageMetadata': toJson_VtSingleSpecStorageMetadata(obj.storageMetadata),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_VtSingleSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => y),
    'useDefaultResources': obj.useDefaultResources,
    'useStrictSecurity': obj.useStrictSecurity,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_VtSingleSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema VtSingleSpecDnsConfig
 */
export interface VtSingleSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema VtSingleSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema VtSingleSpecDnsConfig#options
   */
  readonly options?: VtSingleSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema VtSingleSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'VtSingleSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecDnsConfig(obj: VtSingleSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_VtSingleSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema VtSingleSpecExtraEnvs
 */
export interface VtSingleSpecExtraEnvs {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema VtSingleSpecExtraEnvs#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema VtSingleSpecExtraEnvs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtSingleSpecExtraEnvs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecExtraEnvs(obj: VtSingleSpecExtraEnvs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema VtSingleSpecExtraEnvsFrom
 */
export interface VtSingleSpecExtraEnvsFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema VtSingleSpecExtraEnvsFrom#configMapRef
   */
  readonly configMapRef?: VtSingleSpecExtraEnvsFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema VtSingleSpecExtraEnvsFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema VtSingleSpecExtraEnvsFrom#secretRef
   */
  readonly secretRef?: VtSingleSpecExtraEnvsFromSecretRef;

}

/**
 * Converts an object of type 'VtSingleSpecExtraEnvsFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecExtraEnvsFrom(obj: VtSingleSpecExtraEnvsFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_VtSingleSpecExtraEnvsFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_VtSingleSpecExtraEnvsFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema VtSingleSpecHostAliases
 */
export interface VtSingleSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema VtSingleSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema VtSingleSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'VtSingleSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecHostAliases(obj: VtSingleSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image - docker image settings
 * if no specified operator uses default version from operator config
 *
 * @schema VtSingleSpecImage
 */
export interface VtSingleSpecImage {
  /**
   * PullPolicy describes how to pull docker image
   *
   * @schema VtSingleSpecImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Repository contains name of docker image + it's repository if needed
   *
   * @schema VtSingleSpecImage#repository
   */
  readonly repository?: string;

  /**
   * Tag contains desired docker image version
   *
   * @schema VtSingleSpecImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'VtSingleSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecImage(obj: VtSingleSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema VtSingleSpecImagePullSecrets
 */
export interface VtSingleSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtSingleSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtSingleSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecImagePullSecrets(obj: VtSingleSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LogFormat for VTSingle to be configured with.
 *
 * @schema VtSingleSpecLogFormat
 */
export enum VtSingleSpecLogFormat {
  /** default */
  DEFAULT = "default",
  /** json */
  JSON = "json",
}

/**
 * LogLevel for VictoriaTraces to be configured with.
 *
 * @schema VtSingleSpecLogLevel
 */
export enum VtSingleSpecLogLevel {
  /** INFO */
  INFO = "INFO",
  /** WARN */
  WARN = "WARN",
  /** ERROR */
  ERROR = "ERROR",
  /** FATAL */
  FATAL = "FATAL",
  /** PANIC */
  PANIC = "PANIC",
}

/**
 * ManagedMetadata defines metadata that will be added to the all objects
 * created by operator for the given CustomResource
 *
 * @schema VtSingleSpecManagedMetadata
 */
export interface VtSingleSpecManagedMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtSingleSpecManagedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtSingleSpecManagedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtSingleSpecManagedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecManagedMetadata(obj: VtSingleSpecManagedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to the VTSingle pods.
 *
 * @schema VtSingleSpecPodMetadata
 */
export interface VtSingleSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtSingleSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtSingleSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtSingleSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtSingleSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecPodMetadata(obj: VtSingleSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema VtSingleSpecReadinessGates
 */
export interface VtSingleSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema VtSingleSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'VtSingleSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecReadinessGates(obj: VtSingleSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * if not defined default resources from operator config will be used
 *
 * @schema VtSingleSpecResources
 */
export interface VtSingleSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema VtSingleSpecResources#claims
   */
  readonly claims?: VtSingleSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtSingleSpecResources#limits
   */
  readonly limits?: { [key: string]: VtSingleSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtSingleSpecResources#requests
   */
  readonly requests?: { [key: string]: VtSingleSpecResourcesRequests };

}

/**
 * Converts an object of type 'VtSingleSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecResources(obj: VtSingleSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_VtSingleSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSpec that will be added to vtsingle service spec
 *
 * @schema VtSingleSpecServiceSpec
 */
export interface VtSingleSpecServiceSpec {
  /**
   * EmbeddedObjectMetadata defines objectMeta for additional service.
   *
   * @schema VtSingleSpecServiceSpec#metadata
   */
  readonly metadata?: VtSingleSpecServiceSpecMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema VtSingleSpecServiceSpec#spec
   */
  readonly spec: any;

  /**
   * UseAsDefault applies changes from given service definition to the main object Service
   * Changing from headless service to clusterIP or loadbalancer may break cross-component communication
   *
   * @schema VtSingleSpecServiceSpec#useAsDefault
   */
  readonly useAsDefault?: boolean;

}

/**
 * Converts an object of type 'VtSingleSpecServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecServiceSpec(obj: VtSingleSpecServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_VtSingleSpecServiceSpecMetadata(obj.metadata),
    'spec': obj.spec,
    'useAsDefault': obj.useAsDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage is the definition of how storage will be used by the VTSingle
 * by default it`s empty dir
 *
 * @schema VtSingleSpecStorage
 */
export interface VtSingleSpecStorage {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema VtSingleSpecStorage#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema VtSingleSpecStorage#dataSource
   */
  readonly dataSource?: VtSingleSpecStorageDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VtSingleSpecStorage#dataSourceRef
   */
  readonly dataSourceRef?: VtSingleSpecStorageDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema VtSingleSpecStorage#resources
   */
  readonly resources?: VtSingleSpecStorageResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema VtSingleSpecStorage#selector
   */
  readonly selector?: VtSingleSpecStorageSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema VtSingleSpecStorage#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema VtSingleSpecStorage#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema VtSingleSpecStorage#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema VtSingleSpecStorage#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'VtSingleSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorage(obj: VtSingleSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_VtSingleSpecStorageDataSource(obj.dataSource),
    'dataSourceRef': toJson_VtSingleSpecStorageDataSourceRef(obj.dataSourceRef),
    'resources': toJson_VtSingleSpecStorageResources(obj.resources),
    'selector': toJson_VtSingleSpecStorageSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StorageMeta defines annotations and labels attached to PVC for given vtsingle CR
 *
 * @schema VtSingleSpecStorageMetadata
 */
export interface VtSingleSpecStorageMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtSingleSpecStorageMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtSingleSpecStorageMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtSingleSpecStorageMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtSingleSpecStorageMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageMetadata(obj: VtSingleSpecStorageMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema VtSingleSpecTolerations
 */
export interface VtSingleSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema VtSingleSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema VtSingleSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema VtSingleSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema VtSingleSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema VtSingleSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtSingleSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecTolerations(obj: VtSingleSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema VtSingleSpecVolumeMounts
 */
export interface VtSingleSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema VtSingleSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema VtSingleSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema VtSingleSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema VtSingleSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema VtSingleSpecVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema VtSingleSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema VtSingleSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'VtSingleSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecVolumeMounts(obj: VtSingleSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema VtSingleSpecDnsConfigOptions
 */
export interface VtSingleSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema VtSingleSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema VtSingleSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VtSingleSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecDnsConfigOptions(obj: VtSingleSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema VtSingleSpecExtraEnvsFromConfigMapRef
 */
export interface VtSingleSpecExtraEnvsFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtSingleSpecExtraEnvsFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema VtSingleSpecExtraEnvsFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtSingleSpecExtraEnvsFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecExtraEnvsFromConfigMapRef(obj: VtSingleSpecExtraEnvsFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema VtSingleSpecExtraEnvsFromSecretRef
 */
export interface VtSingleSpecExtraEnvsFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VtSingleSpecExtraEnvsFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema VtSingleSpecExtraEnvsFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'VtSingleSpecExtraEnvsFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecExtraEnvsFromSecretRef(obj: VtSingleSpecExtraEnvsFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema VtSingleSpecResourcesClaims
 */
export interface VtSingleSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema VtSingleSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema VtSingleSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'VtSingleSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecResourcesClaims(obj: VtSingleSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VtSingleSpecResourcesLimits
 */
export class VtSingleSpecResourcesLimits {
  public static fromNumber(value: number): VtSingleSpecResourcesLimits {
    return new VtSingleSpecResourcesLimits(value);
  }
  public static fromString(value: string): VtSingleSpecResourcesLimits {
    return new VtSingleSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VtSingleSpecResourcesRequests
 */
export class VtSingleSpecResourcesRequests {
  public static fromNumber(value: number): VtSingleSpecResourcesRequests {
    return new VtSingleSpecResourcesRequests(value);
  }
  public static fromString(value: string): VtSingleSpecResourcesRequests {
    return new VtSingleSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EmbeddedObjectMetadata defines objectMeta for additional service.
 *
 * @schema VtSingleSpecServiceSpecMetadata
 */
export interface VtSingleSpecServiceSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema VtSingleSpecServiceSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema VtSingleSpecServiceSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
   *
   * @schema VtSingleSpecServiceSpecMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'VtSingleSpecServiceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecServiceSpecMetadata(obj: VtSingleSpecServiceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema VtSingleSpecStorageDataSource
 */
export interface VtSingleSpecStorageDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VtSingleSpecStorageDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VtSingleSpecStorageDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VtSingleSpecStorageDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VtSingleSpecStorageDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageDataSource(obj: VtSingleSpecStorageDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema VtSingleSpecStorageDataSourceRef
 */
export interface VtSingleSpecStorageDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema VtSingleSpecStorageDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema VtSingleSpecStorageDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema VtSingleSpecStorageDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema VtSingleSpecStorageDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VtSingleSpecStorageDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageDataSourceRef(obj: VtSingleSpecStorageDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema VtSingleSpecStorageResources
 */
export interface VtSingleSpecStorageResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtSingleSpecStorageResources#limits
   */
  readonly limits?: { [key: string]: VtSingleSpecStorageResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema VtSingleSpecStorageResources#requests
   */
  readonly requests?: { [key: string]: VtSingleSpecStorageResourcesRequests };

}

/**
 * Converts an object of type 'VtSingleSpecStorageResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageResources(obj: VtSingleSpecStorageResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema VtSingleSpecStorageSelector
 */
export interface VtSingleSpecStorageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VtSingleSpecStorageSelector#matchExpressions
   */
  readonly matchExpressions?: VtSingleSpecStorageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VtSingleSpecStorageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'VtSingleSpecStorageSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageSelector(obj: VtSingleSpecStorageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_VtSingleSpecStorageSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VtSingleSpecStorageResourcesLimits
 */
export class VtSingleSpecStorageResourcesLimits {
  public static fromNumber(value: number): VtSingleSpecStorageResourcesLimits {
    return new VtSingleSpecStorageResourcesLimits(value);
  }
  public static fromString(value: string): VtSingleSpecStorageResourcesLimits {
    return new VtSingleSpecStorageResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema VtSingleSpecStorageResourcesRequests
 */
export class VtSingleSpecStorageResourcesRequests {
  public static fromNumber(value: number): VtSingleSpecStorageResourcesRequests {
    return new VtSingleSpecStorageResourcesRequests(value);
  }
  public static fromString(value: string): VtSingleSpecStorageResourcesRequests {
    return new VtSingleSpecStorageResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VtSingleSpecStorageSelectorMatchExpressions
 */
export interface VtSingleSpecStorageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VtSingleSpecStorageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VtSingleSpecStorageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VtSingleSpecStorageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'VtSingleSpecStorageSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VtSingleSpecStorageSelectorMatchExpressions(obj: VtSingleSpecStorageSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

