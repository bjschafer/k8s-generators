// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * SealedSecret is the K8s representation of a "sealed Secret" - a regular k8s Secret that has been sealed (encrypted) using the controller's key.
 *
 * @schema SealedSecret
 */
export class SealedSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SealedSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bitnami.com/v1alpha1',
    kind: 'SealedSecret',
  }

  /**
   * Renders a Kubernetes manifest for "SealedSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SealedSecretProps): any {
    return {
      ...SealedSecret.GVK,
      ...toJson_SealedSecretProps(props),
    };
  }

  /**
   * Defines a "SealedSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SealedSecretProps) {
    super(scope, id, {
      ...SealedSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SealedSecret.GVK,
      ...toJson_SealedSecretProps(resolved),
    };
  }
}

/**
 * SealedSecret is the K8s representation of a "sealed Secret" - a regular k8s Secret that has been sealed (encrypted) using the controller's key.
 *
 * @schema SealedSecret
 */
export interface SealedSecretProps {
  /**
   * @schema SealedSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SealedSecretSpec is the specification of a SealedSecret
   *
   * @schema SealedSecret#spec
   */
  readonly spec: SealedSecretSpec;

}

/**
 * Converts an object of type 'SealedSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SealedSecretProps(obj: SealedSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SealedSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SealedSecretSpec is the specification of a SealedSecret
 *
 * @schema SealedSecretSpec
 */
export interface SealedSecretSpec {
  /**
   * Data is deprecated and will be removed eventually. Use per-value EncryptedData instead.
   *
   * @schema SealedSecretSpec#data
   */
  readonly data?: string;

  /**
   * @schema SealedSecretSpec#encryptedData
   */
  readonly encryptedData: { [key: string]: string };

  /**
   * Template defines the structure of the Secret that will be created from this sealed secret.
   *
   * @schema SealedSecretSpec#template
   */
  readonly template?: SealedSecretSpecTemplate;

}

/**
 * Converts an object of type 'SealedSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SealedSecretSpec(obj: SealedSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'encryptedData': ((obj.encryptedData) === undefined) ? undefined : (Object.entries(obj.encryptedData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'template': toJson_SealedSecretSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template defines the structure of the Secret that will be created from this sealed secret.
 *
 * @schema SealedSecretSpecTemplate
 */
export interface SealedSecretSpecTemplate {
  /**
   * Keys that should be templated using decrypted data
   *
   * @schema SealedSecretSpecTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.
   *
   * @schema SealedSecretSpecTemplate#immutable
   */
  readonly immutable?: boolean;

  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
   *
   * @schema SealedSecretSpecTemplate#metadata
   */
  readonly metadata?: SealedSecretSpecTemplateMetadata;

  /**
   * Used to facilitate programmatic handling of secret data.
   *
   * @schema SealedSecretSpecTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SealedSecretSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SealedSecretSpecTemplate(obj: SealedSecretSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'immutable': obj.immutable,
    'metadata': toJson_SealedSecretSpecTemplateMetadata(obj.metadata),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
 *
 * @schema SealedSecretSpecTemplateMetadata
 */
export interface SealedSecretSpecTemplateMetadata {
  /**
   * @schema SealedSecretSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema SealedSecretSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema SealedSecretSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema SealedSecretSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema SealedSecretSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SealedSecretSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SealedSecretSpecTemplateMetadata(obj: SealedSecretSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

