// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * GrafanaAgent defines a Grafana Agent deployment.
 *
 * @schema GrafanaAgent
 */
export class GrafanaAgent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GrafanaAgent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.grafana.com/v1alpha1',
    kind: 'GrafanaAgent',
  }

  /**
   * Renders a Kubernetes manifest for "GrafanaAgent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GrafanaAgentProps = {}): any {
    return {
      ...GrafanaAgent.GVK,
      ...toJson_GrafanaAgentProps(props),
    };
  }

  /**
   * Defines a "GrafanaAgent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GrafanaAgentProps = {}) {
    super(scope, id, {
      ...GrafanaAgent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GrafanaAgent.GVK,
      ...toJson_GrafanaAgentProps(resolved),
    };
  }
}

/**
 * GrafanaAgent defines a Grafana Agent deployment.
 *
 * @schema GrafanaAgent
 */
export interface GrafanaAgentProps {
  /**
   * @schema GrafanaAgent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec holds the specification of the desired behavior for the Grafana Agent cluster.
   *
   * @schema GrafanaAgent#spec
   */
  readonly spec?: GrafanaAgentSpec;

}

/**
 * Converts an object of type 'GrafanaAgentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentProps(obj: GrafanaAgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GrafanaAgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec holds the specification of the desired behavior for the Grafana Agent cluster.
 *
 * @schema GrafanaAgentSpec
 */
export interface GrafanaAgentSpec {
  /**
   * Affinity, if specified, controls pod scheduling constraints.
   *
   * @schema GrafanaAgentSpec#affinity
   */
  readonly affinity?: GrafanaAgentSpecAffinity;

  /**
   * APIServerConfig lets you specify a host and auth methods to access the Kubernetes API server. If left empty, the Agent assumes that it is running inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount.
   *
   * @schema GrafanaAgentSpec#apiServer
   */
  readonly apiServer?: GrafanaAgentSpecApiServer;

  /**
   * ConfigMaps is a list of config maps in the same namespace as the GrafanaAgent object which will be mounted into each running Grafana Agent pod. The ConfigMaps are mounted into /etc/grafana-agent/extra-configmaps/<configmap-name>.
   *
   * @schema GrafanaAgentSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers lets you inject additional containers or modify operator-generated containers. This can be used to add an authentication proxy to a Grafana Agent pod or to change the behavior of an operator-generated container. Containers described here modify an operator-generated container if they share the same name and if modifications are done via a strategic merge patch. The current container names are: `grafana-agent` and `config-reloader`. Overriding containers is entirely outside the scope of what the Grafana Agent team supports and by doing so, you accept that this behavior may break at any time without notice.
   *
   * @schema GrafanaAgentSpec#containers
   */
  readonly containers?: GrafanaAgentSpecContainers[];

  /**
   * disableReporting disables reporting of enabled feature flags to Grafana.
   *
   * @schema GrafanaAgentSpec#disableReporting
   */
  readonly disableReporting?: boolean;

  /**
   * disableSupportBundle disables the generation of support bundles.
   *
   * @schema GrafanaAgentSpec#disableSupportBundle
   */
  readonly disableSupportBundle?: boolean;

  /**
   * enableConfigReadAPI enables the read API for viewing the currently running config port 8080 on the agent.
   *
   * @schema GrafanaAgentSpec#enableConfigReadAPI
   */
  readonly enableConfigReadApi?: boolean;

  /**
   * Image, when specified, overrides the image used to run Agent. Specify the image along with a tag. You still need to set the version to ensure Grafana Agent Operator knows which version of Grafana Agent is being configured.
   *
   * @schema GrafanaAgentSpec#image
   */
  readonly image?: string;

  /**
   * ImagePullSecrets holds an optional list of references to Secrets within the same namespace used for pulling the Grafana Agent image from registries. More info: https://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema GrafanaAgentSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: GrafanaAgentSpecImagePullSecrets[];

  /**
   * InitContainers let you add initContainers to the pod definition. These can be used to, for example, fetch secrets for injection into the Grafana Agent configuration from external sources. Errors during the execution of an initContainer cause the pod to restart. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other than secret fetching is entirely outside the scope of what the Grafana Agent maintainers support and by doing so, you accept that this behavior may break at any time without notice.
   *
   * @schema GrafanaAgentSpec#initContainers
   */
  readonly initContainers?: GrafanaAgentSpecInitContainers[];

  /**
   * Integrations controls the integration subsystem of the Agent and settings unique to deployed integration-specific pods.
   *
   * @schema GrafanaAgentSpec#integrations
   */
  readonly integrations?: GrafanaAgentSpecIntegrations;

  /**
   * LogFormat controls the logging format of the generated pods. Defaults to "logfmt" if not set.
   *
   * @default logfmt" if not set.
   * @schema GrafanaAgentSpec#logFormat
   */
  readonly logFormat?: string;

  /**
   * LogLevel controls the log level of the generated pods. Defaults to "info" if not set.
   *
   * @default info" if not set.
   * @schema GrafanaAgentSpec#logLevel
   */
  readonly logLevel?: string;

  /**
   * Logs controls the logging subsystem of the Agent and settings unique to logging-specific pods that are deployed.
   *
   * @schema GrafanaAgentSpec#logs
   */
  readonly logs?: GrafanaAgentSpecLogs;

  /**
   * Metrics controls the metrics subsystem of the Agent and settings unique to metrics-specific pods that are deployed.
   *
   * @schema GrafanaAgentSpec#metrics
   */
  readonly metrics?: GrafanaAgentSpecMetrics;

  /**
   * NodeSelector defines which nodes pods should be scheduling on.
   *
   * @schema GrafanaAgentSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Paused prevents actions except for deletion to be performed on the underlying managed objects.
   *
   * @schema GrafanaAgentSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures Labels and Annotations which are propagated to created Grafana Agent pods.
   *
   * @schema GrafanaAgentSpec#podMetadata
   */
  readonly podMetadata?: GrafanaAgentSpecPodMetadata;

  /**
   * Port name used for the pods and governing service. This defaults to agent-metrics.
   *
   * @schema GrafanaAgentSpec#portName
   */
  readonly portName?: string;

  /**
   * PriorityClassName is the priority class assigned to pods.
   *
   * @schema GrafanaAgentSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Resources holds requests and limits for individual pods.
   *
   * @schema GrafanaAgentSpec#resources
   */
  readonly resources?: GrafanaAgentSpecResources;

  /**
   * Secrets is a list of secrets in the same namespace as the GrafanaAgent object which will be mounted into each running Grafana Agent pod. The secrets are mounted into /etc/grafana-agent/extra-secrets/<secret-name>.
   *
   * @schema GrafanaAgentSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings. When unspecified, defaults to the default PodSecurityContext.
   *
   * @schema GrafanaAgentSpec#securityContext
   */
  readonly securityContext?: GrafanaAgentSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use for running Grafana Agent pods.
   *
   * @schema GrafanaAgentSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Storage spec to specify how storage will be used.
   *
   * @schema GrafanaAgentSpec#storage
   */
  readonly storage?: GrafanaAgentSpecStorage;

  /**
   * Tolerations, if specified, controls the pod's tolerations.
   *
   * @schema GrafanaAgentSpec#tolerations
   */
  readonly tolerations?: GrafanaAgentSpecTolerations[];

  /**
   * TopologySpreadConstraints, if specified, controls the pod's topology spread constraints.
   *
   * @schema GrafanaAgentSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: GrafanaAgentSpecTopologySpreadConstraints[];

  /**
   * Version of Grafana Agent to be deployed.
   *
   * @schema GrafanaAgentSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts lets you configure additional VolumeMounts on the output StatefulSet definition. Specified VolumeMounts are appended to other VolumeMounts generated as a result of StorageSpec objects in the Grafana Agent container.
   *
   * @schema GrafanaAgentSpec#volumeMounts
   */
  readonly volumeMounts?: GrafanaAgentSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output StatefulSet definition. The volumes specified are appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema GrafanaAgentSpec#volumes
   */
  readonly volumes?: GrafanaAgentSpecVolumes[];

}

/**
 * Converts an object of type 'GrafanaAgentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpec(obj: GrafanaAgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_GrafanaAgentSpecAffinity(obj.affinity),
    'apiServer': toJson_GrafanaAgentSpecApiServer(obj.apiServer),
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => toJson_GrafanaAgentSpecContainers(y)),
    'disableReporting': obj.disableReporting,
    'disableSupportBundle': obj.disableSupportBundle,
    'enableConfigReadAPI': obj.enableConfigReadApi,
    'image': obj.image,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_GrafanaAgentSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_GrafanaAgentSpecInitContainers(y)),
    'integrations': toJson_GrafanaAgentSpecIntegrations(obj.integrations),
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'logs': toJson_GrafanaAgentSpecLogs(obj.logs),
    'metrics': toJson_GrafanaAgentSpecMetrics(obj.metrics),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'paused': obj.paused,
    'podMetadata': toJson_GrafanaAgentSpecPodMetadata(obj.podMetadata),
    'portName': obj.portName,
    'priorityClassName': obj.priorityClassName,
    'resources': toJson_GrafanaAgentSpecResources(obj.resources),
    'secrets': obj.secrets?.map(y => y),
    'securityContext': toJson_GrafanaAgentSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'storage': toJson_GrafanaAgentSpecStorage(obj.storage),
    'tolerations': obj.tolerations?.map(y => toJson_GrafanaAgentSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_GrafanaAgentSpecTopologySpreadConstraints(y)),
    'version': obj.version,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_GrafanaAgentSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_GrafanaAgentSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity, if specified, controls pod scheduling constraints.
 *
 * @schema GrafanaAgentSpecAffinity
 */
export interface GrafanaAgentSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema GrafanaAgentSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: GrafanaAgentSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GrafanaAgentSpecAffinity#podAffinity
   */
  readonly podAffinity?: GrafanaAgentSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GrafanaAgentSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: GrafanaAgentSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinity(obj: GrafanaAgentSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_GrafanaAgentSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_GrafanaAgentSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_GrafanaAgentSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIServerConfig lets you specify a host and auth methods to access the Kubernetes API server. If left empty, the Agent assumes that it is running inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount.
 *
 * @schema GrafanaAgentSpecApiServer
 */
export interface GrafanaAgentSpecApiServer {
  /**
   * Authorization section for accessing apiserver
   *
   * @schema GrafanaAgentSpecApiServer#authorization
   */
  readonly authorization?: GrafanaAgentSpecApiServerAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication
   *
   * @schema GrafanaAgentSpecApiServer#basicAuth
   */
  readonly basicAuth?: GrafanaAgentSpecApiServerBasicAuth;

  /**
   * Bearer token for accessing apiserver.
   *
   * @schema GrafanaAgentSpecApiServer#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File to read bearer token for accessing apiserver.
   *
   * @schema GrafanaAgentSpecApiServer#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Host of apiserver. A valid string consisting of a hostname or IP followed by an optional port number
   *
   * @schema GrafanaAgentSpecApiServer#host
   */
  readonly host: string;

  /**
   * TLS Config to use for accessing apiserver.
   *
   * @schema GrafanaAgentSpecApiServer#tlsConfig
   */
  readonly tlsConfig?: GrafanaAgentSpecApiServerTlsConfig;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServer(obj: GrafanaAgentSpecApiServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_GrafanaAgentSpecApiServerAuthorization(obj.authorization),
    'basicAuth': toJson_GrafanaAgentSpecApiServerBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'host': obj.host,
    'tlsConfig': toJson_GrafanaAgentSpecApiServerTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema GrafanaAgentSpecContainers
 */
export interface GrafanaAgentSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema GrafanaAgentSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema GrafanaAgentSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#env
   */
  readonly env?: GrafanaAgentSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#envFrom
   */
  readonly envFrom?: GrafanaAgentSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema GrafanaAgentSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema GrafanaAgentSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#lifecycle
   */
  readonly lifecycle?: GrafanaAgentSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainers#livenessProbe
   */
  readonly livenessProbe?: GrafanaAgentSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#ports
   */
  readonly ports?: GrafanaAgentSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainers#readinessProbe
   */
  readonly readinessProbe?: GrafanaAgentSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecContainers#resources
   */
  readonly resources?: GrafanaAgentSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema GrafanaAgentSpecContainers#securityContext
   */
  readonly securityContext?: GrafanaAgentSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainers#startupProbe
   */
  readonly startupProbe?: GrafanaAgentSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema GrafanaAgentSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema GrafanaAgentSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema GrafanaAgentSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema GrafanaAgentSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema GrafanaAgentSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema GrafanaAgentSpecContainers#volumeDevices
   */
  readonly volumeDevices?: GrafanaAgentSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#volumeMounts
   */
  readonly volumeMounts?: GrafanaAgentSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema GrafanaAgentSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainers(obj: GrafanaAgentSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_GrafanaAgentSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_GrafanaAgentSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_GrafanaAgentSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_GrafanaAgentSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_GrafanaAgentSpecContainersPorts(y)),
    'readinessProbe': toJson_GrafanaAgentSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_GrafanaAgentSpecContainersResources(obj.resources),
    'securityContext': toJson_GrafanaAgentSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_GrafanaAgentSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_GrafanaAgentSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_GrafanaAgentSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema GrafanaAgentSpecImagePullSecrets
 */
export interface GrafanaAgentSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecImagePullSecrets(obj: GrafanaAgentSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema GrafanaAgentSpecInitContainers
 */
export interface GrafanaAgentSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema GrafanaAgentSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema GrafanaAgentSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#env
   */
  readonly env?: GrafanaAgentSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#envFrom
   */
  readonly envFrom?: GrafanaAgentSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema GrafanaAgentSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema GrafanaAgentSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#lifecycle
   */
  readonly lifecycle?: GrafanaAgentSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: GrafanaAgentSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#ports
   */
  readonly ports?: GrafanaAgentSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: GrafanaAgentSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecInitContainers#resources
   */
  readonly resources?: GrafanaAgentSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema GrafanaAgentSpecInitContainers#securityContext
   */
  readonly securityContext?: GrafanaAgentSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainers#startupProbe
   */
  readonly startupProbe?: GrafanaAgentSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema GrafanaAgentSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema GrafanaAgentSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema GrafanaAgentSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema GrafanaAgentSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema GrafanaAgentSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema GrafanaAgentSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: GrafanaAgentSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: GrafanaAgentSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema GrafanaAgentSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainers(obj: GrafanaAgentSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_GrafanaAgentSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_GrafanaAgentSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_GrafanaAgentSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_GrafanaAgentSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_GrafanaAgentSpecInitContainersPorts(y)),
    'readinessProbe': toJson_GrafanaAgentSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_GrafanaAgentSpecInitContainersResources(obj.resources),
    'securityContext': toJson_GrafanaAgentSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_GrafanaAgentSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_GrafanaAgentSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_GrafanaAgentSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Integrations controls the integration subsystem of the Agent and settings unique to deployed integration-specific pods.
 *
 * @schema GrafanaAgentSpecIntegrations
 */
export interface GrafanaAgentSpecIntegrations {
  /**
   * Label selector for namespaces to search when discovering integration resources. If nil, integration resources are only discovered in the namespace of the GrafanaAgent resource.
   * Set to `{}` to search all namespaces.
   *
   * @schema GrafanaAgentSpecIntegrations#namespaceSelector
   */
  readonly namespaceSelector?: GrafanaAgentSpecIntegrationsNamespaceSelector;

  /**
   * Label selector to find Integration resources to run. When nil, no integration resources will be defined.
   *
   * @schema GrafanaAgentSpecIntegrations#selector
   */
  readonly selector?: GrafanaAgentSpecIntegrationsSelector;

}

/**
 * Converts an object of type 'GrafanaAgentSpecIntegrations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecIntegrations(obj: GrafanaAgentSpecIntegrations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelector': toJson_GrafanaAgentSpecIntegrationsNamespaceSelector(obj.namespaceSelector),
    'selector': toJson_GrafanaAgentSpecIntegrationsSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logs controls the logging subsystem of the Agent and settings unique to logging-specific pods that are deployed.
 *
 * @schema GrafanaAgentSpecLogs
 */
export interface GrafanaAgentSpecLogs {
  /**
   * A global set of clients to use when a discovered LogsInstance does not have any clients defined.
   *
   * @schema GrafanaAgentSpecLogs#clients
   */
  readonly clients?: GrafanaAgentSpecLogsClients[];

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each metric that is user-created. The label value will always be the namespace of the object that is being created.
   *
   * @schema GrafanaAgentSpecLogs#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * IgnoreNamespaceSelectors, if true, will ignore NamespaceSelector settings from the PodLogs configs, and they will only discover endpoints within their current namespace.
   *
   * @schema GrafanaAgentSpecLogs#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * InstanceNamespaceSelector are the set of labels to determine which namespaces to watch for LogInstances. If not provided, only checks own namespace.
   *
   * @schema GrafanaAgentSpecLogs#instanceNamespaceSelector
   */
  readonly instanceNamespaceSelector?: GrafanaAgentSpecLogsInstanceNamespaceSelector;

  /**
   * InstanceSelector determines which LogInstances should be selected for running. Each instance runs its own set of Prometheus components, including service discovery, scraping, and remote_write.
   *
   * @schema GrafanaAgentSpecLogs#instanceSelector
   */
  readonly instanceSelector?: GrafanaAgentSpecLogsInstanceSelector;

  /**
   * LogsExternalLabelName is the name of the external label used to denote Grafana Agent cluster. Defaults to "cluster." External label will _not_ be added when value is set to the empty string.
   *
   * @default cluster." External label will _not_ be added when value is set to the empty string.
   * @schema GrafanaAgentSpecLogs#logsExternalLabelName
   */
  readonly logsExternalLabelName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogs(obj: GrafanaAgentSpecLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clients': obj.clients?.map(y => toJson_GrafanaAgentSpecLogsClients(y)),
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'ignoreNamespaceSelectors': obj.ignoreNamespaceSelectors,
    'instanceNamespaceSelector': toJson_GrafanaAgentSpecLogsInstanceNamespaceSelector(obj.instanceNamespaceSelector),
    'instanceSelector': toJson_GrafanaAgentSpecLogsInstanceSelector(obj.instanceSelector),
    'logsExternalLabelName': obj.logsExternalLabelName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics controls the metrics subsystem of the Agent and settings unique to metrics-specific pods that are deployed.
 *
 * @schema GrafanaAgentSpecMetrics
 */
export interface GrafanaAgentSpecMetrics {
  /**
   * ArbitraryFSAccessThroughSMs configures whether configuration based on a ServiceMonitor can access arbitrary files on the file system of the Grafana Agent container, e.g., bearer token files.
   *
   * @schema GrafanaAgentSpecMetrics#arbitraryFSAccessThroughSMs
   */
  readonly arbitraryFsAccessThroughSMs?: GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs;

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each metric that is user-created. The label value is always the namespace of the object that is being created.
   *
   * @schema GrafanaAgentSpecMetrics#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * EnforcedSampleLimit defines a global limit on the number of scraped samples that are accepted. This overrides any SampleLimit set per ServiceMonitor and/or PodMonitor. It is meant to be used by admins to enforce the SampleLimit to keep the overall number of samples and series under the desired limit. Note that if a SampleLimit from a ServiceMonitor or PodMonitor is lower, that value is used instead.
   *
   * @schema GrafanaAgentSpecMetrics#enforcedSampleLimit
   */
  readonly enforcedSampleLimit?: number;

  /**
   * EnforcedTargetLimit defines a global limit on the number of scraped targets. This overrides any TargetLimit set per ServiceMonitor and/or PodMonitor. It is meant to be used by admins to enforce the TargetLimit to keep the overall number of targets under the desired limit. Note that if a TargetLimit from a ServiceMonitor or PodMonitor is higher, that value is used instead.
   *
   * @schema GrafanaAgentSpecMetrics#enforcedTargetLimit
   */
  readonly enforcedTargetLimit?: number;

  /**
   * ExternalLabels are labels to add to any time series when sending data over remote_write.
   *
   * @schema GrafanaAgentSpecMetrics#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * IgnoreNamespaceSelectors, if true, ignores NamespaceSelector settings from the PodMonitor and ServiceMonitor configs, so that they only discover endpoints within their current namespace.
   *
   * @schema GrafanaAgentSpecMetrics#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * InstanceNamespaceSelector is the set of labels that determines which namespaces to watch for MetricsInstances. If not provided, it only checks its own namespace.
   *
   * @schema GrafanaAgentSpecMetrics#instanceNamespaceSelector
   */
  readonly instanceNamespaceSelector?: GrafanaAgentSpecMetricsInstanceNamespaceSelector;

  /**
   * InstanceSelector determines which MetricsInstances should be selected for running. Each instance runs its own set of Metrics components, including service discovery, scraping, and remote_write.
   *
   * @schema GrafanaAgentSpecMetrics#instanceSelector
   */
  readonly instanceSelector?: GrafanaAgentSpecMetricsInstanceSelector;

  /**
   * MetricsExternalLabelName is the name of the external label used to denote Grafana Agent cluster. Defaults to "cluster." The external label is _not_ added when the value is set to the empty string.
   *
   * @default cluster." The external label is _not_ added when the value is set to the empty string.
   * @schema GrafanaAgentSpecMetrics#metricsExternalLabelName
   */
  readonly metricsExternalLabelName?: string;

  /**
   * OverrideHonorLabels, if true, overrides all configured honor_labels read from ServiceMonitor or PodMonitor and sets them to false.
   *
   * @schema GrafanaAgentSpecMetrics#overrideHonorLabels
   */
  readonly overrideHonorLabels?: boolean;

  /**
   * OverrideHonorTimestamps allows global enforcement for honoring timestamps in all scrape configs.
   *
   * @schema GrafanaAgentSpecMetrics#overrideHonorTimestamps
   */
  readonly overrideHonorTimestamps?: boolean;

  /**
   * RemoteWrite controls default remote_write settings for all instances. If an instance does not provide its own RemoteWrite settings, these will be used instead.
   *
   * @schema GrafanaAgentSpecMetrics#remoteWrite
   */
  readonly remoteWrite?: GrafanaAgentSpecMetricsRemoteWrite[];

  /**
   * ReplicaExternalLabelName is the name of the metrics external label used to denote the replica name. Defaults to __replica__. The external label is _not_ added when the value is set to the empty string.
   *
   * @default __replica__. The external label is _not_ added when the value is set to the empty string.
   * @schema GrafanaAgentSpecMetrics#replicaExternalLabelName
   */
  readonly replicaExternalLabelName?: string;

  /**
   * Replicas of each shard to deploy for metrics pods. Number of replicas multiplied by the number of shards is the total number of pods created.
   *
   * @schema GrafanaAgentSpecMetrics#replicas
   */
  readonly replicas?: number;

  /**
   * ScrapeInterval is the time between consecutive scrapes.
   *
   * @schema GrafanaAgentSpecMetrics#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * ScrapeTimeout is the time to wait for a target to respond before marking a scrape as failed.
   *
   * @schema GrafanaAgentSpecMetrics#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Shards to distribute targets onto. Number of replicas multiplied by the number of shards is the total number of pods created. Note that scaling down shards does not reshard data onto remaining instances; it must be manually moved. Increasing shards does not reshard data either, but it will continue to be available from the same instances. Sharding is performed on the content of the __address__ target meta-label.
   *
   * @schema GrafanaAgentSpecMetrics#shards
   */
  readonly shards?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetrics(obj: GrafanaAgentSpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arbitraryFSAccessThroughSMs': toJson_GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs(obj.arbitraryFsAccessThroughSMs),
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'enforcedSampleLimit': obj.enforcedSampleLimit,
    'enforcedTargetLimit': obj.enforcedTargetLimit,
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ignoreNamespaceSelectors': obj.ignoreNamespaceSelectors,
    'instanceNamespaceSelector': toJson_GrafanaAgentSpecMetricsInstanceNamespaceSelector(obj.instanceNamespaceSelector),
    'instanceSelector': toJson_GrafanaAgentSpecMetricsInstanceSelector(obj.instanceSelector),
    'metricsExternalLabelName': obj.metricsExternalLabelName,
    'overrideHonorLabels': obj.overrideHonorLabels,
    'overrideHonorTimestamps': obj.overrideHonorTimestamps,
    'remoteWrite': obj.remoteWrite?.map(y => toJson_GrafanaAgentSpecMetricsRemoteWrite(y)),
    'replicaExternalLabelName': obj.replicaExternalLabelName,
    'replicas': obj.replicas,
    'scrapeInterval': obj.scrapeInterval,
    'scrapeTimeout': obj.scrapeTimeout,
    'shards': obj.shards,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures Labels and Annotations which are propagated to created Grafana Agent pods.
 *
 * @schema GrafanaAgentSpecPodMetadata
 */
export interface GrafanaAgentSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema GrafanaAgentSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema GrafanaAgentSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema GrafanaAgentSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecPodMetadata(obj: GrafanaAgentSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources holds requests and limits for individual pods.
 *
 * @schema GrafanaAgentSpecResources
 */
export interface GrafanaAgentSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecResources(obj: GrafanaAgentSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. When unspecified, defaults to the default PodSecurityContext.
 *
 * @schema GrafanaAgentSpecSecurityContext
 */
export interface GrafanaAgentSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema GrafanaAgentSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: GrafanaAgentSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: GrafanaAgentSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecSecurityContext#sysctls
   */
  readonly sysctls?: GrafanaAgentSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema GrafanaAgentSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: GrafanaAgentSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'GrafanaAgentSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecSecurityContext(obj: GrafanaAgentSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_GrafanaAgentSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_GrafanaAgentSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_GrafanaAgentSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_GrafanaAgentSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage spec to specify how storage will be used.
 *
 * @schema GrafanaAgentSpecStorage
 */
export interface GrafanaAgentSpecStorage {
  /**
   * Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary. DisableMountSubPath allows to remove any subPath usage in volume mounts.
   *
   * @schema GrafanaAgentSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema GrafanaAgentSpecStorage#emptyDir
   */
  readonly emptyDir?: GrafanaAgentSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the Prometheus StatefulSets. This is a beta field in k8s 1.21, for lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema GrafanaAgentSpecStorage#ephemeral
   */
  readonly ephemeral?: GrafanaAgentSpecStorageEphemeral;

  /**
   * A PVC spec to be used by the Prometheus StatefulSets.
   *
   * @schema GrafanaAgentSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: GrafanaAgentSpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorage(obj: GrafanaAgentSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_GrafanaAgentSpecStorageEmptyDir(obj.emptyDir),
    'ephemeral': toJson_GrafanaAgentSpecStorageEphemeral(obj.ephemeral),
    'volumeClaimTemplate': toJson_GrafanaAgentSpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema GrafanaAgentSpecTolerations
 */
export interface GrafanaAgentSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema GrafanaAgentSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema GrafanaAgentSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema GrafanaAgentSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema GrafanaAgentSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema GrafanaAgentSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecTolerations(obj: GrafanaAgentSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema GrafanaAgentSpecTopologySpreadConstraints
 */
export interface GrafanaAgentSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: GrafanaAgentSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecTopologySpreadConstraints(obj: GrafanaAgentSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GrafanaAgentSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema GrafanaAgentSpecVolumeMounts
 */
export interface GrafanaAgentSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema GrafanaAgentSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema GrafanaAgentSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema GrafanaAgentSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema GrafanaAgentSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema GrafanaAgentSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema GrafanaAgentSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumeMounts(obj: GrafanaAgentSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema GrafanaAgentSpecVolumes
 */
export interface GrafanaAgentSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema GrafanaAgentSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: GrafanaAgentSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema GrafanaAgentSpecVolumes#azureDisk
   */
  readonly azureDisk?: GrafanaAgentSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema GrafanaAgentSpecVolumes#azureFile
   */
  readonly azureFile?: GrafanaAgentSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema GrafanaAgentSpecVolumes#cephfs
   */
  readonly cephfs?: GrafanaAgentSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema GrafanaAgentSpecVolumes#cinder
   */
  readonly cinder?: GrafanaAgentSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema GrafanaAgentSpecVolumes#configMap
   */
  readonly configMap?: GrafanaAgentSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema GrafanaAgentSpecVolumes#csi
   */
  readonly csi?: GrafanaAgentSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema GrafanaAgentSpecVolumes#downwardAPI
   */
  readonly downwardApi?: GrafanaAgentSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema GrafanaAgentSpecVolumes#emptyDir
   */
  readonly emptyDir?: GrafanaAgentSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema GrafanaAgentSpecVolumes#ephemeral
   */
  readonly ephemeral?: GrafanaAgentSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema GrafanaAgentSpecVolumes#fc
   */
  readonly fc?: GrafanaAgentSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema GrafanaAgentSpecVolumes#flexVolume
   */
  readonly flexVolume?: GrafanaAgentSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema GrafanaAgentSpecVolumes#flocker
   */
  readonly flocker?: GrafanaAgentSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema GrafanaAgentSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: GrafanaAgentSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema GrafanaAgentSpecVolumes#gitRepo
   */
  readonly gitRepo?: GrafanaAgentSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema GrafanaAgentSpecVolumes#glusterfs
   */
  readonly glusterfs?: GrafanaAgentSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema GrafanaAgentSpecVolumes#hostPath
   */
  readonly hostPath?: GrafanaAgentSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema GrafanaAgentSpecVolumes#iscsi
   */
  readonly iscsi?: GrafanaAgentSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GrafanaAgentSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema GrafanaAgentSpecVolumes#nfs
   */
  readonly nfs?: GrafanaAgentSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema GrafanaAgentSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: GrafanaAgentSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema GrafanaAgentSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: GrafanaAgentSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema GrafanaAgentSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: GrafanaAgentSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema GrafanaAgentSpecVolumes#projected
   */
  readonly projected?: GrafanaAgentSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema GrafanaAgentSpecVolumes#quobyte
   */
  readonly quobyte?: GrafanaAgentSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema GrafanaAgentSpecVolumes#rbd
   */
  readonly rbd?: GrafanaAgentSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema GrafanaAgentSpecVolumes#scaleIO
   */
  readonly scaleIo?: GrafanaAgentSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema GrafanaAgentSpecVolumes#secret
   */
  readonly secret?: GrafanaAgentSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema GrafanaAgentSpecVolumes#storageos
   */
  readonly storageos?: GrafanaAgentSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema GrafanaAgentSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: GrafanaAgentSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumes(obj: GrafanaAgentSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_GrafanaAgentSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_GrafanaAgentSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_GrafanaAgentSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_GrafanaAgentSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_GrafanaAgentSpecVolumesCinder(obj.cinder),
    'configMap': toJson_GrafanaAgentSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_GrafanaAgentSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_GrafanaAgentSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_GrafanaAgentSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_GrafanaAgentSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_GrafanaAgentSpecVolumesFc(obj.fc),
    'flexVolume': toJson_GrafanaAgentSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_GrafanaAgentSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_GrafanaAgentSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_GrafanaAgentSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_GrafanaAgentSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_GrafanaAgentSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_GrafanaAgentSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_GrafanaAgentSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_GrafanaAgentSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_GrafanaAgentSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_GrafanaAgentSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_GrafanaAgentSpecVolumesProjected(obj.projected),
    'quobyte': toJson_GrafanaAgentSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_GrafanaAgentSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_GrafanaAgentSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_GrafanaAgentSpecVolumesSecret(obj.secret),
    'storageos': toJson_GrafanaAgentSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_GrafanaAgentSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinity
 */
export interface GrafanaAgentSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinity(obj: GrafanaAgentSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GrafanaAgentSpecAffinityPodAffinity
 */
export interface GrafanaAgentSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinity(obj: GrafanaAgentSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinity
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinity(obj: GrafanaAgentSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for accessing apiserver
 *
 * @schema GrafanaAgentSpecApiServerAuthorization
 */
export interface GrafanaAgentSpecApiServerAuthorization {
  /**
   * The secret's key that contains the credentials of the request
   *
   * @schema GrafanaAgentSpecApiServerAuthorization#credentials
   */
  readonly credentials?: GrafanaAgentSpecApiServerAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with Credentials (from SafeAuthorization)
   *
   * @schema GrafanaAgentSpecApiServerAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Set the authentication type. Defaults to Bearer, Basic will cause an error
   *
   * @default Bearer, Basic will cause an error
   * @schema GrafanaAgentSpecApiServerAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerAuthorization(obj: GrafanaAgentSpecApiServerAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_GrafanaAgentSpecApiServerAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication
 *
 * @schema GrafanaAgentSpecApiServerBasicAuth
 */
export interface GrafanaAgentSpecApiServerBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema GrafanaAgentSpecApiServerBasicAuth#password
   */
  readonly password?: GrafanaAgentSpecApiServerBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema GrafanaAgentSpecApiServerBasicAuth#username
   */
  readonly username?: GrafanaAgentSpecApiServerBasicAuthUsername;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerBasicAuth(obj: GrafanaAgentSpecApiServerBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_GrafanaAgentSpecApiServerBasicAuthPassword(obj.password),
    'username': toJson_GrafanaAgentSpecApiServerBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for accessing apiserver.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfig
 */
export interface GrafanaAgentSpecApiServerTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#ca
   */
  readonly ca?: GrafanaAgentSpecApiServerTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#cert
   */
  readonly cert?: GrafanaAgentSpecApiServerTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#keySecret
   */
  readonly keySecret?: GrafanaAgentSpecApiServerTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfig(obj: GrafanaAgentSpecApiServerTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_GrafanaAgentSpecApiServerTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_GrafanaAgentSpecApiServerTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_GrafanaAgentSpecApiServerTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema GrafanaAgentSpecContainersEnv
 */
export interface GrafanaAgentSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema GrafanaAgentSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema GrafanaAgentSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema GrafanaAgentSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: GrafanaAgentSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnv(obj: GrafanaAgentSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_GrafanaAgentSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema GrafanaAgentSpecContainersEnvFrom
 */
export interface GrafanaAgentSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema GrafanaAgentSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: GrafanaAgentSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema GrafanaAgentSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema GrafanaAgentSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvFrom(obj: GrafanaAgentSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_GrafanaAgentSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_GrafanaAgentSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema GrafanaAgentSpecContainersLifecycle
 */
export interface GrafanaAgentSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema GrafanaAgentSpecContainersLifecycle#postStart
   */
  readonly postStart?: GrafanaAgentSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema GrafanaAgentSpecContainersLifecycle#preStop
   */
  readonly preStop?: GrafanaAgentSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecycle(obj: GrafanaAgentSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_GrafanaAgentSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_GrafanaAgentSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecContainersLivenessProbe
 */
export interface GrafanaAgentSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#exec
   */
  readonly exec?: GrafanaAgentSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbe(obj: GrafanaAgentSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema GrafanaAgentSpecContainersPorts
 */
export interface GrafanaAgentSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema GrafanaAgentSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema GrafanaAgentSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema GrafanaAgentSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema GrafanaAgentSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema GrafanaAgentSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersPorts(obj: GrafanaAgentSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecContainersReadinessProbe
 */
export interface GrafanaAgentSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#exec
   */
  readonly exec?: GrafanaAgentSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbe(obj: GrafanaAgentSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema GrafanaAgentSpecContainersResources
 */
export interface GrafanaAgentSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersResources(obj: GrafanaAgentSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema GrafanaAgentSpecContainersSecurityContext
 */
export interface GrafanaAgentSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: GrafanaAgentSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: GrafanaAgentSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: GrafanaAgentSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema GrafanaAgentSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: GrafanaAgentSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersSecurityContext(obj: GrafanaAgentSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_GrafanaAgentSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_GrafanaAgentSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_GrafanaAgentSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_GrafanaAgentSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecContainersStartupProbe
 */
export interface GrafanaAgentSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#exec
   */
  readonly exec?: GrafanaAgentSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbe(obj: GrafanaAgentSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema GrafanaAgentSpecContainersVolumeDevices
 */
export interface GrafanaAgentSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema GrafanaAgentSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema GrafanaAgentSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersVolumeDevices(obj: GrafanaAgentSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema GrafanaAgentSpecContainersVolumeMounts
 */
export interface GrafanaAgentSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema GrafanaAgentSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema GrafanaAgentSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema GrafanaAgentSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema GrafanaAgentSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema GrafanaAgentSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema GrafanaAgentSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersVolumeMounts(obj: GrafanaAgentSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema GrafanaAgentSpecInitContainersEnv
 */
export interface GrafanaAgentSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema GrafanaAgentSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema GrafanaAgentSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema GrafanaAgentSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: GrafanaAgentSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnv(obj: GrafanaAgentSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_GrafanaAgentSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema GrafanaAgentSpecInitContainersEnvFrom
 */
export interface GrafanaAgentSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema GrafanaAgentSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: GrafanaAgentSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema GrafanaAgentSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema GrafanaAgentSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvFrom(obj: GrafanaAgentSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_GrafanaAgentSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_GrafanaAgentSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema GrafanaAgentSpecInitContainersLifecycle
 */
export interface GrafanaAgentSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema GrafanaAgentSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: GrafanaAgentSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema GrafanaAgentSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: GrafanaAgentSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecycle(obj: GrafanaAgentSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_GrafanaAgentSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_GrafanaAgentSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbe
 */
export interface GrafanaAgentSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: GrafanaAgentSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbe(obj: GrafanaAgentSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema GrafanaAgentSpecInitContainersPorts
 */
export interface GrafanaAgentSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema GrafanaAgentSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema GrafanaAgentSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema GrafanaAgentSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema GrafanaAgentSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema GrafanaAgentSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersPorts(obj: GrafanaAgentSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbe
 */
export interface GrafanaAgentSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: GrafanaAgentSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbe(obj: GrafanaAgentSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema GrafanaAgentSpecInitContainersResources
 */
export interface GrafanaAgentSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersResources(obj: GrafanaAgentSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema GrafanaAgentSpecInitContainersSecurityContext
 */
export interface GrafanaAgentSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: GrafanaAgentSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema GrafanaAgentSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: GrafanaAgentSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: GrafanaAgentSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersSecurityContext(obj: GrafanaAgentSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_GrafanaAgentSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_GrafanaAgentSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_GrafanaAgentSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbe
 */
export interface GrafanaAgentSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#exec
   */
  readonly exec?: GrafanaAgentSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: GrafanaAgentSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema GrafanaAgentSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema GrafanaAgentSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbe(obj: GrafanaAgentSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_GrafanaAgentSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_GrafanaAgentSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_GrafanaAgentSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema GrafanaAgentSpecInitContainersVolumeDevices
 */
export interface GrafanaAgentSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema GrafanaAgentSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema GrafanaAgentSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersVolumeDevices(obj: GrafanaAgentSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema GrafanaAgentSpecInitContainersVolumeMounts
 */
export interface GrafanaAgentSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema GrafanaAgentSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersVolumeMounts(obj: GrafanaAgentSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label selector for namespaces to search when discovering integration resources. If nil, integration resources are only discovered in the namespace of the GrafanaAgent resource.
 * Set to `{}` to search all namespaces.
 *
 * @schema GrafanaAgentSpecIntegrationsNamespaceSelector
 */
export interface GrafanaAgentSpecIntegrationsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecIntegrationsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecIntegrationsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecIntegrationsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecIntegrationsNamespaceSelector(obj: GrafanaAgentSpecIntegrationsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label selector to find Integration resources to run. When nil, no integration resources will be defined.
 *
 * @schema GrafanaAgentSpecIntegrationsSelector
 */
export interface GrafanaAgentSpecIntegrationsSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecIntegrationsSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecIntegrationsSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecIntegrationsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecIntegrationsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecIntegrationsSelector(obj: GrafanaAgentSpecIntegrationsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecIntegrationsSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogsClientSpec defines the client integration for logs, indicating which Loki server to send logs to.
 *
 * @schema GrafanaAgentSpecLogsClients
 */
export interface GrafanaAgentSpecLogsClients {
  /**
   * Configures how to retry requests to Loki when a request fails. Defaults to a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
   *
   * @default a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
   * @schema GrafanaAgentSpecLogsClients#backoffConfig
   */
  readonly backoffConfig?: GrafanaAgentSpecLogsClientsBackoffConfig;

  /**
   * BasicAuth for the Loki server.
   *
   * @schema GrafanaAgentSpecLogsClients#basicAuth
   */
  readonly basicAuth?: GrafanaAgentSpecLogsClientsBasicAuth;

  /**
   * Maximum batch size (in bytes) of logs to accumulate before sending the batch to Loki.
   *
   * @schema GrafanaAgentSpecLogsClients#batchSize
   */
  readonly batchSize?: number;

  /**
   * Maximum amount of time to wait before sending a batch, even if that batch isn't full.
   *
   * @schema GrafanaAgentSpecLogsClients#batchWait
   */
  readonly batchWait?: string;

  /**
   * BearerToken used for remote_write.
   *
   * @schema GrafanaAgentSpecLogsClients#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * BearerTokenFile used to read bearer token.
   *
   * @schema GrafanaAgentSpecLogsClients#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * ExternalLabels are labels to add to any time series when sending data to Loki.
   *
   * @schema GrafanaAgentSpecLogsClients#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * ProxyURL to proxy requests through. Optional.
   *
   * @schema GrafanaAgentSpecLogsClients#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Tenant ID used by default to push logs to Loki. If omitted assumes remote Loki is running in single-tenant mode or an authentication layer is used to inject an X-Scope-OrgID header.
   *
   * @schema GrafanaAgentSpecLogsClients#tenantId
   */
  readonly tenantId?: string;

  /**
   * Maximum time to wait for a server to respond to a request.
   *
   * @schema GrafanaAgentSpecLogsClients#timeout
   */
  readonly timeout?: string;

  /**
   * TLSConfig to use for the client. Only used when the protocol of the URL is https.
   *
   * @schema GrafanaAgentSpecLogsClients#tlsConfig
   */
  readonly tlsConfig?: GrafanaAgentSpecLogsClientsTlsConfig;

  /**
   * URL is the URL where Loki is listening. Must be a full HTTP URL, including protocol. Required. Example: https://logs-prod-us-central1.grafana.net/loki/api/v1/push.
   *
   * @schema GrafanaAgentSpecLogsClients#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClients' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClients(obj: GrafanaAgentSpecLogsClients | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backoffConfig': toJson_GrafanaAgentSpecLogsClientsBackoffConfig(obj.backoffConfig),
    'basicAuth': toJson_GrafanaAgentSpecLogsClientsBasicAuth(obj.basicAuth),
    'batchSize': obj.batchSize,
    'batchWait': obj.batchWait,
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyUrl': obj.proxyUrl,
    'tenantId': obj.tenantId,
    'timeout': obj.timeout,
    'tlsConfig': toJson_GrafanaAgentSpecLogsClientsTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceNamespaceSelector are the set of labels to determine which namespaces to watch for LogInstances. If not provided, only checks own namespace.
 *
 * @schema GrafanaAgentSpecLogsInstanceNamespaceSelector
 */
export interface GrafanaAgentSpecLogsInstanceNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecLogsInstanceNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecLogsInstanceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsInstanceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsInstanceNamespaceSelector(obj: GrafanaAgentSpecLogsInstanceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSelector determines which LogInstances should be selected for running. Each instance runs its own set of Prometheus components, including service discovery, scraping, and remote_write.
 *
 * @schema GrafanaAgentSpecLogsInstanceSelector
 */
export interface GrafanaAgentSpecLogsInstanceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecLogsInstanceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecLogsInstanceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecLogsInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsInstanceSelector(obj: GrafanaAgentSpecLogsInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecLogsInstanceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArbitraryFSAccessThroughSMs configures whether configuration based on a ServiceMonitor can access arbitrary files on the file system of the Grafana Agent container, e.g., bearer token files.
 *
 * @schema GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs
 */
export interface GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs {
  /**
   * @schema GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs#deny
   */
  readonly deny?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs(obj: GrafanaAgentSpecMetricsArbitraryFsAccessThroughSMs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deny': obj.deny,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceNamespaceSelector is the set of labels that determines which namespaces to watch for MetricsInstances. If not provided, it only checks its own namespace.
 *
 * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelector
 */
export interface GrafanaAgentSpecMetricsInstanceNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsInstanceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsInstanceNamespaceSelector(obj: GrafanaAgentSpecMetricsInstanceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSelector determines which MetricsInstances should be selected for running. Each instance runs its own set of Metrics components, including service discovery, scraping, and remote_write.
 *
 * @schema GrafanaAgentSpecMetricsInstanceSelector
 */
export interface GrafanaAgentSpecMetricsInstanceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecMetricsInstanceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecMetricsInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsInstanceSelector(obj: GrafanaAgentSpecMetricsInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteWriteSpec defines the remote_write configuration for Prometheus.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWrite
 */
export interface GrafanaAgentSpecMetricsRemoteWrite {
  /**
   * BasicAuth for the URL.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#basicAuth
   */
  readonly basicAuth?: GrafanaAgentSpecMetricsRemoteWriteBasicAuth;

  /**
   * BearerToken used for remote_write.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * BearerTokenFile used to read bearer token.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Headers is a set of custom HTTP headers to be sent along with each remote_write request. Be aware that any headers set by Grafana Agent itself can't be overwritten.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MetadataConfig configures the sending of series metadata to remote storage.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#metadataConfig
   */
  readonly metadataConfig?: GrafanaAgentSpecMetricsRemoteWriteMetadataConfig;

  /**
   * Name of the remote_write queue. Must be unique if specified. The name is used in metrics and logging in order to differentiate queues.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#name
   */
  readonly name?: string;

  /**
   * Oauth2 for URL
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#oauth2
   */
  readonly oauth2?: GrafanaAgentSpecMetricsRemoteWriteOauth2;

  /**
   * ProxyURL to proxy requests through. Optional.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * QueueConfig allows tuning of the remote_write queue parameters.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#queueConfig
   */
  readonly queueConfig?: GrafanaAgentSpecMetricsRemoteWriteQueueConfig;

  /**
   * RemoteTimeout is the timeout for requests to the remote_write endpoint.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * SigV4 configures SigV4-based authentication to the remote_write endpoint. SigV4-based authentication is used if SigV4 is defined, even with an empty object.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#sigv4
   */
  readonly sigv4?: GrafanaAgentSpecMetricsRemoteWriteSigv4;

  /**
   * TLSConfig to use for remote_write.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: GrafanaAgentSpecMetricsRemoteWriteTlsConfig;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#url
   */
  readonly url: string;

  /**
   * WriteRelabelConfigs holds relabel_configs to relabel samples before they are sent to the remote_write endpoint.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWrite#writeRelabelConfigs
   */
  readonly writeRelabelConfigs?: GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWrite(obj: GrafanaAgentSpecMetricsRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataConfig': toJson_GrafanaAgentSpecMetricsRemoteWriteMetadataConfig(obj.metadataConfig),
    'name': obj.name,
    'oauth2': toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2(obj.oauth2),
    'proxyUrl': obj.proxyUrl,
    'queueConfig': toJson_GrafanaAgentSpecMetricsRemoteWriteQueueConfig(obj.queueConfig),
    'remoteTimeout': obj.remoteTimeout,
    'sigv4': toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4(obj.sigv4),
    'tlsConfig': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfig(obj.tlsConfig),
    'url': obj.url,
    'writeRelabelConfigs': obj.writeRelabelConfigs?.map(y => toJson_GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecResourcesLimits
 */
export class GrafanaAgentSpecResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecResourcesLimits {
    return new GrafanaAgentSpecResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecResourcesLimits {
    return new GrafanaAgentSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecResourcesRequests
 */
export class GrafanaAgentSpecResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecResourcesRequests {
    return new GrafanaAgentSpecResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecResourcesRequests {
    return new GrafanaAgentSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecSecurityContextSeLinuxOptions
 */
export interface GrafanaAgentSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema GrafanaAgentSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema GrafanaAgentSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema GrafanaAgentSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema GrafanaAgentSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecSecurityContextSeLinuxOptions(obj: GrafanaAgentSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecSecurityContextSeccompProfile
 */
export interface GrafanaAgentSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema GrafanaAgentSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema GrafanaAgentSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecSecurityContextSeccompProfile(obj: GrafanaAgentSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema GrafanaAgentSpecSecurityContextSysctls
 */
export interface GrafanaAgentSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema GrafanaAgentSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema GrafanaAgentSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecSecurityContextSysctls(obj: GrafanaAgentSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema GrafanaAgentSpecSecurityContextWindowsOptions
 */
export interface GrafanaAgentSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema GrafanaAgentSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema GrafanaAgentSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema GrafanaAgentSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema GrafanaAgentSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecSecurityContextWindowsOptions(obj: GrafanaAgentSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema GrafanaAgentSpecStorageEmptyDir
 */
export interface GrafanaAgentSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema GrafanaAgentSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema GrafanaAgentSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: GrafanaAgentSpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEmptyDir(obj: GrafanaAgentSpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the Prometheus StatefulSets. This is a beta field in k8s 1.21, for lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema GrafanaAgentSpecStorageEphemeral
 */
export interface GrafanaAgentSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema GrafanaAgentSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeral(obj: GrafanaAgentSpecStorageEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A PVC spec to be used by the Prometheus StatefulSets.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplate
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: GrafanaAgentSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: GrafanaAgentSpecStorageVolumeClaimTemplateSpec;

  /**
   * Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: GrafanaAgentSpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplate(obj: GrafanaAgentSpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelector
 */
export interface GrafanaAgentSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecTopologySpreadConstraintsLabelSelector(obj: GrafanaAgentSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema GrafanaAgentSpecVolumesAwsElasticBlockStore
 */
export interface GrafanaAgentSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema GrafanaAgentSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema GrafanaAgentSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema GrafanaAgentSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema GrafanaAgentSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesAwsElasticBlockStore(obj: GrafanaAgentSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema GrafanaAgentSpecVolumesAzureDisk
 */
export interface GrafanaAgentSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema GrafanaAgentSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema GrafanaAgentSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema GrafanaAgentSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema GrafanaAgentSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema GrafanaAgentSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema GrafanaAgentSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesAzureDisk(obj: GrafanaAgentSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema GrafanaAgentSpecVolumesAzureFile
 */
export interface GrafanaAgentSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema GrafanaAgentSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema GrafanaAgentSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema GrafanaAgentSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesAzureFile(obj: GrafanaAgentSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema GrafanaAgentSpecVolumesCephfs
 */
export interface GrafanaAgentSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema GrafanaAgentSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCephfs(obj: GrafanaAgentSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_GrafanaAgentSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema GrafanaAgentSpecVolumesCinder
 */
export interface GrafanaAgentSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema GrafanaAgentSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema GrafanaAgentSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema GrafanaAgentSpecVolumesCinder#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema GrafanaAgentSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCinder(obj: GrafanaAgentSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema GrafanaAgentSpecVolumesConfigMap
 */
export interface GrafanaAgentSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema GrafanaAgentSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema GrafanaAgentSpecVolumesConfigMap#items
   */
  readonly items?: GrafanaAgentSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema GrafanaAgentSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesConfigMap(obj: GrafanaAgentSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema GrafanaAgentSpecVolumesCsi
 */
export interface GrafanaAgentSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema GrafanaAgentSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema GrafanaAgentSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema GrafanaAgentSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: GrafanaAgentSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema GrafanaAgentSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema GrafanaAgentSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCsi(obj: GrafanaAgentSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_GrafanaAgentSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema GrafanaAgentSpecVolumesDownwardApi
 */
export interface GrafanaAgentSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema GrafanaAgentSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema GrafanaAgentSpecVolumesDownwardApi#items
   */
  readonly items?: GrafanaAgentSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesDownwardApi(obj: GrafanaAgentSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema GrafanaAgentSpecVolumesEmptyDir
 */
export interface GrafanaAgentSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema GrafanaAgentSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema GrafanaAgentSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: GrafanaAgentSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEmptyDir(obj: GrafanaAgentSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema GrafanaAgentSpecVolumesEphemeral
 */
export interface GrafanaAgentSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema GrafanaAgentSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeral(obj: GrafanaAgentSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema GrafanaAgentSpecVolumesFc
 */
export interface GrafanaAgentSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema GrafanaAgentSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema GrafanaAgentSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema GrafanaAgentSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema GrafanaAgentSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema GrafanaAgentSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesFc(obj: GrafanaAgentSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema GrafanaAgentSpecVolumesFlexVolume
 */
export interface GrafanaAgentSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema GrafanaAgentSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema GrafanaAgentSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema GrafanaAgentSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema GrafanaAgentSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema GrafanaAgentSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesFlexVolume(obj: GrafanaAgentSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema GrafanaAgentSpecVolumesFlocker
 */
export interface GrafanaAgentSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema GrafanaAgentSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema GrafanaAgentSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesFlocker(obj: GrafanaAgentSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema GrafanaAgentSpecVolumesGcePersistentDisk
 */
export interface GrafanaAgentSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema GrafanaAgentSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema GrafanaAgentSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema GrafanaAgentSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema GrafanaAgentSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesGcePersistentDisk(obj: GrafanaAgentSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema GrafanaAgentSpecVolumesGitRepo
 */
export interface GrafanaAgentSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema GrafanaAgentSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema GrafanaAgentSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema GrafanaAgentSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesGitRepo(obj: GrafanaAgentSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema GrafanaAgentSpecVolumesGlusterfs
 */
export interface GrafanaAgentSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema GrafanaAgentSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema GrafanaAgentSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema GrafanaAgentSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesGlusterfs(obj: GrafanaAgentSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema GrafanaAgentSpecVolumesHostPath
 */
export interface GrafanaAgentSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema GrafanaAgentSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema GrafanaAgentSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesHostPath(obj: GrafanaAgentSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema GrafanaAgentSpecVolumesIscsi
 */
export interface GrafanaAgentSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema GrafanaAgentSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema GrafanaAgentSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema GrafanaAgentSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema GrafanaAgentSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema GrafanaAgentSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema GrafanaAgentSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema GrafanaAgentSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema GrafanaAgentSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema GrafanaAgentSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema GrafanaAgentSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema GrafanaAgentSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesIscsi(obj: GrafanaAgentSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema GrafanaAgentSpecVolumesNfs
 */
export interface GrafanaAgentSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema GrafanaAgentSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema GrafanaAgentSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema GrafanaAgentSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesNfs(obj: GrafanaAgentSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema GrafanaAgentSpecVolumesPersistentVolumeClaim
 */
export interface GrafanaAgentSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema GrafanaAgentSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema GrafanaAgentSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesPersistentVolumeClaim(obj: GrafanaAgentSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema GrafanaAgentSpecVolumesPhotonPersistentDisk
 */
export interface GrafanaAgentSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema GrafanaAgentSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema GrafanaAgentSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesPhotonPersistentDisk(obj: GrafanaAgentSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema GrafanaAgentSpecVolumesPortworxVolume
 */
export interface GrafanaAgentSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema GrafanaAgentSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema GrafanaAgentSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema GrafanaAgentSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesPortworxVolume(obj: GrafanaAgentSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema GrafanaAgentSpecVolumesProjected
 */
export interface GrafanaAgentSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema GrafanaAgentSpecVolumesProjected#sources
   */
  readonly sources?: GrafanaAgentSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjected(obj: GrafanaAgentSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_GrafanaAgentSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema GrafanaAgentSpecVolumesQuobyte
 */
export interface GrafanaAgentSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema GrafanaAgentSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema GrafanaAgentSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema GrafanaAgentSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema GrafanaAgentSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema GrafanaAgentSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema GrafanaAgentSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesQuobyte(obj: GrafanaAgentSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema GrafanaAgentSpecVolumesRbd
 */
export interface GrafanaAgentSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema GrafanaAgentSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema GrafanaAgentSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesRbd#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema GrafanaAgentSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesRbd(obj: GrafanaAgentSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema GrafanaAgentSpecVolumesScaleIo
 */
export interface GrafanaAgentSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema GrafanaAgentSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema GrafanaAgentSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: GrafanaAgentSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema GrafanaAgentSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema GrafanaAgentSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesScaleIo(obj: GrafanaAgentSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema GrafanaAgentSpecVolumesSecret
 */
export interface GrafanaAgentSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema GrafanaAgentSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema GrafanaAgentSpecVolumesSecret#items
   */
  readonly items?: GrafanaAgentSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema GrafanaAgentSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema GrafanaAgentSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesSecret(obj: GrafanaAgentSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema GrafanaAgentSpecVolumesStorageos
 */
export interface GrafanaAgentSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema GrafanaAgentSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema GrafanaAgentSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema GrafanaAgentSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: GrafanaAgentSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema GrafanaAgentSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema GrafanaAgentSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesStorageos(obj: GrafanaAgentSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_GrafanaAgentSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema GrafanaAgentSpecVolumesVsphereVolume
 */
export interface GrafanaAgentSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema GrafanaAgentSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema GrafanaAgentSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema GrafanaAgentSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema GrafanaAgentSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesVsphereVolume(obj: GrafanaAgentSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the credentials of the request
 *
 * @schema GrafanaAgentSpecApiServerAuthorizationCredentials
 */
export interface GrafanaAgentSpecApiServerAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerAuthorizationCredentials(obj: GrafanaAgentSpecApiServerAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema GrafanaAgentSpecApiServerBasicAuthPassword
 */
export interface GrafanaAgentSpecApiServerBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerBasicAuthPassword(obj: GrafanaAgentSpecApiServerBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema GrafanaAgentSpecApiServerBasicAuthUsername
 */
export interface GrafanaAgentSpecApiServerBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerBasicAuthUsername(obj: GrafanaAgentSpecApiServerBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCa
 */
export interface GrafanaAgentSpecApiServerTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCa#configMap
   */
  readonly configMap?: GrafanaAgentSpecApiServerTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCa#secret
   */
  readonly secret?: GrafanaAgentSpecApiServerTlsConfigCaSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCa(obj: GrafanaAgentSpecApiServerTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecApiServerTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecApiServerTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCert
 */
export interface GrafanaAgentSpecApiServerTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCert#configMap
   */
  readonly configMap?: GrafanaAgentSpecApiServerTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCert#secret
   */
  readonly secret?: GrafanaAgentSpecApiServerTlsConfigCertSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCert(obj: GrafanaAgentSpecApiServerTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecApiServerTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecApiServerTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigKeySecret
 */
export interface GrafanaAgentSpecApiServerTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigKeySecret(obj: GrafanaAgentSpecApiServerTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema GrafanaAgentSpecContainersEnvValueFrom
 */
export interface GrafanaAgentSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: GrafanaAgentSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: GrafanaAgentSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema GrafanaAgentSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: GrafanaAgentSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvValueFrom(obj: GrafanaAgentSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_GrafanaAgentSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_GrafanaAgentSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_GrafanaAgentSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema GrafanaAgentSpecContainersEnvFromConfigMapRef
 */
export interface GrafanaAgentSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema GrafanaAgentSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvFromConfigMapRef(obj: GrafanaAgentSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema GrafanaAgentSpecContainersEnvFromSecretRef
 */
export interface GrafanaAgentSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema GrafanaAgentSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvFromSecretRef(obj: GrafanaAgentSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStart
 */
export interface GrafanaAgentSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: GrafanaAgentSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePostStart(obj: GrafanaAgentSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_GrafanaAgentSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_GrafanaAgentSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStop
 */
export interface GrafanaAgentSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: GrafanaAgentSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePreStop(obj: GrafanaAgentSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_GrafanaAgentSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_GrafanaAgentSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeExec
 */
export interface GrafanaAgentSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbeExec(obj: GrafanaAgentSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeGrpc
 */
export interface GrafanaAgentSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbeGrpc(obj: GrafanaAgentSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet
 */
export interface GrafanaAgentSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbeHttpGet(obj: GrafanaAgentSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeTcpSocket
 */
export interface GrafanaAgentSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbeTcpSocket(obj: GrafanaAgentSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeExec
 */
export interface GrafanaAgentSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbeExec(obj: GrafanaAgentSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeGrpc
 */
export interface GrafanaAgentSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbeGrpc(obj: GrafanaAgentSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet
 */
export interface GrafanaAgentSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbeHttpGet(obj: GrafanaAgentSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeTcpSocket
 */
export interface GrafanaAgentSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbeTcpSocket(obj: GrafanaAgentSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecContainersResourcesLimits
 */
export class GrafanaAgentSpecContainersResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecContainersResourcesLimits {
    return new GrafanaAgentSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersResourcesLimits {
    return new GrafanaAgentSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecContainersResourcesRequests
 */
export class GrafanaAgentSpecContainersResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecContainersResourcesRequests {
    return new GrafanaAgentSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersResourcesRequests {
    return new GrafanaAgentSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema GrafanaAgentSpecContainersSecurityContextCapabilities
 */
export interface GrafanaAgentSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema GrafanaAgentSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema GrafanaAgentSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersSecurityContextCapabilities(obj: GrafanaAgentSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecContainersSecurityContextSeLinuxOptions
 */
export interface GrafanaAgentSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersSecurityContextSeLinuxOptions(obj: GrafanaAgentSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecContainersSecurityContextSeccompProfile
 */
export interface GrafanaAgentSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersSecurityContextSeccompProfile(obj: GrafanaAgentSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema GrafanaAgentSpecContainersSecurityContextWindowsOptions
 */
export interface GrafanaAgentSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema GrafanaAgentSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema GrafanaAgentSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersSecurityContextWindowsOptions(obj: GrafanaAgentSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeExec
 */
export interface GrafanaAgentSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbeExec(obj: GrafanaAgentSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeGrpc
 */
export interface GrafanaAgentSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbeGrpc(obj: GrafanaAgentSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeHttpGet
 */
export interface GrafanaAgentSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbeHttpGet(obj: GrafanaAgentSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeTcpSocket
 */
export interface GrafanaAgentSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbeTcpSocket(obj: GrafanaAgentSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFrom
 */
export interface GrafanaAgentSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: GrafanaAgentSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvValueFrom(obj: GrafanaAgentSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_GrafanaAgentSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema GrafanaAgentSpecInitContainersEnvFromConfigMapRef
 */
export interface GrafanaAgentSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema GrafanaAgentSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvFromConfigMapRef(obj: GrafanaAgentSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema GrafanaAgentSpecInitContainersEnvFromSecretRef
 */
export interface GrafanaAgentSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema GrafanaAgentSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvFromSecretRef(obj: GrafanaAgentSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStart
 */
export interface GrafanaAgentSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: GrafanaAgentSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePostStart(obj: GrafanaAgentSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStop
 */
export interface GrafanaAgentSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: GrafanaAgentSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePreStop(obj: GrafanaAgentSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_GrafanaAgentSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeExec
 */
export interface GrafanaAgentSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbeExec(obj: GrafanaAgentSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeGrpc
 */
export interface GrafanaAgentSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbeGrpc(obj: GrafanaAgentSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet
 */
export interface GrafanaAgentSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbeHttpGet(obj: GrafanaAgentSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeTcpSocket
 */
export interface GrafanaAgentSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbeTcpSocket(obj: GrafanaAgentSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeExec
 */
export interface GrafanaAgentSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbeExec(obj: GrafanaAgentSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeGrpc
 */
export interface GrafanaAgentSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbeGrpc(obj: GrafanaAgentSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet
 */
export interface GrafanaAgentSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbeHttpGet(obj: GrafanaAgentSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeTcpSocket
 */
export interface GrafanaAgentSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbeTcpSocket(obj: GrafanaAgentSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecInitContainersResourcesLimits
 */
export class GrafanaAgentSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersResourcesLimits {
    return new GrafanaAgentSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersResourcesLimits {
    return new GrafanaAgentSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecInitContainersResourcesRequests
 */
export class GrafanaAgentSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersResourcesRequests {
    return new GrafanaAgentSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersResourcesRequests {
    return new GrafanaAgentSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema GrafanaAgentSpecInitContainersSecurityContextCapabilities
 */
export interface GrafanaAgentSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersSecurityContextCapabilities(obj: GrafanaAgentSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions(obj: GrafanaAgentSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GrafanaAgentSpecInitContainersSecurityContextSeccompProfile
 */
export interface GrafanaAgentSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersSecurityContextSeccompProfile(obj: GrafanaAgentSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema GrafanaAgentSpecInitContainersSecurityContextWindowsOptions
 */
export interface GrafanaAgentSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema GrafanaAgentSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema GrafanaAgentSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersSecurityContextWindowsOptions(obj: GrafanaAgentSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeExec
 */
export interface GrafanaAgentSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbeExec(obj: GrafanaAgentSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeGrpc
 */
export interface GrafanaAgentSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbeGrpc(obj: GrafanaAgentSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet
 */
export interface GrafanaAgentSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: GrafanaAgentSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbeHttpGet(obj: GrafanaAgentSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeTcpSocket
 */
export interface GrafanaAgentSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbeTcpSocket(obj: GrafanaAgentSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecIntegrationsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecIntegrationsSelectorMatchExpressions
 */
export interface GrafanaAgentSpecIntegrationsSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecIntegrationsSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecIntegrationsSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecIntegrationsSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecIntegrationsSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecIntegrationsSelectorMatchExpressions(obj: GrafanaAgentSpecIntegrationsSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how to retry requests to Loki when a request fails. Defaults to a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
 *
 * @default a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
 * @schema GrafanaAgentSpecLogsClientsBackoffConfig
 */
export interface GrafanaAgentSpecLogsClientsBackoffConfig {
  /**
   * Maximum backoff time between retries.
   *
   * @schema GrafanaAgentSpecLogsClientsBackoffConfig#maxPeriod
   */
  readonly maxPeriod?: string;

  /**
   * Maximum number of retries to perform before giving up a request.
   *
   * @schema GrafanaAgentSpecLogsClientsBackoffConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Initial backoff time between retries. Time between retries is increased exponentially.
   *
   * @schema GrafanaAgentSpecLogsClientsBackoffConfig#minPeriod
   */
  readonly minPeriod?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsBackoffConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsBackoffConfig(obj: GrafanaAgentSpecLogsClientsBackoffConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPeriod': obj.maxPeriod,
    'maxRetries': obj.maxRetries,
    'minPeriod': obj.minPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the Loki server.
 *
 * @schema GrafanaAgentSpecLogsClientsBasicAuth
 */
export interface GrafanaAgentSpecLogsClientsBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuth#password
   */
  readonly password?: GrafanaAgentSpecLogsClientsBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuth#username
   */
  readonly username?: GrafanaAgentSpecLogsClientsBasicAuthUsername;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsBasicAuth(obj: GrafanaAgentSpecLogsClientsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_GrafanaAgentSpecLogsClientsBasicAuthPassword(obj.password),
    'username': toJson_GrafanaAgentSpecLogsClientsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSConfig to use for the client. Only used when the protocol of the URL is https.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfig
 */
export interface GrafanaAgentSpecLogsClientsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#ca
   */
  readonly ca?: GrafanaAgentSpecLogsClientsTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#cert
   */
  readonly cert?: GrafanaAgentSpecLogsClientsTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#keySecret
   */
  readonly keySecret?: GrafanaAgentSpecLogsClientsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfig(obj: GrafanaAgentSpecLogsClientsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_GrafanaAgentSpecLogsClientsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_GrafanaAgentSpecLogsClientsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_GrafanaAgentSpecLogsClientsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecLogsInstanceNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecLogsInstanceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecLogsInstanceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecLogsInstanceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecLogsInstanceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecLogsInstanceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsInstanceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsInstanceSelectorMatchExpressions(obj: GrafanaAgentSpecLogsInstanceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecMetricsInstanceNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions(obj: GrafanaAgentSpecMetricsInstanceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the URL.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuth
 */
export interface GrafanaAgentSpecMetricsRemoteWriteBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuth#password
   */
  readonly password?: GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuth#username
   */
  readonly username?: GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuth(obj: GrafanaAgentSpecMetricsRemoteWriteBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword(obj.password),
    'username': toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataConfig configures the sending of series metadata to remote storage.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteMetadataConfig
 */
export interface GrafanaAgentSpecMetricsRemoteWriteMetadataConfig {
  /**
   * Send enables metric metadata to be sent to remote storage.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteMetadataConfig#send
   */
  readonly send?: boolean;

  /**
   * SendInterval controls how frequently metric metadata is sent to remote storage.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteMetadataConfig#sendInterval
   */
  readonly sendInterval?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteMetadataConfig(obj: GrafanaAgentSpecMetricsRemoteWriteMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'send': obj.send,
    'sendInterval': obj.sendInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Oauth2 for URL
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2
 */
export interface GrafanaAgentSpecMetricsRemoteWriteOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2#clientId
   */
  readonly clientId: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret;

  /**
   * Parameters to append to the token URL
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * The URL to fetch the token from
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2(obj: GrafanaAgentSpecMetricsRemoteWriteOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId(obj.clientId),
    'clientSecret': toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfig allows tuning of the remote_write queue parameters.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig
 */
export interface GrafanaAgentSpecMetricsRemoteWriteQueueConfig {
  /**
   * BatchSendDeadline is the maximum time a sample will wait in the buffer.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#batchSendDeadline
   */
  readonly batchSendDeadline?: string;

  /**
   * Capacity is the number of samples to buffer per shard before samples start being dropped.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#capacity
   */
  readonly capacity?: number;

  /**
   * MaxBackoff is the maximum retry delay.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#maxBackoff
   */
  readonly maxBackoff?: string;

  /**
   * MaxRetries is the maximum number of times to retry a batch on recoverable errors.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * MaxSamplesPerSend is the maximum number of samples per send.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#maxSamplesPerSend
   */
  readonly maxSamplesPerSend?: number;

  /**
   * MaxShards is the maximum number of shards, i.e., the amount of concurrency.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#maxShards
   */
  readonly maxShards?: number;

  /**
   * MinBackoff is the initial retry delay. MinBackoff is doubled for every retry.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#minBackoff
   */
  readonly minBackoff?: string;

  /**
   * MinShards is the minimum number of shards, i.e., the amount of concurrency.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#minShards
   */
  readonly minShards?: number;

  /**
   * RetryOnRateLimit retries requests when encountering rate limits.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteQueueConfig#retryOnRateLimit
   */
  readonly retryOnRateLimit?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteQueueConfig(obj: GrafanaAgentSpecMetricsRemoteWriteQueueConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSendDeadline': obj.batchSendDeadline,
    'capacity': obj.capacity,
    'maxBackoff': obj.maxBackoff,
    'maxRetries': obj.maxRetries,
    'maxSamplesPerSend': obj.maxSamplesPerSend,
    'maxShards': obj.maxShards,
    'minBackoff': obj.minBackoff,
    'minShards': obj.minShards,
    'retryOnRateLimit': obj.retryOnRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigV4 configures SigV4-based authentication to the remote_write endpoint. SigV4-based authentication is used if SigV4 is defined, even with an empty object.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4
 */
export interface GrafanaAgentSpecMetricsRemoteWriteSigv4 {
  /**
   * AccessKey holds the secret of the AWS API access key to use for signing. If not provided, the environment variable AWS_ACCESS_KEY_ID is used.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4#accessKey
   */
  readonly accessKey?: GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey;

  /**
   * Profile is the named AWS profile to use for authentication.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region of the AWS endpoint. If blank, the region from the default credentials chain is used.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4#region
   */
  readonly region?: string;

  /**
   * RoleARN is the AWS Role ARN to use for authentication, as an alternative for using the AWS API keys.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4#roleARN
   */
  readonly roleArn?: string;

  /**
   * SecretKey of the AWS API to use for signing. If blank, the environment variable AWS_SECRET_ACCESS_KEY is used.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4#secretKey
   */
  readonly secretKey?: GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4(obj: GrafanaAgentSpecMetricsRemoteWriteSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey(obj.accessKey),
    'profile': obj.profile,
    'region': obj.region,
    'roleARN': obj.roleArn,
    'secretKey': toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSConfig to use for remote_write.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#ca
   */
  readonly ca?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#cert
   */
  readonly cert?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfig(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs
 */
export interface GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   *
   * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#action
   */
  readonly action?: GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   *
   * @default '
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs(obj: GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema GrafanaAgentSpecStorageEmptyDirSizeLimit
 */
export class GrafanaAgentSpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): GrafanaAgentSpecStorageEmptyDirSizeLimit {
    return new GrafanaAgentSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageEmptyDirSizeLimit {
    return new GrafanaAgentSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateMetadata
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateMetadata(obj: GrafanaAgentSpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpec(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

  /**
   * resizeStatus stores status of resize operation. ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty string by resize controller or kubelet. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatus#resizeStatus
   */
  readonly resizeStatus?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateStatus(obj: GrafanaAgentSpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions(y)),
    'phase': obj.phase,
    'resizeStatus': obj.resizeStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: GrafanaAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema GrafanaAgentSpecVolumesCephfsSecretRef
 */
export interface GrafanaAgentSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCephfsSecretRef(obj: GrafanaAgentSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema GrafanaAgentSpecVolumesCinderSecretRef
 */
export interface GrafanaAgentSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCinderSecretRef(obj: GrafanaAgentSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema GrafanaAgentSpecVolumesConfigMapItems
 */
export interface GrafanaAgentSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema GrafanaAgentSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema GrafanaAgentSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesConfigMapItems(obj: GrafanaAgentSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema GrafanaAgentSpecVolumesCsiNodePublishSecretRef
 */
export interface GrafanaAgentSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesCsiNodePublishSecretRef(obj: GrafanaAgentSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema GrafanaAgentSpecVolumesDownwardApiItems
 */
export interface GrafanaAgentSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: GrafanaAgentSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesDownwardApiItems(obj: GrafanaAgentSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_GrafanaAgentSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema GrafanaAgentSpecVolumesEmptyDirSizeLimit
 */
export class GrafanaAgentSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): GrafanaAgentSpecVolumesEmptyDirSizeLimit {
    return new GrafanaAgentSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): GrafanaAgentSpecVolumesEmptyDirSizeLimit {
    return new GrafanaAgentSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema GrafanaAgentSpecVolumesFlexVolumeSecretRef
 */
export interface GrafanaAgentSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesFlexVolumeSecretRef(obj: GrafanaAgentSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema GrafanaAgentSpecVolumesIscsiSecretRef
 */
export interface GrafanaAgentSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesIscsiSecretRef(obj: GrafanaAgentSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema GrafanaAgentSpecVolumesProjectedSources
 */
export interface GrafanaAgentSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema GrafanaAgentSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: GrafanaAgentSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema GrafanaAgentSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: GrafanaAgentSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema GrafanaAgentSpecVolumesProjectedSources#secret
   */
  readonly secret?: GrafanaAgentSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema GrafanaAgentSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSources(obj: GrafanaAgentSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_GrafanaAgentSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema GrafanaAgentSpecVolumesRbdSecretRef
 */
export interface GrafanaAgentSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesRbdSecretRef(obj: GrafanaAgentSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema GrafanaAgentSpecVolumesScaleIoSecretRef
 */
export interface GrafanaAgentSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesScaleIoSecretRef(obj: GrafanaAgentSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema GrafanaAgentSpecVolumesSecretItems
 */
export interface GrafanaAgentSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema GrafanaAgentSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema GrafanaAgentSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesSecretItems(obj: GrafanaAgentSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema GrafanaAgentSpecVolumesStorageosSecretRef
 */
export interface GrafanaAgentSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesStorageosSecretRef(obj: GrafanaAgentSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCaConfigMap
 */
export interface GrafanaAgentSpecApiServerTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCaConfigMap(obj: GrafanaAgentSpecApiServerTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCaSecret
 */
export interface GrafanaAgentSpecApiServerTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCaSecret(obj: GrafanaAgentSpecApiServerTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCertConfigMap
 */
export interface GrafanaAgentSpecApiServerTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCertConfigMap(obj: GrafanaAgentSpecApiServerTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecApiServerTlsConfigCertSecret
 */
export interface GrafanaAgentSpecApiServerTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecApiServerTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecApiServerTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecApiServerTlsConfigCertSecret(obj: GrafanaAgentSpecApiServerTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef(obj: GrafanaAgentSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema GrafanaAgentSpecContainersEnvValueFromFieldRef
 */
export interface GrafanaAgentSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvValueFromFieldRef(obj: GrafanaAgentSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema GrafanaAgentSpecContainersEnvValueFromResourceFieldRef
 */
export interface GrafanaAgentSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvValueFromResourceFieldRef(obj: GrafanaAgentSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema GrafanaAgentSpecContainersEnvValueFromSecretKeyRef
 */
export interface GrafanaAgentSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersEnvValueFromSecretKeyRef(obj: GrafanaAgentSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartExec
 */
export interface GrafanaAgentSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePostStartExec(obj: GrafanaAgentSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet
 */
export interface GrafanaAgentSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePostStartHttpGet(obj: GrafanaAgentSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartTcpSocket
 */
export interface GrafanaAgentSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePostStartTcpSocket(obj: GrafanaAgentSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopExec
 */
export interface GrafanaAgentSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePreStopExec(obj: GrafanaAgentSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet
 */
export interface GrafanaAgentSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePreStopHttpGet(obj: GrafanaAgentSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopTcpSocket
 */
export interface GrafanaAgentSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePreStopTcpSocket(obj: GrafanaAgentSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeHttpGetPort
 */
export class GrafanaAgentSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLivenessProbeHttpGetPort {
    return new GrafanaAgentSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLivenessProbeHttpGetPort {
    return new GrafanaAgentSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLivenessProbeTcpSocketPort
 */
export class GrafanaAgentSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLivenessProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLivenessProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeHttpGetPort
 */
export class GrafanaAgentSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersReadinessProbeHttpGetPort {
    return new GrafanaAgentSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersReadinessProbeHttpGetPort {
    return new GrafanaAgentSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersReadinessProbeTcpSocketPort
 */
export class GrafanaAgentSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersReadinessProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersReadinessProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeHttpGetPort
 */
export class GrafanaAgentSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersStartupProbeHttpGetPort {
    return new GrafanaAgentSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersStartupProbeHttpGetPort {
    return new GrafanaAgentSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersStartupProbeTcpSocketPort
 */
export class GrafanaAgentSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersStartupProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersStartupProbeTcpSocketPort {
    return new GrafanaAgentSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef(obj: GrafanaAgentSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFromFieldRef
 */
export interface GrafanaAgentSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvValueFromFieldRef(obj: GrafanaAgentSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef(obj: GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef(obj: GrafanaAgentSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartExec
 */
export interface GrafanaAgentSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePostStartExec(obj: GrafanaAgentSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet
 */
export interface GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet(obj: GrafanaAgentSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket(obj: GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopExec
 */
export interface GrafanaAgentSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePreStopExec(obj: GrafanaAgentSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet
 */
export interface GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet(obj: GrafanaAgentSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket(obj: GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort
 */
export class GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort
 */
export class GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort
 */
export class GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort
 */
export class GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: GrafanaAgentSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeHttpGetPort
 */
export class GrafanaAgentSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersStartupProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersStartupProbeHttpGetPort {
    return new GrafanaAgentSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort
 */
export class GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort {
    return new GrafanaAgentSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema GrafanaAgentSpecLogsClientsBasicAuthPassword
 */
export interface GrafanaAgentSpecLogsClientsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsBasicAuthPassword(obj: GrafanaAgentSpecLogsClientsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema GrafanaAgentSpecLogsClientsBasicAuthUsername
 */
export interface GrafanaAgentSpecLogsClientsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsBasicAuthUsername(obj: GrafanaAgentSpecLogsClientsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCa
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCa#configMap
   */
  readonly configMap?: GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCa#secret
   */
  readonly secret?: GrafanaAgentSpecLogsClientsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCa(obj: GrafanaAgentSpecLogsClientsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecLogsClientsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCert
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCert#configMap
   */
  readonly configMap?: GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCert#secret
   */
  readonly secret?: GrafanaAgentSpecLogsClientsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCert(obj: GrafanaAgentSpecLogsClientsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecLogsClientsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigKeySecret
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigKeySecret(obj: GrafanaAgentSpecLogsClientsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword
 */
export interface GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword(obj: GrafanaAgentSpecMetricsRemoteWriteBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername
 */
export interface GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername(obj: GrafanaAgentSpecMetricsRemoteWriteBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId
 */
export interface GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId(obj: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret
 */
export interface GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret(obj: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey holds the secret of the AWS API access key to use for signing. If not provided, the environment variable AWS_ACCESS_KEY_ID is used.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey
 */
export interface GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey(obj: GrafanaAgentSpecMetricsRemoteWriteSigv4AccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey of the AWS API to use for signing. If blank, the environment variable AWS_SECRET_ACCESS_KEY is used.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey
 */
export interface GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey(obj: GrafanaAgentSpecMetricsRemoteWriteSigv4SecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 *
 * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 * @schema GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigsAction
 */
export enum GrafanaAgentSpecMetricsRemoteWriteWriteRelabelConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
}

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contails details about state of pvc
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions(obj: GrafanaAgentSpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema GrafanaAgentSpecVolumesDownwardApiItemsFieldRef
 */
export interface GrafanaAgentSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesDownwardApiItemsFieldRef(obj: GrafanaAgentSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef(obj: GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMap
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesConfigMap(obj: GrafanaAgentSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApi
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApi(obj: GrafanaAgentSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesSecret
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: GrafanaAgentSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesSecret(obj: GrafanaAgentSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_GrafanaAgentSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken(obj: GrafanaAgentSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: GrafanaAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: GrafanaAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new GrafanaAgentSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: GrafanaAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort
 */
export class GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort {
    return new GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort {
    return new GrafanaAgentSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort
 */
export class GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort {
    return new GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort {
    return new GrafanaAgentSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: GrafanaAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort
 */
export class GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort {
    return new GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort {
    return new GrafanaAgentSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort
 */
export class GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort {
    return new GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort {
    return new GrafanaAgentSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new GrafanaAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort {
    return new GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort {
    return new GrafanaAgentSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort {
    return new GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort {
    return new GrafanaAgentSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new GrafanaAgentSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap(obj: GrafanaAgentSpecLogsClientsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCaSecret
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCaSecret(obj: GrafanaAgentSpecLogsClientsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap(obj: GrafanaAgentSpecLogsClientsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecLogsClientsTlsConfigCertSecret
 */
export interface GrafanaAgentSpecLogsClientsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecLogsClientsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecLogsClientsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecLogsClientsTlsConfigCertSecret(obj: GrafanaAgentSpecLogsClientsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap
 */
export interface GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap(obj: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret
 */
export interface GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret(obj: GrafanaAgentSpecMetricsRemoteWriteOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret
 */
export interface GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret(obj: GrafanaAgentSpecMetricsRemoteWriteTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: GrafanaAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new GrafanaAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems(obj: GrafanaAgentSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems(obj: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesSecretItems
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesSecretItems(obj: GrafanaAgentSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GrafanaAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: GrafanaAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: GrafanaAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new GrafanaAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * Integration runs a single Grafana Agent integration. Integrations that generate telemetry must be configured to send that telemetry somewhere, such as autoscrape for exporter-based integrations. 
 Integrations have access to the LogsInstances and MetricsInstances in the same GrafanaAgent resource set, referenced by the <namespace>/<name> of the Instance resource. 
 For example, if there is a default/production MetricsInstance, you can configure a supported integration's autoscrape block with: 
 autoscrape: enable: true metrics_instance: default/production 
 There is currently no way for telemetry created by an Operator-managed integration to be collected from outside of the integration itself.
 *
 * @schema Integration
 */
export class Integration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Integration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.grafana.com/v1alpha1',
    kind: 'Integration',
  }

  /**
   * Renders a Kubernetes manifest for "Integration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationProps = {}): any {
    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(props),
    };
  }

  /**
   * Defines a "Integration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationProps = {}) {
    super(scope, id, {
      ...Integration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(resolved),
    };
  }
}

/**
 * Integration runs a single Grafana Agent integration. Integrations that generate telemetry must be configured to send that telemetry somewhere, such as autoscrape for exporter-based integrations.
 * Integrations have access to the LogsInstances and MetricsInstances in the same GrafanaAgent resource set, referenced by the <namespace>/<name> of the Instance resource.
 * For example, if there is a default/production MetricsInstance, you can configure a supported integration's autoscrape block with:
 * autoscrape: enable: true metrics_instance: default/production
 * There is currently no way for telemetry created by an Operator-managed integration to be collected from outside of the integration itself.
 *
 * @schema Integration
 */
export interface IntegrationProps {
  /**
   * @schema Integration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specifies the desired behavior of the Integration.
   *
   * @schema Integration#spec
   */
  readonly spec?: IntegrationSpec;

}

/**
 * Converts an object of type 'IntegrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationProps(obj: IntegrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the desired behavior of the Integration.
 *
 * @schema IntegrationSpec
 */
export interface IntegrationSpec {
  /**
   * The configuration for the named integration. Note that Integrations are deployed with the integrations-next feature flag, which has different common settings:
   * https://grafana.com/docs/agent/latest/configuration/integrations/integrations-next/
   *
   * @schema IntegrationSpec#config
   */
  readonly config: any;

  /**
   * An extra list of keys from ConfigMaps in the same namespace as the Integration which will be mounted into the Grafana Agent pod running this Integration.
   * ConfigMaps are mounted at /etc/grafana-agent/integrations/configMaps/<configmap_namespace>/<configmap_name>/<key>.
   *
   * @schema IntegrationSpec#configMaps
   */
  readonly configMaps?: IntegrationSpecConfigMaps[];

  /**
   * Name of the integration to run (e.g., "node_exporter", "mysqld_exporter").
   *
   * @schema IntegrationSpec#name
   */
  readonly name: string;

  /**
   * An extra list of keys from Secrets in the same namespace as the Integration which will be mounted into the Grafana Agent pod running this Integration.
   * Secrets will be mounted at /etc/grafana-agent/integrations/secrets/<secret_namespace>/<secret_name>/<key>.
   *
   * @schema IntegrationSpec#secrets
   */
  readonly secrets?: IntegrationSpecSecrets[];

  /**
   * Type informs Grafana Agent Operator about how to manage the integration being configured.
   *
   * @schema IntegrationSpec#type
   */
  readonly type: IntegrationSpecType;

  /**
   * An extra list of VolumeMounts to be associated with the Grafana Agent pods running this integration. VolumeMount names are mutated to be unique across all used IntegrationSpecs.
   * Mount paths should include the namespace/name of the Integration CR to avoid potentially colliding with other resources.
   *
   * @schema IntegrationSpec#volumeMounts
   */
  readonly volumeMounts?: IntegrationSpecVolumeMounts[];

  /**
   * An extra list of Volumes to be associated with the Grafana Agent pods running this integration. Volume names are mutated to be unique across all Integrations. Note that the specified volumes should be able to tolerate existing on multiple pods at once when type is daemonset.
   * Don't use volumes for loading Secrets or ConfigMaps from the same namespace as the Integration; use the Secrets and ConfigMaps fields instead.
   *
   * @schema IntegrationSpec#volumes
   */
  readonly volumes?: IntegrationSpecVolumes[];

}

/**
 * Converts an object of type 'IntegrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpec(obj: IntegrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config,
    'configMaps': obj.configMaps?.map(y => toJson_IntegrationSpecConfigMaps(y)),
    'name': obj.name,
    'secrets': obj.secrets?.map(y => toJson_IntegrationSpecSecrets(y)),
    'type': toJson_IntegrationSpecType(obj.type),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_IntegrationSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_IntegrationSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key from a ConfigMap.
 *
 * @schema IntegrationSpecConfigMaps
 */
export interface IntegrationSpecConfigMaps {
  /**
   * The key to select.
   *
   * @schema IntegrationSpecConfigMaps#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecConfigMaps#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema IntegrationSpecConfigMaps#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecConfigMaps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecConfigMaps(obj: IntegrationSpecConfigMaps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema IntegrationSpecSecrets
 */
export interface IntegrationSpecSecrets {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema IntegrationSpecSecrets#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecSecrets#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema IntegrationSpecSecrets#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecSecrets(obj: IntegrationSpecSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type informs Grafana Agent Operator about how to manage the integration being configured.
 *
 * @schema IntegrationSpecType
 */
export interface IntegrationSpecType {
  /**
   * When true, the configured integration should be run on every Node in the cluster. This is required for Integrations that generate Node-specific metrics like node_exporter, otherwise it must be false to avoid generating duplicate metrics.
   *
   * @schema IntegrationSpecType#allNodes
   */
  readonly allNodes?: boolean;

  /**
   * Whether this integration can only be defined once for a Grafana Agent process, such as statsd_exporter. It is invalid for a GrafanaAgent to discover multiple unique Integrations with the same Integration name (i.e., a single GrafanaAgent cannot deploy two statsd_exporters).
   *
   * @schema IntegrationSpecType#unique
   */
  readonly unique?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecType(obj: IntegrationSpecType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allNodes': obj.allNodes,
    'unique': obj.unique,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema IntegrationSpecVolumeMounts
 */
export interface IntegrationSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema IntegrationSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema IntegrationSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema IntegrationSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema IntegrationSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema IntegrationSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema IntegrationSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumeMounts(obj: IntegrationSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema IntegrationSpecVolumes
 */
export interface IntegrationSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema IntegrationSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: IntegrationSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema IntegrationSpecVolumes#azureDisk
   */
  readonly azureDisk?: IntegrationSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema IntegrationSpecVolumes#azureFile
   */
  readonly azureFile?: IntegrationSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema IntegrationSpecVolumes#cephfs
   */
  readonly cephfs?: IntegrationSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema IntegrationSpecVolumes#cinder
   */
  readonly cinder?: IntegrationSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema IntegrationSpecVolumes#configMap
   */
  readonly configMap?: IntegrationSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema IntegrationSpecVolumes#csi
   */
  readonly csi?: IntegrationSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema IntegrationSpecVolumes#downwardAPI
   */
  readonly downwardApi?: IntegrationSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema IntegrationSpecVolumes#emptyDir
   */
  readonly emptyDir?: IntegrationSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema IntegrationSpecVolumes#ephemeral
   */
  readonly ephemeral?: IntegrationSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema IntegrationSpecVolumes#fc
   */
  readonly fc?: IntegrationSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema IntegrationSpecVolumes#flexVolume
   */
  readonly flexVolume?: IntegrationSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema IntegrationSpecVolumes#flocker
   */
  readonly flocker?: IntegrationSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema IntegrationSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: IntegrationSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema IntegrationSpecVolumes#gitRepo
   */
  readonly gitRepo?: IntegrationSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema IntegrationSpecVolumes#glusterfs
   */
  readonly glusterfs?: IntegrationSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema IntegrationSpecVolumes#hostPath
   */
  readonly hostPath?: IntegrationSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema IntegrationSpecVolumes#iscsi
   */
  readonly iscsi?: IntegrationSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IntegrationSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema IntegrationSpecVolumes#nfs
   */
  readonly nfs?: IntegrationSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema IntegrationSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: IntegrationSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema IntegrationSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: IntegrationSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema IntegrationSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: IntegrationSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema IntegrationSpecVolumes#projected
   */
  readonly projected?: IntegrationSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema IntegrationSpecVolumes#quobyte
   */
  readonly quobyte?: IntegrationSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema IntegrationSpecVolumes#rbd
   */
  readonly rbd?: IntegrationSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema IntegrationSpecVolumes#scaleIO
   */
  readonly scaleIo?: IntegrationSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema IntegrationSpecVolumes#secret
   */
  readonly secret?: IntegrationSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema IntegrationSpecVolumes#storageos
   */
  readonly storageos?: IntegrationSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema IntegrationSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: IntegrationSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'IntegrationSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumes(obj: IntegrationSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_IntegrationSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_IntegrationSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_IntegrationSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_IntegrationSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_IntegrationSpecVolumesCinder(obj.cinder),
    'configMap': toJson_IntegrationSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_IntegrationSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_IntegrationSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_IntegrationSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_IntegrationSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_IntegrationSpecVolumesFc(obj.fc),
    'flexVolume': toJson_IntegrationSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_IntegrationSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_IntegrationSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_IntegrationSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_IntegrationSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_IntegrationSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_IntegrationSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_IntegrationSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_IntegrationSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_IntegrationSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_IntegrationSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_IntegrationSpecVolumesProjected(obj.projected),
    'quobyte': toJson_IntegrationSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_IntegrationSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_IntegrationSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_IntegrationSpecVolumesSecret(obj.secret),
    'storageos': toJson_IntegrationSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_IntegrationSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema IntegrationSpecVolumesAwsElasticBlockStore
 */
export interface IntegrationSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema IntegrationSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema IntegrationSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema IntegrationSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema IntegrationSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesAwsElasticBlockStore(obj: IntegrationSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema IntegrationSpecVolumesAzureDisk
 */
export interface IntegrationSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema IntegrationSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema IntegrationSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema IntegrationSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema IntegrationSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema IntegrationSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema IntegrationSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesAzureDisk(obj: IntegrationSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema IntegrationSpecVolumesAzureFile
 */
export interface IntegrationSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema IntegrationSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema IntegrationSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema IntegrationSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesAzureFile(obj: IntegrationSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema IntegrationSpecVolumesCephfs
 */
export interface IntegrationSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema IntegrationSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCephfs(obj: IntegrationSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_IntegrationSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema IntegrationSpecVolumesCinder
 */
export interface IntegrationSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema IntegrationSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema IntegrationSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema IntegrationSpecVolumesCinder#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema IntegrationSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCinder(obj: IntegrationSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema IntegrationSpecVolumesConfigMap
 */
export interface IntegrationSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema IntegrationSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema IntegrationSpecVolumesConfigMap#items
   */
  readonly items?: IntegrationSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema IntegrationSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesConfigMap(obj: IntegrationSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema IntegrationSpecVolumesCsi
 */
export interface IntegrationSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema IntegrationSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema IntegrationSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema IntegrationSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: IntegrationSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema IntegrationSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema IntegrationSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCsi(obj: IntegrationSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_IntegrationSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema IntegrationSpecVolumesDownwardApi
 */
export interface IntegrationSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema IntegrationSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema IntegrationSpecVolumesDownwardApi#items
   */
  readonly items?: IntegrationSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'IntegrationSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesDownwardApi(obj: IntegrationSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema IntegrationSpecVolumesEmptyDir
 */
export interface IntegrationSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema IntegrationSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema IntegrationSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: IntegrationSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEmptyDir(obj: IntegrationSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema IntegrationSpecVolumesEphemeral
 */
export interface IntegrationSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema IntegrationSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: IntegrationSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeral(obj: IntegrationSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema IntegrationSpecVolumesFc
 */
export interface IntegrationSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema IntegrationSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema IntegrationSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema IntegrationSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema IntegrationSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema IntegrationSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'IntegrationSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesFc(obj: IntegrationSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema IntegrationSpecVolumesFlexVolume
 */
export interface IntegrationSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema IntegrationSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema IntegrationSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema IntegrationSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema IntegrationSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema IntegrationSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesFlexVolume(obj: IntegrationSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema IntegrationSpecVolumesFlocker
 */
export interface IntegrationSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema IntegrationSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema IntegrationSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesFlocker(obj: IntegrationSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema IntegrationSpecVolumesGcePersistentDisk
 */
export interface IntegrationSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema IntegrationSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema IntegrationSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema IntegrationSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema IntegrationSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesGcePersistentDisk(obj: IntegrationSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema IntegrationSpecVolumesGitRepo
 */
export interface IntegrationSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema IntegrationSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema IntegrationSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema IntegrationSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesGitRepo(obj: IntegrationSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema IntegrationSpecVolumesGlusterfs
 */
export interface IntegrationSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema IntegrationSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema IntegrationSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema IntegrationSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesGlusterfs(obj: IntegrationSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema IntegrationSpecVolumesHostPath
 */
export interface IntegrationSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema IntegrationSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema IntegrationSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesHostPath(obj: IntegrationSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema IntegrationSpecVolumesIscsi
 */
export interface IntegrationSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema IntegrationSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema IntegrationSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema IntegrationSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema IntegrationSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema IntegrationSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema IntegrationSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema IntegrationSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema IntegrationSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema IntegrationSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema IntegrationSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema IntegrationSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesIscsi(obj: IntegrationSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema IntegrationSpecVolumesNfs
 */
export interface IntegrationSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema IntegrationSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema IntegrationSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema IntegrationSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesNfs(obj: IntegrationSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema IntegrationSpecVolumesPersistentVolumeClaim
 */
export interface IntegrationSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema IntegrationSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema IntegrationSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesPersistentVolumeClaim(obj: IntegrationSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema IntegrationSpecVolumesPhotonPersistentDisk
 */
export interface IntegrationSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema IntegrationSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema IntegrationSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesPhotonPersistentDisk(obj: IntegrationSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema IntegrationSpecVolumesPortworxVolume
 */
export interface IntegrationSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema IntegrationSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema IntegrationSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema IntegrationSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesPortworxVolume(obj: IntegrationSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema IntegrationSpecVolumesProjected
 */
export interface IntegrationSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema IntegrationSpecVolumesProjected#sources
   */
  readonly sources?: IntegrationSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjected(obj: IntegrationSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_IntegrationSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema IntegrationSpecVolumesQuobyte
 */
export interface IntegrationSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema IntegrationSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema IntegrationSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema IntegrationSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema IntegrationSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema IntegrationSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema IntegrationSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesQuobyte(obj: IntegrationSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema IntegrationSpecVolumesRbd
 */
export interface IntegrationSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema IntegrationSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema IntegrationSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesRbd#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema IntegrationSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesRbd(obj: IntegrationSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema IntegrationSpecVolumesScaleIo
 */
export interface IntegrationSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema IntegrationSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema IntegrationSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema IntegrationSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema IntegrationSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema IntegrationSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: IntegrationSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema IntegrationSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema IntegrationSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema IntegrationSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema IntegrationSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema IntegrationSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesScaleIo(obj: IntegrationSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema IntegrationSpecVolumesSecret
 */
export interface IntegrationSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema IntegrationSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema IntegrationSpecVolumesSecret#items
   */
  readonly items?: IntegrationSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema IntegrationSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema IntegrationSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesSecret(obj: IntegrationSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema IntegrationSpecVolumesStorageos
 */
export interface IntegrationSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema IntegrationSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema IntegrationSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema IntegrationSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: IntegrationSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema IntegrationSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema IntegrationSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesStorageos(obj: IntegrationSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_IntegrationSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema IntegrationSpecVolumesVsphereVolume
 */
export interface IntegrationSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema IntegrationSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema IntegrationSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema IntegrationSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema IntegrationSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesVsphereVolume(obj: IntegrationSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema IntegrationSpecVolumesCephfsSecretRef
 */
export interface IntegrationSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCephfsSecretRef(obj: IntegrationSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema IntegrationSpecVolumesCinderSecretRef
 */
export interface IntegrationSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCinderSecretRef(obj: IntegrationSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema IntegrationSpecVolumesConfigMapItems
 */
export interface IntegrationSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema IntegrationSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema IntegrationSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesConfigMapItems(obj: IntegrationSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema IntegrationSpecVolumesCsiNodePublishSecretRef
 */
export interface IntegrationSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesCsiNodePublishSecretRef(obj: IntegrationSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema IntegrationSpecVolumesDownwardApiItems
 */
export interface IntegrationSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema IntegrationSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: IntegrationSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema IntegrationSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema IntegrationSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: IntegrationSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesDownwardApiItems(obj: IntegrationSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_IntegrationSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_IntegrationSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema IntegrationSpecVolumesEmptyDirSizeLimit
 */
export class IntegrationSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): IntegrationSpecVolumesEmptyDirSizeLimit {
    return new IntegrationSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): IntegrationSpecVolumesEmptyDirSizeLimit {
    return new IntegrationSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplate(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema IntegrationSpecVolumesFlexVolumeSecretRef
 */
export interface IntegrationSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesFlexVolumeSecretRef(obj: IntegrationSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema IntegrationSpecVolumesIscsiSecretRef
 */
export interface IntegrationSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesIscsiSecretRef(obj: IntegrationSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema IntegrationSpecVolumesProjectedSources
 */
export interface IntegrationSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema IntegrationSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: IntegrationSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema IntegrationSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: IntegrationSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema IntegrationSpecVolumesProjectedSources#secret
   */
  readonly secret?: IntegrationSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema IntegrationSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: IntegrationSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSources(obj: IntegrationSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_IntegrationSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_IntegrationSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_IntegrationSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_IntegrationSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema IntegrationSpecVolumesRbdSecretRef
 */
export interface IntegrationSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesRbdSecretRef(obj: IntegrationSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema IntegrationSpecVolumesScaleIoSecretRef
 */
export interface IntegrationSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesScaleIoSecretRef(obj: IntegrationSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema IntegrationSpecVolumesSecretItems
 */
export interface IntegrationSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema IntegrationSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema IntegrationSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesSecretItems(obj: IntegrationSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema IntegrationSpecVolumesStorageosSecretRef
 */
export interface IntegrationSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesStorageosSecretRef(obj: IntegrationSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema IntegrationSpecVolumesDownwardApiItemsFieldRef
 */
export interface IntegrationSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema IntegrationSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema IntegrationSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesDownwardApiItemsFieldRef(obj: IntegrationSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema IntegrationSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface IntegrationSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema IntegrationSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema IntegrationSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema IntegrationSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesDownwardApiItemsResourceFieldRef(obj: IntegrationSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema IntegrationSpecVolumesProjectedSourcesConfigMap
 */
export interface IntegrationSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: IntegrationSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesConfigMap(obj: IntegrationSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema IntegrationSpecVolumesProjectedSourcesDownwardApi
 */
export interface IntegrationSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: IntegrationSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesDownwardApi(obj: IntegrationSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema IntegrationSpecVolumesProjectedSourcesSecret
 */
export interface IntegrationSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: IntegrationSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesSecret(obj: IntegrationSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_IntegrationSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema IntegrationSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface IntegrationSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema IntegrationSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesServiceAccountToken(obj: IntegrationSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new IntegrationSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema IntegrationSpecVolumesProjectedSourcesConfigMapItems
 */
export interface IntegrationSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesConfigMapItems(obj: IntegrationSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface IntegrationSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItems(obj: IntegrationSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema IntegrationSpecVolumesProjectedSourcesSecretItems
 */
export interface IntegrationSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesSecretItems(obj: IntegrationSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: IntegrationSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: IntegrationSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new IntegrationSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * LogsInstance controls an individual logs instance within a Grafana Agent deployment.
 *
 * @schema LogsInstance
 */
export class LogsInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LogsInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.grafana.com/v1alpha1',
    kind: 'LogsInstance',
  }

  /**
   * Renders a Kubernetes manifest for "LogsInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LogsInstanceProps = {}): any {
    return {
      ...LogsInstance.GVK,
      ...toJson_LogsInstanceProps(props),
    };
  }

  /**
   * Defines a "LogsInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LogsInstanceProps = {}) {
    super(scope, id, {
      ...LogsInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LogsInstance.GVK,
      ...toJson_LogsInstanceProps(resolved),
    };
  }
}

/**
 * LogsInstance controls an individual logs instance within a Grafana Agent deployment.
 *
 * @schema LogsInstance
 */
export interface LogsInstanceProps {
  /**
   * @schema LogsInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec holds the specification of the desired behavior for the logs instance.
   *
   * @schema LogsInstance#spec
   */
  readonly spec?: LogsInstanceSpec;

}

/**
 * Converts an object of type 'LogsInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceProps(obj: LogsInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LogsInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec holds the specification of the desired behavior for the logs instance.
 *
 * @schema LogsInstanceSpec
 */
export interface LogsInstanceSpec {
  /**
   * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Grafana Agent logging scrape configurations. Scrape configurations specified are appended to the configurations generated by the Grafana Agent Operator.
   * Job configurations specified must have the form as specified in the official Promtail documentation:
   * https://grafana.com/docs/loki/latest/clients/promtail/configuration/#scrape_configs
   * As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Grafana Agent. It is advised to review both Grafana Agent and Promtail release notes to ensure that no incompatible scrape configs are going to break Grafana Agent after the upgrade.
   *
   * @schema LogsInstanceSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: LogsInstanceSpecAdditionalScrapeConfigs;

  /**
   * Clients controls where logs are written to for this instance.
   *
   * @schema LogsInstanceSpec#clients
   */
  readonly clients?: LogsInstanceSpecClients[];

  /**
   * Set of labels to determine which namespaces should be watched for PodLogs. If not provided, checks only namespace of the instance.
   *
   * @schema LogsInstanceSpec#podLogsNamespaceSelector
   */
  readonly podLogsNamespaceSelector?: LogsInstanceSpecPodLogsNamespaceSelector;

  /**
   * Determines which PodLogs should be selected for including in this instance.
   *
   * @schema LogsInstanceSpec#podLogsSelector
   */
  readonly podLogsSelector?: LogsInstanceSpecPodLogsSelector;

  /**
   * Configures how tailed targets are watched.
   *
   * @schema LogsInstanceSpec#targetConfig
   */
  readonly targetConfig?: LogsInstanceSpecTargetConfig;

}

/**
 * Converts an object of type 'LogsInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpec(obj: LogsInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalScrapeConfigs': toJson_LogsInstanceSpecAdditionalScrapeConfigs(obj.additionalScrapeConfigs),
    'clients': obj.clients?.map(y => toJson_LogsInstanceSpecClients(y)),
    'podLogsNamespaceSelector': toJson_LogsInstanceSpecPodLogsNamespaceSelector(obj.podLogsNamespaceSelector),
    'podLogsSelector': toJson_LogsInstanceSpecPodLogsSelector(obj.podLogsSelector),
    'targetConfig': toJson_LogsInstanceSpecTargetConfig(obj.targetConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Grafana Agent logging scrape configurations. Scrape configurations specified are appended to the configurations generated by the Grafana Agent Operator.
 * Job configurations specified must have the form as specified in the official Promtail documentation:
 * https://grafana.com/docs/loki/latest/clients/promtail/configuration/#scrape_configs
 * As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Grafana Agent. It is advised to review both Grafana Agent and Promtail release notes to ensure that no incompatible scrape configs are going to break Grafana Agent after the upgrade.
 *
 * @schema LogsInstanceSpecAdditionalScrapeConfigs
 */
export interface LogsInstanceSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecAdditionalScrapeConfigs(obj: LogsInstanceSpecAdditionalScrapeConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogsClientSpec defines the client integration for logs, indicating which Loki server to send logs to.
 *
 * @schema LogsInstanceSpecClients
 */
export interface LogsInstanceSpecClients {
  /**
   * Configures how to retry requests to Loki when a request fails. Defaults to a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
   *
   * @default a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
   * @schema LogsInstanceSpecClients#backoffConfig
   */
  readonly backoffConfig?: LogsInstanceSpecClientsBackoffConfig;

  /**
   * BasicAuth for the Loki server.
   *
   * @schema LogsInstanceSpecClients#basicAuth
   */
  readonly basicAuth?: LogsInstanceSpecClientsBasicAuth;

  /**
   * Maximum batch size (in bytes) of logs to accumulate before sending the batch to Loki.
   *
   * @schema LogsInstanceSpecClients#batchSize
   */
  readonly batchSize?: number;

  /**
   * Maximum amount of time to wait before sending a batch, even if that batch isn't full.
   *
   * @schema LogsInstanceSpecClients#batchWait
   */
  readonly batchWait?: string;

  /**
   * BearerToken used for remote_write.
   *
   * @schema LogsInstanceSpecClients#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * BearerTokenFile used to read bearer token.
   *
   * @schema LogsInstanceSpecClients#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * ExternalLabels are labels to add to any time series when sending data to Loki.
   *
   * @schema LogsInstanceSpecClients#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * ProxyURL to proxy requests through. Optional.
   *
   * @schema LogsInstanceSpecClients#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Tenant ID used by default to push logs to Loki. If omitted assumes remote Loki is running in single-tenant mode or an authentication layer is used to inject an X-Scope-OrgID header.
   *
   * @schema LogsInstanceSpecClients#tenantId
   */
  readonly tenantId?: string;

  /**
   * Maximum time to wait for a server to respond to a request.
   *
   * @schema LogsInstanceSpecClients#timeout
   */
  readonly timeout?: string;

  /**
   * TLSConfig to use for the client. Only used when the protocol of the URL is https.
   *
   * @schema LogsInstanceSpecClients#tlsConfig
   */
  readonly tlsConfig?: LogsInstanceSpecClientsTlsConfig;

  /**
   * URL is the URL where Loki is listening. Must be a full HTTP URL, including protocol. Required. Example: https://logs-prod-us-central1.grafana.net/loki/api/v1/push.
   *
   * @schema LogsInstanceSpecClients#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'LogsInstanceSpecClients' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClients(obj: LogsInstanceSpecClients | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backoffConfig': toJson_LogsInstanceSpecClientsBackoffConfig(obj.backoffConfig),
    'basicAuth': toJson_LogsInstanceSpecClientsBasicAuth(obj.basicAuth),
    'batchSize': obj.batchSize,
    'batchWait': obj.batchWait,
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyUrl': obj.proxyUrl,
    'tenantId': obj.tenantId,
    'timeout': obj.timeout,
    'tlsConfig': toJson_LogsInstanceSpecClientsTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of labels to determine which namespaces should be watched for PodLogs. If not provided, checks only namespace of the instance.
 *
 * @schema LogsInstanceSpecPodLogsNamespaceSelector
 */
export interface LogsInstanceSpecPodLogsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema LogsInstanceSpecPodLogsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema LogsInstanceSpecPodLogsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'LogsInstanceSpecPodLogsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecPodLogsNamespaceSelector(obj: LogsInstanceSpecPodLogsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines which PodLogs should be selected for including in this instance.
 *
 * @schema LogsInstanceSpecPodLogsSelector
 */
export interface LogsInstanceSpecPodLogsSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema LogsInstanceSpecPodLogsSelector#matchExpressions
   */
  readonly matchExpressions?: LogsInstanceSpecPodLogsSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema LogsInstanceSpecPodLogsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'LogsInstanceSpecPodLogsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecPodLogsSelector(obj: LogsInstanceSpecPodLogsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_LogsInstanceSpecPodLogsSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how tailed targets are watched.
 *
 * @schema LogsInstanceSpecTargetConfig
 */
export interface LogsInstanceSpecTargetConfig {
  /**
   * Period to resync directories being watched and files being tailed to discover new ones or stop watching removed ones.
   *
   * @schema LogsInstanceSpecTargetConfig#syncPeriod
   */
  readonly syncPeriod?: string;

}

/**
 * Converts an object of type 'LogsInstanceSpecTargetConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecTargetConfig(obj: LogsInstanceSpecTargetConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'syncPeriod': obj.syncPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how to retry requests to Loki when a request fails. Defaults to a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
 *
 * @default a minPeriod of 500ms, maxPeriod of 5m, and maxRetries of 10.
 * @schema LogsInstanceSpecClientsBackoffConfig
 */
export interface LogsInstanceSpecClientsBackoffConfig {
  /**
   * Maximum backoff time between retries.
   *
   * @schema LogsInstanceSpecClientsBackoffConfig#maxPeriod
   */
  readonly maxPeriod?: string;

  /**
   * Maximum number of retries to perform before giving up a request.
   *
   * @schema LogsInstanceSpecClientsBackoffConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Initial backoff time between retries. Time between retries is increased exponentially.
   *
   * @schema LogsInstanceSpecClientsBackoffConfig#minPeriod
   */
  readonly minPeriod?: string;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsBackoffConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsBackoffConfig(obj: LogsInstanceSpecClientsBackoffConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPeriod': obj.maxPeriod,
    'maxRetries': obj.maxRetries,
    'minPeriod': obj.minPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the Loki server.
 *
 * @schema LogsInstanceSpecClientsBasicAuth
 */
export interface LogsInstanceSpecClientsBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema LogsInstanceSpecClientsBasicAuth#password
   */
  readonly password?: LogsInstanceSpecClientsBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema LogsInstanceSpecClientsBasicAuth#username
   */
  readonly username?: LogsInstanceSpecClientsBasicAuthUsername;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsBasicAuth(obj: LogsInstanceSpecClientsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_LogsInstanceSpecClientsBasicAuthPassword(obj.password),
    'username': toJson_LogsInstanceSpecClientsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSConfig to use for the client. Only used when the protocol of the URL is https.
 *
 * @schema LogsInstanceSpecClientsTlsConfig
 */
export interface LogsInstanceSpecClientsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#ca
   */
  readonly ca?: LogsInstanceSpecClientsTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#cert
   */
  readonly cert?: LogsInstanceSpecClientsTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#keySecret
   */
  readonly keySecret?: LogsInstanceSpecClientsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfig(obj: LogsInstanceSpecClientsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_LogsInstanceSpecClientsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_LogsInstanceSpecClientsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_LogsInstanceSpecClientsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions
 */
export interface LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions(obj: LogsInstanceSpecPodLogsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema LogsInstanceSpecPodLogsSelectorMatchExpressions
 */
export interface LogsInstanceSpecPodLogsSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema LogsInstanceSpecPodLogsSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema LogsInstanceSpecPodLogsSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema LogsInstanceSpecPodLogsSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LogsInstanceSpecPodLogsSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecPodLogsSelectorMatchExpressions(obj: LogsInstanceSpecPodLogsSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema LogsInstanceSpecClientsBasicAuthPassword
 */
export interface LogsInstanceSpecClientsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecClientsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecClientsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsBasicAuthPassword(obj: LogsInstanceSpecClientsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema LogsInstanceSpecClientsBasicAuthUsername
 */
export interface LogsInstanceSpecClientsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecClientsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecClientsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsBasicAuthUsername(obj: LogsInstanceSpecClientsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCa
 */
export interface LogsInstanceSpecClientsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCa#configMap
   */
  readonly configMap?: LogsInstanceSpecClientsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCa#secret
   */
  readonly secret?: LogsInstanceSpecClientsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCa(obj: LogsInstanceSpecClientsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_LogsInstanceSpecClientsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_LogsInstanceSpecClientsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCert
 */
export interface LogsInstanceSpecClientsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCert#configMap
   */
  readonly configMap?: LogsInstanceSpecClientsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCert#secret
   */
  readonly secret?: LogsInstanceSpecClientsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCert(obj: LogsInstanceSpecClientsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_LogsInstanceSpecClientsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_LogsInstanceSpecClientsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema LogsInstanceSpecClientsTlsConfigKeySecret
 */
export interface LogsInstanceSpecClientsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecClientsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecClientsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigKeySecret(obj: LogsInstanceSpecClientsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCaConfigMap
 */
export interface LogsInstanceSpecClientsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCaConfigMap(obj: LogsInstanceSpecClientsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCaSecret
 */
export interface LogsInstanceSpecClientsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecClientsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCaSecret(obj: LogsInstanceSpecClientsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCertConfigMap
 */
export interface LogsInstanceSpecClientsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCertConfigMap(obj: LogsInstanceSpecClientsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema LogsInstanceSpecClientsTlsConfigCertSecret
 */
export interface LogsInstanceSpecClientsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema LogsInstanceSpecClientsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LogsInstanceSpecClientsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogsInstanceSpecClientsTlsConfigCertSecret(obj: LogsInstanceSpecClientsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * MetricsInstance controls an individual Metrics instance within a Grafana Agent deployment.
 *
 * @schema MetricsInstance
 */
export class MetricsInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MetricsInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.grafana.com/v1alpha1',
    kind: 'MetricsInstance',
  }

  /**
   * Renders a Kubernetes manifest for "MetricsInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricsInstanceProps = {}): any {
    return {
      ...MetricsInstance.GVK,
      ...toJson_MetricsInstanceProps(props),
    };
  }

  /**
   * Defines a "MetricsInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricsInstanceProps = {}) {
    super(scope, id, {
      ...MetricsInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MetricsInstance.GVK,
      ...toJson_MetricsInstanceProps(resolved),
    };
  }
}

/**
 * MetricsInstance controls an individual Metrics instance within a Grafana Agent deployment.
 *
 * @schema MetricsInstance
 */
export interface MetricsInstanceProps {
  /**
   * @schema MetricsInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec holds the specification of the desired behavior for the Metrics instance.
   *
   * @schema MetricsInstance#spec
   */
  readonly spec?: MetricsInstanceSpec;

}

/**
 * Converts an object of type 'MetricsInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceProps(obj: MetricsInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricsInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec holds the specification of the desired behavior for the Metrics instance.
 *
 * @schema MetricsInstanceSpec
 */
export interface MetricsInstanceSpec {
  /**
   * AdditionalScrapeConfigs lets you specify a key of a Secret containing additional Grafana Agent Prometheus scrape configurations. The specified scrape configurations are appended to the configurations generated by Grafana Agent Operator. Specified job configurations must have the form specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, you must make sure the configuration is still valid. Note that it's possible that this feature will break future upgrades of Grafana Agent. Review both Grafana Agent and Prometheus release notes to ensure that no incompatible scrape configs will break Grafana Agent after the upgrade.
   *
   * @schema MetricsInstanceSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: MetricsInstanceSpecAdditionalScrapeConfigs;

  /**
   * MaxWALTime is the maximum amount of time that series and samples can exist in the WAL before being forcibly deleted.
   *
   * @schema MetricsInstanceSpec#maxWALTime
   */
  readonly maxWalTime?: string;

  /**
   * MinWALTime is the minimum amount of time that series and samples can exist in the WAL before being considered for deletion.
   *
   * @schema MetricsInstanceSpec#minWALTime
   */
  readonly minWalTime?: string;

  /**
   * PodMonitorNamespaceSelector are the set of labels to determine which namespaces to watch for PodMonitor discovery. If nil, it only checks its own namespace.
   *
   * @schema MetricsInstanceSpec#podMonitorNamespaceSelector
   */
  readonly podMonitorNamespaceSelector?: MetricsInstanceSpecPodMonitorNamespaceSelector;

  /**
   * PodMonitorSelector determines which PodMonitors to selected for target discovery. Experimental.
   *
   * @schema MetricsInstanceSpec#podMonitorSelector
   */
  readonly podMonitorSelector?: MetricsInstanceSpecPodMonitorSelector;

  /**
   * ProbeNamespaceSelector is the set of labels that determines which namespaces to watch for Probe discovery. If nil, it only checks own namespace.
   *
   * @schema MetricsInstanceSpec#probeNamespaceSelector
   */
  readonly probeNamespaceSelector?: MetricsInstanceSpecProbeNamespaceSelector;

  /**
   * ProbeSelector determines which Probes to select for target discovery.
   *
   * @schema MetricsInstanceSpec#probeSelector
   */
  readonly probeSelector?: MetricsInstanceSpecProbeSelector;

  /**
   * RemoteFlushDeadline is the deadline for flushing data when an instance shuts down.
   *
   * @schema MetricsInstanceSpec#remoteFlushDeadline
   */
  readonly remoteFlushDeadline?: string;

  /**
   * RemoteWrite controls remote_write settings for this instance.
   *
   * @schema MetricsInstanceSpec#remoteWrite
   */
  readonly remoteWrite?: MetricsInstanceSpecRemoteWrite[];

  /**
   * ServiceMonitorNamespaceSelector is the set of labels that determine which namespaces to watch for ServiceMonitor discovery. If nil, it only checks its own namespace.
   *
   * @schema MetricsInstanceSpec#serviceMonitorNamespaceSelector
   */
  readonly serviceMonitorNamespaceSelector?: MetricsInstanceSpecServiceMonitorNamespaceSelector;

  /**
   * ServiceMonitorSelector determines which ServiceMonitors to select for target discovery.
   *
   * @schema MetricsInstanceSpec#serviceMonitorSelector
   */
  readonly serviceMonitorSelector?: MetricsInstanceSpecServiceMonitorSelector;

  /**
   * WALTruncateFrequency specifies how frequently to run the WAL truncation process. Higher values cause the WAL to increase and for old series to stay in the WAL longer, but reduces the chance of data loss when remote_write fails for longer than the given frequency.
   *
   * @schema MetricsInstanceSpec#walTruncateFrequency
   */
  readonly walTruncateFrequency?: string;

  /**
   * WriteStaleOnShutdown writes staleness markers on shutdown for all series.
   *
   * @schema MetricsInstanceSpec#writeStaleOnShutdown
   */
  readonly writeStaleOnShutdown?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpec(obj: MetricsInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalScrapeConfigs': toJson_MetricsInstanceSpecAdditionalScrapeConfigs(obj.additionalScrapeConfigs),
    'maxWALTime': obj.maxWalTime,
    'minWALTime': obj.minWalTime,
    'podMonitorNamespaceSelector': toJson_MetricsInstanceSpecPodMonitorNamespaceSelector(obj.podMonitorNamespaceSelector),
    'podMonitorSelector': toJson_MetricsInstanceSpecPodMonitorSelector(obj.podMonitorSelector),
    'probeNamespaceSelector': toJson_MetricsInstanceSpecProbeNamespaceSelector(obj.probeNamespaceSelector),
    'probeSelector': toJson_MetricsInstanceSpecProbeSelector(obj.probeSelector),
    'remoteFlushDeadline': obj.remoteFlushDeadline,
    'remoteWrite': obj.remoteWrite?.map(y => toJson_MetricsInstanceSpecRemoteWrite(y)),
    'serviceMonitorNamespaceSelector': toJson_MetricsInstanceSpecServiceMonitorNamespaceSelector(obj.serviceMonitorNamespaceSelector),
    'serviceMonitorSelector': toJson_MetricsInstanceSpecServiceMonitorSelector(obj.serviceMonitorSelector),
    'walTruncateFrequency': obj.walTruncateFrequency,
    'writeStaleOnShutdown': obj.writeStaleOnShutdown,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalScrapeConfigs lets you specify a key of a Secret containing additional Grafana Agent Prometheus scrape configurations. The specified scrape configurations are appended to the configurations generated by Grafana Agent Operator. Specified job configurations must have the form specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, you must make sure the configuration is still valid. Note that it's possible that this feature will break future upgrades of Grafana Agent. Review both Grafana Agent and Prometheus release notes to ensure that no incompatible scrape configs will break Grafana Agent after the upgrade.
 *
 * @schema MetricsInstanceSpecAdditionalScrapeConfigs
 */
export interface MetricsInstanceSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecAdditionalScrapeConfigs(obj: MetricsInstanceSpecAdditionalScrapeConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMonitorNamespaceSelector are the set of labels to determine which namespaces to watch for PodMonitor discovery. If nil, it only checks its own namespace.
 *
 * @schema MetricsInstanceSpecPodMonitorNamespaceSelector
 */
export interface MetricsInstanceSpecPodMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecPodMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecPodMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecPodMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecPodMonitorNamespaceSelector(obj: MetricsInstanceSpecPodMonitorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMonitorSelector determines which PodMonitors to selected for target discovery. Experimental.
 *
 * @schema MetricsInstanceSpecPodMonitorSelector
 */
export interface MetricsInstanceSpecPodMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecPodMonitorSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecPodMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecPodMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecPodMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecPodMonitorSelector(obj: MetricsInstanceSpecPodMonitorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecPodMonitorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProbeNamespaceSelector is the set of labels that determines which namespaces to watch for Probe discovery. If nil, it only checks own namespace.
 *
 * @schema MetricsInstanceSpecProbeNamespaceSelector
 */
export interface MetricsInstanceSpecProbeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecProbeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecProbeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecProbeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecProbeNamespaceSelector(obj: MetricsInstanceSpecProbeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProbeSelector determines which Probes to select for target discovery.
 *
 * @schema MetricsInstanceSpecProbeSelector
 */
export interface MetricsInstanceSpecProbeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecProbeSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecProbeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecProbeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecProbeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecProbeSelector(obj: MetricsInstanceSpecProbeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecProbeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteWriteSpec defines the remote_write configuration for Prometheus.
 *
 * @schema MetricsInstanceSpecRemoteWrite
 */
export interface MetricsInstanceSpecRemoteWrite {
  /**
   * BasicAuth for the URL.
   *
   * @schema MetricsInstanceSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: MetricsInstanceSpecRemoteWriteBasicAuth;

  /**
   * BearerToken used for remote_write.
   *
   * @schema MetricsInstanceSpecRemoteWrite#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * BearerTokenFile used to read bearer token.
   *
   * @schema MetricsInstanceSpecRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Headers is a set of custom HTTP headers to be sent along with each remote_write request. Be aware that any headers set by Grafana Agent itself can't be overwritten.
   *
   * @schema MetricsInstanceSpecRemoteWrite#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MetadataConfig configures the sending of series metadata to remote storage.
   *
   * @schema MetricsInstanceSpecRemoteWrite#metadataConfig
   */
  readonly metadataConfig?: MetricsInstanceSpecRemoteWriteMetadataConfig;

  /**
   * Name of the remote_write queue. Must be unique if specified. The name is used in metrics and logging in order to differentiate queues.
   *
   * @schema MetricsInstanceSpecRemoteWrite#name
   */
  readonly name?: string;

  /**
   * Oauth2 for URL
   *
   * @schema MetricsInstanceSpecRemoteWrite#oauth2
   */
  readonly oauth2?: MetricsInstanceSpecRemoteWriteOauth2;

  /**
   * ProxyURL to proxy requests through. Optional.
   *
   * @schema MetricsInstanceSpecRemoteWrite#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * QueueConfig allows tuning of the remote_write queue parameters.
   *
   * @schema MetricsInstanceSpecRemoteWrite#queueConfig
   */
  readonly queueConfig?: MetricsInstanceSpecRemoteWriteQueueConfig;

  /**
   * RemoteTimeout is the timeout for requests to the remote_write endpoint.
   *
   * @schema MetricsInstanceSpecRemoteWrite#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * SigV4 configures SigV4-based authentication to the remote_write endpoint. SigV4-based authentication is used if SigV4 is defined, even with an empty object.
   *
   * @schema MetricsInstanceSpecRemoteWrite#sigv4
   */
  readonly sigv4?: MetricsInstanceSpecRemoteWriteSigv4;

  /**
   * TLSConfig to use for remote_write.
   *
   * @schema MetricsInstanceSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: MetricsInstanceSpecRemoteWriteTlsConfig;

  /**
   * URL of the endpoint to send samples to.
   *
   * @schema MetricsInstanceSpecRemoteWrite#url
   */
  readonly url: string;

  /**
   * WriteRelabelConfigs holds relabel_configs to relabel samples before they are sent to the remote_write endpoint.
   *
   * @schema MetricsInstanceSpecRemoteWrite#writeRelabelConfigs
   */
  readonly writeRelabelConfigs?: MetricsInstanceSpecRemoteWriteWriteRelabelConfigs[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWrite(obj: MetricsInstanceSpecRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuth': toJson_MetricsInstanceSpecRemoteWriteBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataConfig': toJson_MetricsInstanceSpecRemoteWriteMetadataConfig(obj.metadataConfig),
    'name': obj.name,
    'oauth2': toJson_MetricsInstanceSpecRemoteWriteOauth2(obj.oauth2),
    'proxyUrl': obj.proxyUrl,
    'queueConfig': toJson_MetricsInstanceSpecRemoteWriteQueueConfig(obj.queueConfig),
    'remoteTimeout': obj.remoteTimeout,
    'sigv4': toJson_MetricsInstanceSpecRemoteWriteSigv4(obj.sigv4),
    'tlsConfig': toJson_MetricsInstanceSpecRemoteWriteTlsConfig(obj.tlsConfig),
    'url': obj.url,
    'writeRelabelConfigs': obj.writeRelabelConfigs?.map(y => toJson_MetricsInstanceSpecRemoteWriteWriteRelabelConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitorNamespaceSelector is the set of labels that determine which namespaces to watch for ServiceMonitor discovery. If nil, it only checks its own namespace.
 *
 * @schema MetricsInstanceSpecServiceMonitorNamespaceSelector
 */
export interface MetricsInstanceSpecServiceMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecServiceMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecServiceMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecServiceMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecServiceMonitorNamespaceSelector(obj: MetricsInstanceSpecServiceMonitorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitorSelector determines which ServiceMonitors to select for target discovery.
 *
 * @schema MetricsInstanceSpecServiceMonitorSelector
 */
export interface MetricsInstanceSpecServiceMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecServiceMonitorSelector#matchExpressions
   */
  readonly matchExpressions?: MetricsInstanceSpecServiceMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema MetricsInstanceSpecServiceMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricsInstanceSpecServiceMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecServiceMonitorSelector(obj: MetricsInstanceSpecServiceMonitorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_MetricsInstanceSpecServiceMonitorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions
 */
export interface MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions(obj: MetricsInstanceSpecPodMonitorNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecPodMonitorSelectorMatchExpressions
 */
export interface MetricsInstanceSpecPodMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecPodMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecPodMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecPodMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecPodMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecPodMonitorSelectorMatchExpressions(obj: MetricsInstanceSpecPodMonitorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions
 */
export interface MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions(obj: MetricsInstanceSpecProbeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecProbeSelectorMatchExpressions
 */
export interface MetricsInstanceSpecProbeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecProbeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecProbeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecProbeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecProbeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecProbeSelectorMatchExpressions(obj: MetricsInstanceSpecProbeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the URL.
 *
 * @schema MetricsInstanceSpecRemoteWriteBasicAuth
 */
export interface MetricsInstanceSpecRemoteWriteBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuth#password
   */
  readonly password?: MetricsInstanceSpecRemoteWriteBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuth#username
   */
  readonly username?: MetricsInstanceSpecRemoteWriteBasicAuthUsername;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteBasicAuth(obj: MetricsInstanceSpecRemoteWriteBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_MetricsInstanceSpecRemoteWriteBasicAuthPassword(obj.password),
    'username': toJson_MetricsInstanceSpecRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataConfig configures the sending of series metadata to remote storage.
 *
 * @schema MetricsInstanceSpecRemoteWriteMetadataConfig
 */
export interface MetricsInstanceSpecRemoteWriteMetadataConfig {
  /**
   * Send enables metric metadata to be sent to remote storage.
   *
   * @schema MetricsInstanceSpecRemoteWriteMetadataConfig#send
   */
  readonly send?: boolean;

  /**
   * SendInterval controls how frequently metric metadata is sent to remote storage.
   *
   * @schema MetricsInstanceSpecRemoteWriteMetadataConfig#sendInterval
   */
  readonly sendInterval?: string;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteMetadataConfig(obj: MetricsInstanceSpecRemoteWriteMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'send': obj.send,
    'sendInterval': obj.sendInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Oauth2 for URL
 *
 * @schema MetricsInstanceSpecRemoteWriteOauth2
 */
export interface MetricsInstanceSpecRemoteWriteOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2#clientId
   */
  readonly clientId: MetricsInstanceSpecRemoteWriteOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret: MetricsInstanceSpecRemoteWriteOauth2ClientSecret;

  /**
   * Parameters to append to the token URL
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * The URL to fetch the token from
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteOauth2(obj: MetricsInstanceSpecRemoteWriteOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_MetricsInstanceSpecRemoteWriteOauth2ClientId(obj.clientId),
    'clientSecret': toJson_MetricsInstanceSpecRemoteWriteOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfig allows tuning of the remote_write queue parameters.
 *
 * @schema MetricsInstanceSpecRemoteWriteQueueConfig
 */
export interface MetricsInstanceSpecRemoteWriteQueueConfig {
  /**
   * BatchSendDeadline is the maximum time a sample will wait in the buffer.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#batchSendDeadline
   */
  readonly batchSendDeadline?: string;

  /**
   * Capacity is the number of samples to buffer per shard before samples start being dropped.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#capacity
   */
  readonly capacity?: number;

  /**
   * MaxBackoff is the maximum retry delay.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#maxBackoff
   */
  readonly maxBackoff?: string;

  /**
   * MaxRetries is the maximum number of times to retry a batch on recoverable errors.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * MaxSamplesPerSend is the maximum number of samples per send.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#maxSamplesPerSend
   */
  readonly maxSamplesPerSend?: number;

  /**
   * MaxShards is the maximum number of shards, i.e., the amount of concurrency.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#maxShards
   */
  readonly maxShards?: number;

  /**
   * MinBackoff is the initial retry delay. MinBackoff is doubled for every retry.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#minBackoff
   */
  readonly minBackoff?: string;

  /**
   * MinShards is the minimum number of shards, i.e., the amount of concurrency.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#minShards
   */
  readonly minShards?: number;

  /**
   * RetryOnRateLimit retries requests when encountering rate limits.
   *
   * @schema MetricsInstanceSpecRemoteWriteQueueConfig#retryOnRateLimit
   */
  readonly retryOnRateLimit?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteQueueConfig(obj: MetricsInstanceSpecRemoteWriteQueueConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSendDeadline': obj.batchSendDeadline,
    'capacity': obj.capacity,
    'maxBackoff': obj.maxBackoff,
    'maxRetries': obj.maxRetries,
    'maxSamplesPerSend': obj.maxSamplesPerSend,
    'maxShards': obj.maxShards,
    'minBackoff': obj.minBackoff,
    'minShards': obj.minShards,
    'retryOnRateLimit': obj.retryOnRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigV4 configures SigV4-based authentication to the remote_write endpoint. SigV4-based authentication is used if SigV4 is defined, even with an empty object.
 *
 * @schema MetricsInstanceSpecRemoteWriteSigv4
 */
export interface MetricsInstanceSpecRemoteWriteSigv4 {
  /**
   * AccessKey holds the secret of the AWS API access key to use for signing. If not provided, the environment variable AWS_ACCESS_KEY_ID is used.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4#accessKey
   */
  readonly accessKey?: MetricsInstanceSpecRemoteWriteSigv4AccessKey;

  /**
   * Profile is the named AWS profile to use for authentication.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region of the AWS endpoint. If blank, the region from the default credentials chain is used.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4#region
   */
  readonly region?: string;

  /**
   * RoleARN is the AWS Role ARN to use for authentication, as an alternative for using the AWS API keys.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4#roleARN
   */
  readonly roleArn?: string;

  /**
   * SecretKey of the AWS API to use for signing. If blank, the environment variable AWS_SECRET_ACCESS_KEY is used.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4#secretKey
   */
  readonly secretKey?: MetricsInstanceSpecRemoteWriteSigv4SecretKey;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteSigv4(obj: MetricsInstanceSpecRemoteWriteSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_MetricsInstanceSpecRemoteWriteSigv4AccessKey(obj.accessKey),
    'profile': obj.profile,
    'region': obj.region,
    'roleARN': obj.roleArn,
    'secretKey': toJson_MetricsInstanceSpecRemoteWriteSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSConfig to use for remote_write.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfig
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#ca
   */
  readonly ca?: MetricsInstanceSpecRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#cert
   */
  readonly cert?: MetricsInstanceSpecRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: MetricsInstanceSpecRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfig(obj: MetricsInstanceSpecRemoteWriteTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_MetricsInstanceSpecRemoteWriteTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
 *
 * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs
 */
export interface MetricsInstanceSpecRemoteWriteWriteRelabelConfigs {
  /**
   * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   *
   * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#action
   */
  readonly action?: MetricsInstanceSpecRemoteWriteWriteRelabelConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   *
   * @default '
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
   *
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteWriteRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteWriteRelabelConfigs(obj: MetricsInstanceSpecRemoteWriteWriteRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions
 */
export interface MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions(obj: MetricsInstanceSpecServiceMonitorNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema MetricsInstanceSpecServiceMonitorSelectorMatchExpressions
 */
export interface MetricsInstanceSpecServiceMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema MetricsInstanceSpecServiceMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema MetricsInstanceSpecServiceMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema MetricsInstanceSpecServiceMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'MetricsInstanceSpecServiceMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecServiceMonitorSelectorMatchExpressions(obj: MetricsInstanceSpecServiceMonitorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema MetricsInstanceSpecRemoteWriteBasicAuthPassword
 */
export interface MetricsInstanceSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteBasicAuthPassword(obj: MetricsInstanceSpecRemoteWriteBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema MetricsInstanceSpecRemoteWriteBasicAuthUsername
 */
export interface MetricsInstanceSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteBasicAuthUsername(obj: MetricsInstanceSpecRemoteWriteBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema MetricsInstanceSpecRemoteWriteOauth2ClientId
 */
export interface MetricsInstanceSpecRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteOauth2ClientId(obj: MetricsInstanceSpecRemoteWriteOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema MetricsInstanceSpecRemoteWriteOauth2ClientSecret
 */
export interface MetricsInstanceSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteOauth2ClientSecret(obj: MetricsInstanceSpecRemoteWriteOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey holds the secret of the AWS API access key to use for signing. If not provided, the environment variable AWS_ACCESS_KEY_ID is used.
 *
 * @schema MetricsInstanceSpecRemoteWriteSigv4AccessKey
 */
export interface MetricsInstanceSpecRemoteWriteSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4AccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteSigv4AccessKey(obj: MetricsInstanceSpecRemoteWriteSigv4AccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey of the AWS API to use for signing. If blank, the environment variable AWS_SECRET_ACCESS_KEY is used.
 *
 * @schema MetricsInstanceSpecRemoteWriteSigv4SecretKey
 */
export interface MetricsInstanceSpecRemoteWriteSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteSigv4SecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteSigv4SecretKey(obj: MetricsInstanceSpecRemoteWriteSigv4SecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCa
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: MetricsInstanceSpecRemoteWriteTlsConfigCaSecret;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCa(obj: MetricsInstanceSpecRemoteWriteTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCert
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: MetricsInstanceSpecRemoteWriteTlsConfigCertSecret;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCert(obj: MetricsInstanceSpecRemoteWriteTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_MetricsInstanceSpecRemoteWriteTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigKeySecret
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigKeySecret(obj: MetricsInstanceSpecRemoteWriteTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 *
 * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 * @schema MetricsInstanceSpecRemoteWriteWriteRelabelConfigsAction
 */
export enum MetricsInstanceSpecRemoteWriteWriteRelabelConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap
 */
export interface MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap(obj: MetricsInstanceSpecRemoteWriteOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret
 */
export interface MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret(obj: MetricsInstanceSpecRemoteWriteOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap(obj: MetricsInstanceSpecRemoteWriteTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaSecret
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCaSecret(obj: MetricsInstanceSpecRemoteWriteTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap(obj: MetricsInstanceSpecRemoteWriteTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertSecret
 */
export interface MetricsInstanceSpecRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema MetricsInstanceSpecRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'MetricsInstanceSpecRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsInstanceSpecRemoteWriteTlsConfigCertSecret(obj: MetricsInstanceSpecRemoteWriteTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * PodLogs defines how to collect logs for a pod.
 *
 * @schema PodLogs
 */
export class PodLogs extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PodLogs"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.grafana.com/v1alpha1',
    kind: 'PodLogs',
  }

  /**
   * Renders a Kubernetes manifest for "PodLogs".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PodLogsProps = {}): any {
    return {
      ...PodLogs.GVK,
      ...toJson_PodLogsProps(props),
    };
  }

  /**
   * Defines a "PodLogs" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PodLogsProps = {}) {
    super(scope, id, {
      ...PodLogs.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PodLogs.GVK,
      ...toJson_PodLogsProps(resolved),
    };
  }
}

/**
 * PodLogs defines how to collect logs for a pod.
 *
 * @schema PodLogs
 */
export interface PodLogsProps {
  /**
   * @schema PodLogs#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec holds the specification of the desired behavior for the PodLogs.
   *
   * @schema PodLogs#spec
   */
  readonly spec?: PodLogsSpec;

}

/**
 * Converts an object of type 'PodLogsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsProps(obj: PodLogsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PodLogsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec holds the specification of the desired behavior for the PodLogs.
 *
 * @schema PodLogsSpec
 */
export interface PodLogsSpec {
  /**
   * The label to use to retrieve the job name from.
   *
   * @schema PodLogsSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Selector to select which namespaces the Pod objects are discovered from.
   *
   * @schema PodLogsSpec#namespaceSelector
   */
  readonly namespaceSelector?: PodLogsSpecNamespaceSelector;

  /**
   * Pipeline stages for this pod. Pipeline stages support transforming and filtering log lines.
   *
   * @schema PodLogsSpec#pipelineStages
   */
  readonly pipelineStages?: PodLogsSpecPipelineStages[];

  /**
   * PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
   *
   * @schema PodLogsSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * RelabelConfigs to apply to logs before delivering. Grafana Agent Operator automatically adds relabelings for a few standard Kubernetes fields and replaces original scrape job name with __tmp_logs_job_name.
   * More info: https://grafana.com/docs/loki/latest/clients/promtail/configuration/#relabel_configs
   *
   * @schema PodLogsSpec#relabelings
   */
  readonly relabelings?: PodLogsSpecRelabelings[];

  /**
   * Selector to select Pod objects. Required.
   *
   * @schema PodLogsSpec#selector
   */
  readonly selector: PodLogsSpecSelector;

}

/**
 * Converts an object of type 'PodLogsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpec(obj: PodLogsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobLabel': obj.jobLabel,
    'namespaceSelector': toJson_PodLogsSpecNamespaceSelector(obj.namespaceSelector),
    'pipelineStages': obj.pipelineStages?.map(y => toJson_PodLogsSpecPipelineStages(y)),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'relabelings': obj.relabelings?.map(y => toJson_PodLogsSpecRelabelings(y)),
    'selector': toJson_PodLogsSpecSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select which namespaces the Pod objects are discovered from.
 *
 * @schema PodLogsSpecNamespaceSelector
 */
export interface PodLogsSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
   *
   * @schema PodLogsSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema PodLogsSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'PodLogsSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecNamespaceSelector(obj: PodLogsSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PipelineStageSpec defines an individual pipeline stage. Each stage type is mutually exclusive and no more than one may be set per stage.
 * More information on pipelines can be found in the Promtail documentation: https://grafana.com/docs/loki/latest/clients/promtail/pipelines/
 *
 * @schema PodLogsSpecPipelineStages
 */
export interface PodLogsSpecPipelineStages {
  /**
   * CRI is a parsing stage that reads log lines using the standard CRI logging format. Supply cri: {} to enable.
   *
   * @schema PodLogsSpecPipelineStages#cri
   */
  readonly cri?: any;

  /**
   * Docker is a parsing stage that reads log lines using the standard Docker logging format. Supply docker: {} to enable.
   *
   * @schema PodLogsSpecPipelineStages#docker
   */
  readonly docker?: any;

  /**
   * Drop is a filtering stage that lets you drop certain logs.
   *
   * @schema PodLogsSpecPipelineStages#drop
   */
  readonly drop?: PodLogsSpecPipelineStagesDrop;

  /**
   * JSON is a parsing stage that reads the log line as JSON and accepts JMESPath expressions to extract data.
   * Information on JMESPath: http://jmespath.org/
   *
   * @schema PodLogsSpecPipelineStages#json
   */
  readonly json?: PodLogsSpecPipelineStagesJson;

  /**
   * LabelAllow is an action stage that only allows the provided labels to be included in the label set that is sent to Loki with the log entry.
   *
   * @schema PodLogsSpecPipelineStages#labelAllow
   */
  readonly labelAllow?: string[];

  /**
   * LabelDrop is an action stage that drops labels from the label set that is sent to Loki with the log entry.
   *
   * @schema PodLogsSpecPipelineStages#labelDrop
   */
  readonly labelDrop?: string[];

  /**
   * Labels is an action stage that takes data from the extracted map and modifies the label set that is sent to Loki with the log entry.
   * The key is REQUIRED and represents the name for the label that will be created. Value is optional and will be the name from extracted data to use for the value of the label. If the value is not provided, it defaults to match the key.
   *
   * @schema PodLogsSpecPipelineStages#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Match is a filtering stage that conditionally applies a set of stages or drop entries when a log entry matches a configurable LogQL stream selector and filter expressions.
   *
   * @schema PodLogsSpecPipelineStages#match
   */
  readonly match?: PodLogsSpecPipelineStagesMatch;

  /**
   * Metrics is an action stage that supports defining and updating metrics based on data from the extracted map. Created metrics are not pushed to Loki or Prometheus and are instead exposed via the /metrics endpoint of the Grafana Agent pod. The Grafana Agent Operator should be configured with a MetricsInstance that discovers the logging DaemonSet to collect metrics created by this stage.
   *
   * @schema PodLogsSpecPipelineStages#metrics
   */
  readonly metrics?: { [key: string]: PodLogsSpecPipelineStagesMetrics };

  /**
   * Multiline stage merges multiple lines into a multiline block before passing it on to the next stage in the pipeline.
   *
   * @schema PodLogsSpecPipelineStages#multiline
   */
  readonly multiline?: PodLogsSpecPipelineStagesMultiline;

  /**
   * Output stage is an action stage that takes data from the extracted map and changes the log line that will be sent to Loki.
   *
   * @schema PodLogsSpecPipelineStages#output
   */
  readonly output?: PodLogsSpecPipelineStagesOutput;

  /**
   * Pack is a transform stage that lets you embed extracted values and labels into the log line by packing the log line and labels inside of a JSON object.
   *
   * @schema PodLogsSpecPipelineStages#pack
   */
  readonly pack?: PodLogsSpecPipelineStagesPack;

  /**
   * Regex is a parsing stage that parses a log line using a regular expression.  Named capture groups in the regex allows for adding data into the extracted map.
   *
   * @schema PodLogsSpecPipelineStages#regex
   */
  readonly regex?: PodLogsSpecPipelineStagesRegex;

  /**
   * Replace is a parsing stage that parses a log line using a regular expression and replaces the log line. Named capture groups in the regex allows for adding data into the extracted map.
   *
   * @schema PodLogsSpecPipelineStages#replace
   */
  readonly replace?: PodLogsSpecPipelineStagesReplace;

  /**
   * Template is a transform stage that manipulates the values in the extracted map using Go's template syntax.
   *
   * @schema PodLogsSpecPipelineStages#template
   */
  readonly template?: PodLogsSpecPipelineStagesTemplate;

  /**
   * Tenant is an action stage that sets the tenant ID for the log entry picking it from a field in the extracted data map. If the field is missing, the default LogsClientSpec.tenantId will be used.
   *
   * @schema PodLogsSpecPipelineStages#tenant
   */
  readonly tenant?: PodLogsSpecPipelineStagesTenant;

  /**
   * Timestamp is an action stage that can change the timestamp of a log line before it is sent to Loki. If not present, the timestamp of a log line defaults to the time when the log line was read.
   *
   * @schema PodLogsSpecPipelineStages#timestamp
   */
  readonly timestamp?: PodLogsSpecPipelineStagesTimestamp;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStages(obj: PodLogsSpecPipelineStages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cri': obj.cri,
    'docker': obj.docker,
    'drop': toJson_PodLogsSpecPipelineStagesDrop(obj.drop),
    'json': toJson_PodLogsSpecPipelineStagesJson(obj.json),
    'labelAllow': obj.labelAllow?.map(y => y),
    'labelDrop': obj.labelDrop?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_PodLogsSpecPipelineStagesMatch(obj.match),
    'metrics': ((obj.metrics) === undefined) ? undefined : (Object.entries(obj.metrics).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_PodLogsSpecPipelineStagesMetrics(i[1]) }), {})),
    'multiline': toJson_PodLogsSpecPipelineStagesMultiline(obj.multiline),
    'output': toJson_PodLogsSpecPipelineStagesOutput(obj.output),
    'pack': toJson_PodLogsSpecPipelineStagesPack(obj.pack),
    'regex': toJson_PodLogsSpecPipelineStagesRegex(obj.regex),
    'replace': toJson_PodLogsSpecPipelineStagesReplace(obj.replace),
    'template': toJson_PodLogsSpecPipelineStagesTemplate(obj.template),
    'tenant': toJson_PodLogsSpecPipelineStagesTenant(obj.tenant),
    'timestamp': toJson_PodLogsSpecPipelineStagesTimestamp(obj.timestamp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
 *
 * @schema PodLogsSpecRelabelings
 */
export interface PodLogsSpecRelabelings {
  /**
   * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   *
   * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
   * @schema PodLogsSpecRelabelings#action
   */
  readonly action?: PodLogsSpecRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema PodLogsSpecRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   *
   * @default '
   * @schema PodLogsSpecRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema PodLogsSpecRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema PodLogsSpecRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
   *
   * @schema PodLogsSpecRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema PodLogsSpecRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PodLogsSpecRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecRelabelings(obj: PodLogsSpecRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select Pod objects. Required.
 *
 * @schema PodLogsSpecSelector
 */
export interface PodLogsSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PodLogsSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PodLogsSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PodLogsSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PodLogsSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecSelector(obj: PodLogsSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PodLogsSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Drop is a filtering stage that lets you drop certain logs.
 *
 * @schema PodLogsSpecPipelineStagesDrop
 */
export interface PodLogsSpecPipelineStagesDrop {
  /**
   * Every time a log line is dropped, the metric logentry_dropped_lines_total is incremented. A "reason" label is added, and can be customized by providing a custom value here. Defaults to "drop_stage".
   *
   * @default drop_stage".
   * @schema PodLogsSpecPipelineStagesDrop#dropCounterReason
   */
  readonly dropCounterReason?: string;

  /**
   * RE2 regular expression.
   * If source is provided, the regex attempts to match the source.
   * If no source is provided, then the regex attempts to attach the log line.
   * If the provided regex matches the log line or a provided source, the line is dropped.
   *
   * @schema PodLogsSpecPipelineStagesDrop#expression
   */
  readonly expression?: string;

  /**
   * LongerThan will drop a log line if it its content is longer than this value (in bytes). Can be expressed as an integer (8192) or a number with a suffix (8kb).
   *
   * @schema PodLogsSpecPipelineStagesDrop#longerThan
   */
  readonly longerThan?: string;

  /**
   * OlderThan will be parsed as a Go duration. If the log line's timestamp is older than the current time minus the provided duration, it will be dropped.
   *
   * @schema PodLogsSpecPipelineStagesDrop#olderThan
   */
  readonly olderThan?: string;

  /**
   * Name from the extract data to parse. If empty, uses the log message.
   *
   * @schema PodLogsSpecPipelineStagesDrop#source
   */
  readonly source?: string;

  /**
   * Value can only be specified when source is specified. If the value provided is an exact match for the given source then the line will be dropped.
   * Mutually exclusive with expression.
   *
   * @schema PodLogsSpecPipelineStagesDrop#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesDrop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesDrop(obj: PodLogsSpecPipelineStagesDrop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dropCounterReason': obj.dropCounterReason,
    'expression': obj.expression,
    'longerThan': obj.longerThan,
    'olderThan': obj.olderThan,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JSON is a parsing stage that reads the log line as JSON and accepts JMESPath expressions to extract data.
 * Information on JMESPath: http://jmespath.org/
 *
 * @schema PodLogsSpecPipelineStagesJson
 */
export interface PodLogsSpecPipelineStagesJson {
  /**
   * Set of the key/value pairs of JMESPath expressions. The key will be the key in the extracted data while the expression will be the value, evaluated as a JMESPath from the source data.
   * Literal JMESPath expressions can be used by wrapping a key in double quotes, which then must be wrapped again in single quotes in YAML so they get passed to the JMESPath parser.
   *
   * @schema PodLogsSpecPipelineStagesJson#expressions
   */
  readonly expressions?: { [key: string]: string };

  /**
   * Name from the extracted data to parse as JSON. If empty, uses entire log message.
   *
   * @schema PodLogsSpecPipelineStagesJson#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesJson(obj: PodLogsSpecPipelineStagesJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': ((obj.expressions) === undefined) ? undefined : (Object.entries(obj.expressions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match is a filtering stage that conditionally applies a set of stages or drop entries when a log entry matches a configurable LogQL stream selector and filter expressions.
 *
 * @schema PodLogsSpecPipelineStagesMatch
 */
export interface PodLogsSpecPipelineStagesMatch {
  /**
   * Determines what action is taken when the selector matches the log line. Can be keep or drop. Defaults to keep. When set to drop, entries are dropped and no later metrics are recorded. Stages must be empty when dropping metrics.
   *
   * @default keep. When set to drop, entries are dropped and no later metrics are recorded. Stages must be empty when dropping metrics.
   * @schema PodLogsSpecPipelineStagesMatch#action
   */
  readonly action?: string;

  /**
   * Every time a log line is dropped, the metric logentry_dropped_lines_total is incremented. A "reason" label is added, and can be customized by providing a custom value here. Defaults to "match_stage."
   *
   * @default match_stage."
   * @schema PodLogsSpecPipelineStagesMatch#dropCounterReason
   */
  readonly dropCounterReason?: string;

  /**
   * Names the pipeline. When defined, creates an additional label in the pipeline_duration_seconds histogram, where the value is concatenated with job_name using an underscore.
   *
   * @schema PodLogsSpecPipelineStagesMatch#pipelineName
   */
  readonly pipelineName?: string;

  /**
   * LogQL stream selector and filter expressions. Required.
   *
   * @schema PodLogsSpecPipelineStagesMatch#selector
   */
  readonly selector: string;

  /**
   * Nested set of pipeline stages to execute when action is keep and the log line matches selector.
   * An example value for stages may be:
   * stages: | - json: {} - labelAllow: [foo, bar]
   * Note that stages is a string because SIG API Machinery does not support recursive types, and so it cannot be validated for correctness. Be careful not to mistype anything.
   *
   * @schema PodLogsSpecPipelineStagesMatch#stages
   */
  readonly stages?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesMatch(obj: PodLogsSpecPipelineStagesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'dropCounterReason': obj.dropCounterReason,
    'pipelineName': obj.pipelineName,
    'selector': obj.selector,
    'stages': obj.stages,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricsStageSpec is an action stage that allows for defining and updating metrics based on data from the extracted map. Created metrics are not pushed to Loki or Prometheus and are instead exposed via the /metrics endpoint of the Grafana Agent pod. The Grafana Agent Operator should be configured with a MetricsInstance that discovers the logging DaemonSet to collect metrics created by this stage.
 *
 * @schema PodLogsSpecPipelineStagesMetrics
 */
export interface PodLogsSpecPipelineStagesMetrics {
  /**
   * The action to take against the metric. Required.
   * Must be either "inc" or "add" for type: counter or type: histogram. When type: gauge, must be one of "set", "inc", "dec", "add", or "sub".
   * "add", "set", or "sub" requires the extracted value to be convertible to a positive float.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#action
   */
  readonly action: string;

  /**
   * Buckets to create. Bucket values must be convertible to float64s. Extremely large or small numbers are subject to some loss of precision. Only valid for type: histogram.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#buckets
   */
  readonly buckets?: string[];

  /**
   * If true all log line bytes are counted. Can only be set with matchAll: true and action: add.
   * Only valid for type: counter.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#countEntryBytes
   */
  readonly countEntryBytes?: boolean;

  /**
   * Sets the description for the created metric.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#description
   */
  readonly description?: string;

  /**
   * If true, all log lines are counted without attempting to match the source to the extracted map. Mutually exclusive with value.
   * Only valid for type: counter.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#matchAll
   */
  readonly matchAll?: boolean;

  /**
   * Label values on metrics are dynamic which can cause exported metrics to go stale. To prevent unbounded cardinality, any metrics not updated within MaxIdleDuration are removed.
   * Must be greater or equal to 1s. Defaults to 5m.
   *
   * @default 5m.
   * @schema PodLogsSpecPipelineStagesMetrics#maxIdleDuration
   */
  readonly maxIdleDuration?: string;

  /**
   * Sets the custom prefix name for the metric. Defaults to "promtail_custom_".
   *
   * @default promtail_custom_".
   * @schema PodLogsSpecPipelineStagesMetrics#prefix
   */
  readonly prefix?: string;

  /**
   * Key from the extracted data map to use for the metric. Defaults to the metrics name if not present.
   *
   * @default the metrics name if not present.
   * @schema PodLogsSpecPipelineStagesMetrics#source
   */
  readonly source?: string;

  /**
   * The metric type to create. Must be one of counter, gauge, histogram. Required.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#type
   */
  readonly type: string;

  /**
   * Filters down source data and only changes the metric if the targeted value matches the provided string exactly. If not present, all data matches.
   *
   * @schema PodLogsSpecPipelineStagesMetrics#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesMetrics(obj: PodLogsSpecPipelineStagesMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'buckets': obj.buckets?.map(y => y),
    'countEntryBytes': obj.countEntryBytes,
    'description': obj.description,
    'matchAll': obj.matchAll,
    'maxIdleDuration': obj.maxIdleDuration,
    'prefix': obj.prefix,
    'source': obj.source,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Multiline stage merges multiple lines into a multiline block before passing it on to the next stage in the pipeline.
 *
 * @schema PodLogsSpecPipelineStagesMultiline
 */
export interface PodLogsSpecPipelineStagesMultiline {
  /**
   * RE2 regular expression. Creates a new multiline block when matched. Required.
   *
   * @schema PodLogsSpecPipelineStagesMultiline#firstLine
   */
  readonly firstLine: string;

  /**
   * Maximum number of lines a block can have. A new block is started if the number of lines surpasses this value. Defaults to 128.
   *
   * @default 128.
   * @schema PodLogsSpecPipelineStagesMultiline#maxLines
   */
  readonly maxLines?: number;

  /**
   * Maximum time to wait before passing on the multiline block to the next stage if no new lines are received. Defaults to 3s.
   *
   * @default 3s.
   * @schema PodLogsSpecPipelineStagesMultiline#maxWaitTime
   */
  readonly maxWaitTime?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesMultiline' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesMultiline(obj: PodLogsSpecPipelineStagesMultiline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'firstLine': obj.firstLine,
    'maxLines': obj.maxLines,
    'maxWaitTime': obj.maxWaitTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Output stage is an action stage that takes data from the extracted map and changes the log line that will be sent to Loki.
 *
 * @schema PodLogsSpecPipelineStagesOutput
 */
export interface PodLogsSpecPipelineStagesOutput {
  /**
   * Name from extract data to use for the log entry. Required.
   *
   * @schema PodLogsSpecPipelineStagesOutput#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesOutput(obj: PodLogsSpecPipelineStagesOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pack is a transform stage that lets you embed extracted values and labels into the log line by packing the log line and labels inside of a JSON object.
 *
 * @schema PodLogsSpecPipelineStagesPack
 */
export interface PodLogsSpecPipelineStagesPack {
  /**
   * If the resulting log line should use any existing timestamp or use time.Now() when the line was created. Set to true when combining several log streams from different containers to avoid out of order errors.
   *
   * @schema PodLogsSpecPipelineStagesPack#ingestTimestamp
   */
  readonly ingestTimestamp?: boolean;

  /**
   * Name from extracted data or line labels. Required. Labels provided here are automatically removed from output labels.
   *
   * @schema PodLogsSpecPipelineStagesPack#labels
   */
  readonly labels: string[];

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesPack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesPack(obj: PodLogsSpecPipelineStagesPack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestTimestamp': obj.ingestTimestamp,
    'labels': obj.labels?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regex is a parsing stage that parses a log line using a regular expression.  Named capture groups in the regex allows for adding data into the extracted map.
 *
 * @schema PodLogsSpecPipelineStagesRegex
 */
export interface PodLogsSpecPipelineStagesRegex {
  /**
   * RE2 regular expression. Each capture group MUST be named. Required.
   *
   * @schema PodLogsSpecPipelineStagesRegex#expression
   */
  readonly expression: string;

  /**
   * Name from extracted data to parse. If empty, defaults to using the log message.
   *
   * @schema PodLogsSpecPipelineStagesRegex#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesRegex(obj: PodLogsSpecPipelineStagesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replace is a parsing stage that parses a log line using a regular expression and replaces the log line. Named capture groups in the regex allows for adding data into the extracted map.
 *
 * @schema PodLogsSpecPipelineStagesReplace
 */
export interface PodLogsSpecPipelineStagesReplace {
  /**
   * RE2 regular expression. Each capture group MUST be named. Required.
   *
   * @schema PodLogsSpecPipelineStagesReplace#expression
   */
  readonly expression: string;

  /**
   * Value to replace the captured group with.
   *
   * @schema PodLogsSpecPipelineStagesReplace#replace
   */
  readonly replace?: string;

  /**
   * Name from extracted data to parse. If empty, defaults to using the log message.
   *
   * @schema PodLogsSpecPipelineStagesReplace#source
   */
  readonly source?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesReplace' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesReplace(obj: PodLogsSpecPipelineStagesReplace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'replace': obj.replace,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template is a transform stage that manipulates the values in the extracted map using Go's template syntax.
 *
 * @schema PodLogsSpecPipelineStagesTemplate
 */
export interface PodLogsSpecPipelineStagesTemplate {
  /**
   * Name from extracted data to parse. Required. If empty, defaults to using the log message.
   *
   * @schema PodLogsSpecPipelineStagesTemplate#source
   */
  readonly source: string;

  /**
   * Go template string to use. Required. In addition to normal template functions, ToLower, ToUpper, Replace, Trim, TrimLeft, TrimRight, TrimPrefix, and TrimSpace are also available.
   *
   * @schema PodLogsSpecPipelineStagesTemplate#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesTemplate(obj: PodLogsSpecPipelineStagesTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tenant is an action stage that sets the tenant ID for the log entry picking it from a field in the extracted data map. If the field is missing, the default LogsClientSpec.tenantId will be used.
 *
 * @schema PodLogsSpecPipelineStagesTenant
 */
export interface PodLogsSpecPipelineStagesTenant {
  /**
   * Name from labels whose value should be set as tenant ID. Mutually exclusive with source and value.
   *
   * @schema PodLogsSpecPipelineStagesTenant#label
   */
  readonly label?: string;

  /**
   * Name from extracted data to use as the tenant ID. Mutually exclusive with label and value.
   *
   * @schema PodLogsSpecPipelineStagesTenant#source
   */
  readonly source?: string;

  /**
   * Value to use for the template ID. Useful when this stage is used within a conditional pipeline such as match. Mutually exclusive with label and source.
   *
   * @schema PodLogsSpecPipelineStagesTenant#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesTenant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesTenant(obj: PodLogsSpecPipelineStagesTenant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timestamp is an action stage that can change the timestamp of a log line before it is sent to Loki. If not present, the timestamp of a log line defaults to the time when the log line was read.
 *
 * @schema PodLogsSpecPipelineStagesTimestamp
 */
export interface PodLogsSpecPipelineStagesTimestamp {
  /**
   * Action to take when the timestamp can't be extracted or parsed. Can be skip or fudge. Defaults to fudge.
   *
   * @default fudge.
   * @schema PodLogsSpecPipelineStagesTimestamp#actionOnFailure
   */
  readonly actionOnFailure?: string;

  /**
   * Fallback formats to try if format fails.
   *
   * @schema PodLogsSpecPipelineStagesTimestamp#fallbackFormats
   */
  readonly fallbackFormats?: string[];

  /**
   * Determines format of the time string. Required. Can be one of: ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, RFC3339, RFC3339Nano, Unix, UnixMs, UnixUs, UnixNs.
   *
   * @schema PodLogsSpecPipelineStagesTimestamp#format
   */
  readonly format: string;

  /**
   * IANA Timezone Database string.
   *
   * @schema PodLogsSpecPipelineStagesTimestamp#location
   */
  readonly location?: string;

  /**
   * Name from extracted data to use as the timestamp. Required.
   *
   * @schema PodLogsSpecPipelineStagesTimestamp#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'PodLogsSpecPipelineStagesTimestamp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecPipelineStagesTimestamp(obj: PodLogsSpecPipelineStagesTimestamp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionOnFailure': obj.actionOnFailure,
    'fallbackFormats': obj.fallbackFormats?.map(y => y),
    'format': obj.format,
    'location': obj.location,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 *
 * @default replace'. uppercase and lowercase actions require Prometheus >= 2.36.
 * @schema PodLogsSpecRelabelingsAction
 */
export enum PodLogsSpecRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PodLogsSpecSelectorMatchExpressions
 */
export interface PodLogsSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PodLogsSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PodLogsSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PodLogsSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PodLogsSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodLogsSpecSelectorMatchExpressions(obj: PodLogsSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

