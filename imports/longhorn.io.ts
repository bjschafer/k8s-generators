// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImage
 */
export class BackingImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'BackingImage',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageProps = {}): any {
    return {
      ...BackingImage.GVK,
      ...toJson_BackingImageProps(props),
    };
  }

  /**
   * Defines a "BackingImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageProps = {}) {
    super(scope, id, {
      ...BackingImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImage.GVK,
      ...toJson_BackingImageProps(resolved),
    };
  }
}

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImage
 */
export interface BackingImageProps {
  /**
   * @schema BackingImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImage#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackingImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageProps(obj: BackingImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImageV1Beta2
 */
export class BackingImageV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackingImage',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImageV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageV1Beta2Props = {}): any {
    return {
      ...BackingImageV1Beta2.GVK,
      ...toJson_BackingImageV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageV1Beta2Props = {}) {
    super(scope, id, {
      ...BackingImageV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageV1Beta2.GVK,
      ...toJson_BackingImageV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImageV1Beta2
 */
export interface BackingImageV1Beta2Props {
  /**
   * @schema BackingImageV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageSpec defines the desired state of the Longhorn backing image
   *
   * @schema BackingImageV1Beta2#spec
   */
  readonly spec?: BackingImageV1Beta2Spec;

}

/**
 * Converts an object of type 'BackingImageV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageV1Beta2Props(obj: BackingImageV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackingImageV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageSpec defines the desired state of the Longhorn backing image
 *
 * @schema BackingImageV1Beta2Spec
 */
export interface BackingImageV1Beta2Spec {
  /**
   * @schema BackingImageV1Beta2Spec#checksum
   */
  readonly checksum?: string;

  /**
   * @schema BackingImageV1Beta2Spec#dataEngine
   */
  readonly dataEngine?: BackingImageV1Beta2SpecDataEngine;

  /**
   * @schema BackingImageV1Beta2Spec#diskFileSpecMap
   */
  readonly diskFileSpecMap?: { [key: string]: BackingImageV1Beta2SpecDiskFileSpecMap };

  /**
   * @schema BackingImageV1Beta2Spec#diskSelector
   */
  readonly diskSelector?: string[];

  /**
   * Deprecated. We are now using DiskFileSpecMap to assign different spec to the file on different disks.
   *
   * @schema BackingImageV1Beta2Spec#disks
   */
  readonly disks?: { [key: string]: string };

  /**
   * @schema BackingImageV1Beta2Spec#minNumberOfCopies
   */
  readonly minNumberOfCopies?: number;

  /**
   * @schema BackingImageV1Beta2Spec#nodeSelector
   */
  readonly nodeSelector?: string[];

  /**
   * @schema BackingImageV1Beta2Spec#secret
   */
  readonly secret?: string;

  /**
   * @schema BackingImageV1Beta2Spec#secretNamespace
   */
  readonly secretNamespace?: string;

  /**
   * @schema BackingImageV1Beta2Spec#sourceParameters
   */
  readonly sourceParameters?: { [key: string]: string };

  /**
   * @schema BackingImageV1Beta2Spec#sourceType
   */
  readonly sourceType?: BackingImageV1Beta2SpecSourceType;

}

/**
 * Converts an object of type 'BackingImageV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageV1Beta2Spec(obj: BackingImageV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checksum': obj.checksum,
    'dataEngine': obj.dataEngine,
    'diskFileSpecMap': ((obj.diskFileSpecMap) === undefined) ? undefined : (Object.entries(obj.diskFileSpecMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_BackingImageV1Beta2SpecDiskFileSpecMap(i[1]) }), {})),
    'diskSelector': obj.diskSelector?.map(y => y),
    'disks': ((obj.disks) === undefined) ? undefined : (Object.entries(obj.disks).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minNumberOfCopies': obj.minNumberOfCopies,
    'nodeSelector': obj.nodeSelector?.map(y => y),
    'secret': obj.secret,
    'secretNamespace': obj.secretNamespace,
    'sourceParameters': ((obj.sourceParameters) === undefined) ? undefined : (Object.entries(obj.sourceParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceType': obj.sourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackingImageV1Beta2SpecDataEngine
 */
export enum BackingImageV1Beta2SpecDataEngine {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema BackingImageV1Beta2SpecDiskFileSpecMap
 */
export interface BackingImageV1Beta2SpecDiskFileSpecMap {
  /**
   * @schema BackingImageV1Beta2SpecDiskFileSpecMap#dataEngine
   */
  readonly dataEngine?: BackingImageV1Beta2SpecDiskFileSpecMapDataEngine;

  /**
   * @schema BackingImageV1Beta2SpecDiskFileSpecMap#evictionRequested
   */
  readonly evictionRequested?: boolean;

}

/**
 * Converts an object of type 'BackingImageV1Beta2SpecDiskFileSpecMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageV1Beta2SpecDiskFileSpecMap(obj: BackingImageV1Beta2SpecDiskFileSpecMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataEngine': obj.dataEngine,
    'evictionRequested': obj.evictionRequested,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackingImageV1Beta2SpecSourceType
 */
export enum BackingImageV1Beta2SpecSourceType {
  /** download */
  DOWNLOAD = "download",
  /** upload */
  UPLOAD = "upload",
  /** export-from-volume */
  EXPORT_HYPHEN_FROM_HYPHEN_VOLUME = "export-from-volume",
  /** restore */
  RESTORE = "restore",
  /** clone */
  CLONE = "clone",
}

/**
 * @schema BackingImageV1Beta2SpecDiskFileSpecMapDataEngine
 */
export enum BackingImageV1Beta2SpecDiskFileSpecMapDataEngine {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}


/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSource
 */
export class BackingImageDataSource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageDataSource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'BackingImageDataSource',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImageDataSource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageDataSourceProps = {}): any {
    return {
      ...BackingImageDataSource.GVK,
      ...toJson_BackingImageDataSourceProps(props),
    };
  }

  /**
   * Defines a "BackingImageDataSource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageDataSourceProps = {}) {
    super(scope, id, {
      ...BackingImageDataSource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageDataSource.GVK,
      ...toJson_BackingImageDataSourceProps(resolved),
    };
  }
}

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSource
 */
export interface BackingImageDataSourceProps {
  /**
   * @schema BackingImageDataSource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImageDataSource#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackingImageDataSourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceProps(obj: BackingImageDataSourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSourceV1Beta2
 */
export class BackingImageDataSourceV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageDataSourceV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackingImageDataSource',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImageDataSourceV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageDataSourceV1Beta2Props = {}): any {
    return {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...toJson_BackingImageDataSourceV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageDataSourceV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageDataSourceV1Beta2Props = {}) {
    super(scope, id, {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...toJson_BackingImageDataSourceV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSourceV1Beta2
 */
export interface BackingImageDataSourceV1Beta2Props {
  /**
   * @schema BackingImageDataSourceV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
   *
   * @schema BackingImageDataSourceV1Beta2#spec
   */
  readonly spec?: BackingImageDataSourceV1Beta2Spec;

}

/**
 * Converts an object of type 'BackingImageDataSourceV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceV1Beta2Props(obj: BackingImageDataSourceV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackingImageDataSourceV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
 *
 * @schema BackingImageDataSourceV1Beta2Spec
 */
export interface BackingImageDataSourceV1Beta2Spec {
  /**
   * @schema BackingImageDataSourceV1Beta2Spec#checksum
   */
  readonly checksum?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#diskUUID
   */
  readonly diskUuid?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#fileTransferred
   */
  readonly fileTransferred?: boolean;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#sourceType
   */
  readonly sourceType?: BackingImageDataSourceV1Beta2SpecSourceType;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#uuid
   */
  readonly uuid?: string;

}

/**
 * Converts an object of type 'BackingImageDataSourceV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceV1Beta2Spec(obj: BackingImageDataSourceV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checksum': obj.checksum,
    'diskPath': obj.diskPath,
    'diskUUID': obj.diskUuid,
    'fileTransferred': obj.fileTransferred,
    'nodeID': obj.nodeId,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceType': obj.sourceType,
    'uuid': obj.uuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackingImageDataSourceV1Beta2SpecSourceType
 */
export enum BackingImageDataSourceV1Beta2SpecSourceType {
  /** download */
  DOWNLOAD = "download",
  /** upload */
  UPLOAD = "upload",
  /** export-from-volume */
  EXPORT_HYPHEN_FROM_HYPHEN_VOLUME = "export-from-volume",
  /** restore */
  RESTORE = "restore",
  /** clone */
  CLONE = "clone",
}


/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManager
 */
export class BackingImageManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'BackingImageManager',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImageManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageManagerProps = {}): any {
    return {
      ...BackingImageManager.GVK,
      ...toJson_BackingImageManagerProps(props),
    };
  }

  /**
   * Defines a "BackingImageManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageManagerProps = {}) {
    super(scope, id, {
      ...BackingImageManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageManager.GVK,
      ...toJson_BackingImageManagerProps(resolved),
    };
  }
}

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManager
 */
export interface BackingImageManagerProps {
  /**
   * @schema BackingImageManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImageManager#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackingImageManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerProps(obj: BackingImageManagerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManagerV1Beta2
 */
export class BackingImageManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackingImageManager',
  }

  /**
   * Renders a Kubernetes manifest for "BackingImageManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageManagerV1Beta2Props = {}): any {
    return {
      ...BackingImageManagerV1Beta2.GVK,
      ...toJson_BackingImageManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackingImageManagerV1Beta2Props = {}) {
    super(scope, id, {
      ...BackingImageManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageManagerV1Beta2.GVK,
      ...toJson_BackingImageManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManagerV1Beta2
 */
export interface BackingImageManagerV1Beta2Props {
  /**
   * @schema BackingImageManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
   *
   * @schema BackingImageManagerV1Beta2#spec
   */
  readonly spec?: BackingImageManagerV1Beta2Spec;

}

/**
 * Converts an object of type 'BackingImageManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerV1Beta2Props(obj: BackingImageManagerV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackingImageManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
 *
 * @schema BackingImageManagerV1Beta2Spec
 */
export interface BackingImageManagerV1Beta2Spec {
  /**
   * @schema BackingImageManagerV1Beta2Spec#backingImages
   */
  readonly backingImages?: { [key: string]: string };

  /**
   * @schema BackingImageManagerV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#diskUUID
   */
  readonly diskUuid?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

}

/**
 * Converts an object of type 'BackingImageManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerV1Beta2Spec(obj: BackingImageManagerV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backingImages': ((obj.backingImages) === undefined) ? undefined : (Object.entries(obj.backingImages).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'diskPath': obj.diskPath,
    'diskUUID': obj.diskUuid,
    'image': obj.image,
    'nodeID': obj.nodeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps = {}): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps = {}) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Backup#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema BackupV1Beta2
 */
export class BackupV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "BackupV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupV1Beta2Props = {}): any {
    return {
      ...BackupV1Beta2.GVK,
      ...toJson_BackupV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupV1Beta2Props = {}) {
    super(scope, id, {
      ...BackupV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupV1Beta2.GVK,
      ...toJson_BackupV1Beta2Props(resolved),
    };
  }
}

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema BackupV1Beta2
 */
export interface BackupV1Beta2Props {
  /**
   * @schema BackupV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the desired state of the Longhorn backup
   *
   * @schema BackupV1Beta2#spec
   */
  readonly spec?: BackupV1Beta2Spec;

}

/**
 * Converts an object of type 'BackupV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupV1Beta2Props(obj: BackupV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines the desired state of the Longhorn backup
 *
 * @schema BackupV1Beta2Spec
 */
export interface BackupV1Beta2Spec {
  /**
   * The backup mode of this backup.
   * Can be "full" or "incremental"
   *
   * @schema BackupV1Beta2Spec#backupMode
   */
  readonly backupMode?: BackupV1Beta2SpecBackupMode;

  /**
   * The labels of snapshot backup.
   *
   * @schema BackupV1Beta2Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The snapshot name.
   *
   * @schema BackupV1Beta2Spec#snapshotName
   */
  readonly snapshotName?: string;

  /**
   * The time to request run sync the remote backup.
   *
   * @schema BackupV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;

}

/**
 * Converts an object of type 'BackupV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupV1Beta2Spec(obj: BackupV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupMode': obj.backupMode,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'snapshotName': obj.snapshotName,
    'syncRequestedAt': obj.syncRequestedAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backup mode of this backup.
 * Can be "full" or "incremental"
 *
 * @schema BackupV1Beta2SpecBackupMode
 */
export enum BackupV1Beta2SpecBackupMode {
  /** full */
  FULL = "full",
  /** incremental */
  INCREMENTAL = "incremental",
}


/**
 * BackupBackingImage is where Longhorn stores backing image backup object.
 *
 * @schema BackupBackingImage
 */
export class BackupBackingImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupBackingImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackupBackingImage',
  }

  /**
   * Renders a Kubernetes manifest for "BackupBackingImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupBackingImageProps = {}): any {
    return {
      ...BackupBackingImage.GVK,
      ...toJson_BackupBackingImageProps(props),
    };
  }

  /**
   * Defines a "BackupBackingImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupBackingImageProps = {}) {
    super(scope, id, {
      ...BackupBackingImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupBackingImage.GVK,
      ...toJson_BackupBackingImageProps(resolved),
    };
  }
}

/**
 * BackupBackingImage is where Longhorn stores backing image backup object.
 *
 * @schema BackupBackingImage
 */
export interface BackupBackingImageProps {
  /**
   * @schema BackupBackingImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
   *
   * @schema BackupBackingImage#spec
   */
  readonly spec?: BackupBackingImageSpec;

}

/**
 * Converts an object of type 'BackupBackingImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackingImageProps(obj: BackupBackingImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupBackingImageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
 *
 * @schema BackupBackingImageSpec
 */
export interface BackupBackingImageSpec {
  /**
   * The backing image name.
   *
   * @schema BackupBackingImageSpec#backingImage
   */
  readonly backingImage: string;

  /**
   * The backup target name.
   *
   * @schema BackupBackingImageSpec#backupTargetName
   */
  readonly backupTargetName?: string;

  /**
   * The labels of backing image backup.
   *
   * @schema BackupBackingImageSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The time to request run sync the remote backing image backup.
   *
   * @schema BackupBackingImageSpec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;

  /**
   * Is this CR created by user through API or UI.
   *
   * @schema BackupBackingImageSpec#userCreated
   */
  readonly userCreated: boolean;

}

/**
 * Converts an object of type 'BackupBackingImageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupBackingImageSpec(obj: BackupBackingImageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backingImage': obj.backingImage,
    'backupTargetName': obj.backupTargetName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'syncRequestedAt': obj.syncRequestedAt?.toISOString(),
    'userCreated': obj.userCreated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTarget
 */
export class BackupTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'BackupTarget',
  }

  /**
   * Renders a Kubernetes manifest for "BackupTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupTargetProps = {}): any {
    return {
      ...BackupTarget.GVK,
      ...toJson_BackupTargetProps(props),
    };
  }

  /**
   * Defines a "BackupTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupTargetProps = {}) {
    super(scope, id, {
      ...BackupTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupTarget.GVK,
      ...toJson_BackupTargetProps(resolved),
    };
  }
}

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTarget
 */
export interface BackupTargetProps {
  /**
   * @schema BackupTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackupTarget#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackupTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetProps(obj: BackupTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTargetV1Beta2
 */
export class BackupTargetV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupTargetV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackupTarget',
  }

  /**
   * Renders a Kubernetes manifest for "BackupTargetV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupTargetV1Beta2Props = {}): any {
    return {
      ...BackupTargetV1Beta2.GVK,
      ...toJson_BackupTargetV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupTargetV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupTargetV1Beta2Props = {}) {
    super(scope, id, {
      ...BackupTargetV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupTargetV1Beta2.GVK,
      ...toJson_BackupTargetV1Beta2Props(resolved),
    };
  }
}

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTargetV1Beta2
 */
export interface BackupTargetV1Beta2Props {
  /**
   * @schema BackupTargetV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupTargetSpec defines the desired state of the Longhorn backup target
   *
   * @schema BackupTargetV1Beta2#spec
   */
  readonly spec?: BackupTargetV1Beta2Spec;

}

/**
 * Converts an object of type 'BackupTargetV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetV1Beta2Props(obj: BackupTargetV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupTargetV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupTargetSpec defines the desired state of the Longhorn backup target
 *
 * @schema BackupTargetV1Beta2Spec
 */
export interface BackupTargetV1Beta2Spec {
  /**
   * The backup target URL.
   *
   * @schema BackupTargetV1Beta2Spec#backupTargetURL
   */
  readonly backupTargetUrl?: string;

  /**
   * The backup target credential secret.
   *
   * @schema BackupTargetV1Beta2Spec#credentialSecret
   */
  readonly credentialSecret?: string;

  /**
   * The interval that the cluster needs to run sync with the backup target.
   *
   * @schema BackupTargetV1Beta2Spec#pollInterval
   */
  readonly pollInterval?: string;

  /**
   * The time to request run sync the remote backup target.
   *
   * @schema BackupTargetV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;

}

/**
 * Converts an object of type 'BackupTargetV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetV1Beta2Spec(obj: BackupTargetV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupTargetURL': obj.backupTargetUrl,
    'credentialSecret': obj.credentialSecret,
    'pollInterval': obj.pollInterval,
    'syncRequestedAt': obj.syncRequestedAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolume
 */
export class BackupVolume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupVolume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'BackupVolume',
  }

  /**
   * Renders a Kubernetes manifest for "BackupVolume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupVolumeProps = {}): any {
    return {
      ...BackupVolume.GVK,
      ...toJson_BackupVolumeProps(props),
    };
  }

  /**
   * Defines a "BackupVolume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupVolumeProps = {}) {
    super(scope, id, {
      ...BackupVolume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupVolume.GVK,
      ...toJson_BackupVolumeProps(resolved),
    };
  }
}

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolume
 */
export interface BackupVolumeProps {
  /**
   * @schema BackupVolume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackupVolume#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'BackupVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeProps(obj: BackupVolumeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolumeV1Beta2
 */
export class BackupVolumeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupVolumeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'BackupVolume',
  }

  /**
   * Renders a Kubernetes manifest for "BackupVolumeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupVolumeV1Beta2Props = {}): any {
    return {
      ...BackupVolumeV1Beta2.GVK,
      ...toJson_BackupVolumeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupVolumeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupVolumeV1Beta2Props = {}) {
    super(scope, id, {
      ...BackupVolumeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupVolumeV1Beta2.GVK,
      ...toJson_BackupVolumeV1Beta2Props(resolved),
    };
  }
}

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolumeV1Beta2
 */
export interface BackupVolumeV1Beta2Props {
  /**
   * @schema BackupVolumeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupVolumeSpec defines the desired state of the Longhorn backup volume
   *
   * @schema BackupVolumeV1Beta2#spec
   */
  readonly spec?: BackupVolumeV1Beta2Spec;

}

/**
 * Converts an object of type 'BackupVolumeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeV1Beta2Props(obj: BackupVolumeV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupVolumeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupVolumeSpec defines the desired state of the Longhorn backup volume
 *
 * @schema BackupVolumeV1Beta2Spec
 */
export interface BackupVolumeV1Beta2Spec {
  /**
   * The backup target name that the backup volume was synced.
   *
   * @schema BackupVolumeV1Beta2Spec#backupTargetName
   */
  readonly backupTargetName?: string;

  /**
   * The time to request run sync the remote backup volume.
   *
   * @schema BackupVolumeV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;

  /**
   * The volume name that the backup volume was used to backup.
   *
   * @schema BackupVolumeV1Beta2Spec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'BackupVolumeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeV1Beta2Spec(obj: BackupVolumeV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupTargetName': obj.backupTargetName,
    'syncRequestedAt': obj.syncRequestedAt?.toISOString(),
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema Engine
 */
export class Engine extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Engine"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Engine',
  }

  /**
   * Renders a Kubernetes manifest for "Engine".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineProps = {}): any {
    return {
      ...Engine.GVK,
      ...toJson_EngineProps(props),
    };
  }

  /**
   * Defines a "Engine" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EngineProps = {}) {
    super(scope, id, {
      ...Engine.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Engine.GVK,
      ...toJson_EngineProps(resolved),
    };
  }
}

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema Engine
 */
export interface EngineProps {
  /**
   * @schema Engine#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Engine#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'EngineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineProps(obj: EngineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema EngineV1Beta2
 */
export class EngineV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Engine',
  }

  /**
   * Renders a Kubernetes manifest for "EngineV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineV1Beta2Props = {}): any {
    return {
      ...EngineV1Beta2.GVK,
      ...toJson_EngineV1Beta2Props(props),
    };
  }

  /**
   * Defines a "EngineV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EngineV1Beta2Props = {}) {
    super(scope, id, {
      ...EngineV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineV1Beta2.GVK,
      ...toJson_EngineV1Beta2Props(resolved),
    };
  }
}

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema EngineV1Beta2
 */
export interface EngineV1Beta2Props {
  /**
   * @schema EngineV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EngineSpec defines the desired state of the Longhorn engine
   *
   * @schema EngineV1Beta2#spec
   */
  readonly spec?: EngineV1Beta2Spec;

}

/**
 * Converts an object of type 'EngineV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineV1Beta2Props(obj: EngineV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EngineV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EngineSpec defines the desired state of the Longhorn engine
 *
 * @schema EngineV1Beta2Spec
 */
export interface EngineV1Beta2Spec {
  /**
   * @schema EngineV1Beta2Spec#active
   */
  readonly active?: boolean;

  /**
   * Deprecated:Replaced by field `dataEngine`.
   *
   * @schema EngineV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: string;

  /**
   * @schema EngineV1Beta2Spec#backupVolume
   */
  readonly backupVolume?: string;

  /**
   * @schema EngineV1Beta2Spec#dataEngine
   */
  readonly dataEngine?: EngineV1Beta2SpecDataEngine;

  /**
   * @schema EngineV1Beta2Spec#desireState
   */
  readonly desireState?: string;

  /**
   * @schema EngineV1Beta2Spec#disableFrontend
   */
  readonly disableFrontend?: boolean;

  /**
   * Deprecated: Replaced by field `image`.
   *
   * @schema EngineV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * @schema EngineV1Beta2Spec#frontend
   */
  readonly frontend?: EngineV1Beta2SpecFrontend;

  /**
   * @schema EngineV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema EngineV1Beta2Spec#logRequested
   */
  readonly logRequested?: boolean;

  /**
   * @schema EngineV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema EngineV1Beta2Spec#replicaAddressMap
   */
  readonly replicaAddressMap?: { [key: string]: string };

  /**
   * @schema EngineV1Beta2Spec#requestedBackupRestore
   */
  readonly requestedBackupRestore?: string;

  /**
   * @schema EngineV1Beta2Spec#requestedDataSource
   */
  readonly requestedDataSource?: string;

  /**
   * @schema EngineV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema EngineV1Beta2Spec#salvageRequested
   */
  readonly salvageRequested?: boolean;

  /**
   * @schema EngineV1Beta2Spec#snapshotMaxCount
   */
  readonly snapshotMaxCount?: number;

  /**
   * @schema EngineV1Beta2Spec#snapshotMaxSize
   */
  readonly snapshotMaxSize?: string;

  /**
   * @schema EngineV1Beta2Spec#unmapMarkSnapChainRemovedEnabled
   */
  readonly unmapMarkSnapChainRemovedEnabled?: boolean;

  /**
   * @schema EngineV1Beta2Spec#upgradedReplicaAddressMap
   */
  readonly upgradedReplicaAddressMap?: { [key: string]: string };

  /**
   * @schema EngineV1Beta2Spec#volumeName
   */
  readonly volumeName?: string;

  /**
   * @schema EngineV1Beta2Spec#volumeSize
   */
  readonly volumeSize?: string;

}

/**
 * Converts an object of type 'EngineV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineV1Beta2Spec(obj: EngineV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
    'backendStoreDriver': obj.backendStoreDriver,
    'backupVolume': obj.backupVolume,
    'dataEngine': obj.dataEngine,
    'desireState': obj.desireState,
    'disableFrontend': obj.disableFrontend,
    'engineImage': obj.engineImage,
    'frontend': obj.frontend,
    'image': obj.image,
    'logRequested': obj.logRequested,
    'nodeID': obj.nodeId,
    'replicaAddressMap': ((obj.replicaAddressMap) === undefined) ? undefined : (Object.entries(obj.replicaAddressMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestedBackupRestore': obj.requestedBackupRestore,
    'requestedDataSource': obj.requestedDataSource,
    'revisionCounterDisabled': obj.revisionCounterDisabled,
    'salvageRequested': obj.salvageRequested,
    'snapshotMaxCount': obj.snapshotMaxCount,
    'snapshotMaxSize': obj.snapshotMaxSize,
    'unmapMarkSnapChainRemovedEnabled': obj.unmapMarkSnapChainRemovedEnabled,
    'upgradedReplicaAddressMap': ((obj.upgradedReplicaAddressMap) === undefined) ? undefined : (Object.entries(obj.upgradedReplicaAddressMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'volumeName': obj.volumeName,
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EngineV1Beta2SpecDataEngine
 */
export enum EngineV1Beta2SpecDataEngine {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema EngineV1Beta2SpecFrontend
 */
export enum EngineV1Beta2SpecFrontend {
  /** blockdev */
  BLOCKDEV = "blockdev",
  /** iscsi */
  ISCSI = "iscsi",
  /** nvmf */
  NVMF = "nvmf",
}


/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImage
 */
export class EngineImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'EngineImage',
  }

  /**
   * Renders a Kubernetes manifest for "EngineImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineImageProps = {}): any {
    return {
      ...EngineImage.GVK,
      ...toJson_EngineImageProps(props),
    };
  }

  /**
   * Defines a "EngineImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EngineImageProps = {}) {
    super(scope, id, {
      ...EngineImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineImage.GVK,
      ...toJson_EngineImageProps(resolved),
    };
  }
}

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImage
 */
export interface EngineImageProps {
  /**
   * @schema EngineImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema EngineImage#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'EngineImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageProps(obj: EngineImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImageV1Beta2
 */
export class EngineImageV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineImageV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'EngineImage',
  }

  /**
   * Renders a Kubernetes manifest for "EngineImageV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineImageV1Beta2Props = {}): any {
    return {
      ...EngineImageV1Beta2.GVK,
      ...toJson_EngineImageV1Beta2Props(props),
    };
  }

  /**
   * Defines a "EngineImageV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EngineImageV1Beta2Props = {}) {
    super(scope, id, {
      ...EngineImageV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineImageV1Beta2.GVK,
      ...toJson_EngineImageV1Beta2Props(resolved),
    };
  }
}

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImageV1Beta2
 */
export interface EngineImageV1Beta2Props {
  /**
   * @schema EngineImageV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EngineImageSpec defines the desired state of the Longhorn engine image
   *
   * @schema EngineImageV1Beta2#spec
   */
  readonly spec?: EngineImageV1Beta2Spec;

}

/**
 * Converts an object of type 'EngineImageV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageV1Beta2Props(obj: EngineImageV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EngineImageV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EngineImageSpec defines the desired state of the Longhorn engine image
 *
 * @schema EngineImageV1Beta2Spec
 */
export interface EngineImageV1Beta2Spec {
  /**
   * @schema EngineImageV1Beta2Spec#image
   */
  readonly image: string;

}

/**
 * Converts an object of type 'EngineImageV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageV1Beta2Spec(obj: EngineImageV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManager
 */
export class InstanceManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'InstanceManager',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceManagerProps = {}): any {
    return {
      ...InstanceManager.GVK,
      ...toJson_InstanceManagerProps(props),
    };
  }

  /**
   * Defines a "InstanceManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceManagerProps = {}) {
    super(scope, id, {
      ...InstanceManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceManager.GVK,
      ...toJson_InstanceManagerProps(resolved),
    };
  }
}

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManager
 */
export interface InstanceManagerProps {
  /**
   * @schema InstanceManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema InstanceManager#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'InstanceManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerProps(obj: InstanceManagerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManagerV1Beta2
 */
export class InstanceManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'InstanceManager',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceManagerV1Beta2Props = {}): any {
    return {
      ...InstanceManagerV1Beta2.GVK,
      ...toJson_InstanceManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "InstanceManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceManagerV1Beta2Props = {}) {
    super(scope, id, {
      ...InstanceManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceManagerV1Beta2.GVK,
      ...toJson_InstanceManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManagerV1Beta2
 */
export interface InstanceManagerV1Beta2Props {
  /**
   * @schema InstanceManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceManagerSpec defines the desired state of the Longhorn instance manager
   *
   * @schema InstanceManagerV1Beta2#spec
   */
  readonly spec?: InstanceManagerV1Beta2Spec;

}

/**
 * Converts an object of type 'InstanceManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2Props(obj: InstanceManagerV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceManagerSpec defines the desired state of the Longhorn instance manager
 *
 * @schema InstanceManagerV1Beta2Spec
 */
export interface InstanceManagerV1Beta2Spec {
  /**
   * @schema InstanceManagerV1Beta2Spec#dataEngine
   */
  readonly dataEngine?: string;

  /**
   * @schema InstanceManagerV1Beta2Spec#dataEngineSpec
   */
  readonly dataEngineSpec?: InstanceManagerV1Beta2SpecDataEngineSpec;

  /**
   * @schema InstanceManagerV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema InstanceManagerV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema InstanceManagerV1Beta2Spec#type
   */
  readonly type?: InstanceManagerV1Beta2SpecType;

}

/**
 * Converts an object of type 'InstanceManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2Spec(obj: InstanceManagerV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataEngine': obj.dataEngine,
    'dataEngineSpec': toJson_InstanceManagerV1Beta2SpecDataEngineSpec(obj.dataEngineSpec),
    'image': obj.image,
    'nodeID': obj.nodeId,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceManagerV1Beta2SpecDataEngineSpec
 */
export interface InstanceManagerV1Beta2SpecDataEngineSpec {
  /**
   * @schema InstanceManagerV1Beta2SpecDataEngineSpec#v2
   */
  readonly v2?: InstanceManagerV1Beta2SpecDataEngineSpecV2;

}

/**
 * Converts an object of type 'InstanceManagerV1Beta2SpecDataEngineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2SpecDataEngineSpec(obj: InstanceManagerV1Beta2SpecDataEngineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'v2': toJson_InstanceManagerV1Beta2SpecDataEngineSpecV2(obj.v2),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceManagerV1Beta2SpecType
 */
export enum InstanceManagerV1Beta2SpecType {
  /** aio */
  AIO = "aio",
  /** engine */
  ENGINE = "engine",
  /** replica */
  REPLICA = "replica",
}

/**
 * @schema InstanceManagerV1Beta2SpecDataEngineSpecV2
 */
export interface InstanceManagerV1Beta2SpecDataEngineSpecV2 {
  /**
   * @schema InstanceManagerV1Beta2SpecDataEngineSpecV2#cpuMask
   */
  readonly cpuMask?: string;

}

/**
 * Converts an object of type 'InstanceManagerV1Beta2SpecDataEngineSpecV2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2SpecDataEngineSpecV2(obj: InstanceManagerV1Beta2SpecDataEngineSpecV2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuMask': obj.cpuMask,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema Node
 */
export class Node extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Node"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Node',
  }

  /**
   * Renders a Kubernetes manifest for "Node".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeProps = {}): any {
    return {
      ...Node.GVK,
      ...toJson_NodeProps(props),
    };
  }

  /**
   * Defines a "Node" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeProps = {}) {
    super(scope, id, {
      ...Node.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Node.GVK,
      ...toJson_NodeProps(resolved),
    };
  }
}

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema Node
 */
export interface NodeProps {
  /**
   * @schema Node#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Node#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'NodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeProps(obj: NodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema NodeV1Beta2
 */
export class NodeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Node',
  }

  /**
   * Renders a Kubernetes manifest for "NodeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeV1Beta2Props = {}): any {
    return {
      ...NodeV1Beta2.GVK,
      ...toJson_NodeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "NodeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeV1Beta2Props = {}) {
    super(scope, id, {
      ...NodeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeV1Beta2.GVK,
      ...toJson_NodeV1Beta2Props(resolved),
    };
  }
}

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema NodeV1Beta2
 */
export interface NodeV1Beta2Props {
  /**
   * @schema NodeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodeSpec defines the desired state of the Longhorn node
   *
   * @schema NodeV1Beta2#spec
   */
  readonly spec?: NodeV1Beta2Spec;

}

/**
 * Converts an object of type 'NodeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2Props(obj: NodeV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSpec defines the desired state of the Longhorn node
 *
 * @schema NodeV1Beta2Spec
 */
export interface NodeV1Beta2Spec {
  /**
   * @schema NodeV1Beta2Spec#allowScheduling
   */
  readonly allowScheduling?: boolean;

  /**
   * @schema NodeV1Beta2Spec#disks
   */
  readonly disks?: { [key: string]: NodeV1Beta2SpecDisks };

  /**
   * @schema NodeV1Beta2Spec#evictionRequested
   */
  readonly evictionRequested?: boolean;

  /**
   * @schema NodeV1Beta2Spec#instanceManagerCPURequest
   */
  readonly instanceManagerCpuRequest?: number;

  /**
   * @schema NodeV1Beta2Spec#name
   */
  readonly name?: string;

  /**
   * @schema NodeV1Beta2Spec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'NodeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2Spec(obj: NodeV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowScheduling': obj.allowScheduling,
    'disks': ((obj.disks) === undefined) ? undefined : (Object.entries(obj.disks).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_NodeV1Beta2SpecDisks(i[1]) }), {})),
    'evictionRequested': obj.evictionRequested,
    'instanceManagerCPURequest': obj.instanceManagerCpuRequest,
    'name': obj.name,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeV1Beta2SpecDisks
 */
export interface NodeV1Beta2SpecDisks {
  /**
   * @schema NodeV1Beta2SpecDisks#allowScheduling
   */
  readonly allowScheduling?: boolean;

  /**
   * @schema NodeV1Beta2SpecDisks#diskDriver
   */
  readonly diskDriver?: NodeV1Beta2SpecDisksDiskDriver;

  /**
   * @schema NodeV1Beta2SpecDisks#diskType
   */
  readonly diskType?: NodeV1Beta2SpecDisksDiskType;

  /**
   * @schema NodeV1Beta2SpecDisks#evictionRequested
   */
  readonly evictionRequested?: boolean;

  /**
   * @schema NodeV1Beta2SpecDisks#path
   */
  readonly path?: string;

  /**
   * @schema NodeV1Beta2SpecDisks#storageReserved
   */
  readonly storageReserved?: number;

  /**
   * @schema NodeV1Beta2SpecDisks#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'NodeV1Beta2SpecDisks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2SpecDisks(obj: NodeV1Beta2SpecDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowScheduling': obj.allowScheduling,
    'diskDriver': obj.diskDriver,
    'diskType': obj.diskType,
    'evictionRequested': obj.evictionRequested,
    'path': obj.path,
    'storageReserved': obj.storageReserved,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeV1Beta2SpecDisksDiskDriver
 */
export enum NodeV1Beta2SpecDisksDiskDriver {
  /** auto */
  AUTO = "auto",
  /** aio */
  AIO = "aio",
}

/**
 * @schema NodeV1Beta2SpecDisksDiskType
 */
export enum NodeV1Beta2SpecDisksDiskType {
  /** filesystem */
  FILESYSTEM = "filesystem",
  /** block */
  BLOCK = "block",
}


/**
 * Orphan is where Longhorn stores orphan object.
 *
 * @schema Orphan
 */
export class Orphan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Orphan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Orphan',
  }

  /**
   * Renders a Kubernetes manifest for "Orphan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrphanProps = {}): any {
    return {
      ...Orphan.GVK,
      ...toJson_OrphanProps(props),
    };
  }

  /**
   * Defines a "Orphan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrphanProps = {}) {
    super(scope, id, {
      ...Orphan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Orphan.GVK,
      ...toJson_OrphanProps(resolved),
    };
  }
}

/**
 * Orphan is where Longhorn stores orphan object.
 *
 * @schema Orphan
 */
export interface OrphanProps {
  /**
   * @schema Orphan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrphanSpec defines the desired state of the Longhorn orphaned data
   *
   * @schema Orphan#spec
   */
  readonly spec?: OrphanSpec;

}

/**
 * Converts an object of type 'OrphanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrphanProps(obj: OrphanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrphanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrphanSpec defines the desired state of the Longhorn orphaned data
 *
 * @schema OrphanSpec
 */
export interface OrphanSpec {
  /**
   * The node ID on which the controller is responsible to reconcile this orphan CR.
   *
   * @schema OrphanSpec#nodeID
   */
  readonly nodeId?: string;

  /**
   * The type of the orphaned data.
   * Can be "replica".
   *
   * @schema OrphanSpec#orphanType
   */
  readonly orphanType?: string;

  /**
   * The parameters of the orphaned data
   *
   * @schema OrphanSpec#parameters
   */
  readonly parameters?: { [key: string]: string };

}

/**
 * Converts an object of type 'OrphanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrphanSpec(obj: OrphanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeID': obj.nodeId,
    'orphanType': obj.orphanType,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJob
 */
export class RecurringJob extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecurringJob"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'RecurringJob',
  }

  /**
   * Renders a Kubernetes manifest for "RecurringJob".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecurringJobProps = {}): any {
    return {
      ...RecurringJob.GVK,
      ...toJson_RecurringJobProps(props),
    };
  }

  /**
   * Defines a "RecurringJob" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecurringJobProps = {}) {
    super(scope, id, {
      ...RecurringJob.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecurringJob.GVK,
      ...toJson_RecurringJobProps(resolved),
    };
  }
}

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJob
 */
export interface RecurringJobProps {
  /**
   * @schema RecurringJob#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema RecurringJob#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'RecurringJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobProps(obj: RecurringJobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJobV1Beta2
 */
export class RecurringJobV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecurringJobV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'RecurringJob',
  }

  /**
   * Renders a Kubernetes manifest for "RecurringJobV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecurringJobV1Beta2Props = {}): any {
    return {
      ...RecurringJobV1Beta2.GVK,
      ...toJson_RecurringJobV1Beta2Props(props),
    };
  }

  /**
   * Defines a "RecurringJobV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecurringJobV1Beta2Props = {}) {
    super(scope, id, {
      ...RecurringJobV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecurringJobV1Beta2.GVK,
      ...toJson_RecurringJobV1Beta2Props(resolved),
    };
  }
}

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJobV1Beta2
 */
export interface RecurringJobV1Beta2Props {
  /**
   * @schema RecurringJobV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecurringJobSpec defines the desired state of the Longhorn recurring job
   *
   * @schema RecurringJobV1Beta2#spec
   */
  readonly spec?: RecurringJobV1Beta2Spec;

}

/**
 * Converts an object of type 'RecurringJobV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobV1Beta2Props(obj: RecurringJobV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecurringJobV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecurringJobSpec defines the desired state of the Longhorn recurring job
 *
 * @schema RecurringJobV1Beta2Spec
 */
export interface RecurringJobV1Beta2Spec {
  /**
   * The concurrency of taking the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#concurrency
   */
  readonly concurrency?: number;

  /**
   * The cron setting.
   *
   * @schema RecurringJobV1Beta2Spec#cron
   */
  readonly cron?: string;

  /**
   * The recurring job group.
   *
   * @schema RecurringJobV1Beta2Spec#groups
   */
  readonly groups?: string[];

  /**
   * The label of the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The recurring job name.
   *
   * @schema RecurringJobV1Beta2Spec#name
   */
  readonly name?: string;

  /**
   * The parameters of the snapshot/backup.
   * Support parameters: "full-backup-interval".
   *
   * @schema RecurringJobV1Beta2Spec#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * The retain count of the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#retain
   */
  readonly retain?: number;

  /**
   * The recurring job task.
   * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create" or "filesystem-trim"
   *
   * @schema RecurringJobV1Beta2Spec#task
   */
  readonly task?: RecurringJobV1Beta2SpecTask;

}

/**
 * Converts an object of type 'RecurringJobV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobV1Beta2Spec(obj: RecurringJobV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrency': obj.concurrency,
    'cron': obj.cron,
    'groups': obj.groups?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'retain': obj.retain,
    'task': obj.task,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The recurring job task.
 * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create" or "filesystem-trim"
 *
 * @schema RecurringJobV1Beta2SpecTask
 */
export enum RecurringJobV1Beta2SpecTask {
  /** snapshot */
  SNAPSHOT = "snapshot",
  /** snapshot-force-create */
  SNAPSHOT_HYPHEN_FORCE_HYPHEN_CREATE = "snapshot-force-create",
  /** snapshot-cleanup */
  SNAPSHOT_HYPHEN_CLEANUP = "snapshot-cleanup",
  /** snapshot-delete */
  SNAPSHOT_HYPHEN_DELETE = "snapshot-delete",
  /** backup */
  BACKUP = "backup",
  /** backup-force-create */
  BACKUP_HYPHEN_FORCE_HYPHEN_CREATE = "backup-force-create",
  /** filesystem-trim */
  FILESYSTEM_HYPHEN_TRIM = "filesystem-trim",
}


/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema Replica
 */
export class Replica extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Replica"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Replica',
  }

  /**
   * Renders a Kubernetes manifest for "Replica".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaProps = {}): any {
    return {
      ...Replica.GVK,
      ...toJson_ReplicaProps(props),
    };
  }

  /**
   * Defines a "Replica" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicaProps = {}) {
    super(scope, id, {
      ...Replica.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Replica.GVK,
      ...toJson_ReplicaProps(resolved),
    };
  }
}

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema Replica
 */
export interface ReplicaProps {
  /**
   * @schema Replica#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Replica#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'ReplicaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaProps(obj: ReplicaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema ReplicaV1Beta2
 */
export class ReplicaV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicaV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Replica',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicaV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaV1Beta2Props = {}): any {
    return {
      ...ReplicaV1Beta2.GVK,
      ...toJson_ReplicaV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ReplicaV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicaV1Beta2Props = {}) {
    super(scope, id, {
      ...ReplicaV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicaV1Beta2.GVK,
      ...toJson_ReplicaV1Beta2Props(resolved),
    };
  }
}

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema ReplicaV1Beta2
 */
export interface ReplicaV1Beta2Props {
  /**
   * @schema ReplicaV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicaSpec defines the desired state of the Longhorn replica
   *
   * @schema ReplicaV1Beta2#spec
   */
  readonly spec?: ReplicaV1Beta2Spec;

}

/**
 * Converts an object of type 'ReplicaV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaV1Beta2Props(obj: ReplicaV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicaV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaSpec defines the desired state of the Longhorn replica
 *
 * @schema ReplicaV1Beta2Spec
 */
export interface ReplicaV1Beta2Spec {
  /**
   * @schema ReplicaV1Beta2Spec#active
   */
  readonly active?: boolean;

  /**
   * Deprecated:Replaced by field `dataEngine`.
   *
   * @schema ReplicaV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: string;

  /**
   * @schema ReplicaV1Beta2Spec#backingImage
   */
  readonly backingImage?: string;

  /**
   * @schema ReplicaV1Beta2Spec#dataDirectoryName
   */
  readonly dataDirectoryName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#dataEngine
   */
  readonly dataEngine?: ReplicaV1Beta2SpecDataEngine;

  /**
   * @schema ReplicaV1Beta2Spec#desireState
   */
  readonly desireState?: string;

  /**
   * @schema ReplicaV1Beta2Spec#diskID
   */
  readonly diskId?: string;

  /**
   * @schema ReplicaV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * Deprecated: Replaced by field `image`.
   *
   * @schema ReplicaV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * @schema ReplicaV1Beta2Spec#engineName
   */
  readonly engineName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#evictionRequested
   */
  readonly evictionRequested?: boolean;

  /**
   * FailedAt is set when a running replica fails or when a running engine is unable to use a replica for any reason.
   * FailedAt indicates the time the failure occurred. When FailedAt is set, a replica is likely to have useful
   * (though possibly stale) data. A replica with FailedAt set must be rebuilt from a non-failed replica (or it can
   * be used in a salvage if all replicas are failed). FailedAt is cleared before a rebuild or salvage. FailedAt may
   * be later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
   * controller acknowledges the change.
   *
   * @schema ReplicaV1Beta2Spec#failedAt
   */
  readonly failedAt?: string;

  /**
   * @schema ReplicaV1Beta2Spec#hardNodeAffinity
   */
  readonly hardNodeAffinity?: string;

  /**
   * HealthyAt is set the first time a replica becomes read/write in an engine after creation or rebuild. HealthyAt
   * indicates the time the last successful rebuild occurred. When HealthyAt is set, a replica is likely to have
   * useful (though possibly stale) data. HealthyAt is cleared before a rebuild. HealthyAt may be later than the
   * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
   * acknowledges the change.
   *
   * @schema ReplicaV1Beta2Spec#healthyAt
   */
  readonly healthyAt?: string;

  /**
   * @schema ReplicaV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * LastFailedAt is always set at the same time as FailedAt. Unlike FailedAt, LastFailedAt is never cleared.
   * LastFailedAt is not a reliable indicator of the state of a replica's data. For example, a replica with
   * LastFailedAt may already be healthy and in use again. However, because it is never cleared, it can be compared to
   * LastHealthyAt to help prevent dangerous replica deletion in some corner cases. LastFailedAt may be later than the
   * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
   * acknowledges the change.
   *
   * @schema ReplicaV1Beta2Spec#lastFailedAt
   */
  readonly lastFailedAt?: string;

  /**
   * LastHealthyAt is set every time a replica becomes read/write in an engine. Unlike HealthyAt, LastHealthyAt is
   * never cleared. LastHealthyAt is not a reliable indicator of the state of a replica's data. For example, a
   * replica with LastHealthyAt set may be in the middle of a rebuild. However, because it is never cleared, it can be
   * compared to LastFailedAt to help prevent dangerous replica deletion in some corner cases. LastHealthyAt may be
   * later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
   * controller acknowledges the change.
   *
   * @schema ReplicaV1Beta2Spec#lastHealthyAt
   */
  readonly lastHealthyAt?: string;

  /**
   * @schema ReplicaV1Beta2Spec#logRequested
   */
  readonly logRequested?: boolean;

  /**
   * MigrationEngineName is indicating the migrating engine which current connected to this replica. This is only
   * used for live migration of v2 data engine
   *
   * @schema ReplicaV1Beta2Spec#migrationEngineName
   */
  readonly migrationEngineName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema ReplicaV1Beta2Spec#rebuildRetryCount
   */
  readonly rebuildRetryCount?: number;

  /**
   * @schema ReplicaV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#salvageRequested
   */
  readonly salvageRequested?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#snapshotMaxCount
   */
  readonly snapshotMaxCount?: number;

  /**
   * @schema ReplicaV1Beta2Spec#snapshotMaxSize
   */
  readonly snapshotMaxSize?: string;

  /**
   * @schema ReplicaV1Beta2Spec#unmapMarkDiskChainRemovedEnabled
   */
  readonly unmapMarkDiskChainRemovedEnabled?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#volumeName
   */
  readonly volumeName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#volumeSize
   */
  readonly volumeSize?: string;

}

/**
 * Converts an object of type 'ReplicaV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaV1Beta2Spec(obj: ReplicaV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
    'backendStoreDriver': obj.backendStoreDriver,
    'backingImage': obj.backingImage,
    'dataDirectoryName': obj.dataDirectoryName,
    'dataEngine': obj.dataEngine,
    'desireState': obj.desireState,
    'diskID': obj.diskId,
    'diskPath': obj.diskPath,
    'engineImage': obj.engineImage,
    'engineName': obj.engineName,
    'evictionRequested': obj.evictionRequested,
    'failedAt': obj.failedAt,
    'hardNodeAffinity': obj.hardNodeAffinity,
    'healthyAt': obj.healthyAt,
    'image': obj.image,
    'lastFailedAt': obj.lastFailedAt,
    'lastHealthyAt': obj.lastHealthyAt,
    'logRequested': obj.logRequested,
    'migrationEngineName': obj.migrationEngineName,
    'nodeID': obj.nodeId,
    'rebuildRetryCount': obj.rebuildRetryCount,
    'revisionCounterDisabled': obj.revisionCounterDisabled,
    'salvageRequested': obj.salvageRequested,
    'snapshotMaxCount': obj.snapshotMaxCount,
    'snapshotMaxSize': obj.snapshotMaxSize,
    'unmapMarkDiskChainRemovedEnabled': obj.unmapMarkDiskChainRemovedEnabled,
    'volumeName': obj.volumeName,
    'volumeSize': obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicaV1Beta2SpecDataEngine
 */
export enum ReplicaV1Beta2SpecDataEngine {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}


/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema Setting
 */
export class Setting extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Setting"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Setting',
  }

  /**
   * Renders a Kubernetes manifest for "Setting".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SettingProps): any {
    return {
      ...Setting.GVK,
      ...toJson_SettingProps(props),
    };
  }

  /**
   * Defines a "Setting" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SettingProps) {
    super(scope, id, {
      ...Setting.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Setting.GVK,
      ...toJson_SettingProps(resolved),
    };
  }
}

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema Setting
 */
export interface SettingProps {
  /**
   * @schema Setting#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Setting#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SettingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SettingProps(obj: SettingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema SettingV1Beta2
 */
export class SettingV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SettingV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Setting',
  }

  /**
   * Renders a Kubernetes manifest for "SettingV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SettingV1Beta2Props): any {
    return {
      ...SettingV1Beta2.GVK,
      ...toJson_SettingV1Beta2Props(props),
    };
  }

  /**
   * Defines a "SettingV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SettingV1Beta2Props) {
    super(scope, id, {
      ...SettingV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SettingV1Beta2.GVK,
      ...toJson_SettingV1Beta2Props(resolved),
    };
  }
}

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema SettingV1Beta2
 */
export interface SettingV1Beta2Props {
  /**
   * @schema SettingV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The value of the setting.
   *
   * @schema SettingV1Beta2#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SettingV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SettingV1Beta2Props(obj: SettingV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManager
 */
export class ShareManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ShareManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'ShareManager',
  }

  /**
   * Renders a Kubernetes manifest for "ShareManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ShareManagerProps = {}): any {
    return {
      ...ShareManager.GVK,
      ...toJson_ShareManagerProps(props),
    };
  }

  /**
   * Defines a "ShareManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ShareManagerProps = {}) {
    super(scope, id, {
      ...ShareManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ShareManager.GVK,
      ...toJson_ShareManagerProps(resolved),
    };
  }
}

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManager
 */
export interface ShareManagerProps {
  /**
   * @schema ShareManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ShareManager#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'ShareManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerProps(obj: ShareManagerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManagerV1Beta2
 */
export class ShareManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ShareManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'ShareManager',
  }

  /**
   * Renders a Kubernetes manifest for "ShareManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ShareManagerV1Beta2Props = {}): any {
    return {
      ...ShareManagerV1Beta2.GVK,
      ...toJson_ShareManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ShareManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ShareManagerV1Beta2Props = {}) {
    super(scope, id, {
      ...ShareManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ShareManagerV1Beta2.GVK,
      ...toJson_ShareManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManagerV1Beta2
 */
export interface ShareManagerV1Beta2Props {
  /**
   * @schema ShareManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ShareManagerSpec defines the desired state of the Longhorn share manager
   *
   * @schema ShareManagerV1Beta2#spec
   */
  readonly spec?: ShareManagerV1Beta2Spec;

}

/**
 * Converts an object of type 'ShareManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerV1Beta2Props(obj: ShareManagerV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ShareManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ShareManagerSpec defines the desired state of the Longhorn share manager
 *
 * @schema ShareManagerV1Beta2Spec
 */
export interface ShareManagerV1Beta2Spec {
  /**
   * Share manager image used for creating a share manager pod
   *
   * @schema ShareManagerV1Beta2Spec#image
   */
  readonly image?: string;

}

/**
 * Converts an object of type 'ShareManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerV1Beta2Spec(obj: ShareManagerV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Snapshot',
  }

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps = {}): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps = {}) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec defines the desired state of Longhorn Snapshot
   *
   * @schema Snapshot#spec
   */
  readonly spec?: SnapshotSpec;

}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(obj: SnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec defines the desired state of Longhorn Snapshot
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * require creating a new snapshot
   *
   * @schema SnapshotSpec#createSnapshot
   */
  readonly createSnapshot?: boolean;

  /**
   * The labels of snapshot
   *
   * @schema SnapshotSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * the volume that this snapshot belongs to.
   * This field is immutable after creation.
   *
   * @schema SnapshotSpec#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(obj: SnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createSnapshot': obj.createSnapshot,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SupportBundle is where Longhorn stores support bundle object
 *
 * @schema SupportBundle
 */
export class SupportBundle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SupportBundle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'SupportBundle',
  }

  /**
   * Renders a Kubernetes manifest for "SupportBundle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SupportBundleProps = {}): any {
    return {
      ...SupportBundle.GVK,
      ...toJson_SupportBundleProps(props),
    };
  }

  /**
   * Defines a "SupportBundle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SupportBundleProps = {}) {
    super(scope, id, {
      ...SupportBundle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SupportBundle.GVK,
      ...toJson_SupportBundleProps(resolved),
    };
  }
}

/**
 * SupportBundle is where Longhorn stores support bundle object
 *
 * @schema SupportBundle
 */
export interface SupportBundleProps {
  /**
   * @schema SupportBundle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
   *
   * @schema SupportBundle#spec
   */
  readonly spec?: SupportBundleSpec;

}

/**
 * Converts an object of type 'SupportBundleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SupportBundleProps(obj: SupportBundleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SupportBundleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
 *
 * @schema SupportBundleSpec
 */
export interface SupportBundleSpec {
  /**
   * A brief description of the issue
   *
   * @schema SupportBundleSpec#description
   */
  readonly description: string;

  /**
   * The issue URL
   *
   * @schema SupportBundleSpec#issueURL
   */
  readonly issueUrl?: string;

  /**
   * The preferred responsible controller node ID.
   *
   * @schema SupportBundleSpec#nodeID
   */
  readonly nodeId?: string;

}

/**
 * Converts an object of type 'SupportBundleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SupportBundleSpec(obj: SupportBundleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'issueURL': obj.issueUrl,
    'nodeID': obj.nodeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SystemBackup is where Longhorn stores system backup object
 *
 * @schema SystemBackup
 */
export class SystemBackup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SystemBackup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'SystemBackup',
  }

  /**
   * Renders a Kubernetes manifest for "SystemBackup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SystemBackupProps = {}): any {
    return {
      ...SystemBackup.GVK,
      ...toJson_SystemBackupProps(props),
    };
  }

  /**
   * Defines a "SystemBackup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SystemBackupProps = {}) {
    super(scope, id, {
      ...SystemBackup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SystemBackup.GVK,
      ...toJson_SystemBackupProps(resolved),
    };
  }
}

/**
 * SystemBackup is where Longhorn stores system backup object
 *
 * @schema SystemBackup
 */
export interface SystemBackupProps {
  /**
   * @schema SystemBackup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
   *
   * @schema SystemBackup#spec
   */
  readonly spec?: SystemBackupSpec;

}

/**
 * Converts an object of type 'SystemBackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemBackupProps(obj: SystemBackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SystemBackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
 *
 * @schema SystemBackupSpec
 */
export interface SystemBackupSpec {
  /**
   * The create volume backup policy
   * Can be "if-not-present", "always" or "disabled"
   *
   * @schema SystemBackupSpec#volumeBackupPolicy
   */
  readonly volumeBackupPolicy?: string;

}

/**
 * Converts an object of type 'SystemBackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemBackupSpec(obj: SystemBackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeBackupPolicy': obj.volumeBackupPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SystemRestore is where Longhorn stores system restore object
 *
 * @schema SystemRestore
 */
export class SystemRestore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SystemRestore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'SystemRestore',
  }

  /**
   * Renders a Kubernetes manifest for "SystemRestore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SystemRestoreProps = {}): any {
    return {
      ...SystemRestore.GVK,
      ...toJson_SystemRestoreProps(props),
    };
  }

  /**
   * Defines a "SystemRestore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SystemRestoreProps = {}) {
    super(scope, id, {
      ...SystemRestore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SystemRestore.GVK,
      ...toJson_SystemRestoreProps(resolved),
    };
  }
}

/**
 * SystemRestore is where Longhorn stores system restore object
 *
 * @schema SystemRestore
 */
export interface SystemRestoreProps {
  /**
   * @schema SystemRestore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
   *
   * @schema SystemRestore#spec
   */
  readonly spec?: SystemRestoreSpec;

}

/**
 * Converts an object of type 'SystemRestoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemRestoreProps(obj: SystemRestoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SystemRestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
 *
 * @schema SystemRestoreSpec
 */
export interface SystemRestoreSpec {
  /**
   * The system backup name in the object store.
   *
   * @schema SystemRestoreSpec#systemBackup
   */
  readonly systemBackup: string;

}

/**
 * Converts an object of type 'SystemRestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemRestoreSpec(obj: SystemRestoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'systemBackup': obj.systemBackup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema Volume
 */
export class Volume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Volume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta1',
    kind: 'Volume',
  }

  /**
   * Renders a Kubernetes manifest for "Volume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeProps = {}): any {
    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(props),
    };
  }

  /**
   * Defines a "Volume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeProps = {}) {
    super(scope, id, {
      ...Volume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(resolved),
    };
  }
}

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema Volume
 */
export interface VolumeProps {
  /**
   * @schema Volume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Volume#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'VolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeProps(obj: VolumeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema VolumeV1Beta2
 */
export class VolumeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'Volume',
  }

  /**
   * Renders a Kubernetes manifest for "VolumeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeV1Beta2Props = {}): any {
    return {
      ...VolumeV1Beta2.GVK,
      ...toJson_VolumeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "VolumeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeV1Beta2Props = {}) {
    super(scope, id, {
      ...VolumeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeV1Beta2.GVK,
      ...toJson_VolumeV1Beta2Props(resolved),
    };
  }
}

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema VolumeV1Beta2
 */
export interface VolumeV1Beta2Props {
  /**
   * @schema VolumeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeSpec defines the desired state of the Longhorn volume
   *
   * @schema VolumeV1Beta2#spec
   */
  readonly spec?: VolumeV1Beta2Spec;

}

/**
 * Converts an object of type 'VolumeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeV1Beta2Props(obj: VolumeV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VolumeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeSpec defines the desired state of the Longhorn volume
 *
 * @schema VolumeV1Beta2Spec
 */
export interface VolumeV1Beta2Spec {
  /**
   * @schema VolumeV1Beta2Spec#Standby
   */
  readonly standby?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#accessMode
   */
  readonly accessMode?: VolumeV1Beta2SpecAccessMode;

  /**
   * Deprecated:Replaced by field `dataEngine`.'
   *
   * @schema VolumeV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: string;

  /**
   * @schema VolumeV1Beta2Spec#backingImage
   */
  readonly backingImage?: string;

  /**
   * @schema VolumeV1Beta2Spec#backupCompressionMethod
   */
  readonly backupCompressionMethod?: VolumeV1Beta2SpecBackupCompressionMethod;

  /**
   * The backup target name that the volume will be backed up to or is synced.
   *
   * @schema VolumeV1Beta2Spec#backupTargetName
   */
  readonly backupTargetName?: string;

  /**
   * @schema VolumeV1Beta2Spec#dataEngine
   */
  readonly dataEngine?: VolumeV1Beta2SpecDataEngine;

  /**
   * @schema VolumeV1Beta2Spec#dataLocality
   */
  readonly dataLocality?: VolumeV1Beta2SpecDataLocality;

  /**
   * @schema VolumeV1Beta2Spec#dataSource
   */
  readonly dataSource?: string;

  /**
   * @schema VolumeV1Beta2Spec#disableFrontend
   */
  readonly disableFrontend?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#diskSelector
   */
  readonly diskSelector?: string[];

  /**
   * @schema VolumeV1Beta2Spec#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * Deprecated: Replaced by field `image`.
   *
   * @schema VolumeV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * Setting that freezes the filesystem on the root partition before a snapshot is created.
   *
   * @schema VolumeV1Beta2Spec#freezeFilesystemForSnapshot
   */
  readonly freezeFilesystemForSnapshot?: VolumeV1Beta2SpecFreezeFilesystemForSnapshot;

  /**
   * @schema VolumeV1Beta2Spec#fromBackup
   */
  readonly fromBackup?: string;

  /**
   * @schema VolumeV1Beta2Spec#frontend
   */
  readonly frontend?: VolumeV1Beta2SpecFrontend;

  /**
   * @schema VolumeV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema VolumeV1Beta2Spec#lastAttachedBy
   */
  readonly lastAttachedBy?: string;

  /**
   * @schema VolumeV1Beta2Spec#migratable
   */
  readonly migratable?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#migrationNodeID
   */
  readonly migrationNodeId?: string;

  /**
   * @schema VolumeV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema VolumeV1Beta2Spec#nodeSelector
   */
  readonly nodeSelector?: string[];

  /**
   * @schema VolumeV1Beta2Spec#numberOfReplicas
   */
  readonly numberOfReplicas?: number;

  /**
   * @schema VolumeV1Beta2Spec#replicaAutoBalance
   */
  readonly replicaAutoBalance?: VolumeV1Beta2SpecReplicaAutoBalance;

  /**
   * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
   *
   * @schema VolumeV1Beta2Spec#replicaDiskSoftAntiAffinity
   */
  readonly replicaDiskSoftAntiAffinity?: VolumeV1Beta2SpecReplicaDiskSoftAntiAffinity;

  /**
   * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
   *
   * @schema VolumeV1Beta2Spec#replicaSoftAntiAffinity
   */
  readonly replicaSoftAntiAffinity?: VolumeV1Beta2SpecReplicaSoftAntiAffinity;

  /**
   * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
   *
   * @schema VolumeV1Beta2Spec#replicaZoneSoftAntiAffinity
   */
  readonly replicaZoneSoftAntiAffinity?: VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity;

  /**
   * @schema VolumeV1Beta2Spec#restoreVolumeRecurringJob
   */
  readonly restoreVolumeRecurringJob?: VolumeV1Beta2SpecRestoreVolumeRecurringJob;

  /**
   * @schema VolumeV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#size
   */
  readonly size?: string;

  /**
   * @schema VolumeV1Beta2Spec#snapshotDataIntegrity
   */
  readonly snapshotDataIntegrity?: VolumeV1Beta2SpecSnapshotDataIntegrity;

  /**
   * @schema VolumeV1Beta2Spec#snapshotMaxCount
   */
  readonly snapshotMaxCount?: number;

  /**
   * @schema VolumeV1Beta2Spec#snapshotMaxSize
   */
  readonly snapshotMaxSize?: string;

  /**
   * @schema VolumeV1Beta2Spec#staleReplicaTimeout
   */
  readonly staleReplicaTimeout?: number;

  /**
   * @schema VolumeV1Beta2Spec#unmapMarkSnapChainRemoved
   */
  readonly unmapMarkSnapChainRemoved?: VolumeV1Beta2SpecUnmapMarkSnapChainRemoved;

}

/**
 * Converts an object of type 'VolumeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeV1Beta2Spec(obj: VolumeV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Standby': obj.standby,
    'accessMode': obj.accessMode,
    'backendStoreDriver': obj.backendStoreDriver,
    'backingImage': obj.backingImage,
    'backupCompressionMethod': obj.backupCompressionMethod,
    'backupTargetName': obj.backupTargetName,
    'dataEngine': obj.dataEngine,
    'dataLocality': obj.dataLocality,
    'dataSource': obj.dataSource,
    'disableFrontend': obj.disableFrontend,
    'diskSelector': obj.diskSelector?.map(y => y),
    'encrypted': obj.encrypted,
    'engineImage': obj.engineImage,
    'freezeFilesystemForSnapshot': obj.freezeFilesystemForSnapshot,
    'fromBackup': obj.fromBackup,
    'frontend': obj.frontend,
    'image': obj.image,
    'lastAttachedBy': obj.lastAttachedBy,
    'migratable': obj.migratable,
    'migrationNodeID': obj.migrationNodeId,
    'nodeID': obj.nodeId,
    'nodeSelector': obj.nodeSelector?.map(y => y),
    'numberOfReplicas': obj.numberOfReplicas,
    'replicaAutoBalance': obj.replicaAutoBalance,
    'replicaDiskSoftAntiAffinity': obj.replicaDiskSoftAntiAffinity,
    'replicaSoftAntiAffinity': obj.replicaSoftAntiAffinity,
    'replicaZoneSoftAntiAffinity': obj.replicaZoneSoftAntiAffinity,
    'restoreVolumeRecurringJob': obj.restoreVolumeRecurringJob,
    'revisionCounterDisabled': obj.revisionCounterDisabled,
    'size': obj.size,
    'snapshotDataIntegrity': obj.snapshotDataIntegrity,
    'snapshotMaxCount': obj.snapshotMaxCount,
    'snapshotMaxSize': obj.snapshotMaxSize,
    'staleReplicaTimeout': obj.staleReplicaTimeout,
    'unmapMarkSnapChainRemoved': obj.unmapMarkSnapChainRemoved,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeV1Beta2SpecAccessMode
 */
export enum VolumeV1Beta2SpecAccessMode {
  /** rwo */
  RWO = "rwo",
  /** rwx */
  RWX = "rwx",
}

/**
 * @schema VolumeV1Beta2SpecBackupCompressionMethod
 */
export enum VolumeV1Beta2SpecBackupCompressionMethod {
  /** none */
  NONE = "none",
  /** lz4 */
  LZ4 = "lz4",
  /** gzip */
  GZIP = "gzip",
}

/**
 * @schema VolumeV1Beta2SpecDataEngine
 */
export enum VolumeV1Beta2SpecDataEngine {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema VolumeV1Beta2SpecDataLocality
 */
export enum VolumeV1Beta2SpecDataLocality {
  /** disabled */
  DISABLED = "disabled",
  /** best-effort */
  BEST_HYPHEN_EFFORT = "best-effort",
  /** strict-local */
  STRICT_HYPHEN_LOCAL = "strict-local",
}

/**
 * Setting that freezes the filesystem on the root partition before a snapshot is created.
 *
 * @schema VolumeV1Beta2SpecFreezeFilesystemForSnapshot
 */
export enum VolumeV1Beta2SpecFreezeFilesystemForSnapshot {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * @schema VolumeV1Beta2SpecFrontend
 */
export enum VolumeV1Beta2SpecFrontend {
  /** blockdev */
  BLOCKDEV = "blockdev",
  /** iscsi */
  ISCSI = "iscsi",
  /** nvmf */
  NVMF = "nvmf",
}

/**
 * @schema VolumeV1Beta2SpecReplicaAutoBalance
 */
export enum VolumeV1Beta2SpecReplicaAutoBalance {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** least-effort */
  LEAST_HYPHEN_EFFORT = "least-effort",
  /** best-effort */
  BEST_HYPHEN_EFFORT = "best-effort",
}

/**
 * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
 *
 * @schema VolumeV1Beta2SpecReplicaDiskSoftAntiAffinity
 */
export enum VolumeV1Beta2SpecReplicaDiskSoftAntiAffinity {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
 *
 * @schema VolumeV1Beta2SpecReplicaSoftAntiAffinity
 */
export enum VolumeV1Beta2SpecReplicaSoftAntiAffinity {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
 *
 * @schema VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity
 */
export enum VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * @schema VolumeV1Beta2SpecRestoreVolumeRecurringJob
 */
export enum VolumeV1Beta2SpecRestoreVolumeRecurringJob {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * @schema VolumeV1Beta2SpecSnapshotDataIntegrity
 */
export enum VolumeV1Beta2SpecSnapshotDataIntegrity {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** enabled */
  ENABLED = "enabled",
  /** fast-check */
  FAST_HYPHEN_CHECK = "fast-check",
}

/**
 * @schema VolumeV1Beta2SpecUnmapMarkSnapChainRemoved
 */
export enum VolumeV1Beta2SpecUnmapMarkSnapChainRemoved {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** enabled */
  ENABLED = "enabled",
}


/**
 * VolumeAttachment stores attachment information of a Longhorn volume
 *
 * @schema VolumeAttachment
 */
export class VolumeAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'longhorn.io/v1beta2',
    kind: 'VolumeAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "VolumeAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeAttachmentProps = {}): any {
    return {
      ...VolumeAttachment.GVK,
      ...toJson_VolumeAttachmentProps(props),
    };
  }

  /**
   * Defines a "VolumeAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeAttachmentProps = {}) {
    super(scope, id, {
      ...VolumeAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeAttachment.GVK,
      ...toJson_VolumeAttachmentProps(resolved),
    };
  }
}

/**
 * VolumeAttachment stores attachment information of a Longhorn volume
 *
 * @schema VolumeAttachment
 */
export interface VolumeAttachmentProps {
  /**
   * @schema VolumeAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
   *
   * @schema VolumeAttachment#spec
   */
  readonly spec?: VolumeAttachmentSpec;

}

/**
 * Converts an object of type 'VolumeAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentProps(obj: VolumeAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VolumeAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
 *
 * @schema VolumeAttachmentSpec
 */
export interface VolumeAttachmentSpec {
  /**
   * @schema VolumeAttachmentSpec#attachmentTickets
   */
  readonly attachmentTickets?: { [key: string]: VolumeAttachmentSpecAttachmentTickets };

  /**
   * The name of Longhorn volume of this VolumeAttachment
   *
   * @schema VolumeAttachmentSpec#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'VolumeAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentSpec(obj: VolumeAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachmentTickets': ((obj.attachmentTickets) === undefined) ? undefined : (Object.entries(obj.attachmentTickets).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VolumeAttachmentSpecAttachmentTickets(i[1]) }), {})),
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeAttachmentSpecAttachmentTickets
 */
export interface VolumeAttachmentSpecAttachmentTickets {
  /**
   * A sequence number representing a specific generation of the desired state.
   * Populated by the system. Read-only.
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#generation
   */
  readonly generation?: number;

  /**
   * The unique ID of this attachment. Used to differentiate different attachments of the same volume.
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#id
   */
  readonly id?: string;

  /**
   * The node that this attachment is requesting
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#nodeID
   */
  readonly nodeId?: string;

  /**
   * Optional additional parameter for this attachment
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * @schema VolumeAttachmentSpecAttachmentTickets#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VolumeAttachmentSpecAttachmentTickets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentSpecAttachmentTickets(obj: VolumeAttachmentSpecAttachmentTickets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generation': obj.generation,
    'id': obj.id,
    'nodeID': obj.nodeId,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

