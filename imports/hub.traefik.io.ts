// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessControlPolicy defines an access control policy.
 *
 * @schema AccessControlPolicy
 */
export class AccessControlPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessControlPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'AccessControlPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AccessControlPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessControlPolicyProps = {}): any {
    return {
      ...AccessControlPolicy.GVK,
      ...toJson_AccessControlPolicyProps(props),
    };
  }

  /**
   * Defines a "AccessControlPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessControlPolicyProps = {}) {
    super(scope, id, {
      ...AccessControlPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessControlPolicy.GVK,
      ...toJson_AccessControlPolicyProps(resolved),
    };
  }
}

/**
 * AccessControlPolicy defines an access control policy.
 *
 * @schema AccessControlPolicy
 */
export interface AccessControlPolicyProps {
  /**
   * @schema AccessControlPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessControlPolicySpec configures an access control policy.
   *
   * @schema AccessControlPolicy#spec
   */
  readonly spec?: AccessControlPolicySpec;

}

/**
 * Converts an object of type 'AccessControlPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicyProps(obj: AccessControlPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessControlPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicySpec configures an access control policy.
 *
 * @schema AccessControlPolicySpec
 */
export interface AccessControlPolicySpec {
  /**
   * AccessControlPolicyAPIKey configure an APIKey control policy.
   *
   * @schema AccessControlPolicySpec#apiKey
   */
  readonly apiKey?: AccessControlPolicySpecApiKey;

  /**
   * AccessControlPolicyBasicAuth holds the HTTP basic authentication configuration.
   *
   * @schema AccessControlPolicySpec#basicAuth
   */
  readonly basicAuth?: AccessControlPolicySpecBasicAuth;

  /**
   * AccessControlPolicyJWT configures a JWT access control policy.
   *
   * @schema AccessControlPolicySpec#jwt
   */
  readonly jwt?: AccessControlPolicySpecJwt;

  /**
   * AccessControlOAuthIntro configures an OAuth 2.0 Token Introspection access control policy.
   *
   * @schema AccessControlPolicySpec#oAuthIntro
   */
  readonly oAuthIntro?: AccessControlPolicySpecOAuthIntro;

  /**
   * AccessControlPolicyOIDC holds the OIDC authentication configuration.
   *
   * @schema AccessControlPolicySpec#oidc
   */
  readonly oidc?: AccessControlPolicySpecOidc;

  /**
   * AccessControlPolicyOIDCGoogle holds the Google OIDC authentication configuration.
   *
   * @schema AccessControlPolicySpec#oidcGoogle
   */
  readonly oidcGoogle?: AccessControlPolicySpecOidcGoogle;

}

/**
 * Converts an object of type 'AccessControlPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpec(obj: AccessControlPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_AccessControlPolicySpecApiKey(obj.apiKey),
    'basicAuth': toJson_AccessControlPolicySpecBasicAuth(obj.basicAuth),
    'jwt': toJson_AccessControlPolicySpecJwt(obj.jwt),
    'oAuthIntro': toJson_AccessControlPolicySpecOAuthIntro(obj.oAuthIntro),
    'oidc': toJson_AccessControlPolicySpecOidc(obj.oidc),
    'oidcGoogle': toJson_AccessControlPolicySpecOidcGoogle(obj.oidcGoogle),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyAPIKey configure an APIKey control policy.
 *
 * @schema AccessControlPolicySpecApiKey
 */
export interface AccessControlPolicySpecApiKey {
  /**
   * ForwardHeaders instructs the middleware to forward key metadata as header values upon successful authentication.
   *
   * @schema AccessControlPolicySpecApiKey#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * KeySource defines how to extract API keys from requests.
   *
   * @schema AccessControlPolicySpecApiKey#keySource
   */
  readonly keySource: AccessControlPolicySpecApiKeyKeySource;

  /**
   * Keys define the set of authorized keys to access a protected resource.
   *
   * @schema AccessControlPolicySpecApiKey#keys
   */
  readonly keys?: AccessControlPolicySpecApiKeyKeys[];

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecApiKey(obj: AccessControlPolicySpecApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keySource': toJson_AccessControlPolicySpecApiKeyKeySource(obj.keySource),
    'keys': obj.keys?.map(y => toJson_AccessControlPolicySpecApiKeyKeys(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyBasicAuth holds the HTTP basic authentication configuration.
 *
 * @schema AccessControlPolicySpecBasicAuth
 */
export interface AccessControlPolicySpecBasicAuth {
  /**
   * @schema AccessControlPolicySpecBasicAuth#forwardUsernameHeader
   */
  readonly forwardUsernameHeader?: string;

  /**
   * @schema AccessControlPolicySpecBasicAuth#realm
   */
  readonly realm?: string;

  /**
   * @schema AccessControlPolicySpecBasicAuth#stripAuthorizationHeader
   */
  readonly stripAuthorizationHeader?: boolean;

  /**
   * @schema AccessControlPolicySpecBasicAuth#users
   */
  readonly users?: string[];

}

/**
 * Converts an object of type 'AccessControlPolicySpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecBasicAuth(obj: AccessControlPolicySpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardUsernameHeader': obj.forwardUsernameHeader,
    'realm': obj.realm,
    'stripAuthorizationHeader': obj.stripAuthorizationHeader,
    'users': obj.users?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyJWT configures a JWT access control policy.
 *
 * @schema AccessControlPolicySpecJwt
 */
export interface AccessControlPolicySpecJwt {
  /**
   * @schema AccessControlPolicySpecJwt#claims
   */
  readonly claims?: string;

  /**
   * @schema AccessControlPolicySpecJwt#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecJwt#jwksFile
   */
  readonly jwksFile?: string;

  /**
   * @schema AccessControlPolicySpecJwt#jwksUrl
   */
  readonly jwksUrl?: string;

  /**
   * @schema AccessControlPolicySpecJwt#publicKey
   */
  readonly publicKey?: string;

  /**
   * @schema AccessControlPolicySpecJwt#signingSecret
   */
  readonly signingSecret?: string;

  /**
   * @schema AccessControlPolicySpecJwt#signingSecretBase64Encoded
   */
  readonly signingSecretBase64Encoded?: boolean;

  /**
   * @schema AccessControlPolicySpecJwt#stripAuthorizationHeader
   */
  readonly stripAuthorizationHeader?: boolean;

  /**
   * @schema AccessControlPolicySpecJwt#tokenQueryKey
   */
  readonly tokenQueryKey?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecJwt(obj: AccessControlPolicySpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims,
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'jwksFile': obj.jwksFile,
    'jwksUrl': obj.jwksUrl,
    'publicKey': obj.publicKey,
    'signingSecret': obj.signingSecret,
    'signingSecretBase64Encoded': obj.signingSecretBase64Encoded,
    'stripAuthorizationHeader': obj.stripAuthorizationHeader,
    'tokenQueryKey': obj.tokenQueryKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlOAuthIntro configures an OAuth 2.0 Token Introspection access control policy.
 *
 * @schema AccessControlPolicySpecOAuthIntro
 */
export interface AccessControlPolicySpecOAuthIntro {
  /**
   * @schema AccessControlPolicySpecOAuthIntro#claims
   */
  readonly claims?: string;

  /**
   * AccessControlOAuthIntroClientConfig configures the OAuth 2.0 client for issuing token introspection requests.
   *
   * @schema AccessControlPolicySpecOAuthIntro#clientConfig
   */
  readonly clientConfig: AccessControlPolicySpecOAuthIntroClientConfig;

  /**
   * @schema AccessControlPolicySpecOAuthIntro#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * TokenSource describes how to extract tokens from HTTP requests.
   * If multiple sources are set, the order is the following: header > query > cookie.
   *
   * @schema AccessControlPolicySpecOAuthIntro#tokenSource
   */
  readonly tokenSource: AccessControlPolicySpecOAuthIntroTokenSource;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntro' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOAuthIntro(obj: AccessControlPolicySpecOAuthIntro | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims,
    'clientConfig': toJson_AccessControlPolicySpecOAuthIntroClientConfig(obj.clientConfig),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tokenSource': toJson_AccessControlPolicySpecOAuthIntroTokenSource(obj.tokenSource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyOIDC holds the OIDC authentication configuration.
 *
 * @schema AccessControlPolicySpecOidc
 */
export interface AccessControlPolicySpecOidc {
  /**
   * @schema AccessControlPolicySpecOidc#authParams
   */
  readonly authParams?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidc#claims
   */
  readonly claims?: string;

  /**
   * @schema AccessControlPolicySpecOidc#clientId
   */
  readonly clientId?: string;

  /**
   * @schema AccessControlPolicySpecOidc#disableAuthRedirectionPaths
   */
  readonly disableAuthRedirectionPaths?: string[];

  /**
   * @schema AccessControlPolicySpecOidc#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidc#issuer
   */
  readonly issuer?: string;

  /**
   * @schema AccessControlPolicySpecOidc#logoutUrl
   */
  readonly logoutUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidc#redirectUrl
   */
  readonly redirectUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidc#scopes
   */
  readonly scopes?: string[];

  /**
   * SecretReference represents a Secret Reference. It has enough information to retrieve secret
   * in any namespace
   *
   * @schema AccessControlPolicySpecOidc#secret
   */
  readonly secret?: AccessControlPolicySpecOidcSecret;

  /**
   * Session holds session configuration.
   *
   * @schema AccessControlPolicySpecOidc#session
   */
  readonly session?: AccessControlPolicySpecOidcSession;

  /**
   * StateCookie holds state cookie configuration.
   *
   * @schema AccessControlPolicySpecOidc#stateCookie
   */
  readonly stateCookie?: AccessControlPolicySpecOidcStateCookie;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidc(obj: AccessControlPolicySpecOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authParams': ((obj.authParams) === undefined) ? undefined : (Object.entries(obj.authParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'claims': obj.claims,
    'clientId': obj.clientId,
    'disableAuthRedirectionPaths': obj.disableAuthRedirectionPaths?.map(y => y),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'issuer': obj.issuer,
    'logoutUrl': obj.logoutUrl,
    'redirectUrl': obj.redirectUrl,
    'scopes': obj.scopes?.map(y => y),
    'secret': toJson_AccessControlPolicySpecOidcSecret(obj.secret),
    'session': toJson_AccessControlPolicySpecOidcSession(obj.session),
    'stateCookie': toJson_AccessControlPolicySpecOidcStateCookie(obj.stateCookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyOIDCGoogle holds the Google OIDC authentication configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogle
 */
export interface AccessControlPolicySpecOidcGoogle {
  /**
   * @schema AccessControlPolicySpecOidcGoogle#authParams
   */
  readonly authParams?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidcGoogle#clientId
   */
  readonly clientId?: string;

  /**
   * Emails are the allowed emails to connect.
   *
   * @schema AccessControlPolicySpecOidcGoogle#emails
   */
  readonly emails?: string[];

  /**
   * @schema AccessControlPolicySpecOidcGoogle#forwardHeaders
   */
  readonly forwardHeaders?: { [key: string]: string };

  /**
   * @schema AccessControlPolicySpecOidcGoogle#logoutUrl
   */
  readonly logoutUrl?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogle#redirectUrl
   */
  readonly redirectUrl?: string;

  /**
   * SecretReference represents a Secret Reference. It has enough information to retrieve secret
   * in any namespace
   *
   * @schema AccessControlPolicySpecOidcGoogle#secret
   */
  readonly secret?: AccessControlPolicySpecOidcGoogleSecret;

  /**
   * Session holds session configuration.
   *
   * @schema AccessControlPolicySpecOidcGoogle#session
   */
  readonly session?: AccessControlPolicySpecOidcGoogleSession;

  /**
   * StateCookie holds state cookie configuration.
   *
   * @schema AccessControlPolicySpecOidcGoogle#stateCookie
   */
  readonly stateCookie?: AccessControlPolicySpecOidcGoogleStateCookie;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcGoogle(obj: AccessControlPolicySpecOidcGoogle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authParams': ((obj.authParams) === undefined) ? undefined : (Object.entries(obj.authParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'clientId': obj.clientId,
    'emails': obj.emails?.map(y => y),
    'forwardHeaders': ((obj.forwardHeaders) === undefined) ? undefined : (Object.entries(obj.forwardHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'logoutUrl': obj.logoutUrl,
    'redirectUrl': obj.redirectUrl,
    'secret': toJson_AccessControlPolicySpecOidcGoogleSecret(obj.secret),
    'session': toJson_AccessControlPolicySpecOidcGoogleSession(obj.session),
    'stateCookie': toJson_AccessControlPolicySpecOidcGoogleStateCookie(obj.stateCookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySource defines how to extract API keys from requests.
 *
 * @schema AccessControlPolicySpecApiKeyKeySource
 */
export interface AccessControlPolicySpecApiKeyKeySource {
  /**
   * Cookie is the name of a cookie.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#cookie
   */
  readonly cookie?: string;

  /**
   * Header is the name of a header.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#header
   */
  readonly header?: string;

  /**
   * HeaderAuthScheme sets an optional auth scheme when Header is set to "Authorization".
   * If set, this scheme is removed from the token, and all requests not including it are dropped.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#headerAuthScheme
   */
  readonly headerAuthScheme?: string;

  /**
   * Query is the name of a query parameter.
   *
   * @schema AccessControlPolicySpecApiKeyKeySource#query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKeyKeySource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecApiKeyKeySource(obj: AccessControlPolicySpecApiKeyKeySource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': obj.cookie,
    'header': obj.header,
    'headerAuthScheme': obj.headerAuthScheme,
    'query': obj.query,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlPolicyAPIKeyKey defines an API key.
 *
 * @schema AccessControlPolicySpecApiKeyKeys
 */
export interface AccessControlPolicySpecApiKeyKeys {
  /**
   * ID is the unique identifier of the key.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#id
   */
  readonly id: string;

  /**
   * Metadata holds arbitrary metadata for this key, can be used by ForwardHeaders.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Value is the SHAKE-256 hash (using 64 bytes) of the API key.
   *
   * @schema AccessControlPolicySpecApiKeyKeys#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecApiKeyKeys' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecApiKeyKeys(obj: AccessControlPolicySpecApiKeyKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControlOAuthIntroClientConfig configures the OAuth 2.0 client for issuing token introspection requests.
 *
 * @schema AccessControlPolicySpecOAuthIntroClientConfig
 */
export interface AccessControlPolicySpecOAuthIntroClientConfig {
  /**
   * Headers to set when sending requests to the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MaxRetries defines the number of retries for introspection requests.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * TimeoutSeconds configures the maximum amount of seconds to wait before giving up on requests.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * TLS configures TLS communication with the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#tls
   */
  readonly tls?: AccessControlPolicySpecOAuthIntroClientConfigTls;

  /**
   * TokenTypeHint is a hint to pass to the Authorization Server.
   * See https://tools.ietf.org/html/rfc7662#section-2.1 for more information.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#tokenTypeHint
   */
  readonly tokenTypeHint?: string;

  /**
   * URL of the Authorization Server.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfig#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOAuthIntroClientConfig(obj: AccessControlPolicySpecOAuthIntroClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maxRetries': obj.maxRetries,
    'timeoutSeconds': obj.timeoutSeconds,
    'tls': toJson_AccessControlPolicySpecOAuthIntroClientConfigTls(obj.tls),
    'tokenTypeHint': obj.tokenTypeHint,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSource describes how to extract tokens from HTTP requests.
 * If multiple sources are set, the order is the following: header > query > cookie.
 *
 * @schema AccessControlPolicySpecOAuthIntroTokenSource
 */
export interface AccessControlPolicySpecOAuthIntroTokenSource {
  /**
   * Cookie is the name of a cookie.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#cookie
   */
  readonly cookie?: string;

  /**
   * Header is the name of a header.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#header
   */
  readonly header?: string;

  /**
   * HeaderAuthScheme sets an optional auth scheme when Header is set to "Authorization".
   * If set, this scheme is removed from the token, and all requests not including it are dropped.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#headerAuthScheme
   */
  readonly headerAuthScheme?: string;

  /**
   * Query is the name of a query parameter.
   *
   * @schema AccessControlPolicySpecOAuthIntroTokenSource#query
   */
  readonly query?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroTokenSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOAuthIntroTokenSource(obj: AccessControlPolicySpecOAuthIntroTokenSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': obj.cookie,
    'header': obj.header,
    'headerAuthScheme': obj.headerAuthScheme,
    'query': obj.query,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 *
 * @schema AccessControlPolicySpecOidcSecret
 */
export interface AccessControlPolicySpecOidcSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema AccessControlPolicySpecOidcSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema AccessControlPolicySpecOidcSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcSecret(obj: AccessControlPolicySpecOidcSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Session holds session configuration.
 *
 * @schema AccessControlPolicySpecOidcSession
 */
export interface AccessControlPolicySpecOidcSession {
  /**
   * @schema AccessControlPolicySpecOidcSession#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#refresh
   */
  readonly refresh?: boolean;

  /**
   * @schema AccessControlPolicySpecOidcSession#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcSession#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcSession' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcSession(obj: AccessControlPolicySpecOidcSession | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'refresh': obj.refresh,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StateCookie holds state cookie configuration.
 *
 * @schema AccessControlPolicySpecOidcStateCookie
 */
export interface AccessControlPolicySpecOidcStateCookie {
  /**
   * @schema AccessControlPolicySpecOidcStateCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcStateCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcStateCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcStateCookie(obj: AccessControlPolicySpecOidcStateCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 *
 * @schema AccessControlPolicySpecOidcGoogleSecret
 */
export interface AccessControlPolicySpecOidcGoogleSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema AccessControlPolicySpecOidcGoogleSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema AccessControlPolicySpecOidcGoogleSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcGoogleSecret(obj: AccessControlPolicySpecOidcGoogleSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Session holds session configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogleSession
 */
export interface AccessControlPolicySpecOidcGoogleSession {
  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#refresh
   */
  readonly refresh?: boolean;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleSession#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleSession' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcGoogleSession(obj: AccessControlPolicySpecOidcGoogleSession | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'refresh': obj.refresh,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StateCookie holds state cookie configuration.
 *
 * @schema AccessControlPolicySpecOidcGoogleStateCookie
 */
export interface AccessControlPolicySpecOidcGoogleStateCookie {
  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#path
   */
  readonly path?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema AccessControlPolicySpecOidcGoogleStateCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOidcGoogleStateCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOidcGoogleStateCookie(obj: AccessControlPolicySpecOidcGoogleStateCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configures TLS communication with the Authorization Server.
 *
 * @schema AccessControlPolicySpecOAuthIntroClientConfigTls
 */
export interface AccessControlPolicySpecOAuthIntroClientConfigTls {
  /**
   * CA sets the CA bundle used to sign the Authorization Server certificate.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfigTls#ca
   */
  readonly ca?: string;

  /**
   * InsecureSkipVerify skips the Authorization Server certificate validation.
   * For testing purposes only, do not use in production.
   *
   * @schema AccessControlPolicySpecOAuthIntroClientConfigTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

}

/**
 * Converts an object of type 'AccessControlPolicySpecOAuthIntroClientConfigTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessControlPolicySpecOAuthIntroClientConfigTls(obj: AccessControlPolicySpecOAuthIntroClientConfigTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': obj.ca,
    'insecureSkipVerify': obj.insecureSkipVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * AIService is a Kubernetes-like Service to interact with a text-based LLM provider. It defines the parameters and credentials required to interact with various LLM providers.
 *
 * @schema AIService
 */
export class AiService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AIService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'AIService',
  }

  /**
   * Renders a Kubernetes manifest for "AIService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AiServiceProps = {}): any {
    return {
      ...AiService.GVK,
      ...toJson_AiServiceProps(props),
    };
  }

  /**
   * Defines a "AIService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AiServiceProps = {}) {
    super(scope, id, {
      ...AiService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AiService.GVK,
      ...toJson_AiServiceProps(resolved),
    };
  }
}

/**
 * AIService is a Kubernetes-like Service to interact with a text-based LLM provider. It defines the parameters and credentials required to interact with various LLM providers.
 *
 * @schema AIService
 */
export interface AiServiceProps {
  /**
   * @schema AIService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this AIService.
   *
   * @schema AIService#spec
   */
  readonly spec?: AiServiceSpec;

}

/**
 * Converts an object of type 'AiServiceProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceProps(obj: AiServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AiServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this AIService.
 *
 * @schema AiServiceSpec
 */
export interface AiServiceSpec {
  /**
   * Anthropic configures Anthropic backend.
   *
   * @schema AiServiceSpec#anthropic
   */
  readonly anthropic?: AiServiceSpecAnthropic;

  /**
   * AzureOpenAI configures AzureOpenAI.
   *
   * @schema AiServiceSpec#azureOpenai
   */
  readonly azureOpenai?: AiServiceSpecAzureOpenai;

  /**
   * Bedrock configures Bedrock backend.
   *
   * @schema AiServiceSpec#bedrock
   */
  readonly bedrock?: AiServiceSpecBedrock;

  /**
   * Cohere configures Cohere backend.
   *
   * @schema AiServiceSpec#cohere
   */
  readonly cohere?: AiServiceSpecCohere;

  /**
   * Gemini configures Gemini backend.
   *
   * @schema AiServiceSpec#gemini
   */
  readonly gemini?: AiServiceSpecGemini;

  /**
   * Mistral configures Mistral AI backend.
   *
   * @schema AiServiceSpec#mistral
   */
  readonly mistral?: AiServiceSpecMistral;

  /**
   * Ollama configures Ollama backend.
   *
   * @schema AiServiceSpec#ollama
   */
  readonly ollama?: AiServiceSpecOllama;

  /**
   * OpenAI configures OpenAI.
   *
   * @schema AiServiceSpec#openai
   */
  readonly openai?: AiServiceSpecOpenai;

}

/**
 * Converts an object of type 'AiServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpec(obj: AiServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anthropic': toJson_AiServiceSpecAnthropic(obj.anthropic),
    'azureOpenai': toJson_AiServiceSpecAzureOpenai(obj.azureOpenai),
    'bedrock': toJson_AiServiceSpecBedrock(obj.bedrock),
    'cohere': toJson_AiServiceSpecCohere(obj.cohere),
    'gemini': toJson_AiServiceSpecGemini(obj.gemini),
    'mistral': toJson_AiServiceSpecMistral(obj.mistral),
    'ollama': toJson_AiServiceSpecOllama(obj.ollama),
    'openai': toJson_AiServiceSpecOpenai(obj.openai),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Anthropic configures Anthropic backend.
 *
 * @schema AiServiceSpecAnthropic
 */
export interface AiServiceSpecAnthropic {
  /**
   * @schema AiServiceSpecAnthropic#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecAnthropic#params
   */
  readonly params?: AiServiceSpecAnthropicParams;

  /**
   * @schema AiServiceSpecAnthropic#token
   */
  readonly token: string;

}

/**
 * Converts an object of type 'AiServiceSpecAnthropic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecAnthropic(obj: AiServiceSpecAnthropic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecAnthropicParams(obj.params),
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureOpenAI configures AzureOpenAI.
 *
 * @schema AiServiceSpecAzureOpenai
 */
export interface AiServiceSpecAzureOpenai {
  /**
   * @schema AiServiceSpecAzureOpenai#apiKey
   */
  readonly apiKey: string;

  /**
   * @schema AiServiceSpecAzureOpenai#baseUrl
   */
  readonly baseUrl: string;

  /**
   * @schema AiServiceSpecAzureOpenai#deploymentName
   */
  readonly deploymentName: string;

  /**
   * @schema AiServiceSpecAzureOpenai#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecAzureOpenai#params
   */
  readonly params?: AiServiceSpecAzureOpenaiParams;

}

/**
 * Converts an object of type 'AiServiceSpecAzureOpenai' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecAzureOpenai(obj: AiServiceSpecAzureOpenai | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'baseUrl': obj.baseUrl,
    'deploymentName': obj.deploymentName,
    'model': obj.model,
    'params': toJson_AiServiceSpecAzureOpenaiParams(obj.params),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bedrock configures Bedrock backend.
 *
 * @schema AiServiceSpecBedrock
 */
export interface AiServiceSpecBedrock {
  /**
   * @schema AiServiceSpecBedrock#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecBedrock#params
   */
  readonly params?: AiServiceSpecBedrockParams;

  /**
   * @schema AiServiceSpecBedrock#region
   */
  readonly region?: string;

  /**
   * @schema AiServiceSpecBedrock#systemMessage
   */
  readonly systemMessage?: boolean;

}

/**
 * Converts an object of type 'AiServiceSpecBedrock' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecBedrock(obj: AiServiceSpecBedrock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecBedrockParams(obj.params),
    'region': obj.region,
    'systemMessage': obj.systemMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cohere configures Cohere backend.
 *
 * @schema AiServiceSpecCohere
 */
export interface AiServiceSpecCohere {
  /**
   * @schema AiServiceSpecCohere#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecCohere#params
   */
  readonly params?: AiServiceSpecCohereParams;

  /**
   * @schema AiServiceSpecCohere#token
   */
  readonly token: string;

}

/**
 * Converts an object of type 'AiServiceSpecCohere' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecCohere(obj: AiServiceSpecCohere | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecCohereParams(obj.params),
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Gemini configures Gemini backend.
 *
 * @schema AiServiceSpecGemini
 */
export interface AiServiceSpecGemini {
  /**
   * @schema AiServiceSpecGemini#apiKey
   */
  readonly apiKey: string;

  /**
   * @schema AiServiceSpecGemini#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecGemini#params
   */
  readonly params?: AiServiceSpecGeminiParams;

}

/**
 * Converts an object of type 'AiServiceSpecGemini' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecGemini(obj: AiServiceSpecGemini | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'model': obj.model,
    'params': toJson_AiServiceSpecGeminiParams(obj.params),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mistral configures Mistral AI backend.
 *
 * @schema AiServiceSpecMistral
 */
export interface AiServiceSpecMistral {
  /**
   * @schema AiServiceSpecMistral#apiKey
   */
  readonly apiKey: string;

  /**
   * @schema AiServiceSpecMistral#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecMistral#params
   */
  readonly params?: AiServiceSpecMistralParams;

}

/**
 * Converts an object of type 'AiServiceSpecMistral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecMistral(obj: AiServiceSpecMistral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'model': obj.model,
    'params': toJson_AiServiceSpecMistralParams(obj.params),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ollama configures Ollama backend.
 *
 * @schema AiServiceSpecOllama
 */
export interface AiServiceSpecOllama {
  /**
   * @schema AiServiceSpecOllama#baseUrl
   */
  readonly baseUrl: string;

  /**
   * @schema AiServiceSpecOllama#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecOllama#params
   */
  readonly params?: AiServiceSpecOllamaParams;

}

/**
 * Converts an object of type 'AiServiceSpecOllama' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecOllama(obj: AiServiceSpecOllama | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'model': obj.model,
    'params': toJson_AiServiceSpecOllamaParams(obj.params),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenAI configures OpenAI.
 *
 * @schema AiServiceSpecOpenai
 */
export interface AiServiceSpecOpenai {
  /**
   * @schema AiServiceSpecOpenai#model
   */
  readonly model?: string;

  /**
   * Params holds the LLM hyperparameters.
   *
   * @schema AiServiceSpecOpenai#params
   */
  readonly params?: AiServiceSpecOpenaiParams;

  /**
   * @schema AiServiceSpecOpenai#token
   */
  readonly token: string;

}

/**
 * Converts an object of type 'AiServiceSpecOpenai' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecOpenai(obj: AiServiceSpecOpenai | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'model': obj.model,
    'params': toJson_AiServiceSpecOpenaiParams(obj.params),
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecAnthropicParams
 */
export interface AiServiceSpecAnthropicParams {
  /**
   * @schema AiServiceSpecAnthropicParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecAnthropicParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecAnthropicParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecAnthropicParams(obj: AiServiceSpecAnthropicParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecAzureOpenaiParams
 */
export interface AiServiceSpecAzureOpenaiParams {
  /**
   * @schema AiServiceSpecAzureOpenaiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecAzureOpenaiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecAzureOpenaiParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecAzureOpenaiParams(obj: AiServiceSpecAzureOpenaiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecBedrockParams
 */
export interface AiServiceSpecBedrockParams {
  /**
   * @schema AiServiceSpecBedrockParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecBedrockParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecBedrockParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecBedrockParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecBedrockParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecBedrockParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecBedrockParams(obj: AiServiceSpecBedrockParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecCohereParams
 */
export interface AiServiceSpecCohereParams {
  /**
   * @schema AiServiceSpecCohereParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecCohereParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecCohereParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecCohereParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecCohereParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecCohereParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecCohereParams(obj: AiServiceSpecCohereParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecGeminiParams
 */
export interface AiServiceSpecGeminiParams {
  /**
   * @schema AiServiceSpecGeminiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecGeminiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecGeminiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecGeminiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecGeminiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecGeminiParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecGeminiParams(obj: AiServiceSpecGeminiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecMistralParams
 */
export interface AiServiceSpecMistralParams {
  /**
   * @schema AiServiceSpecMistralParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecMistralParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecMistralParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecMistralParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecMistralParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecMistralParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecMistralParams(obj: AiServiceSpecMistralParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecOllamaParams
 */
export interface AiServiceSpecOllamaParams {
  /**
   * @schema AiServiceSpecOllamaParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecOllamaParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecOllamaParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecOllamaParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecOllamaParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecOllamaParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecOllamaParams(obj: AiServiceSpecOllamaParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Params holds the LLM hyperparameters.
 *
 * @schema AiServiceSpecOpenaiParams
 */
export interface AiServiceSpecOpenaiParams {
  /**
   * @schema AiServiceSpecOpenaiParams#frequencyPenalty
   */
  readonly frequencyPenalty?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#presencePenalty
   */
  readonly presencePenalty?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#temperature
   */
  readonly temperature?: number;

  /**
   * @schema AiServiceSpecOpenaiParams#topP
   */
  readonly topP?: number;

}

/**
 * Converts an object of type 'AiServiceSpecOpenaiParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AiServiceSpecOpenaiParams(obj: AiServiceSpecOpenaiParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'presencePenalty': obj.presencePenalty,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * API defines an HTTP interface that is exposed to external clients. It specifies the supported versions
and provides instructions for accessing its documentation. Once instantiated, an API object is associated
with an Ingress, IngressRoute, or HTTPRoute resource, enabling the exposure of the described API to the outside world.
 *
 * @schema API
 */
export class Api extends ApiObject {
  /**
   * Returns the apiVersion and kind for "API"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'API',
  }

  /**
   * Renders a Kubernetes manifest for "API".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiProps = {}): any {
    return {
      ...Api.GVK,
      ...toJson_ApiProps(props),
    };
  }

  /**
   * Defines a "API" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiProps = {}) {
    super(scope, id, {
      ...Api.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Api.GVK,
      ...toJson_ApiProps(resolved),
    };
  }
}

/**
 * API defines an HTTP interface that is exposed to external clients. It specifies the supported versions
 * and provides instructions for accessing its documentation. Once instantiated, an API object is associated
 * with an Ingress, IngressRoute, or HTTPRoute resource, enabling the exposure of the described API to the outside world.
 *
 * @schema API
 */
export interface ApiProps {
  /**
   * @schema API#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APISpec describes the API.
   *
   * @schema API#spec
   */
  readonly spec?: ApiSpec;

}

/**
 * Converts an object of type 'ApiProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiProps(obj: ApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISpec describes the API.
 *
 * @schema ApiSpec
 */
export interface ApiSpec {
  /**
   * OpenAPISpec defines the API contract as an OpenAPI specification.
   *
   * @schema ApiSpec#openApiSpec
   */
  readonly openApiSpec?: ApiSpecOpenApiSpec;

  /**
   * Versions are the different APIVersions available.
   *
   * @schema ApiSpec#versions
   */
  readonly versions?: ApiSpecVersions[];

}

/**
 * Converts an object of type 'ApiSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpec(obj: ApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openApiSpec': toJson_ApiSpecOpenApiSpec(obj.openApiSpec),
    'versions': obj.versions?.map(y => toJson_ApiSpecVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenAPISpec defines the API contract as an OpenAPI specification.
 *
 * @schema ApiSpecOpenApiSpec
 */
export interface ApiSpecOpenApiSpec {
  /**
   * OperationSets defines the sets of operations to be referenced for granular filtering in APIAccesses.
   *
   * @schema ApiSpecOpenApiSpec#operationSets
   */
  readonly operationSets?: ApiSpecOpenApiSpecOperationSets[];

  /**
   * Override holds data used to override OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#override
   */
  readonly override?: ApiSpecOpenApiSpecOverride;

  /**
   * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
   * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
   * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
   * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#path
   */
  readonly path?: string;

  /**
   * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
   * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiSpecOpenApiSpec#url
   */
  readonly url?: string;

  /**
   * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
   * This option overrides the default behavior configured in the static configuration.
   *
   * @schema ApiSpecOpenApiSpec#validateRequestMethodAndPath
   */
  readonly validateRequestMethodAndPath?: boolean;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecOpenApiSpec(obj: ApiSpecOpenApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operationSets': obj.operationSets?.map(y => toJson_ApiSpecOpenApiSpecOperationSets(y)),
    'override': toJson_ApiSpecOpenApiSpecOverride(obj.override),
    'path': obj.path,
    'url': obj.url,
    'validateRequestMethodAndPath': obj.validateRequestMethodAndPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIVersionRef references an APIVersion.
 *
 * @schema ApiSpecVersions
 */
export interface ApiSpecVersions {
  /**
   * Name of the APIVersion.
   *
   * @schema ApiSpecVersions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecVersions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecVersions(obj: ApiSpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationSet gives a name to a set of matching OpenAPI operations.
 * This set of operations can then be referenced for granular filtering in APIAccesses.
 *
 * @schema ApiSpecOpenApiSpecOperationSets
 */
export interface ApiSpecOpenApiSpecOperationSets {
  /**
   * Matchers defines a list of alternative rules for matching OpenAPI operations.
   *
   * @schema ApiSpecOpenApiSpecOperationSets#matchers
   */
  readonly matchers: ApiSpecOpenApiSpecOperationSetsMatchers[];

  /**
   * Name is the name of the OperationSet to reference in APIAccesses.
   *
   * @schema ApiSpecOpenApiSpecOperationSets#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOperationSets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecOpenApiSpecOperationSets(obj: ApiSpecOpenApiSpecOperationSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchers': obj.matchers?.map(y => toJson_ApiSpecOpenApiSpecOperationSetsMatchers(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Override holds data used to override OpenAPI specification.
 *
 * @schema ApiSpecOpenApiSpecOverride
 */
export interface ApiSpecOpenApiSpecOverride {
  /**
   * @schema ApiSpecOpenApiSpecOverride#servers
   */
  readonly servers: ApiSpecOpenApiSpecOverrideServers[];

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecOpenApiSpecOverride(obj: ApiSpecOpenApiSpecOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'servers': obj.servers?.map(y => toJson_ApiSpecOpenApiSpecOverrideServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationMatcher defines criteria for matching an OpenAPI operation.
 *
 * @schema ApiSpecOpenApiSpecOperationSetsMatchers
 */
export interface ApiSpecOpenApiSpecOperationSetsMatchers {
  /**
   * Methods specifies the HTTP methods to be included for selection.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#methods
   */
  readonly methods?: string[];

  /**
   * Path specifies the exact path of the operations to select.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#path
   */
  readonly path?: string;

  /**
   * PathPrefix specifies the path prefix of the operations to select.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * PathRegex specifies a regular expression pattern for matching operations based on their paths.
   *
   * @schema ApiSpecOpenApiSpecOperationSetsMatchers#pathRegex
   */
  readonly pathRegex?: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOperationSetsMatchers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecOpenApiSpecOperationSetsMatchers(obj: ApiSpecOpenApiSpecOperationSetsMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methods': obj.methods?.map(y => y),
    'path': obj.path,
    'pathPrefix': obj.pathPrefix,
    'pathRegex': obj.pathRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ApiSpecOpenApiSpecOverrideServers
 */
export interface ApiSpecOpenApiSpecOverrideServers {
  /**
   * @schema ApiSpecOpenApiSpecOverrideServers#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ApiSpecOpenApiSpecOverrideServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiSpecOpenApiSpecOverrideServers(obj: ApiSpecOpenApiSpecOverrideServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIAccess defines who can access to a set of APIs.
 *
 * @schema APIAccess
 */
export class ApiAccess extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIAccess"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIAccess',
  }

  /**
   * Renders a Kubernetes manifest for "APIAccess".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiAccessProps = {}): any {
    return {
      ...ApiAccess.GVK,
      ...toJson_ApiAccessProps(props),
    };
  }

  /**
   * Defines a "APIAccess" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiAccessProps = {}) {
    super(scope, id, {
      ...ApiAccess.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiAccess.GVK,
      ...toJson_ApiAccessProps(resolved),
    };
  }
}

/**
 * APIAccess defines who can access to a set of APIs.
 *
 * @schema APIAccess
 */
export interface ApiAccessProps {
  /**
   * @schema APIAccess#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIAccess.
   *
   * @schema APIAccess#spec
   */
  readonly spec?: ApiAccessSpec;

}

/**
 * Converts an object of type 'ApiAccessProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessProps(obj: ApiAccessProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiAccessSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIAccess.
 *
 * @schema ApiAccessSpec
 */
export interface ApiAccessSpec {
  /**
   * APIBundles defines a set of APIBundle that will be accessible to the configured audience.
   * Multiple APIAccesses can select the same APIBundles.
   *
   * @schema ApiAccessSpec#apiBundles
   */
  readonly apiBundles?: ApiAccessSpecApiBundles[];

  /**
   * APIPlan defines which APIPlan will be used.
   *
   * @schema ApiAccessSpec#apiPlan
   */
  readonly apiPlan?: ApiAccessSpecApiPlan;

  /**
   * APISelector selects the APIs that will be accessible to the configured audience.
   * Multiple APIAccesses can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiAccessSpec#apiSelector
   */
  readonly apiSelector?: ApiAccessSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be accessible to the configured audience.
   * Multiple APIAccesses can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiAccessSpec#apis
   */
  readonly apis?: ApiAccessSpecApis[];

  /**
   * Everyone indicates that all users will have access to the selected APIs.
   *
   * @schema ApiAccessSpec#everyone
   */
  readonly everyone?: boolean;

  /**
   * Groups are the consumer groups that will gain access to the selected APIs.
   *
   * @schema ApiAccessSpec#groups
   */
  readonly groups?: string[];

  /**
   * OperationFilter specifies the allowed operations on APIs and APIVersions.
   * If not set, all operations are available.
   * An empty OperationFilter prohibits all operations.
   *
   * @schema ApiAccessSpec#operationFilter
   */
  readonly operationFilter?: ApiAccessSpecOperationFilter;

  /**
   * Weight specifies the evaluation order of the plan.
   *
   * @schema ApiAccessSpec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ApiAccessSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpec(obj: ApiAccessSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiBundles': obj.apiBundles?.map(y => toJson_ApiAccessSpecApiBundles(y)),
    'apiPlan': toJson_ApiAccessSpecApiPlan(obj.apiPlan),
    'apiSelector': toJson_ApiAccessSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map(y => toJson_ApiAccessSpecApis(y)),
    'everyone': obj.everyone,
    'groups': obj.groups?.map(y => y),
    'operationFilter': toJson_ApiAccessSpecOperationFilter(obj.operationFilter),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIBundleReference references an APIBundle.
 *
 * @schema ApiAccessSpecApiBundles
 */
export interface ApiAccessSpecApiBundles {
  /**
   * Name of the APIBundle.
   *
   * @schema ApiAccessSpecApiBundles#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiAccessSpecApiBundles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecApiBundles(obj: ApiAccessSpecApiBundles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIPlan defines which APIPlan will be used.
 *
 * @schema ApiAccessSpecApiPlan
 */
export interface ApiAccessSpecApiPlan {
  /**
   * Name of the APIPlan.
   *
   * @schema ApiAccessSpecApiPlan#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiAccessSpecApiPlan' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecApiPlan(obj: ApiAccessSpecApiPlan | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISelector selects the APIs that will be accessible to the configured audience.
 * Multiple APIAccesses can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiAccessSpecApiSelector
 */
export interface ApiAccessSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiAccessSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiAccessSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiAccessSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiAccessSpecApiSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecApiSelector(obj: ApiAccessSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ApiAccessSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIReference references an API.
 *
 * @schema ApiAccessSpecApis
 */
export interface ApiAccessSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiAccessSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiAccessSpecApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecApis(obj: ApiAccessSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationFilter specifies the allowed operations on APIs and APIVersions.
 * If not set, all operations are available.
 * An empty OperationFilter prohibits all operations.
 *
 * @schema ApiAccessSpecOperationFilter
 */
export interface ApiAccessSpecOperationFilter {
  /**
   * Include defines the names of OperationSets that will be accessible.
   *
   * @schema ApiAccessSpecOperationFilter#include
   */
  readonly include?: string[];

}

/**
 * Converts an object of type 'ApiAccessSpecOperationFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecOperationFilter(obj: ApiAccessSpecOperationFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'include': obj.include?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiAccessSpecApiSelectorMatchExpressions
 */
export interface ApiAccessSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiAccessSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiAccessSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiAccessSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiAccessSpecApiSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiAccessSpecApiSelectorMatchExpressions(obj: ApiAccessSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIBundle defines a set of APIs.
 *
 * @schema APIBundle
 */
export class ApiBundle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIBundle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIBundle',
  }

  /**
   * Renders a Kubernetes manifest for "APIBundle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiBundleProps = {}): any {
    return {
      ...ApiBundle.GVK,
      ...toJson_ApiBundleProps(props),
    };
  }

  /**
   * Defines a "APIBundle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiBundleProps = {}) {
    super(scope, id, {
      ...ApiBundle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiBundle.GVK,
      ...toJson_ApiBundleProps(resolved),
    };
  }
}

/**
 * APIBundle defines a set of APIs.
 *
 * @schema APIBundle
 */
export interface ApiBundleProps {
  /**
   * @schema APIBundle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIBundle.
   *
   * @schema APIBundle#spec
   */
  readonly spec?: ApiBundleSpec;

}

/**
 * Converts an object of type 'ApiBundleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiBundleProps(obj: ApiBundleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiBundleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIBundle.
 *
 * @schema ApiBundleSpec
 */
export interface ApiBundleSpec {
  /**
   * APISelector selects the APIs that will be accessible to the configured audience.
   * Multiple APIBundles can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiBundleSpec#apiSelector
   */
  readonly apiSelector?: ApiBundleSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be accessible to the configured audience.
   * Multiple APIBundles can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiBundleSpec#apis
   */
  readonly apis?: ApiBundleSpecApis[];

}

/**
 * Converts an object of type 'ApiBundleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiBundleSpec(obj: ApiBundleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiSelector': toJson_ApiBundleSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map(y => toJson_ApiBundleSpecApis(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISelector selects the APIs that will be accessible to the configured audience.
 * Multiple APIBundles can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiBundleSpecApiSelector
 */
export interface ApiBundleSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiBundleSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiBundleSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiBundleSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiBundleSpecApiSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiBundleSpecApiSelector(obj: ApiBundleSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ApiBundleSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIReference references an API.
 *
 * @schema ApiBundleSpecApis
 */
export interface ApiBundleSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiBundleSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiBundleSpecApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiBundleSpecApis(obj: ApiBundleSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiBundleSpecApiSelectorMatchExpressions
 */
export interface ApiBundleSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiBundleSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiBundleSpecApiSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiBundleSpecApiSelectorMatchExpressions(obj: ApiBundleSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APICatalogItem defines APIs that will be part of the API catalog on the portal.
 *
 * @schema APICatalogItem
 */
export class ApiCatalogItem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APICatalogItem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APICatalogItem',
  }

  /**
   * Renders a Kubernetes manifest for "APICatalogItem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiCatalogItemProps = {}): any {
    return {
      ...ApiCatalogItem.GVK,
      ...toJson_ApiCatalogItemProps(props),
    };
  }

  /**
   * Defines a "APICatalogItem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiCatalogItemProps = {}) {
    super(scope, id, {
      ...ApiCatalogItem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiCatalogItem.GVK,
      ...toJson_ApiCatalogItemProps(resolved),
    };
  }
}

/**
 * APICatalogItem defines APIs that will be part of the API catalog on the portal.
 *
 * @schema APICatalogItem
 */
export interface ApiCatalogItemProps {
  /**
   * @schema APICatalogItem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APICatalogItem.
   *
   * @schema APICatalogItem#spec
   */
  readonly spec?: ApiCatalogItemSpec;

}

/**
 * Converts an object of type 'ApiCatalogItemProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemProps(obj: ApiCatalogItemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiCatalogItemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APICatalogItem.
 *
 * @schema ApiCatalogItemSpec
 */
export interface ApiCatalogItemSpec {
  /**
   * APIBundles defines a set of APIBundle that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same APIBundles.
   *
   * @schema ApiCatalogItemSpec#apiBundles
   */
  readonly apiBundles?: ApiCatalogItemSpecApiBundles[];

  /**
   * APIPlan defines which APIPlan will be available.
   * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
   * a plan from this list.
   *
   * @schema ApiCatalogItemSpec#apiPlan
   */
  readonly apiPlan?: ApiCatalogItemSpecApiPlan;

  /**
   * APISelector selects the APIs that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiCatalogItemSpec#apiSelector
   */
  readonly apiSelector?: ApiCatalogItemSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be visible to the configured audience.
   * Multiple APICatalogItem can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiCatalogItemSpec#apis
   */
  readonly apis?: ApiCatalogItemSpecApis[];

  /**
   * Everyone indicates that all users will see these APIs.
   *
   * @schema ApiCatalogItemSpec#everyone
   */
  readonly everyone?: boolean;

  /**
   * Groups are the consumer groups that will see the APIs.
   *
   * @schema ApiCatalogItemSpec#groups
   */
  readonly groups?: string[];

  /**
   * OperationFilter specifies the visible operations on APIs and APIVersions.
   * If not set, all operations are available.
   * An empty OperationFilter prohibits all operations.
   *
   * @schema ApiCatalogItemSpec#operationFilter
   */
  readonly operationFilter?: ApiCatalogItemSpecOperationFilter;

}

/**
 * Converts an object of type 'ApiCatalogItemSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpec(obj: ApiCatalogItemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiBundles': obj.apiBundles?.map(y => toJson_ApiCatalogItemSpecApiBundles(y)),
    'apiPlan': toJson_ApiCatalogItemSpecApiPlan(obj.apiPlan),
    'apiSelector': toJson_ApiCatalogItemSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map(y => toJson_ApiCatalogItemSpecApis(y)),
    'everyone': obj.everyone,
    'groups': obj.groups?.map(y => y),
    'operationFilter': toJson_ApiCatalogItemSpecOperationFilter(obj.operationFilter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIBundleReference references an APIBundle.
 *
 * @schema ApiCatalogItemSpecApiBundles
 */
export interface ApiCatalogItemSpecApiBundles {
  /**
   * Name of the APIBundle.
   *
   * @schema ApiCatalogItemSpecApiBundles#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiBundles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecApiBundles(obj: ApiCatalogItemSpecApiBundles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIPlan defines which APIPlan will be available.
 * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
 * a plan from this list.
 *
 * @schema ApiCatalogItemSpecApiPlan
 */
export interface ApiCatalogItemSpecApiPlan {
  /**
   * Name of the APIPlan.
   *
   * @schema ApiCatalogItemSpecApiPlan#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiPlan' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecApiPlan(obj: ApiCatalogItemSpecApiPlan | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISelector selects the APIs that will be visible to the configured audience.
 * Multiple APICatalogItem can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiCatalogItemSpecApiSelector
 */
export interface ApiCatalogItemSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiCatalogItemSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiCatalogItemSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiCatalogItemSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecApiSelector(obj: ApiCatalogItemSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ApiCatalogItemSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIReference references an API.
 *
 * @schema ApiCatalogItemSpecApis
 */
export interface ApiCatalogItemSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiCatalogItemSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecApis(obj: ApiCatalogItemSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationFilter specifies the visible operations on APIs and APIVersions.
 * If not set, all operations are available.
 * An empty OperationFilter prohibits all operations.
 *
 * @schema ApiCatalogItemSpecOperationFilter
 */
export interface ApiCatalogItemSpecOperationFilter {
  /**
   * Include defines the names of OperationSets that will be accessible.
   *
   * @schema ApiCatalogItemSpecOperationFilter#include
   */
  readonly include?: string[];

}

/**
 * Converts an object of type 'ApiCatalogItemSpecOperationFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecOperationFilter(obj: ApiCatalogItemSpecOperationFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'include': obj.include?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiCatalogItemSpecApiSelectorMatchExpressions
 */
export interface ApiCatalogItemSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiCatalogItemSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiCatalogItemSpecApiSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiCatalogItemSpecApiSelectorMatchExpressions(obj: ApiCatalogItemSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIPlan defines API Plan policy.
 *
 * @schema APIPlan
 */
export class ApiPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIPlan',
  }

  /**
   * Renders a Kubernetes manifest for "APIPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiPlanProps = {}): any {
    return {
      ...ApiPlan.GVK,
      ...toJson_ApiPlanProps(props),
    };
  }

  /**
   * Defines a "APIPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiPlanProps = {}) {
    super(scope, id, {
      ...ApiPlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiPlan.GVK,
      ...toJson_ApiPlanProps(resolved),
    };
  }
}

/**
 * APIPlan defines API Plan policy.
 *
 * @schema APIPlan
 */
export interface ApiPlanProps {
  /**
   * @schema APIPlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIPlan.
   *
   * @schema APIPlan#spec
   */
  readonly spec?: ApiPlanSpec;

}

/**
 * Converts an object of type 'ApiPlanProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPlanProps(obj: ApiPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiPlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIPlan.
 *
 * @schema ApiPlanSpec
 */
export interface ApiPlanSpec {
  /**
   * Description describes the plan.
   *
   * @schema ApiPlanSpec#description
   */
  readonly description?: string;

  /**
   * Quota defines the quota policy.
   *
   * @schema ApiPlanSpec#quota
   */
  readonly quota?: ApiPlanSpecQuota;

  /**
   * RateLimit defines the rate limit policy.
   *
   * @schema ApiPlanSpec#rateLimit
   */
  readonly rateLimit?: ApiPlanSpecRateLimit;

  /**
   * Title is the human-readable name of the plan.
   *
   * @schema ApiPlanSpec#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'ApiPlanSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPlanSpec(obj: ApiPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'quota': toJson_ApiPlanSpecQuota(obj.quota),
    'rateLimit': toJson_ApiPlanSpecRateLimit(obj.rateLimit),
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Quota defines the quota policy.
 *
 * @schema ApiPlanSpecQuota
 */
export interface ApiPlanSpecQuota {
  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiPlanSpecQuota#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiPlanSpecQuota#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'ApiPlanSpecQuota' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPlanSpecQuota(obj: ApiPlanSpecQuota | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limit': obj.limit,
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimit defines the rate limit policy.
 *
 * @schema ApiPlanSpecRateLimit
 */
export interface ApiPlanSpecRateLimit {
  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiPlanSpecRateLimit#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiPlanSpecRateLimit#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'ApiPlanSpecRateLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPlanSpecRateLimit(obj: ApiPlanSpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limit': obj.limit,
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIPortal defines a developer portal for accessing the documentation of APIs.
 *
 * @schema APIPortal
 */
export class ApiPortal extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIPortal"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIPortal',
  }

  /**
   * Renders a Kubernetes manifest for "APIPortal".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiPortalProps = {}): any {
    return {
      ...ApiPortal.GVK,
      ...toJson_ApiPortalProps(props),
    };
  }

  /**
   * Defines a "APIPortal" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiPortalProps = {}) {
    super(scope, id, {
      ...ApiPortal.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiPortal.GVK,
      ...toJson_ApiPortalProps(resolved),
    };
  }
}

/**
 * APIPortal defines a developer portal for accessing the documentation of APIs.
 *
 * @schema APIPortal
 */
export interface ApiPortalProps {
  /**
   * @schema APIPortal#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIPortal.
   *
   * @schema APIPortal#spec
   */
  readonly spec?: ApiPortalSpec;

}

/**
 * Converts an object of type 'ApiPortalProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPortalProps(obj: ApiPortalProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiPortalSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIPortal.
 *
 * @schema ApiPortalSpec
 */
export interface ApiPortalSpec {
  /**
   * Description of the APIPortal.
   *
   * @schema ApiPortalSpec#description
   */
  readonly description?: string;

  /**
   * Title is the public facing name of the APIPortal.
   *
   * @schema ApiPortalSpec#title
   */
  readonly title?: string;

  /**
   * TrustedURLs are the urls that are trusted by the OAuth 2.0 authorization server.
   *
   * @schema ApiPortalSpec#trustedUrls
   */
  readonly trustedUrls: string[];

  /**
   * UI holds the UI customization options.
   *
   * @schema ApiPortalSpec#ui
   */
  readonly ui?: ApiPortalSpecUi;

}

/**
 * Converts an object of type 'ApiPortalSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPortalSpec(obj: ApiPortalSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'title': obj.title,
    'trustedUrls': obj.trustedUrls?.map(y => y),
    'ui': toJson_ApiPortalSpecUi(obj.ui),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UI holds the UI customization options.
 *
 * @schema ApiPortalSpecUi
 */
export interface ApiPortalSpecUi {
  /**
   * LogoURL is the public URL of the logo.
   *
   * @schema ApiPortalSpecUi#logoUrl
   */
  readonly logoUrl?: string;

}

/**
 * Converts an object of type 'ApiPortalSpecUi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiPortalSpecUi(obj: ApiPortalSpecUi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logoUrl': obj.logoUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIRateLimit defines how group of consumers are rate limited on a set of APIs.
 *
 * @schema APIRateLimit
 */
export class ApiRateLimit extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIRateLimit"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIRateLimit',
  }

  /**
   * Renders a Kubernetes manifest for "APIRateLimit".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiRateLimitProps = {}): any {
    return {
      ...ApiRateLimit.GVK,
      ...toJson_ApiRateLimitProps(props),
    };
  }

  /**
   * Defines a "APIRateLimit" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiRateLimitProps = {}) {
    super(scope, id, {
      ...ApiRateLimit.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiRateLimit.GVK,
      ...toJson_ApiRateLimitProps(resolved),
    };
  }
}

/**
 * APIRateLimit defines how group of consumers are rate limited on a set of APIs.
 *
 * @schema APIRateLimit
 */
export interface ApiRateLimitProps {
  /**
   * @schema APIRateLimit#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIRateLimit.
   *
   * @schema APIRateLimit#spec
   */
  readonly spec?: ApiRateLimitSpec;

}

/**
 * Converts an object of type 'ApiRateLimitProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiRateLimitProps(obj: ApiRateLimitProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiRateLimitSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIRateLimit.
 *
 * @schema ApiRateLimitSpec
 */
export interface ApiRateLimitSpec {
  /**
   * APISelector selects the APIs that will be rate limited.
   * Multiple APIRateLimits can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ApiRateLimitSpec#apiSelector
   */
  readonly apiSelector?: ApiRateLimitSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be rate limited.
   * Multiple APIRateLimits can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ApiRateLimitSpec#apis
   */
  readonly apis?: ApiRateLimitSpecApis[];

  /**
   * Everyone indicates that all users will, by default, be rate limited with this configuration.
   * If an APIRateLimit explicitly target a group, the default rate limit will be ignored.
   *
   * @schema ApiRateLimitSpec#everyone
   */
  readonly everyone?: boolean;

  /**
   * Groups are the consumer groups that will be rate limited.
   * Multiple APIRateLimits can target the same set of consumer groups, the most restrictive one applies.
   * When a consumer belongs to multiple groups, the least restrictive APIRateLimit applies.
   *
   * @schema ApiRateLimitSpec#groups
   */
  readonly groups?: string[];

  /**
   * Limit is the maximum number of token in the bucket.
   *
   * @schema ApiRateLimitSpec#limit
   */
  readonly limit: number;

  /**
   * Period is the unit of time for the Limit.
   *
   * @schema ApiRateLimitSpec#period
   */
  readonly period?: string;

  /**
   * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
   * It can be, either "local" or "distributed".
   *
   * @schema ApiRateLimitSpec#strategy
   */
  readonly strategy?: ApiRateLimitSpecStrategy;

}

/**
 * Converts an object of type 'ApiRateLimitSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiRateLimitSpec(obj: ApiRateLimitSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiSelector': toJson_ApiRateLimitSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map(y => toJson_ApiRateLimitSpecApis(y)),
    'everyone': obj.everyone,
    'groups': obj.groups?.map(y => y),
    'limit': obj.limit,
    'period': obj.period,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISelector selects the APIs that will be rate limited.
 * Multiple APIRateLimits can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ApiRateLimitSpecApiSelector
 */
export interface ApiRateLimitSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ApiRateLimitSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ApiRateLimitSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ApiRateLimitSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApiRateLimitSpecApiSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiRateLimitSpecApiSelector(obj: ApiRateLimitSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ApiRateLimitSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIReference references an API.
 *
 * @schema ApiRateLimitSpecApis
 */
export interface ApiRateLimitSpecApis {
  /**
   * Name of the API.
   *
   * @schema ApiRateLimitSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiRateLimitSpecApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiRateLimitSpecApis(obj: ApiRateLimitSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
 * It can be, either "local" or "distributed".
 *
 * @schema ApiRateLimitSpecStrategy
 */
export enum ApiRateLimitSpecStrategy {
  /** local */
  LOCAL = "local",
  /** distributed */
  DISTRIBUTED = "distributed",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ApiRateLimitSpecApiSelectorMatchExpressions
 */
export interface ApiRateLimitSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ApiRateLimitSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ApiRateLimitSpecApiSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiRateLimitSpecApiSelectorMatchExpressions(obj: ApiRateLimitSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * APIVersion defines a version of an API.
 *
 * @schema APIVersion
 */
export class ApiVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'APIVersion',
  }

  /**
   * Renders a Kubernetes manifest for "APIVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiVersionProps = {}): any {
    return {
      ...ApiVersion.GVK,
      ...toJson_ApiVersionProps(props),
    };
  }

  /**
   * Defines a "APIVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiVersionProps = {}) {
    super(scope, id, {
      ...ApiVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiVersion.GVK,
      ...toJson_ApiVersionProps(resolved),
    };
  }
}

/**
 * APIVersion defines a version of an API.
 *
 * @schema APIVersion
 */
export interface ApiVersionProps {
  /**
   * @schema APIVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this APIVersion.
   *
   * @schema APIVersion#spec
   */
  readonly spec?: ApiVersionSpec;

}

/**
 * Converts an object of type 'ApiVersionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionProps(obj: ApiVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this APIVersion.
 *
 * @schema ApiVersionSpec
 */
export interface ApiVersionSpec {
  /**
   * OpenAPISpec defines the API contract as an OpenAPI specification.
   *
   * @schema ApiVersionSpec#openApiSpec
   */
  readonly openApiSpec?: ApiVersionSpecOpenApiSpec;

  /**
   * Release is the version number of the API.
   * This value must follow the SemVer format: https://semver.org/
   *
   * @schema ApiVersionSpec#release
   */
  readonly release: string;

  /**
   * Title is the public facing name of the APIVersion.
   *
   * @schema ApiVersionSpec#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ApiVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpec(obj: ApiVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openApiSpec': toJson_ApiVersionSpecOpenApiSpec(obj.openApiSpec),
    'release': obj.release,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenAPISpec defines the API contract as an OpenAPI specification.
 *
 * @schema ApiVersionSpecOpenApiSpec
 */
export interface ApiVersionSpecOpenApiSpec {
  /**
   * OperationSets defines the sets of operations to be referenced for granular filtering in APIAccesses.
   *
   * @schema ApiVersionSpecOpenApiSpec#operationSets
   */
  readonly operationSets?: ApiVersionSpecOpenApiSpecOperationSets[];

  /**
   * Override holds data used to override OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#override
   */
  readonly override?: ApiVersionSpecOpenApiSpecOverride;

  /**
   * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
   * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
   * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
   * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#path
   */
  readonly path?: string;

  /**
   * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
   * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
   *
   * @schema ApiVersionSpecOpenApiSpec#url
   */
  readonly url?: string;

  /**
   * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
   * This option overrides the default behavior configured in the static configuration.
   *
   * @schema ApiVersionSpecOpenApiSpec#validateRequestMethodAndPath
   */
  readonly validateRequestMethodAndPath?: boolean;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpecOpenApiSpec(obj: ApiVersionSpecOpenApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operationSets': obj.operationSets?.map(y => toJson_ApiVersionSpecOpenApiSpecOperationSets(y)),
    'override': toJson_ApiVersionSpecOpenApiSpecOverride(obj.override),
    'path': obj.path,
    'url': obj.url,
    'validateRequestMethodAndPath': obj.validateRequestMethodAndPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationSet gives a name to a set of matching OpenAPI operations.
 * This set of operations can then be referenced for granular filtering in APIAccesses.
 *
 * @schema ApiVersionSpecOpenApiSpecOperationSets
 */
export interface ApiVersionSpecOpenApiSpecOperationSets {
  /**
   * Matchers defines a list of alternative rules for matching OpenAPI operations.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSets#matchers
   */
  readonly matchers: ApiVersionSpecOpenApiSpecOperationSetsMatchers[];

  /**
   * Name is the name of the OperationSet to reference in APIAccesses.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSets#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOperationSets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpecOpenApiSpecOperationSets(obj: ApiVersionSpecOpenApiSpecOperationSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchers': obj.matchers?.map(y => toJson_ApiVersionSpecOpenApiSpecOperationSetsMatchers(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Override holds data used to override OpenAPI specification.
 *
 * @schema ApiVersionSpecOpenApiSpecOverride
 */
export interface ApiVersionSpecOpenApiSpecOverride {
  /**
   * @schema ApiVersionSpecOpenApiSpecOverride#servers
   */
  readonly servers: ApiVersionSpecOpenApiSpecOverrideServers[];

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpecOpenApiSpecOverride(obj: ApiVersionSpecOpenApiSpecOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'servers': obj.servers?.map(y => toJson_ApiVersionSpecOpenApiSpecOverrideServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationMatcher defines criteria for matching an OpenAPI operation.
 *
 * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers
 */
export interface ApiVersionSpecOpenApiSpecOperationSetsMatchers {
  /**
   * Methods specifies the HTTP methods to be included for selection.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#methods
   */
  readonly methods?: string[];

  /**
   * Path specifies the exact path of the operations to select.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#path
   */
  readonly path?: string;

  /**
   * PathPrefix specifies the path prefix of the operations to select.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * PathRegex specifies a regular expression pattern for matching operations based on their paths.
   *
   * @schema ApiVersionSpecOpenApiSpecOperationSetsMatchers#pathRegex
   */
  readonly pathRegex?: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOperationSetsMatchers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpecOpenApiSpecOperationSetsMatchers(obj: ApiVersionSpecOpenApiSpecOperationSetsMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methods': obj.methods?.map(y => y),
    'path': obj.path,
    'pathPrefix': obj.pathPrefix,
    'pathRegex': obj.pathRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ApiVersionSpecOpenApiSpecOverrideServers
 */
export interface ApiVersionSpecOpenApiSpecOverrideServers {
  /**
   * @schema ApiVersionSpecOpenApiSpecOverrideServers#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ApiVersionSpecOpenApiSpecOverrideServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ApiVersionSpecOpenApiSpecOverrideServers(obj: ApiVersionSpecOpenApiSpecOverrideServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ManagedSubscription defines a Subscription managed by the API manager as the result of a pre-negotiation with its
API consumers. This subscription grant consuming access to a set of APIs to a set of Applications.
 *
 * @schema ManagedSubscription
 */
export class ManagedSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'hub.traefik.io/v1alpha1',
    kind: 'ManagedSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedSubscriptionProps = {}): any {
    return {
      ...ManagedSubscription.GVK,
      ...toJson_ManagedSubscriptionProps(props),
    };
  }

  /**
   * Defines a "ManagedSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedSubscriptionProps = {}) {
    super(scope, id, {
      ...ManagedSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedSubscription.GVK,
      ...toJson_ManagedSubscriptionProps(resolved),
    };
  }
}

/**
 * ManagedSubscription defines a Subscription managed by the API manager as the result of a pre-negotiation with its
 * API consumers. This subscription grant consuming access to a set of APIs to a set of Applications.
 *
 * @schema ManagedSubscription
 */
export interface ManagedSubscriptionProps {
  /**
   * @schema ManagedSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The desired behavior of this ManagedSubscription.
   *
   * @schema ManagedSubscription#spec
   */
  readonly spec?: ManagedSubscriptionSpec;

}

/**
 * Converts an object of type 'ManagedSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionProps(obj: ManagedSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired behavior of this ManagedSubscription.
 *
 * @schema ManagedSubscriptionSpec
 */
export interface ManagedSubscriptionSpec {
  /**
   * APIBundles defines a set of APIBundle that will be accessible.
   * Multiple ManagedSubscriptions can select the same APIBundles.
   *
   * @schema ManagedSubscriptionSpec#apiBundles
   */
  readonly apiBundles?: ManagedSubscriptionSpecApiBundles[];

  /**
   * APIPlan defines which APIPlan will be used.
   *
   * @schema ManagedSubscriptionSpec#apiPlan
   */
  readonly apiPlan?: ManagedSubscriptionSpecApiPlan;

  /**
   * APISelector selects the APIs that will be accessible.
   * Multiple ManagedSubscriptions can select the same set of APIs.
   * This field is optional and follows standard label selector semantics.
   * An empty APISelector matches any API.
   *
   * @schema ManagedSubscriptionSpec#apiSelector
   */
  readonly apiSelector?: ManagedSubscriptionSpecApiSelector;

  /**
   * APIs defines a set of APIs that will be accessible.
   * Multiple ManagedSubscriptions can select the same APIs.
   * When combined with APISelector, this set of APIs is appended to the matching APIs.
   *
   * @schema ManagedSubscriptionSpec#apis
   */
  readonly apis?: ManagedSubscriptionSpecApis[];

  /**
   * Applications references the Applications that will gain access to the specified APIs.
   * Multiple ManagedSubscriptions can select the same AppID.
   *
   * @schema ManagedSubscriptionSpec#applications
   */
  readonly applications: ManagedSubscriptionSpecApplications[];

  /**
   * Claims specifies an expression that validate claims in order to authorize the request.
   *
   * @schema ManagedSubscriptionSpec#claims
   */
  readonly claims?: string;

  /**
   * OperationFilter specifies the allowed operations on APIs and APIVersions.
   * If not set, all operations are available.
   * An empty OperationFilter prohibits all operations.
   *
   * @schema ManagedSubscriptionSpec#operationFilter
   */
  readonly operationFilter?: ManagedSubscriptionSpecOperationFilter;

  /**
   * Weight specifies the evaluation order of the APIPlan.
   * When multiple ManagedSubscriptions targets the same API and Application with different APIPlan,
   * the APIPlan with the highest weight will be enforced. If weights are equal, alphabetical order is used.
   *
   * @schema ManagedSubscriptionSpec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpec(obj: ManagedSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiBundles': obj.apiBundles?.map(y => toJson_ManagedSubscriptionSpecApiBundles(y)),
    'apiPlan': toJson_ManagedSubscriptionSpecApiPlan(obj.apiPlan),
    'apiSelector': toJson_ManagedSubscriptionSpecApiSelector(obj.apiSelector),
    'apis': obj.apis?.map(y => toJson_ManagedSubscriptionSpecApis(y)),
    'applications': obj.applications?.map(y => toJson_ManagedSubscriptionSpecApplications(y)),
    'claims': obj.claims,
    'operationFilter': toJson_ManagedSubscriptionSpecOperationFilter(obj.operationFilter),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIBundleReference references an APIBundle.
 *
 * @schema ManagedSubscriptionSpecApiBundles
 */
export interface ManagedSubscriptionSpecApiBundles {
  /**
   * Name of the APIBundle.
   *
   * @schema ManagedSubscriptionSpecApiBundles#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiBundles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApiBundles(obj: ManagedSubscriptionSpecApiBundles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIPlan defines which APIPlan will be used.
 *
 * @schema ManagedSubscriptionSpecApiPlan
 */
export interface ManagedSubscriptionSpecApiPlan {
  /**
   * Name of the APIPlan.
   *
   * @schema ManagedSubscriptionSpecApiPlan#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiPlan' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApiPlan(obj: ManagedSubscriptionSpecApiPlan | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APISelector selects the APIs that will be accessible.
 * Multiple ManagedSubscriptions can select the same set of APIs.
 * This field is optional and follows standard label selector semantics.
 * An empty APISelector matches any API.
 *
 * @schema ManagedSubscriptionSpecApiSelector
 */
export interface ManagedSubscriptionSpecApiSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ManagedSubscriptionSpecApiSelector#matchExpressions
   */
  readonly matchExpressions?: ManagedSubscriptionSpecApiSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ManagedSubscriptionSpecApiSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApiSelector(obj: ManagedSubscriptionSpecApiSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ManagedSubscriptionSpecApiSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIReference references an API.
 *
 * @schema ManagedSubscriptionSpecApis
 */
export interface ManagedSubscriptionSpecApis {
  /**
   * Name of the API.
   *
   * @schema ManagedSubscriptionSpecApis#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApis(obj: ManagedSubscriptionSpecApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ApplicationReference references an Application.
 *
 * @schema ManagedSubscriptionSpecApplications
 */
export interface ManagedSubscriptionSpecApplications {
  /**
   * AppID is the public identifier of the application.
   * In the case of OIDC, it corresponds to the clientId.
   *
   * @schema ManagedSubscriptionSpecApplications#appId
   */
  readonly appId: string;

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApplications' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApplications(obj: ManagedSubscriptionSpecApplications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperationFilter specifies the allowed operations on APIs and APIVersions.
 * If not set, all operations are available.
 * An empty OperationFilter prohibits all operations.
 *
 * @schema ManagedSubscriptionSpecOperationFilter
 */
export interface ManagedSubscriptionSpecOperationFilter {
  /**
   * Include defines the names of OperationSets that will be accessible.
   *
   * @schema ManagedSubscriptionSpecOperationFilter#include
   */
  readonly include?: string[];

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecOperationFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecOperationFilter(obj: ManagedSubscriptionSpecOperationFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'include': obj.include?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions
 */
export interface ManagedSubscriptionSpecApiSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ManagedSubscriptionSpecApiSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ManagedSubscriptionSpecApiSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedSubscriptionSpecApiSelectorMatchExpressions(obj: ManagedSubscriptionSpecApiSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

