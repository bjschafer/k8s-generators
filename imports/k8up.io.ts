// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Archive is the Schema for the archives API
 *
 * @schema Archive
 */
export class Archive extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Archive"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Archive',
  }

  /**
   * Renders a Kubernetes manifest for "Archive".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ArchiveProps = {}): any {
    return {
      ...Archive.GVK,
      ...toJson_ArchiveProps(props),
    };
  }

  /**
   * Defines a "Archive" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ArchiveProps = {}) {
    super(scope, id, {
      ...Archive.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Archive.GVK,
      ...toJson_ArchiveProps(resolved),
    };
  }
}

/**
 * Archive is the Schema for the archives API
 *
 * @schema Archive
 */
export interface ArchiveProps {
  /**
   * @schema Archive#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ArchiveSpec defines the desired state of Archive.
   *
   * @schema Archive#spec
   */
  readonly spec?: ArchiveSpec;

}

/**
 * Converts an object of type 'ArchiveProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveProps(obj: ArchiveProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ArchiveSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArchiveSpec defines the desired state of Archive.
 *
 * @schema ArchiveSpec
 */
export interface ArchiveSpec {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ArchiveSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ArchiveSpec#backend
   */
  readonly backend?: ArchiveSpecBackend;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ArchiveSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ArchiveSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ArchiveSpec#podSecurityContext
   */
  readonly podSecurityContext?: ArchiveSpecPodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ArchiveSpec#resources
   */
  readonly resources?: ArchiveSpecResources;

  /**
   * @schema ArchiveSpec#restoreFilter
   */
  readonly restoreFilter?: string;

  /**
   * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
   *
   * @schema ArchiveSpec#restoreMethod
   */
  readonly restoreMethod?: ArchiveSpecRestoreMethod;

  /**
   * @schema ArchiveSpec#snapshot
   */
  readonly snapshot?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ArchiveSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema ArchiveSpec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ArchiveSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpec(obj: ArchiveSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ArchiveSpecBackend(obj.backend),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ArchiveSpecPodSecurityContext(obj.podSecurityContext),
    'resources': toJson_ArchiveSpecResources(obj.resources),
    'restoreFilter': obj.restoreFilter,
    'restoreMethod': toJson_ArchiveSpecRestoreMethod(obj.restoreMethod),
    'snapshot': obj.snapshot,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ArchiveSpecBackend
 */
export interface ArchiveSpecBackend {
  /**
   * @schema ArchiveSpecBackend#azure
   */
  readonly azure?: ArchiveSpecBackendAzure;

  /**
   * @schema ArchiveSpecBackend#b2
   */
  readonly b2?: ArchiveSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ArchiveSpecBackend#envFrom
   */
  readonly envFrom?: ArchiveSpecBackendEnvFrom[];

  /**
   * @schema ArchiveSpecBackend#gcs
   */
  readonly gcs?: ArchiveSpecBackendGcs;

  /**
   * @schema ArchiveSpecBackend#local
   */
  readonly local?: ArchiveSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ArchiveSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ArchiveSpecBackendRepoPasswordSecretRef;

  /**
   * @schema ArchiveSpecBackend#rest
   */
  readonly rest?: ArchiveSpecBackendRest;

  /**
   * @schema ArchiveSpecBackend#s3
   */
  readonly s3?: ArchiveSpecBackendS3;

  /**
   * @schema ArchiveSpecBackend#swift
   */
  readonly swift?: ArchiveSpecBackendSwift;

}

/**
 * Converts an object of type 'ArchiveSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackend(obj: ArchiveSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ArchiveSpecBackendAzure(obj.azure),
    'b2': toJson_ArchiveSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ArchiveSpecBackendEnvFrom(y)),
    'gcs': toJson_ArchiveSpecBackendGcs(obj.gcs),
    'local': toJson_ArchiveSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ArchiveSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ArchiveSpecBackendRest(obj.rest),
    's3': toJson_ArchiveSpecBackendS3(obj.s3),
    'swift': toJson_ArchiveSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ArchiveSpecPodSecurityContext
 */
export interface ArchiveSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ArchiveSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ArchiveSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ArchiveSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ArchiveSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ArchiveSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: ArchiveSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ArchiveSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ArchiveSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ArchiveSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPodSecurityContext(obj: ArchiveSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ArchiveSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ArchiveSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ArchiveSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ArchiveSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ArchiveSpecResources
 */
export interface ArchiveSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ArchiveSpecResources#limits
   */
  readonly limits?: { [key: string]: ArchiveSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ArchiveSpecResources#requests
   */
  readonly requests?: { [key: string]: ArchiveSpecResourcesRequests };

}

/**
 * Converts an object of type 'ArchiveSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecResources(obj: ArchiveSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
 *
 * @schema ArchiveSpecRestoreMethod
 */
export interface ArchiveSpecRestoreMethod {
  /**
   * @schema ArchiveSpecRestoreMethod#folder
   */
  readonly folder?: ArchiveSpecRestoreMethodFolder;

  /**
   * @schema ArchiveSpecRestoreMethod#s3
   */
  readonly s3?: ArchiveSpecRestoreMethodS3;

}

/**
 * Converts an object of type 'ArchiveSpecRestoreMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecRestoreMethod(obj: ArchiveSpecRestoreMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'folder': toJson_ArchiveSpecRestoreMethodFolder(obj.folder),
    's3': toJson_ArchiveSpecRestoreMethodS3(obj.s3),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendAzure
 */
export interface ArchiveSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ArchiveSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ArchiveSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema ArchiveSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ArchiveSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendAzure(obj: ArchiveSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ArchiveSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ArchiveSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendB2
 */
export interface ArchiveSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ArchiveSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ArchiveSpecBackendB2AccountKeySecretRef;

  /**
   * @schema ArchiveSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ArchiveSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ArchiveSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendB2(obj: ArchiveSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ArchiveSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ArchiveSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ArchiveSpecBackendEnvFrom
 */
export interface ArchiveSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ArchiveSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ArchiveSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ArchiveSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ArchiveSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: ArchiveSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ArchiveSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendEnvFrom(obj: ArchiveSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ArchiveSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ArchiveSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendGcs
 */
export interface ArchiveSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ArchiveSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema ArchiveSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ArchiveSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ArchiveSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendGcs(obj: ArchiveSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ArchiveSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ArchiveSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendLocal
 */
export interface ArchiveSpecBackendLocal {
  /**
   * @schema ArchiveSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ArchiveSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendLocal(obj: ArchiveSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ArchiveSpecBackendRepoPasswordSecretRef
 */
export interface ArchiveSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendRepoPasswordSecretRef(obj: ArchiveSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendRest
 */
export interface ArchiveSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ArchiveSpecBackendRestPasswordSecretReg;

  /**
   * @schema ArchiveSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: ArchiveSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ArchiveSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendRest(obj: ArchiveSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ArchiveSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ArchiveSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendS3
 */
export interface ArchiveSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ArchiveSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ArchiveSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ArchiveSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ArchiveSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ArchiveSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendS3(obj: ArchiveSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ArchiveSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ArchiveSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecBackendSwift
 */
export interface ArchiveSpecBackendSwift {
  /**
   * @schema ArchiveSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ArchiveSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ArchiveSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendSwift(obj: ArchiveSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ArchiveSpecPodSecurityContextSeLinuxOptions
 */
export interface ArchiveSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ArchiveSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ArchiveSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ArchiveSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ArchiveSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ArchiveSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPodSecurityContextSeLinuxOptions(obj: ArchiveSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ArchiveSpecPodSecurityContextSeccompProfile
 */
export interface ArchiveSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ArchiveSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ArchiveSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ArchiveSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPodSecurityContextSeccompProfile(obj: ArchiveSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ArchiveSpecPodSecurityContextSysctls
 */
export interface ArchiveSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ArchiveSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ArchiveSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ArchiveSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPodSecurityContextSysctls(obj: ArchiveSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ArchiveSpecPodSecurityContextWindowsOptions
 */
export interface ArchiveSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ArchiveSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ArchiveSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ArchiveSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ArchiveSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ArchiveSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPodSecurityContextWindowsOptions(obj: ArchiveSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecResourcesLimits
 */
export class ArchiveSpecResourcesLimits {
  public static fromNumber(value: number): ArchiveSpecResourcesLimits {
    return new ArchiveSpecResourcesLimits(value);
  }
  public static fromString(value: string): ArchiveSpecResourcesLimits {
    return new ArchiveSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ArchiveSpecResourcesRequests
 */
export class ArchiveSpecResourcesRequests {
  public static fromNumber(value: number): ArchiveSpecResourcesRequests {
    return new ArchiveSpecResourcesRequests(value);
  }
  public static fromString(value: string): ArchiveSpecResourcesRequests {
    return new ArchiveSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ArchiveSpecRestoreMethodFolder
 */
export interface ArchiveSpecRestoreMethodFolder {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ArchiveSpecRestoreMethodFolder#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema ArchiveSpecRestoreMethodFolder#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecRestoreMethodFolder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecRestoreMethodFolder(obj: ArchiveSpecRestoreMethodFolder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveSpecRestoreMethodS3
 */
export interface ArchiveSpecRestoreMethodS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecRestoreMethodS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef;

  /**
   * @schema ArchiveSpecRestoreMethodS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ArchiveSpecRestoreMethodS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ArchiveSpecRestoreMethodS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ArchiveSpecRestoreMethodS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecRestoreMethodS3(obj: ArchiveSpecRestoreMethodS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendAzureAccountKeySecretRef
 */
export interface ArchiveSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendAzureAccountKeySecretRef(obj: ArchiveSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendAzureAccountNameSecretRef
 */
export interface ArchiveSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendAzureAccountNameSecretRef(obj: ArchiveSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendB2AccountIdSecretRef
 */
export interface ArchiveSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendB2AccountIdSecretRef(obj: ArchiveSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendB2AccountKeySecretRef
 */
export interface ArchiveSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendB2AccountKeySecretRef(obj: ArchiveSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ArchiveSpecBackendEnvFromConfigMapRef
 */
export interface ArchiveSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ArchiveSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendEnvFromConfigMapRef(obj: ArchiveSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ArchiveSpecBackendEnvFromSecretRef
 */
export interface ArchiveSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ArchiveSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendEnvFromSecretRef(obj: ArchiveSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendGcsAccessTokenSecretRef
 */
export interface ArchiveSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendGcsAccessTokenSecretRef(obj: ArchiveSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendGcsProjectIdSecretRef
 */
export interface ArchiveSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendGcsProjectIdSecretRef(obj: ArchiveSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendRestPasswordSecretReg
 */
export interface ArchiveSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendRestPasswordSecretReg(obj: ArchiveSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendRestUserSecretRef
 */
export interface ArchiveSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendRestUserSecretRef(obj: ArchiveSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendS3AccessKeyIdSecretRef
 */
export interface ArchiveSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendS3AccessKeyIdSecretRef(obj: ArchiveSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecBackendS3SecretAccessKeySecretRef
 */
export interface ArchiveSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecBackendS3SecretAccessKeySecretRef(obj: ArchiveSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef
 */
export interface ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef(obj: ArchiveSpecRestoreMethodS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef
 */
export interface ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef(obj: ArchiveSpecRestoreMethodS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Backup is the Schema for the backups API
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps = {}): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps = {}) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is the Schema for the backups API
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines a single backup. It must contain all information to connect to the backup repository when applied. If used with defaults or schedules the operator will ensure that the defaults are applied before creating the object on the API.
   *
   * @schema Backup#spec
   */
  readonly spec?: BackupSpec;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines a single backup. It must contain all information to connect to the backup repository when applied. If used with defaults or schedules the operator will ensure that the defaults are applied before creating the object on the API.
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema BackupSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema BackupSpec#backend
   */
  readonly backend?: BackupSpecBackend;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema BackupSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema BackupSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema BackupSpec#podSecurityContext
   */
  readonly podSecurityContext?: BackupSpecPodSecurityContext;

  /**
   * PromURL sets a prometheus push URL where the backup container send metrics to
   *
   * @schema BackupSpec#promURL
   */
  readonly promUrl?: string;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema BackupSpec#resources
   */
  readonly resources?: BackupSpecResources;

  /**
   * StatsURL sets an arbitrary URL where the restic container posts metrics and information about the snapshots to. This is in addition to the prometheus pushgateway.
   *
   * @schema BackupSpec#statsURL
   */
  readonly statsUrl?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema BackupSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema BackupSpec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_BackupSpecBackend(obj.backend),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_BackupSpecPodSecurityContext(obj.podSecurityContext),
    'promURL': obj.promUrl,
    'resources': toJson_BackupSpecResources(obj.resources),
    'statsURL': obj.statsUrl,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema BackupSpecBackend
 */
export interface BackupSpecBackend {
  /**
   * @schema BackupSpecBackend#azure
   */
  readonly azure?: BackupSpecBackendAzure;

  /**
   * @schema BackupSpecBackend#b2
   */
  readonly b2?: BackupSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema BackupSpecBackend#envFrom
   */
  readonly envFrom?: BackupSpecBackendEnvFrom[];

  /**
   * @schema BackupSpecBackend#gcs
   */
  readonly gcs?: BackupSpecBackendGcs;

  /**
   * @schema BackupSpecBackend#local
   */
  readonly local?: BackupSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema BackupSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: BackupSpecBackendRepoPasswordSecretRef;

  /**
   * @schema BackupSpecBackend#rest
   */
  readonly rest?: BackupSpecBackendRest;

  /**
   * @schema BackupSpecBackend#s3
   */
  readonly s3?: BackupSpecBackendS3;

  /**
   * @schema BackupSpecBackend#swift
   */
  readonly swift?: BackupSpecBackendSwift;

}

/**
 * Converts an object of type 'BackupSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackend(obj: BackupSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_BackupSpecBackendAzure(obj.azure),
    'b2': toJson_BackupSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_BackupSpecBackendEnvFrom(y)),
    'gcs': toJson_BackupSpecBackendGcs(obj.gcs),
    'local': toJson_BackupSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_BackupSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_BackupSpecBackendRest(obj.rest),
    's3': toJson_BackupSpecBackendS3(obj.s3),
    'swift': toJson_BackupSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema BackupSpecPodSecurityContext
 */
export interface BackupSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema BackupSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema BackupSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: BackupSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: BackupSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema BackupSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: BackupSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema BackupSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: BackupSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'BackupSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPodSecurityContext(obj: BackupSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_BackupSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_BackupSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_BackupSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_BackupSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema BackupSpecResources
 */
export interface BackupSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema BackupSpecResources#limits
   */
  readonly limits?: { [key: string]: BackupSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema BackupSpecResources#requests
   */
  readonly requests?: { [key: string]: BackupSpecResourcesRequests };

}

/**
 * Converts an object of type 'BackupSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecResources(obj: BackupSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendAzure
 */
export interface BackupSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: BackupSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: BackupSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema BackupSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'BackupSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendAzure(obj: BackupSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_BackupSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_BackupSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendB2
 */
export interface BackupSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: BackupSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: BackupSpecBackendB2AccountKeySecretRef;

  /**
   * @schema BackupSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema BackupSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'BackupSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendB2(obj: BackupSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_BackupSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_BackupSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema BackupSpecBackendEnvFrom
 */
export interface BackupSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema BackupSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: BackupSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema BackupSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema BackupSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: BackupSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'BackupSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendEnvFrom(obj: BackupSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_BackupSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_BackupSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendGcs
 */
export interface BackupSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: BackupSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema BackupSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: BackupSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'BackupSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendGcs(obj: BackupSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_BackupSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_BackupSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendLocal
 */
export interface BackupSpecBackendLocal {
  /**
   * @schema BackupSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'BackupSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendLocal(obj: BackupSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema BackupSpecBackendRepoPasswordSecretRef
 */
export interface BackupSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendRepoPasswordSecretRef(obj: BackupSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendRest
 */
export interface BackupSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: BackupSpecBackendRestPasswordSecretReg;

  /**
   * @schema BackupSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: BackupSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'BackupSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendRest(obj: BackupSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_BackupSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_BackupSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendS3
 */
export interface BackupSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: BackupSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema BackupSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema BackupSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema BackupSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: BackupSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'BackupSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendS3(obj: BackupSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_BackupSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_BackupSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecBackendSwift
 */
export interface BackupSpecBackendSwift {
  /**
   * @schema BackupSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema BackupSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'BackupSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendSwift(obj: BackupSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema BackupSpecPodSecurityContextSeLinuxOptions
 */
export interface BackupSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema BackupSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema BackupSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema BackupSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema BackupSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'BackupSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPodSecurityContextSeLinuxOptions(obj: BackupSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema BackupSpecPodSecurityContextSeccompProfile
 */
export interface BackupSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema BackupSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema BackupSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'BackupSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPodSecurityContextSeccompProfile(obj: BackupSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema BackupSpecPodSecurityContextSysctls
 */
export interface BackupSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema BackupSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema BackupSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BackupSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPodSecurityContextSysctls(obj: BackupSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema BackupSpecPodSecurityContextWindowsOptions
 */
export interface BackupSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema BackupSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema BackupSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema BackupSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema BackupSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'BackupSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPodSecurityContextWindowsOptions(obj: BackupSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackupSpecResourcesLimits
 */
export class BackupSpecResourcesLimits {
  public static fromNumber(value: number): BackupSpecResourcesLimits {
    return new BackupSpecResourcesLimits(value);
  }
  public static fromString(value: string): BackupSpecResourcesLimits {
    return new BackupSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema BackupSpecResourcesRequests
 */
export class BackupSpecResourcesRequests {
  public static fromNumber(value: number): BackupSpecResourcesRequests {
    return new BackupSpecResourcesRequests(value);
  }
  public static fromString(value: string): BackupSpecResourcesRequests {
    return new BackupSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendAzureAccountKeySecretRef
 */
export interface BackupSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendAzureAccountKeySecretRef(obj: BackupSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendAzureAccountNameSecretRef
 */
export interface BackupSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendAzureAccountNameSecretRef(obj: BackupSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendB2AccountIdSecretRef
 */
export interface BackupSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendB2AccountIdSecretRef(obj: BackupSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendB2AccountKeySecretRef
 */
export interface BackupSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendB2AccountKeySecretRef(obj: BackupSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema BackupSpecBackendEnvFromConfigMapRef
 */
export interface BackupSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema BackupSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendEnvFromConfigMapRef(obj: BackupSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema BackupSpecBackendEnvFromSecretRef
 */
export interface BackupSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema BackupSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendEnvFromSecretRef(obj: BackupSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendGcsAccessTokenSecretRef
 */
export interface BackupSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendGcsAccessTokenSecretRef(obj: BackupSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendGcsProjectIdSecretRef
 */
export interface BackupSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendGcsProjectIdSecretRef(obj: BackupSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendRestPasswordSecretReg
 */
export interface BackupSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendRestPasswordSecretReg(obj: BackupSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendRestUserSecretRef
 */
export interface BackupSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendRestUserSecretRef(obj: BackupSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendS3AccessKeyIdSecretRef
 */
export interface BackupSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendS3AccessKeyIdSecretRef(obj: BackupSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema BackupSpecBackendS3SecretAccessKeySecretRef
 */
export interface BackupSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema BackupSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'BackupSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecBackendS3SecretAccessKeySecretRef(obj: BackupSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Check is the Schema for the checks API
 *
 * @schema Check
 */
export class Check extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Check"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Check',
  }

  /**
   * Renders a Kubernetes manifest for "Check".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CheckProps = {}): any {
    return {
      ...Check.GVK,
      ...toJson_CheckProps(props),
    };
  }

  /**
   * Defines a "Check" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CheckProps = {}) {
    super(scope, id, {
      ...Check.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Check.GVK,
      ...toJson_CheckProps(resolved),
    };
  }
}

/**
 * Check is the Schema for the checks API
 *
 * @schema Check
 */
export interface CheckProps {
  /**
   * @schema Check#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CheckSpec defines the desired state of Check. It needs to contain the repository information.
   *
   * @schema Check#spec
   */
  readonly spec?: CheckSpec;

}

/**
 * Converts an object of type 'CheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckProps(obj: CheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CheckSpec defines the desired state of Check. It needs to contain the repository information.
 *
 * @schema CheckSpec
 */
export interface CheckSpec {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema CheckSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema CheckSpec#backend
   */
  readonly backend?: CheckSpecBackend;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema CheckSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema CheckSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema CheckSpec#podSecurityContext
   */
  readonly podSecurityContext?: CheckSpecPodSecurityContext;

  /**
   * PromURL sets a prometheus push URL where the backup container send metrics to
   *
   * @schema CheckSpec#promURL
   */
  readonly promUrl?: string;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema CheckSpec#resources
   */
  readonly resources?: CheckSpecResources;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema CheckSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

}

/**
 * Converts an object of type 'CheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpec(obj: CheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_CheckSpecBackend(obj.backend),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_CheckSpecPodSecurityContext(obj.podSecurityContext),
    'promURL': obj.promUrl,
    'resources': toJson_CheckSpecResources(obj.resources),
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema CheckSpecBackend
 */
export interface CheckSpecBackend {
  /**
   * @schema CheckSpecBackend#azure
   */
  readonly azure?: CheckSpecBackendAzure;

  /**
   * @schema CheckSpecBackend#b2
   */
  readonly b2?: CheckSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema CheckSpecBackend#envFrom
   */
  readonly envFrom?: CheckSpecBackendEnvFrom[];

  /**
   * @schema CheckSpecBackend#gcs
   */
  readonly gcs?: CheckSpecBackendGcs;

  /**
   * @schema CheckSpecBackend#local
   */
  readonly local?: CheckSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema CheckSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: CheckSpecBackendRepoPasswordSecretRef;

  /**
   * @schema CheckSpecBackend#rest
   */
  readonly rest?: CheckSpecBackendRest;

  /**
   * @schema CheckSpecBackend#s3
   */
  readonly s3?: CheckSpecBackendS3;

  /**
   * @schema CheckSpecBackend#swift
   */
  readonly swift?: CheckSpecBackendSwift;

}

/**
 * Converts an object of type 'CheckSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackend(obj: CheckSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_CheckSpecBackendAzure(obj.azure),
    'b2': toJson_CheckSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_CheckSpecBackendEnvFrom(y)),
    'gcs': toJson_CheckSpecBackendGcs(obj.gcs),
    'local': toJson_CheckSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_CheckSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_CheckSpecBackendRest(obj.rest),
    's3': toJson_CheckSpecBackendS3(obj.s3),
    'swift': toJson_CheckSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema CheckSpecPodSecurityContext
 */
export interface CheckSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema CheckSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema CheckSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: CheckSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: CheckSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema CheckSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: CheckSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema CheckSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: CheckSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'CheckSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecPodSecurityContext(obj: CheckSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_CheckSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_CheckSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_CheckSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_CheckSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema CheckSpecResources
 */
export interface CheckSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema CheckSpecResources#limits
   */
  readonly limits?: { [key: string]: CheckSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema CheckSpecResources#requests
   */
  readonly requests?: { [key: string]: CheckSpecResourcesRequests };

}

/**
 * Converts an object of type 'CheckSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecResources(obj: CheckSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendAzure
 */
export interface CheckSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: CheckSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: CheckSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema CheckSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'CheckSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendAzure(obj: CheckSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_CheckSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_CheckSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendB2
 */
export interface CheckSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: CheckSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: CheckSpecBackendB2AccountKeySecretRef;

  /**
   * @schema CheckSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema CheckSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CheckSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendB2(obj: CheckSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_CheckSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_CheckSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema CheckSpecBackendEnvFrom
 */
export interface CheckSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema CheckSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: CheckSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema CheckSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema CheckSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: CheckSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'CheckSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendEnvFrom(obj: CheckSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_CheckSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_CheckSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendGcs
 */
export interface CheckSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: CheckSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema CheckSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: CheckSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'CheckSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendGcs(obj: CheckSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_CheckSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_CheckSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendLocal
 */
export interface CheckSpecBackendLocal {
  /**
   * @schema CheckSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'CheckSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendLocal(obj: CheckSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema CheckSpecBackendRepoPasswordSecretRef
 */
export interface CheckSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendRepoPasswordSecretRef(obj: CheckSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendRest
 */
export interface CheckSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: CheckSpecBackendRestPasswordSecretReg;

  /**
   * @schema CheckSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: CheckSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'CheckSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendRest(obj: CheckSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_CheckSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_CheckSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendS3
 */
export interface CheckSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: CheckSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema CheckSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema CheckSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema CheckSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: CheckSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'CheckSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendS3(obj: CheckSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_CheckSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_CheckSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecBackendSwift
 */
export interface CheckSpecBackendSwift {
  /**
   * @schema CheckSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema CheckSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CheckSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendSwift(obj: CheckSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema CheckSpecPodSecurityContextSeLinuxOptions
 */
export interface CheckSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema CheckSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema CheckSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema CheckSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema CheckSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'CheckSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecPodSecurityContextSeLinuxOptions(obj: CheckSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema CheckSpecPodSecurityContextSeccompProfile
 */
export interface CheckSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema CheckSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema CheckSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CheckSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecPodSecurityContextSeccompProfile(obj: CheckSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema CheckSpecPodSecurityContextSysctls
 */
export interface CheckSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema CheckSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema CheckSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CheckSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecPodSecurityContextSysctls(obj: CheckSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema CheckSpecPodSecurityContextWindowsOptions
 */
export interface CheckSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema CheckSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema CheckSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema CheckSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema CheckSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'CheckSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecPodSecurityContextWindowsOptions(obj: CheckSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CheckSpecResourcesLimits
 */
export class CheckSpecResourcesLimits {
  public static fromNumber(value: number): CheckSpecResourcesLimits {
    return new CheckSpecResourcesLimits(value);
  }
  public static fromString(value: string): CheckSpecResourcesLimits {
    return new CheckSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema CheckSpecResourcesRequests
 */
export class CheckSpecResourcesRequests {
  public static fromNumber(value: number): CheckSpecResourcesRequests {
    return new CheckSpecResourcesRequests(value);
  }
  public static fromString(value: string): CheckSpecResourcesRequests {
    return new CheckSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendAzureAccountKeySecretRef
 */
export interface CheckSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendAzureAccountKeySecretRef(obj: CheckSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendAzureAccountNameSecretRef
 */
export interface CheckSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendAzureAccountNameSecretRef(obj: CheckSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendB2AccountIdSecretRef
 */
export interface CheckSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendB2AccountIdSecretRef(obj: CheckSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendB2AccountKeySecretRef
 */
export interface CheckSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendB2AccountKeySecretRef(obj: CheckSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema CheckSpecBackendEnvFromConfigMapRef
 */
export interface CheckSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema CheckSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendEnvFromConfigMapRef(obj: CheckSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema CheckSpecBackendEnvFromSecretRef
 */
export interface CheckSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema CheckSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendEnvFromSecretRef(obj: CheckSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendGcsAccessTokenSecretRef
 */
export interface CheckSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendGcsAccessTokenSecretRef(obj: CheckSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendGcsProjectIdSecretRef
 */
export interface CheckSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendGcsProjectIdSecretRef(obj: CheckSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendRestPasswordSecretReg
 */
export interface CheckSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendRestPasswordSecretReg(obj: CheckSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendRestUserSecretRef
 */
export interface CheckSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendRestUserSecretRef(obj: CheckSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendS3AccessKeyIdSecretRef
 */
export interface CheckSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendS3AccessKeyIdSecretRef(obj: CheckSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema CheckSpecBackendS3SecretAccessKeySecretRef
 */
export interface CheckSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema CheckSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CheckSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema CheckSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'CheckSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CheckSpecBackendS3SecretAccessKeySecretRef(obj: CheckSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * PreBackupPod is the Schema for the prebackuppods API
 *
 * @schema PreBackupPod
 */
export class PreBackupPod extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PreBackupPod"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'PreBackupPod',
  }

  /**
   * Renders a Kubernetes manifest for "PreBackupPod".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PreBackupPodProps = {}): any {
    return {
      ...PreBackupPod.GVK,
      ...toJson_PreBackupPodProps(props),
    };
  }

  /**
   * Defines a "PreBackupPod" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PreBackupPodProps = {}) {
    super(scope, id, {
      ...PreBackupPod.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PreBackupPod.GVK,
      ...toJson_PreBackupPodProps(resolved),
    };
  }
}

/**
 * PreBackupPod is the Schema for the prebackuppods API
 *
 * @schema PreBackupPod
 */
export interface PreBackupPodProps {
  /**
   * @schema PreBackupPod#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PreBackupPodSpec define pods that will be launched during the backup. After the backup has finished (successfully or not), they should be removed again automatically by the operator.
   *
   * @schema PreBackupPod#spec
   */
  readonly spec?: PreBackupPodSpec;

}

/**
 * Converts an object of type 'PreBackupPodProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodProps(obj: PreBackupPodProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PreBackupPodSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreBackupPodSpec define pods that will be launched during the backup. After the backup has finished (successfully or not), they should be removed again automatically by the operator.
 *
 * @schema PreBackupPodSpec
 */
export interface PreBackupPodSpec {
  /**
   * BackupCommand will be added to the backupcommand annotation on the pod.
   *
   * @schema PreBackupPodSpec#backupCommand
   */
  readonly backupCommand?: string;

  /**
   * @schema PreBackupPodSpec#fileExtension
   */
  readonly fileExtension?: string;

  /**
   * Pod is a dummy struct to fix some code generation issues.
   *
   * @schema PreBackupPodSpec#pod
   */
  readonly pod?: PreBackupPodSpecPod;

}

/**
 * Converts an object of type 'PreBackupPodSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpec(obj: PreBackupPodSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupCommand': obj.backupCommand,
    'fileExtension': obj.fileExtension,
    'pod': toJson_PreBackupPodSpecPod(obj.pod),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod is a dummy struct to fix some code generation issues.
 *
 * @schema PreBackupPodSpecPod
 */
export interface PreBackupPodSpecPod {
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema PreBackupPodSpecPod#metadata
   */
  readonly metadata?: any;

  /**
   * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema PreBackupPodSpecPod#spec
   */
  readonly spec?: PreBackupPodSpecPodSpec;

}

/**
 * Converts an object of type 'PreBackupPodSpecPod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPod(obj: PreBackupPodSpecPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PreBackupPodSpecPodSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema PreBackupPodSpecPodSpec
 */
export interface PreBackupPodSpecPodSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
   *
   * @schema PreBackupPodSpecPodSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema PreBackupPodSpecPodSpec#affinity
   */
  readonly affinity?: PreBackupPodSpecPodSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema PreBackupPodSpecPodSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpec#containers
   */
  readonly containers: PreBackupPodSpecPodSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
   *
   * @schema PreBackupPodSpecPodSpec#dnsConfig
   */
  readonly dnsConfig?: PreBackupPodSpecPodSpecDnsConfig;

  /**
   * Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   * @schema PreBackupPodSpecPodSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.
   *
   * @default true.
   * @schema PreBackupPodSpecPodSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema PreBackupPodSpecPodSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: PreBackupPodSpecPodSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
   *
   * @schema PreBackupPodSpecPodSpec#hostAliases
   */
  readonly hostAliases?: PreBackupPodSpecPodSpecHostAliases[];

  /**
   * Use the host's ipc namespace. Optional: Default to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace. Optional: Default to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   * @schema PreBackupPodSpecPodSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema PreBackupPodSpecPodSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema PreBackupPodSpecPodSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PreBackupPodSpecPodSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema PreBackupPodSpecPodSpec#initContainers
   */
  readonly initContainers?: PreBackupPodSpecPodSpecInitContainers[];

  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
   *
   * @schema PreBackupPodSpecPodSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema PreBackupPodSpecPodSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.
   * If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions
   * If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup
   *
   * @schema PreBackupPodSpecPodSpec#os
   */
  readonly os?: PreBackupPodSpecPodSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema PreBackupPodSpecPodSpec#overhead
   */
  readonly overhead?: { [key: string]: PreBackupPodSpecPodSpecOverhead };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema PreBackupPodSpecPodSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
   *
   * @schema PreBackupPodSpecPodSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema PreBackupPodSpecPodSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema PreBackupPodSpecPodSpec#readinessGates
   */
  readonly readinessGates?: PreBackupPodSpecPodSpecReadinessGates[];

  /**
   * Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * @schema PreBackupPodSpecPodSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema PreBackupPodSpecPodSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema PreBackupPodSpecPodSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema PreBackupPodSpecPodSpec#securityContext
   */
  readonly securityContext?: PreBackupPodSpecPodSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
   *
   * @schema PreBackupPodSpecPodSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema PreBackupPodSpecPodSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
   *
   * @schema PreBackupPodSpecPodSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema PreBackupPodSpecPodSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema PreBackupPodSpecPodSpec#tolerations
   */
  readonly tolerations?: PreBackupPodSpecPodSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
   *
   * @schema PreBackupPodSpecPodSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: PreBackupPodSpecPodSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema PreBackupPodSpecPodSpec#volumes
   */
  readonly volumes?: PreBackupPodSpecPodSpecVolumes[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpec(obj: PreBackupPodSpecPodSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'affinity': toJson_PreBackupPodSpecPodSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_PreBackupPodSpecPodSpecContainers(y)),
    'dnsConfig': toJson_PreBackupPodSpecPodSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enableServiceLinks': obj.enableServiceLinks,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainers(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_PreBackupPodSpecPodSpecHostAliases(y)),
    'hostIPC': obj.hostIpc,
    'hostNetwork': obj.hostNetwork,
    'hostPID': obj.hostPid,
    'hostUsers': obj.hostUsers,
    'hostname': obj.hostname,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_PreBackupPodSpecPodSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_PreBackupPodSpecPodSpecInitContainers(y)),
    'nodeName': obj.nodeName,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'os': toJson_PreBackupPodSpecPodSpecOs(obj.os),
    'overhead': ((obj.overhead) === undefined) ? undefined : (Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'preemptionPolicy': obj.preemptionPolicy,
    'priority': obj.priority,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_PreBackupPodSpecPodSpecReadinessGates(y)),
    'restartPolicy': obj.restartPolicy,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'securityContext': toJson_PreBackupPodSpecPodSpecSecurityContext(obj.securityContext),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountName': obj.serviceAccountName,
    'setHostnameAsFQDN': obj.setHostnameAsFqdn,
    'shareProcessNamespace': obj.shareProcessNamespace,
    'subdomain': obj.subdomain,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_PreBackupPodSpecPodSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_PreBackupPodSpecPodSpecTopologySpreadConstraints(y)),
    'volumes': obj.volumes?.map(y => toJson_PreBackupPodSpecPodSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema PreBackupPodSpecPodSpecAffinity
 */
export interface PreBackupPodSpecPodSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema PreBackupPodSpecPodSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PreBackupPodSpecPodSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PreBackupPodSpecPodSpecAffinity#podAffinity
   */
  readonly podAffinity?: PreBackupPodSpecPodSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PreBackupPodSpecPodSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PreBackupPodSpecPodSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinity(obj: PreBackupPodSpecPodSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_PreBackupPodSpecPodSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_PreBackupPodSpecPodSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PreBackupPodSpecPodSpecContainers
 */
export interface PreBackupPodSpecPodSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#env
   */
  readonly env?: PreBackupPodSpecPodSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#envFrom
   */
  readonly envFrom?: PreBackupPodSpecPodSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PreBackupPodSpecPodSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PreBackupPodSpecPodSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#lifecycle
   */
  readonly lifecycle?: PreBackupPodSpecPodSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainers#livenessProbe
   */
  readonly livenessProbe?: PreBackupPodSpecPodSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#ports
   */
  readonly ports?: PreBackupPodSpecPodSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainers#readinessProbe
   */
  readonly readinessProbe?: PreBackupPodSpecPodSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecContainers#resources
   */
  readonly resources?: PreBackupPodSpecPodSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PreBackupPodSpecPodSpecContainers#securityContext
   */
  readonly securityContext?: PreBackupPodSpecPodSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainers#startupProbe
   */
  readonly startupProbe?: PreBackupPodSpecPodSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PreBackupPodSpecPodSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PreBackupPodSpecPodSpecContainers#volumeDevices
   */
  readonly volumeDevices?: PreBackupPodSpecPodSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#volumeMounts
   */
  readonly volumeMounts?: PreBackupPodSpecPodSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainers(obj: PreBackupPodSpecPodSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_PreBackupPodSpecPodSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_PreBackupPodSpecPodSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_PreBackupPodSpecPodSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_PreBackupPodSpecPodSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_PreBackupPodSpecPodSpecContainersPorts(y)),
    'readinessProbe': toJson_PreBackupPodSpecPodSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_PreBackupPodSpecPodSpecContainersResources(obj.resources),
    'securityContext': toJson_PreBackupPodSpecPodSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_PreBackupPodSpecPodSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_PreBackupPodSpecPodSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PreBackupPodSpecPodSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
 *
 * @schema PreBackupPodSpecPodSpecDnsConfig
 */
export interface PreBackupPodSpecPodSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema PreBackupPodSpecPodSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema PreBackupPodSpecPodSpecDnsConfig#options
   */
  readonly options?: PreBackupPodSpecPodSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema PreBackupPodSpecPodSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecDnsConfig(obj: PreBackupPodSpecPodSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_PreBackupPodSpecPodSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainers
 */
export interface PreBackupPodSpecPodSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint. The image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#env
   */
  readonly env?: PreBackupPodSpecPodSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: PreBackupPodSpecPodSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: PreBackupPodSpecPodSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#ports
   */
  readonly ports?: PreBackupPodSpecPodSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe;

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#resources
   */
  readonly resources?: PreBackupPodSpecPodSpecEphemeralContainersResources;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: PreBackupPodSpecPodSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   * The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainers(obj: PreBackupPodSpecPodSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_PreBackupPodSpecPodSpecEphemeralContainersResources(obj.resources),
    'securityContext': toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema PreBackupPodSpecPodSpecHostAliases
 */
export interface PreBackupPodSpecPodSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema PreBackupPodSpecPodSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema PreBackupPodSpecPodSpecHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecHostAliases(obj: PreBackupPodSpecPodSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PreBackupPodSpecPodSpecImagePullSecrets
 */
export interface PreBackupPodSpecPodSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecImagePullSecrets(obj: PreBackupPodSpecPodSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PreBackupPodSpecPodSpecInitContainers
 */
export interface PreBackupPodSpecPodSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#env
   */
  readonly env?: PreBackupPodSpecPodSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#envFrom
   */
  readonly envFrom?: PreBackupPodSpecPodSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PreBackupPodSpecPodSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PreBackupPodSpecPodSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PreBackupPodSpecPodSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#ports
   */
  readonly ports?: PreBackupPodSpecPodSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PreBackupPodSpecPodSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#resources
   */
  readonly resources?: PreBackupPodSpecPodSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#securityContext
   */
  readonly securityContext?: PreBackupPodSpecPodSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#startupProbe
   */
  readonly startupProbe?: PreBackupPodSpecPodSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PreBackupPodSpecPodSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PreBackupPodSpecPodSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PreBackupPodSpecPodSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PreBackupPodSpecPodSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PreBackupPodSpecPodSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainers(obj: PreBackupPodSpecPodSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_PreBackupPodSpecPodSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersPorts(y)),
    'readinessProbe': toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_PreBackupPodSpecPodSpecInitContainersResources(obj.resources),
    'securityContext': toJson_PreBackupPodSpecPodSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_PreBackupPodSpecPodSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.
 * If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions
 * If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup
 *
 * @schema PreBackupPodSpecPodSpecOs
 */
export interface PreBackupPodSpecPodSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows. Additional value may be defined in future and can be one of: https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema PreBackupPodSpecPodSpecOs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecOs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecOs(obj: PreBackupPodSpecPodSpecOs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PreBackupPodSpecPodSpecOverhead
 */
export class PreBackupPodSpecPodSpecOverhead {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecOverhead {
    return new PreBackupPodSpecPodSpecOverhead(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecOverhead {
    return new PreBackupPodSpecPodSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema PreBackupPodSpecPodSpecReadinessGates
 */
export interface PreBackupPodSpecPodSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema PreBackupPodSpecPodSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecReadinessGates(obj: PreBackupPodSpecPodSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema PreBackupPodSpecPodSpecSecurityContext
 */
export interface PreBackupPodSpecPodSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PreBackupPodSpecPodSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#sysctls
   */
  readonly sysctls?: PreBackupPodSpecPodSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PreBackupPodSpecPodSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecSecurityContext(obj: PreBackupPodSpecPodSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PreBackupPodSpecPodSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_PreBackupPodSpecPodSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_PreBackupPodSpecPodSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PreBackupPodSpecPodSpecTolerations
 */
export interface PreBackupPodSpecPodSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PreBackupPodSpecPodSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PreBackupPodSpecPodSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema PreBackupPodSpecPodSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PreBackupPodSpecPodSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PreBackupPodSpecPodSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecTolerations(obj: PreBackupPodSpecPodSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints
 */
export interface PreBackupPodSpecPodSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecTopologySpreadConstraints(obj: PreBackupPodSpecPodSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema PreBackupPodSpecPodSpecVolumes
 */
export interface PreBackupPodSpecPodSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PreBackupPodSpecPodSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#azureDisk
   */
  readonly azureDisk?: PreBackupPodSpecPodSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#azureFile
   */
  readonly azureFile?: PreBackupPodSpecPodSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema PreBackupPodSpecPodSpecVolumes#cephfs
   */
  readonly cephfs?: PreBackupPodSpecPodSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumes#cinder
   */
  readonly cinder?: PreBackupPodSpecPodSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema PreBackupPodSpecPodSpecVolumes#configMap
   */
  readonly configMap?: PreBackupPodSpecPodSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema PreBackupPodSpecPodSpecVolumes#csi
   */
  readonly csi?: PreBackupPodSpecPodSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema PreBackupPodSpecPodSpecVolumes#downwardAPI
   */
  readonly downwardApi?: PreBackupPodSpecPodSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PreBackupPodSpecPodSpecVolumes#emptyDir
   */
  readonly emptyDir?: PreBackupPodSpecPodSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#ephemeral
   */
  readonly ephemeral?: PreBackupPodSpecPodSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#fc
   */
  readonly fc?: PreBackupPodSpecPodSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#flexVolume
   */
  readonly flexVolume?: PreBackupPodSpecPodSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema PreBackupPodSpecPodSpecVolumes#flocker
   */
  readonly flocker?: PreBackupPodSpecPodSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PreBackupPodSpecPodSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PreBackupPodSpecPodSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#gitRepo
   */
  readonly gitRepo?: PreBackupPodSpecPodSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumes#glusterfs
   */
  readonly glusterfs?: PreBackupPodSpecPodSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#hostPath
   */
  readonly hostPath?: PreBackupPodSpecPodSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumes#iscsi
   */
  readonly iscsi?: PreBackupPodSpecPodSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PreBackupPodSpecPodSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PreBackupPodSpecPodSpecVolumes#nfs
   */
  readonly nfs?: PreBackupPodSpecPodSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PreBackupPodSpecPodSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema PreBackupPodSpecPodSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema PreBackupPodSpecPodSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: PreBackupPodSpecPodSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema PreBackupPodSpecPodSpecVolumes#projected
   */
  readonly projected?: PreBackupPodSpecPodSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema PreBackupPodSpecPodSpecVolumes#quobyte
   */
  readonly quobyte?: PreBackupPodSpecPodSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumes#rbd
   */
  readonly rbd?: PreBackupPodSpecPodSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#scaleIO
   */
  readonly scaleIo?: PreBackupPodSpecPodSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PreBackupPodSpecPodSpecVolumes#secret
   */
  readonly secret?: PreBackupPodSpecPodSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema PreBackupPodSpecPodSpecVolumes#storageos
   */
  readonly storageos?: PreBackupPodSpecPodSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema PreBackupPodSpecPodSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: PreBackupPodSpecPodSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumes(obj: PreBackupPodSpecPodSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_PreBackupPodSpecPodSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_PreBackupPodSpecPodSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_PreBackupPodSpecPodSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_PreBackupPodSpecPodSpecVolumesCinder(obj.cinder),
    'configMap': toJson_PreBackupPodSpecPodSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_PreBackupPodSpecPodSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_PreBackupPodSpecPodSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_PreBackupPodSpecPodSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_PreBackupPodSpecPodSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_PreBackupPodSpecPodSpecVolumesFc(obj.fc),
    'flexVolume': toJson_PreBackupPodSpecPodSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_PreBackupPodSpecPodSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_PreBackupPodSpecPodSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_PreBackupPodSpecPodSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_PreBackupPodSpecPodSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_PreBackupPodSpecPodSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_PreBackupPodSpecPodSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_PreBackupPodSpecPodSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_PreBackupPodSpecPodSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_PreBackupPodSpecPodSpecVolumesProjected(obj.projected),
    'quobyte': toJson_PreBackupPodSpecPodSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_PreBackupPodSpecPodSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_PreBackupPodSpecPodSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_PreBackupPodSpecPodSpecVolumesSecret(obj.secret),
    'storageos': toJson_PreBackupPodSpecPodSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_PreBackupPodSpecPodSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinity
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinity(obj: PreBackupPodSpecPodSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinity
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinity(obj: PreBackupPodSpecPodSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinity
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinity(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PreBackupPodSpecPodSpecContainersEnv
 */
export interface PreBackupPodSpecPodSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PreBackupPodSpecPodSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: PreBackupPodSpecPodSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnv(obj: PreBackupPodSpecPodSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_PreBackupPodSpecPodSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvFrom
 */
export interface PreBackupPodSpecPodSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvFrom(obj: PreBackupPodSpecPodSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PreBackupPodSpecPodSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecycle
 */
export interface PreBackupPodSpecPodSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecycle#postStart
   */
  readonly postStart?: PreBackupPodSpecPodSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecycle#preStop
   */
  readonly preStop?: PreBackupPodSpecPodSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecycle(obj: PreBackupPodSpecPodSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbe
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbe(obj: PreBackupPodSpecPodSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PreBackupPodSpecPodSpecContainersPorts
 */
export interface PreBackupPodSpecPodSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PreBackupPodSpecPodSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PreBackupPodSpecPodSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PreBackupPodSpecPodSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PreBackupPodSpecPodSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PreBackupPodSpecPodSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersPorts(obj: PreBackupPodSpecPodSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbe
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbe(obj: PreBackupPodSpecPodSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PreBackupPodSpecPodSpecContainersResources
 */
export interface PreBackupPodSpecPodSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: PreBackupPodSpecPodSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: PreBackupPodSpecPodSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersResources(obj: PreBackupPodSpecPodSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PreBackupPodSpecPodSpecContainersSecurityContext
 */
export interface PreBackupPodSpecPodSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: PreBackupPodSpecPodSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersSecurityContext(obj: PreBackupPodSpecPodSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_PreBackupPodSpecPodSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbe
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbe(obj: PreBackupPodSpecPodSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PreBackupPodSpecPodSpecContainersVolumeDevices
 */
export interface PreBackupPodSpecPodSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PreBackupPodSpecPodSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PreBackupPodSpecPodSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersVolumeDevices(obj: PreBackupPodSpecPodSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PreBackupPodSpecPodSpecContainersVolumeMounts
 */
export interface PreBackupPodSpecPodSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PreBackupPodSpecPodSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersVolumeMounts(obj: PreBackupPodSpecPodSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema PreBackupPodSpecPodSpecDnsConfigOptions
 */
export interface PreBackupPodSpecPodSpecDnsConfigOptions {
  /**
   * Required.
   *
   * @schema PreBackupPodSpecPodSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema PreBackupPodSpecPodSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecDnsConfigOptions(obj: PreBackupPodSpecPodSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnv
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnv(obj: PreBackupPodSpecPodSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFrom
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFrom(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecycle
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecycle(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PreBackupPodSpecPodSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersPorts(obj: PreBackupPodSpecPodSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersResources
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersResources(obj: PreBackupPodSpecPodSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContext(obj: PreBackupPodSpecPodSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbe(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices(obj: PreBackupPodSpecPodSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts(obj: PreBackupPodSpecPodSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnv
 */
export interface PreBackupPodSpecPodSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PreBackupPodSpecPodSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PreBackupPodSpecPodSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnv(obj: PreBackupPodSpecPodSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvFrom
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvFrom(obj: PreBackupPodSpecPodSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecycle
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PreBackupPodSpecPodSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PreBackupPodSpecPodSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecycle(obj: PreBackupPodSpecPodSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbe(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersPorts
 */
export interface PreBackupPodSpecPodSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PreBackupPodSpecPodSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersPorts(obj: PreBackupPodSpecPodSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbe(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PreBackupPodSpecPodSpecInitContainersResources
 */
export interface PreBackupPodSpecPodSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: PreBackupPodSpecPodSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: PreBackupPodSpecPodSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersResources(obj: PreBackupPodSpecPodSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext
 */
export interface PreBackupPodSpecPodSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersSecurityContext(obj: PreBackupPodSpecPodSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbe(obj: PreBackupPodSpecPodSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersVolumeDevices
 */
export interface PreBackupPodSpecPodSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersVolumeDevices(obj: PreBackupPodSpecPodSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts
 */
export interface PreBackupPodSpecPodSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PreBackupPodSpecPodSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersVolumeMounts(obj: PreBackupPodSpecPodSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions
 */
export interface PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions(obj: PreBackupPodSpecPodSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecSecurityContextSeccompProfile
 */
export interface PreBackupPodSpecPodSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecSecurityContextSeccompProfile(obj: PreBackupPodSpecPodSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PreBackupPodSpecPodSpecSecurityContextSysctls
 */
export interface PreBackupPodSpecPodSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecSecurityContextSysctls(obj: PreBackupPodSpecPodSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PreBackupPodSpecPodSpecSecurityContextWindowsOptions
 */
export interface PreBackupPodSpecPodSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PreBackupPodSpecPodSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PreBackupPodSpecPodSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecSecurityContextWindowsOptions(obj: PreBackupPodSpecPodSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector
 */
export interface PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector(obj: PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore
 */
export interface PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore(obj: PreBackupPodSpecPodSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PreBackupPodSpecPodSpecVolumesAzureDisk
 */
export interface PreBackupPodSpecPodSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PreBackupPodSpecPodSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesAzureDisk(obj: PreBackupPodSpecPodSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PreBackupPodSpecPodSpecVolumesAzureFile
 */
export interface PreBackupPodSpecPodSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema PreBackupPodSpecPodSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesAzureFile(obj: PreBackupPodSpecPodSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema PreBackupPodSpecPodSpecVolumesCephfs
 */
export interface PreBackupPodSpecPodSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCephfs(obj: PreBackupPodSpecPodSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema PreBackupPodSpecPodSpecVolumesCinder
 */
export interface PreBackupPodSpecPodSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema PreBackupPodSpecPodSpecVolumesCinder#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PreBackupPodSpecPodSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCinder(obj: PreBackupPodSpecPodSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema PreBackupPodSpecPodSpecVolumesConfigMap
 */
export interface PreBackupPodSpecPodSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PreBackupPodSpecPodSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMap#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesConfigMap(obj: PreBackupPodSpecPodSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema PreBackupPodSpecPodSpecVolumesCsi
 */
export interface PreBackupPodSpecPodSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PreBackupPodSpecPodSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema PreBackupPodSpecPodSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema PreBackupPodSpecPodSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PreBackupPodSpecPodSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema PreBackupPodSpecPodSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCsi(obj: PreBackupPodSpecPodSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema PreBackupPodSpecPodSpecVolumesDownwardApi
 */
export interface PreBackupPodSpecPodSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApi#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesDownwardApi(obj: PreBackupPodSpecPodSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PreBackupPodSpecPodSpecVolumesEmptyDir
 */
export interface PreBackupPodSpecPodSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PreBackupPodSpecPodSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema PreBackupPodSpecPodSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEmptyDir(obj: PreBackupPodSpecPodSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeral
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeral(obj: PreBackupPodSpecPodSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema PreBackupPodSpecPodSpecVolumesFc
 */
export interface PreBackupPodSpecPodSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PreBackupPodSpecPodSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema PreBackupPodSpecPodSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PreBackupPodSpecPodSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema PreBackupPodSpecPodSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesFc(obj: PreBackupPodSpecPodSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema PreBackupPodSpecPodSpecVolumesFlexVolume
 */
export interface PreBackupPodSpecPodSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesFlexVolume(obj: PreBackupPodSpecPodSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema PreBackupPodSpecPodSpecVolumesFlocker
 */
export interface PreBackupPodSpecPodSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesFlocker(obj: PreBackupPodSpecPodSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema PreBackupPodSpecPodSpecVolumesGcePersistentDisk
 */
export interface PreBackupPodSpecPodSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PreBackupPodSpecPodSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PreBackupPodSpecPodSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PreBackupPodSpecPodSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema PreBackupPodSpecPodSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesGcePersistentDisk(obj: PreBackupPodSpecPodSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema PreBackupPodSpecPodSpecVolumesGitRepo
 */
export interface PreBackupPodSpecPodSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema PreBackupPodSpecPodSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema PreBackupPodSpecPodSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema PreBackupPodSpecPodSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesGitRepo(obj: PreBackupPodSpecPodSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema PreBackupPodSpecPodSpecVolumesGlusterfs
 */
export interface PreBackupPodSpecPodSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PreBackupPodSpecPodSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PreBackupPodSpecPodSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema PreBackupPodSpecPodSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesGlusterfs(obj: PreBackupPodSpecPodSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema PreBackupPodSpecPodSpecVolumesHostPath
 */
export interface PreBackupPodSpecPodSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PreBackupPodSpecPodSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PreBackupPodSpecPodSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesHostPath(obj: PreBackupPodSpecPodSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema PreBackupPodSpecPodSpecVolumesIscsi
 */
export interface PreBackupPodSpecPodSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesIscsi(obj: PreBackupPodSpecPodSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema PreBackupPodSpecPodSpecVolumesNfs
 */
export interface PreBackupPodSpecPodSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PreBackupPodSpecPodSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema PreBackupPodSpecPodSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PreBackupPodSpecPodSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesNfs(obj: PreBackupPodSpecPodSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim
 */
export interface PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim(obj: PreBackupPodSpecPodSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk
 */
export interface PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk(obj: PreBackupPodSpecPodSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema PreBackupPodSpecPodSpecVolumesPortworxVolume
 */
export interface PreBackupPodSpecPodSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PreBackupPodSpecPodSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PreBackupPodSpecPodSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema PreBackupPodSpecPodSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesPortworxVolume(obj: PreBackupPodSpecPodSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjected
 */
export interface PreBackupPodSpecPodSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjected#sources
   */
  readonly sources?: PreBackupPodSpecPodSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjected(obj: PreBackupPodSpecPodSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_PreBackupPodSpecPodSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema PreBackupPodSpecPodSpecVolumesQuobyte
 */
export interface PreBackupPodSpecPodSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PreBackupPodSpecPodSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesQuobyte(obj: PreBackupPodSpecPodSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema PreBackupPodSpecPodSpecVolumesRbd
 */
export interface PreBackupPodSpecPodSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PreBackupPodSpecPodSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PreBackupPodSpecPodSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesRbd#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PreBackupPodSpecPodSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesRbd(obj: PreBackupPodSpecPodSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema PreBackupPodSpecPodSpecVolumesScaleIo
 */
export interface PreBackupPodSpecPodSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: PreBackupPodSpecPodSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesScaleIo(obj: PreBackupPodSpecPodSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema PreBackupPodSpecPodSpecVolumesSecret
 */
export interface PreBackupPodSpecPodSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PreBackupPodSpecPodSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecret#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesSecret(obj: PreBackupPodSpecPodSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema PreBackupPodSpecPodSpecVolumesStorageos
 */
export interface PreBackupPodSpecPodSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: PreBackupPodSpecPodSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesStorageos(obj: PreBackupPodSpecPodSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PreBackupPodSpecPodSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema PreBackupPodSpecPodSpecVolumesVsphereVolume
 */
export interface PreBackupPodSpecPodSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PreBackupPodSpecPodSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PreBackupPodSpecPodSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema PreBackupPodSpecPodSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema PreBackupPodSpecPodSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesVsphereVolume(obj: PreBackupPodSpecPodSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFrom
 */
export interface PreBackupPodSpecPodSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvValueFrom(obj: PreBackupPodSpecPodSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef(obj: PreBackupPodSpecPodSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvFromSecretRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvFromSecretRef(obj: PreBackupPodSpecPodSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStart
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStart(obj: PreBackupPodSpecPodSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStop
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStop(obj: PreBackupPodSpecPodSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeExec
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbeExec(obj: PreBackupPodSpecPodSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbeGrpc(obj: PreBackupPodSpecPodSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet(obj: PreBackupPodSpecPodSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket(obj: PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeExec
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbeExec(obj: PreBackupPodSpecPodSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbeGrpc(obj: PreBackupPodSpecPodSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet(obj: PreBackupPodSpecPodSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket(obj: PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PreBackupPodSpecPodSpecContainersResourcesLimits
 */
export class PreBackupPodSpecPodSpecContainersResourcesLimits {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PreBackupPodSpecPodSpecContainersResourcesRequests
 */
export class PreBackupPodSpecPodSpecContainersResourcesRequests {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PreBackupPodSpecPodSpecContainersSecurityContextCapabilities
 */
export interface PreBackupPodSpecPodSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersSecurityContextCapabilities(obj: PreBackupPodSpecPodSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions
 */
export interface PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions(obj: PreBackupPodSpecPodSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile
 */
export interface PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile(obj: PreBackupPodSpecPodSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions
 */
export interface PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions(obj: PreBackupPodSpecPodSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeExec
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbeExec(obj: PreBackupPodSpecPodSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeGrpc
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbeGrpc(obj: PreBackupPodSpecPodSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbeHttpGet(obj: PreBackupPodSpecPodSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket(obj: PreBackupPodSpecPodSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits
 */
export class PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests
 */
export class PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities(obj: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile(obj: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions(obj: PreBackupPodSpecPodSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFrom
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFrom(obj: PreBackupPodSpecPodSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef(obj: PreBackupPodSpecPodSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef(obj: PreBackupPodSpecPodSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStart
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStart(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStop
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStop(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeExec
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeExec(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeExec
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeExec(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PreBackupPodSpecPodSpecInitContainersResourcesLimits
 */
export class PreBackupPodSpecPodSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersResourcesLimits {
    return new PreBackupPodSpecPodSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PreBackupPodSpecPodSpecInitContainersResourcesRequests
 */
export class PreBackupPodSpecPodSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersResourcesRequests {
    return new PreBackupPodSpecPodSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities
 */
export interface PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities(obj: PreBackupPodSpecPodSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions(obj: PreBackupPodSpecPodSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile
 */
export interface PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile(obj: PreBackupPodSpecPodSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions
 */
export interface PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions(obj: PreBackupPodSpecPodSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeExec
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeExec(obj: PreBackupPodSpecPodSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is a beta field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc(obj: PreBackupPodSpecPodSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet(obj: PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket(obj: PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema PreBackupPodSpecPodSpecVolumesCephfsSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCephfsSecretRef(obj: PreBackupPodSpecPodSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema PreBackupPodSpecPodSpecVolumesCinderSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCinderSecretRef(obj: PreBackupPodSpecPodSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PreBackupPodSpecPodSpecVolumesConfigMapItems
 */
export interface PreBackupPodSpecPodSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesConfigMapItems(obj: PreBackupPodSpecPodSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef(obj: PreBackupPodSpecPodSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItems
 */
export interface PreBackupPodSpecPodSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItems(obj: PreBackupPodSpecPodSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit
 */
export class PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit {
    return new PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit {
    return new PreBackupPodSpecPodSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef(obj: PreBackupPodSpecPodSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema PreBackupPodSpecPodSpecVolumesIscsiSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesIscsiSecretRef(obj: PreBackupPodSpecPodSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSources
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSources#secret
   */
  readonly secret?: PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSources(obj: PreBackupPodSpecPodSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema PreBackupPodSpecPodSpecVolumesRbdSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesRbdSecretRef(obj: PreBackupPodSpecPodSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema PreBackupPodSpecPodSpecVolumesScaleIoSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesScaleIoSecretRef(obj: PreBackupPodSpecPodSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PreBackupPodSpecPodSpecVolumesSecretItems
 */
export interface PreBackupPodSpecPodSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesSecretItems(obj: PreBackupPodSpecPodSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema PreBackupPodSpecPodSpecVolumesStorageosSecretRef
 */
export interface PreBackupPodSpecPodSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesStorageosSecretRef(obj: PreBackupPodSpecPodSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef(obj: PreBackupPodSpecPodSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef(obj: PreBackupPodSpecPodSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef(obj: PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef
 */
export interface PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef(obj: PreBackupPodSpecPodSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartExec
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartExec(obj: PreBackupPodSpecPodSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet(obj: PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket(obj: PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopExec
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopExec(obj: PreBackupPodSpecPodSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet(obj: PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket(obj: PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef(obj: PreBackupPodSpecPodSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef(obj: PreBackupPodSpecPodSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef(obj: PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef(obj: PreBackupPodSpecPodSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort
 */
export class PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort
 */
export class PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef
 */
export interface PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef(obj: PreBackupPodSpecPodSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef(obj: PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: PreBackupPodSpecPodSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort
 */
export class PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort
 */
export class PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort
 */
export class PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort
 */
export class PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PreBackupPodSpecPodSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: PreBackupPodSpecPodSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PreBackupPodSpecPodSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * Prune is the Schema for the prunes API
 *
 * @schema Prune
 */
export class Prune extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Prune"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Prune',
  }

  /**
   * Renders a Kubernetes manifest for "Prune".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PruneProps = {}): any {
    return {
      ...Prune.GVK,
      ...toJson_PruneProps(props),
    };
  }

  /**
   * Defines a "Prune" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PruneProps = {}) {
    super(scope, id, {
      ...Prune.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Prune.GVK,
      ...toJson_PruneProps(resolved),
    };
  }
}

/**
 * Prune is the Schema for the prunes API
 *
 * @schema Prune
 */
export interface PruneProps {
  /**
   * @schema Prune#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PruneSpec needs to contain the repository information as well as the desired retention policies.
   *
   * @schema Prune#spec
   */
  readonly spec?: PruneSpec;

}

/**
 * Converts an object of type 'PruneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneProps(obj: PruneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PruneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PruneSpec needs to contain the repository information as well as the desired retention policies.
 *
 * @schema PruneSpec
 */
export interface PruneSpec {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema PruneSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema PruneSpec#backend
   */
  readonly backend?: PruneSpecBackend;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema PruneSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema PruneSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema PruneSpec#podSecurityContext
   */
  readonly podSecurityContext?: PruneSpecPodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema PruneSpec#resources
   */
  readonly resources?: PruneSpecResources;

  /**
   * Retention sets how many backups should be kept after a forget and prune
   *
   * @schema PruneSpec#retention
   */
  readonly retention?: PruneSpecRetention;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema PruneSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

}

/**
 * Converts an object of type 'PruneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpec(obj: PruneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_PruneSpecBackend(obj.backend),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_PruneSpecPodSecurityContext(obj.podSecurityContext),
    'resources': toJson_PruneSpecResources(obj.resources),
    'retention': toJson_PruneSpecRetention(obj.retention),
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema PruneSpecBackend
 */
export interface PruneSpecBackend {
  /**
   * @schema PruneSpecBackend#azure
   */
  readonly azure?: PruneSpecBackendAzure;

  /**
   * @schema PruneSpecBackend#b2
   */
  readonly b2?: PruneSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema PruneSpecBackend#envFrom
   */
  readonly envFrom?: PruneSpecBackendEnvFrom[];

  /**
   * @schema PruneSpecBackend#gcs
   */
  readonly gcs?: PruneSpecBackendGcs;

  /**
   * @schema PruneSpecBackend#local
   */
  readonly local?: PruneSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema PruneSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: PruneSpecBackendRepoPasswordSecretRef;

  /**
   * @schema PruneSpecBackend#rest
   */
  readonly rest?: PruneSpecBackendRest;

  /**
   * @schema PruneSpecBackend#s3
   */
  readonly s3?: PruneSpecBackendS3;

  /**
   * @schema PruneSpecBackend#swift
   */
  readonly swift?: PruneSpecBackendSwift;

}

/**
 * Converts an object of type 'PruneSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackend(obj: PruneSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_PruneSpecBackendAzure(obj.azure),
    'b2': toJson_PruneSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_PruneSpecBackendEnvFrom(y)),
    'gcs': toJson_PruneSpecBackendGcs(obj.gcs),
    'local': toJson_PruneSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_PruneSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_PruneSpecBackendRest(obj.rest),
    's3': toJson_PruneSpecBackendS3(obj.s3),
    'swift': toJson_PruneSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema PruneSpecPodSecurityContext
 */
export interface PruneSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PruneSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema PruneSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PruneSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PruneSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PruneSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: PruneSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PruneSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PruneSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PruneSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecPodSecurityContext(obj: PruneSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PruneSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PruneSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_PruneSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_PruneSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema PruneSpecResources
 */
export interface PruneSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PruneSpecResources#limits
   */
  readonly limits?: { [key: string]: PruneSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PruneSpecResources#requests
   */
  readonly requests?: { [key: string]: PruneSpecResourcesRequests };

}

/**
 * Converts an object of type 'PruneSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecResources(obj: PruneSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retention sets how many backups should be kept after a forget and prune
 *
 * @schema PruneSpecRetention
 */
export interface PruneSpecRetention {
  /**
   * Hostnames is a filter on what hostnames the policy should be applied
   *
   * @schema PruneSpecRetention#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema PruneSpecRetention#keepDaily
   */
  readonly keepDaily?: number;

  /**
   * @schema PruneSpecRetention#keepHourly
   */
  readonly keepHourly?: number;

  /**
   * @schema PruneSpecRetention#keepLast
   */
  readonly keepLast?: number;

  /**
   * @schema PruneSpecRetention#keepMonthly
   */
  readonly keepMonthly?: number;

  /**
   * @schema PruneSpecRetention#keepTags
   */
  readonly keepTags?: string[];

  /**
   * @schema PruneSpecRetention#keepWeekly
   */
  readonly keepWeekly?: number;

  /**
   * @schema PruneSpecRetention#keepYearly
   */
  readonly keepYearly?: number;

  /**
   * Tags is a filter on what tags the policy should be applied DO NOT CONFUSE THIS WITH KeepTags OR YOU'LL have a bad time
   *
   * @schema PruneSpecRetention#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'PruneSpecRetention' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecRetention(obj: PruneSpecRetention | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'keepDaily': obj.keepDaily,
    'keepHourly': obj.keepHourly,
    'keepLast': obj.keepLast,
    'keepMonthly': obj.keepMonthly,
    'keepTags': obj.keepTags?.map(y => y),
    'keepWeekly': obj.keepWeekly,
    'keepYearly': obj.keepYearly,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendAzure
 */
export interface PruneSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: PruneSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: PruneSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema PruneSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'PruneSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendAzure(obj: PruneSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_PruneSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_PruneSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendB2
 */
export interface PruneSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: PruneSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: PruneSpecBackendB2AccountKeySecretRef;

  /**
   * @schema PruneSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema PruneSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PruneSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendB2(obj: PruneSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_PruneSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_PruneSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PruneSpecBackendEnvFrom
 */
export interface PruneSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PruneSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: PruneSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PruneSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PruneSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: PruneSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'PruneSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendEnvFrom(obj: PruneSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PruneSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PruneSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendGcs
 */
export interface PruneSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: PruneSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema PruneSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: PruneSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'PruneSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendGcs(obj: PruneSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_PruneSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_PruneSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendLocal
 */
export interface PruneSpecBackendLocal {
  /**
   * @schema PruneSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'PruneSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendLocal(obj: PruneSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema PruneSpecBackendRepoPasswordSecretRef
 */
export interface PruneSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendRepoPasswordSecretRef(obj: PruneSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendRest
 */
export interface PruneSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: PruneSpecBackendRestPasswordSecretReg;

  /**
   * @schema PruneSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: PruneSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'PruneSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendRest(obj: PruneSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_PruneSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_PruneSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendS3
 */
export interface PruneSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: PruneSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema PruneSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema PruneSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PruneSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: PruneSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'PruneSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendS3(obj: PruneSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_PruneSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_PruneSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecBackendSwift
 */
export interface PruneSpecBackendSwift {
  /**
   * @schema PruneSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema PruneSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PruneSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendSwift(obj: PruneSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PruneSpecPodSecurityContextSeLinuxOptions
 */
export interface PruneSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PruneSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PruneSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PruneSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PruneSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PruneSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecPodSecurityContextSeLinuxOptions(obj: PruneSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PruneSpecPodSecurityContextSeccompProfile
 */
export interface PruneSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema PruneSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PruneSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PruneSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecPodSecurityContextSeccompProfile(obj: PruneSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PruneSpecPodSecurityContextSysctls
 */
export interface PruneSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PruneSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PruneSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PruneSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecPodSecurityContextSysctls(obj: PruneSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PruneSpecPodSecurityContextWindowsOptions
 */
export interface PruneSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PruneSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PruneSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PruneSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PruneSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PruneSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecPodSecurityContextWindowsOptions(obj: PruneSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PruneSpecResourcesLimits
 */
export class PruneSpecResourcesLimits {
  public static fromNumber(value: number): PruneSpecResourcesLimits {
    return new PruneSpecResourcesLimits(value);
  }
  public static fromString(value: string): PruneSpecResourcesLimits {
    return new PruneSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PruneSpecResourcesRequests
 */
export class PruneSpecResourcesRequests {
  public static fromNumber(value: number): PruneSpecResourcesRequests {
    return new PruneSpecResourcesRequests(value);
  }
  public static fromString(value: string): PruneSpecResourcesRequests {
    return new PruneSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendAzureAccountKeySecretRef
 */
export interface PruneSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendAzureAccountKeySecretRef(obj: PruneSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendAzureAccountNameSecretRef
 */
export interface PruneSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendAzureAccountNameSecretRef(obj: PruneSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendB2AccountIdSecretRef
 */
export interface PruneSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendB2AccountIdSecretRef(obj: PruneSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendB2AccountKeySecretRef
 */
export interface PruneSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendB2AccountKeySecretRef(obj: PruneSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PruneSpecBackendEnvFromConfigMapRef
 */
export interface PruneSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PruneSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendEnvFromConfigMapRef(obj: PruneSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PruneSpecBackendEnvFromSecretRef
 */
export interface PruneSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PruneSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendEnvFromSecretRef(obj: PruneSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendGcsAccessTokenSecretRef
 */
export interface PruneSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendGcsAccessTokenSecretRef(obj: PruneSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendGcsProjectIdSecretRef
 */
export interface PruneSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendGcsProjectIdSecretRef(obj: PruneSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendRestPasswordSecretReg
 */
export interface PruneSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendRestPasswordSecretReg(obj: PruneSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendRestUserSecretRef
 */
export interface PruneSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendRestUserSecretRef(obj: PruneSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendS3AccessKeyIdSecretRef
 */
export interface PruneSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendS3AccessKeyIdSecretRef(obj: PruneSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PruneSpecBackendS3SecretAccessKeySecretRef
 */
export interface PruneSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PruneSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PruneSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PruneSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PruneSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PruneSpecBackendS3SecretAccessKeySecretRef(obj: PruneSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Restore is the Schema for the restores API
 *
 * @schema Restore
 */
export class Restore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Restore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Restore',
  }

  /**
   * Renders a Kubernetes manifest for "Restore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RestoreProps = {}): any {
    return {
      ...Restore.GVK,
      ...toJson_RestoreProps(props),
    };
  }

  /**
   * Defines a "Restore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RestoreProps = {}) {
    super(scope, id, {
      ...Restore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Restore.GVK,
      ...toJson_RestoreProps(resolved),
    };
  }
}

/**
 * Restore is the Schema for the restores API
 *
 * @schema Restore
 */
export interface RestoreProps {
  /**
   * @schema Restore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RestoreSpec can either contain an S3 restore point or a local one. For the local one you need to define an existing PVC.
   *
   * @schema Restore#spec
   */
  readonly spec?: RestoreSpec;

}

/**
 * Converts an object of type 'RestoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreProps(obj: RestoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreSpec can either contain an S3 restore point or a local one. For the local one you need to define an existing PVC.
 *
 * @schema RestoreSpec
 */
export interface RestoreSpec {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema RestoreSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema RestoreSpec#backend
   */
  readonly backend?: RestoreSpecBackend;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema RestoreSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema RestoreSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema RestoreSpec#podSecurityContext
   */
  readonly podSecurityContext?: RestoreSpecPodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema RestoreSpec#resources
   */
  readonly resources?: RestoreSpecResources;

  /**
   * @schema RestoreSpec#restoreFilter
   */
  readonly restoreFilter?: string;

  /**
   * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
   *
   * @schema RestoreSpec#restoreMethod
   */
  readonly restoreMethod?: RestoreSpecRestoreMethod;

  /**
   * @schema RestoreSpec#snapshot
   */
  readonly snapshot?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema RestoreSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema RestoreSpec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'RestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpec(obj: RestoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_RestoreSpecBackend(obj.backend),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_RestoreSpecPodSecurityContext(obj.podSecurityContext),
    'resources': toJson_RestoreSpecResources(obj.resources),
    'restoreFilter': obj.restoreFilter,
    'restoreMethod': toJson_RestoreSpecRestoreMethod(obj.restoreMethod),
    'snapshot': obj.snapshot,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema RestoreSpecBackend
 */
export interface RestoreSpecBackend {
  /**
   * @schema RestoreSpecBackend#azure
   */
  readonly azure?: RestoreSpecBackendAzure;

  /**
   * @schema RestoreSpecBackend#b2
   */
  readonly b2?: RestoreSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema RestoreSpecBackend#envFrom
   */
  readonly envFrom?: RestoreSpecBackendEnvFrom[];

  /**
   * @schema RestoreSpecBackend#gcs
   */
  readonly gcs?: RestoreSpecBackendGcs;

  /**
   * @schema RestoreSpecBackend#local
   */
  readonly local?: RestoreSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema RestoreSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: RestoreSpecBackendRepoPasswordSecretRef;

  /**
   * @schema RestoreSpecBackend#rest
   */
  readonly rest?: RestoreSpecBackendRest;

  /**
   * @schema RestoreSpecBackend#s3
   */
  readonly s3?: RestoreSpecBackendS3;

  /**
   * @schema RestoreSpecBackend#swift
   */
  readonly swift?: RestoreSpecBackendSwift;

}

/**
 * Converts an object of type 'RestoreSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackend(obj: RestoreSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_RestoreSpecBackendAzure(obj.azure),
    'b2': toJson_RestoreSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_RestoreSpecBackendEnvFrom(y)),
    'gcs': toJson_RestoreSpecBackendGcs(obj.gcs),
    'local': toJson_RestoreSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_RestoreSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_RestoreSpecBackendRest(obj.rest),
    's3': toJson_RestoreSpecBackendS3(obj.s3),
    'swift': toJson_RestoreSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema RestoreSpecPodSecurityContext
 */
export interface RestoreSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RestoreSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema RestoreSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RestoreSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RestoreSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RestoreSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: RestoreSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RestoreSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RestoreSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RestoreSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecPodSecurityContext(obj: RestoreSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RestoreSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RestoreSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_RestoreSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_RestoreSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema RestoreSpecResources
 */
export interface RestoreSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RestoreSpecResources#limits
   */
  readonly limits?: { [key: string]: RestoreSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RestoreSpecResources#requests
   */
  readonly requests?: { [key: string]: RestoreSpecResourcesRequests };

}

/**
 * Converts an object of type 'RestoreSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecResources(obj: RestoreSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
 *
 * @schema RestoreSpecRestoreMethod
 */
export interface RestoreSpecRestoreMethod {
  /**
   * @schema RestoreSpecRestoreMethod#folder
   */
  readonly folder?: RestoreSpecRestoreMethodFolder;

  /**
   * @schema RestoreSpecRestoreMethod#s3
   */
  readonly s3?: RestoreSpecRestoreMethodS3;

}

/**
 * Converts an object of type 'RestoreSpecRestoreMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecRestoreMethod(obj: RestoreSpecRestoreMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'folder': toJson_RestoreSpecRestoreMethodFolder(obj.folder),
    's3': toJson_RestoreSpecRestoreMethodS3(obj.s3),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendAzure
 */
export interface RestoreSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: RestoreSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: RestoreSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema RestoreSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'RestoreSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendAzure(obj: RestoreSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_RestoreSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_RestoreSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendB2
 */
export interface RestoreSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: RestoreSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: RestoreSpecBackendB2AccountKeySecretRef;

  /**
   * @schema RestoreSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema RestoreSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'RestoreSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendB2(obj: RestoreSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_RestoreSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_RestoreSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RestoreSpecBackendEnvFrom
 */
export interface RestoreSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RestoreSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: RestoreSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RestoreSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RestoreSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: RestoreSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'RestoreSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendEnvFrom(obj: RestoreSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RestoreSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RestoreSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendGcs
 */
export interface RestoreSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: RestoreSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema RestoreSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: RestoreSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'RestoreSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendGcs(obj: RestoreSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_RestoreSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_RestoreSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendLocal
 */
export interface RestoreSpecBackendLocal {
  /**
   * @schema RestoreSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'RestoreSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendLocal(obj: RestoreSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema RestoreSpecBackendRepoPasswordSecretRef
 */
export interface RestoreSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendRepoPasswordSecretRef(obj: RestoreSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendRest
 */
export interface RestoreSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: RestoreSpecBackendRestPasswordSecretReg;

  /**
   * @schema RestoreSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: RestoreSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'RestoreSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendRest(obj: RestoreSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_RestoreSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_RestoreSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendS3
 */
export interface RestoreSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: RestoreSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema RestoreSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema RestoreSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: RestoreSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'RestoreSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendS3(obj: RestoreSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_RestoreSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_RestoreSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecBackendSwift
 */
export interface RestoreSpecBackendSwift {
  /**
   * @schema RestoreSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema RestoreSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'RestoreSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendSwift(obj: RestoreSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RestoreSpecPodSecurityContextSeLinuxOptions
 */
export interface RestoreSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RestoreSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RestoreSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RestoreSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RestoreSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RestoreSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecPodSecurityContextSeLinuxOptions(obj: RestoreSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RestoreSpecPodSecurityContextSeccompProfile
 */
export interface RestoreSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RestoreSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RestoreSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RestoreSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecPodSecurityContextSeccompProfile(obj: RestoreSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RestoreSpecPodSecurityContextSysctls
 */
export interface RestoreSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RestoreSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RestoreSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RestoreSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecPodSecurityContextSysctls(obj: RestoreSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RestoreSpecPodSecurityContextWindowsOptions
 */
export interface RestoreSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RestoreSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RestoreSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RestoreSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RestoreSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RestoreSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecPodSecurityContextWindowsOptions(obj: RestoreSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecResourcesLimits
 */
export class RestoreSpecResourcesLimits {
  public static fromNumber(value: number): RestoreSpecResourcesLimits {
    return new RestoreSpecResourcesLimits(value);
  }
  public static fromString(value: string): RestoreSpecResourcesLimits {
    return new RestoreSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema RestoreSpecResourcesRequests
 */
export class RestoreSpecResourcesRequests {
  public static fromNumber(value: number): RestoreSpecResourcesRequests {
    return new RestoreSpecResourcesRequests(value);
  }
  public static fromString(value: string): RestoreSpecResourcesRequests {
    return new RestoreSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema RestoreSpecRestoreMethodFolder
 */
export interface RestoreSpecRestoreMethodFolder {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RestoreSpecRestoreMethodFolder#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RestoreSpecRestoreMethodFolder#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecRestoreMethodFolder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecRestoreMethodFolder(obj: RestoreSpecRestoreMethodFolder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestoreSpecRestoreMethodS3
 */
export interface RestoreSpecRestoreMethodS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecRestoreMethodS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: RestoreSpecRestoreMethodS3AccessKeyIdSecretRef;

  /**
   * @schema RestoreSpecRestoreMethodS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema RestoreSpecRestoreMethodS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RestoreSpecRestoreMethodS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: RestoreSpecRestoreMethodS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'RestoreSpecRestoreMethodS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecRestoreMethodS3(obj: RestoreSpecRestoreMethodS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_RestoreSpecRestoreMethodS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_RestoreSpecRestoreMethodS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendAzureAccountKeySecretRef
 */
export interface RestoreSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendAzureAccountKeySecretRef(obj: RestoreSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendAzureAccountNameSecretRef
 */
export interface RestoreSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendAzureAccountNameSecretRef(obj: RestoreSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendB2AccountIdSecretRef
 */
export interface RestoreSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendB2AccountIdSecretRef(obj: RestoreSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendB2AccountKeySecretRef
 */
export interface RestoreSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendB2AccountKeySecretRef(obj: RestoreSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RestoreSpecBackendEnvFromConfigMapRef
 */
export interface RestoreSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RestoreSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendEnvFromConfigMapRef(obj: RestoreSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RestoreSpecBackendEnvFromSecretRef
 */
export interface RestoreSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RestoreSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendEnvFromSecretRef(obj: RestoreSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendGcsAccessTokenSecretRef
 */
export interface RestoreSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendGcsAccessTokenSecretRef(obj: RestoreSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendGcsProjectIdSecretRef
 */
export interface RestoreSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendGcsProjectIdSecretRef(obj: RestoreSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendRestPasswordSecretReg
 */
export interface RestoreSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendRestPasswordSecretReg(obj: RestoreSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendRestUserSecretRef
 */
export interface RestoreSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendRestUserSecretRef(obj: RestoreSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendS3AccessKeyIdSecretRef
 */
export interface RestoreSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendS3AccessKeyIdSecretRef(obj: RestoreSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecBackendS3SecretAccessKeySecretRef
 */
export interface RestoreSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecBackendS3SecretAccessKeySecretRef(obj: RestoreSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecRestoreMethodS3AccessKeyIdSecretRef
 */
export interface RestoreSpecRestoreMethodS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecRestoreMethodS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecRestoreMethodS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecRestoreMethodS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecRestoreMethodS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecRestoreMethodS3AccessKeyIdSecretRef(obj: RestoreSpecRestoreMethodS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RestoreSpecRestoreMethodS3SecretAccessKeySecretRef
 */
export interface RestoreSpecRestoreMethodS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RestoreSpecRestoreMethodS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RestoreSpecRestoreMethodS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RestoreSpecRestoreMethodS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RestoreSpecRestoreMethodS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestoreSpecRestoreMethodS3SecretAccessKeySecretRef(obj: RestoreSpecRestoreMethodS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Schedule is the Schema for the schedules API
 *
 * @schema Schedule
 */
export class Schedule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schedule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Schedule',
  }

  /**
   * Renders a Kubernetes manifest for "Schedule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduleProps = {}): any {
    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(props),
    };
  }

  /**
   * Defines a "Schedule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduleProps = {}) {
    super(scope, id, {
      ...Schedule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(resolved),
    };
  }
}

/**
 * Schedule is the Schema for the schedules API
 *
 * @schema Schedule
 */
export interface ScheduleProps {
  /**
   * @schema Schedule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduleSpec defines the schedules for the various job types.
   *
   * @schema Schedule#spec
   */
  readonly spec?: ScheduleSpec;

}

/**
 * Converts an object of type 'ScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleProps(obj: ScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduleSpec defines the schedules for the various job types.
 *
 * @schema ScheduleSpec
 */
export interface ScheduleSpec {
  /**
   * ArchiveSchedule manages schedules for the archival service
   *
   * @schema ScheduleSpec#archive
   */
  readonly archive?: ScheduleSpecArchive;

  /**
   * Backend allows configuring several backend implementations. It is expected that users only configure one storage type.
   *
   * @schema ScheduleSpec#backend
   */
  readonly backend?: ScheduleSpecBackend;

  /**
   * BackupSchedule manages schedules for the backup service
   *
   * @schema ScheduleSpec#backup
   */
  readonly backup?: ScheduleSpecBackup;

  /**
   * CheckSchedule manages the schedules for the checks
   *
   * @schema ScheduleSpec#check
   */
  readonly check?: ScheduleSpecCheck;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpec#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpec#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which actions (such as backups) shall be executed.
   *
   * @schema ScheduleSpec#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecPodSecurityContext;

  /**
   * PruneSchedule manages the schedules for the prunes
   *
   * @schema ScheduleSpec#prune
   */
  readonly prune?: ScheduleSpecPrune;

  /**
   * ResourceRequirementsTemplate describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpec#resourceRequirementsTemplate
   */
  readonly resourceRequirementsTemplate?: ScheduleSpecResourceRequirementsTemplate;

  /**
   * RestoreSchedule manages schedules for the restore service
   *
   * @schema ScheduleSpec#restore
   */
  readonly restore?: ScheduleSpecRestore;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpec#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

}

/**
 * Converts an object of type 'ScheduleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpec(obj: ScheduleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archive': toJson_ScheduleSpecArchive(obj.archive),
    'backend': toJson_ScheduleSpecBackend(obj.backend),
    'backup': toJson_ScheduleSpecBackup(obj.backup),
    'check': toJson_ScheduleSpecCheck(obj.check),
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecPodSecurityContext(obj.podSecurityContext),
    'prune': toJson_ScheduleSpecPrune(obj.prune),
    'resourceRequirementsTemplate': toJson_ScheduleSpecResourceRequirementsTemplate(obj.resourceRequirementsTemplate),
    'restore': toJson_ScheduleSpecRestore(obj.restore),
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArchiveSchedule manages schedules for the archival service
 *
 * @schema ScheduleSpecArchive
 */
export interface ScheduleSpecArchive {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ScheduleSpecArchive#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ScheduleSpecArchive#backend
   */
  readonly backend?: ScheduleSpecArchiveBackend;

  /**
   * @schema ScheduleSpecArchive#concurrentRunsAllowed
   */
  readonly concurrentRunsAllowed?: boolean;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecArchive#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpecArchive#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ScheduleSpecArchive#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecArchivePodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpecArchive#resources
   */
  readonly resources?: ScheduleSpecArchiveResources;

  /**
   * @schema ScheduleSpecArchive#restoreFilter
   */
  readonly restoreFilter?: string;

  /**
   * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
   *
   * @schema ScheduleSpecArchive#restoreMethod
   */
  readonly restoreMethod?: ScheduleSpecArchiveRestoreMethod;

  /**
   * ScheduleDefinition is the actual cron-type expression that defines the interval of the actions.
   *
   * @schema ScheduleSpecArchive#schedule
   */
  readonly schedule?: string;

  /**
   * @schema ScheduleSpecArchive#snapshot
   */
  readonly snapshot?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecArchive#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema ScheduleSpecArchive#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecArchive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchive(obj: ScheduleSpecArchive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ScheduleSpecArchiveBackend(obj.backend),
    'concurrentRunsAllowed': obj.concurrentRunsAllowed,
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecArchivePodSecurityContext(obj.podSecurityContext),
    'resources': toJson_ScheduleSpecArchiveResources(obj.resources),
    'restoreFilter': obj.restoreFilter,
    'restoreMethod': toJson_ScheduleSpecArchiveRestoreMethod(obj.restoreMethod),
    'schedule': obj.schedule,
    'snapshot': obj.snapshot,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend allows configuring several backend implementations. It is expected that users only configure one storage type.
 *
 * @schema ScheduleSpecBackend
 */
export interface ScheduleSpecBackend {
  /**
   * @schema ScheduleSpecBackend#azure
   */
  readonly azure?: ScheduleSpecBackendAzure;

  /**
   * @schema ScheduleSpecBackend#b2
   */
  readonly b2?: ScheduleSpecBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecBackendEnvFrom[];

  /**
   * @schema ScheduleSpecBackend#gcs
   */
  readonly gcs?: ScheduleSpecBackendGcs;

  /**
   * @schema ScheduleSpecBackend#local
   */
  readonly local?: ScheduleSpecBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecBackend#rest
   */
  readonly rest?: ScheduleSpecBackendRest;

  /**
   * @schema ScheduleSpecBackend#s3
   */
  readonly s3?: ScheduleSpecBackendS3;

  /**
   * @schema ScheduleSpecBackend#swift
   */
  readonly swift?: ScheduleSpecBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackend(obj: ScheduleSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecBackendRest(obj.rest),
    's3': toJson_ScheduleSpecBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSchedule manages schedules for the backup service
 *
 * @schema ScheduleSpecBackup
 */
export interface ScheduleSpecBackup {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ScheduleSpecBackup#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ScheduleSpecBackup#backend
   */
  readonly backend?: ScheduleSpecBackupBackend;

  /**
   * @schema ScheduleSpecBackup#concurrentRunsAllowed
   */
  readonly concurrentRunsAllowed?: boolean;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecBackup#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpecBackup#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ScheduleSpecBackup#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecBackupPodSecurityContext;

  /**
   * PromURL sets a prometheus push URL where the backup container send metrics to
   *
   * @schema ScheduleSpecBackup#promURL
   */
  readonly promUrl?: string;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpecBackup#resources
   */
  readonly resources?: ScheduleSpecBackupResources;

  /**
   * ScheduleDefinition is the actual cron-type expression that defines the interval of the actions.
   *
   * @schema ScheduleSpecBackup#schedule
   */
  readonly schedule?: string;

  /**
   * StatsURL sets an arbitrary URL where the restic container posts metrics and information about the snapshots to. This is in addition to the prometheus pushgateway.
   *
   * @schema ScheduleSpecBackup#statsURL
   */
  readonly statsUrl?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecBackup#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema ScheduleSpecBackup#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecBackup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackup(obj: ScheduleSpecBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ScheduleSpecBackupBackend(obj.backend),
    'concurrentRunsAllowed': obj.concurrentRunsAllowed,
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecBackupPodSecurityContext(obj.podSecurityContext),
    'promURL': obj.promUrl,
    'resources': toJson_ScheduleSpecBackupResources(obj.resources),
    'schedule': obj.schedule,
    'statsURL': obj.statsUrl,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CheckSchedule manages the schedules for the checks
 *
 * @schema ScheduleSpecCheck
 */
export interface ScheduleSpecCheck {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ScheduleSpecCheck#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ScheduleSpecCheck#backend
   */
  readonly backend?: ScheduleSpecCheckBackend;

  /**
   * @schema ScheduleSpecCheck#concurrentRunsAllowed
   */
  readonly concurrentRunsAllowed?: boolean;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecCheck#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpecCheck#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ScheduleSpecCheck#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecCheckPodSecurityContext;

  /**
   * PromURL sets a prometheus push URL where the backup container send metrics to
   *
   * @schema ScheduleSpecCheck#promURL
   */
  readonly promUrl?: string;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpecCheck#resources
   */
  readonly resources?: ScheduleSpecCheckResources;

  /**
   * ScheduleDefinition is the actual cron-type expression that defines the interval of the actions.
   *
   * @schema ScheduleSpecCheck#schedule
   */
  readonly schedule?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecCheck#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

}

/**
 * Converts an object of type 'ScheduleSpecCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheck(obj: ScheduleSpecCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ScheduleSpecCheckBackend(obj.backend),
    'concurrentRunsAllowed': obj.concurrentRunsAllowed,
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecCheckPodSecurityContext(obj.podSecurityContext),
    'promURL': obj.promUrl,
    'resources': toJson_ScheduleSpecCheckResources(obj.resources),
    'schedule': obj.schedule,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which actions (such as backups) shall be executed.
 *
 * @schema ScheduleSpecPodSecurityContext
 */
export interface ScheduleSpecPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPodSecurityContext(obj: ScheduleSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PruneSchedule manages the schedules for the prunes
 *
 * @schema ScheduleSpecPrune
 */
export interface ScheduleSpecPrune {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ScheduleSpecPrune#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ScheduleSpecPrune#backend
   */
  readonly backend?: ScheduleSpecPruneBackend;

  /**
   * @schema ScheduleSpecPrune#concurrentRunsAllowed
   */
  readonly concurrentRunsAllowed?: boolean;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecPrune#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpecPrune#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ScheduleSpecPrune#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecPrunePodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpecPrune#resources
   */
  readonly resources?: ScheduleSpecPruneResources;

  /**
   * Retention sets how many backups should be kept after a forget and prune
   *
   * @schema ScheduleSpecPrune#retention
   */
  readonly retention?: ScheduleSpecPruneRetention;

  /**
   * ScheduleDefinition is the actual cron-type expression that defines the interval of the actions.
   *
   * @schema ScheduleSpecPrune#schedule
   */
  readonly schedule?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecPrune#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

}

/**
 * Converts an object of type 'ScheduleSpecPrune' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrune(obj: ScheduleSpecPrune | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ScheduleSpecPruneBackend(obj.backend),
    'concurrentRunsAllowed': obj.concurrentRunsAllowed,
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecPrunePodSecurityContext(obj.podSecurityContext),
    'resources': toJson_ScheduleSpecPruneResources(obj.resources),
    'retention': toJson_ScheduleSpecPruneRetention(obj.retention),
    'schedule': obj.schedule,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirementsTemplate describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecResourceRequirementsTemplate
 */
export interface ScheduleSpecResourceRequirementsTemplate {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecResourceRequirementsTemplate#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecResourceRequirementsTemplateLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecResourceRequirementsTemplate#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecResourceRequirementsTemplateRequests };

}

/**
 * Converts an object of type 'ScheduleSpecResourceRequirementsTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecResourceRequirementsTemplate(obj: ScheduleSpecResourceRequirementsTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreSchedule manages schedules for the restore service
 *
 * @schema ScheduleSpecRestore
 */
export interface ScheduleSpecRestore {
  /**
   * ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it. Value must be positive integer if given.
   *
   * @schema ScheduleSpecRestore#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * Backend contains the restic repo where the job should backup to.
   *
   * @schema ScheduleSpecRestore#backend
   */
  readonly backend?: ScheduleSpecRestoreBackend;

  /**
   * @schema ScheduleSpecRestore#concurrentRunsAllowed
   */
  readonly concurrentRunsAllowed?: boolean;

  /**
   * FailedJobsHistoryLimit amount of failed jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecRestore#failedJobsHistoryLimit
   */
  readonly failedJobsHistoryLimit?: number;

  /**
   * KeepJobs amount of jobs to keep for later analysis.
   * Deprecated: Use FailedJobsHistoryLimit and SuccessfulJobsHistoryLimit respectively.
   *
   * @schema ScheduleSpecRestore#keepJobs
   */
  readonly keepJobs?: number;

  /**
   * PodSecurityContext describes the security context with which this action shall be executed.
   *
   * @schema ScheduleSpecRestore#podSecurityContext
   */
  readonly podSecurityContext?: ScheduleSpecRestorePodSecurityContext;

  /**
   * Resources describes the compute resource requirements (cpu, memory, etc.)
   *
   * @schema ScheduleSpecRestore#resources
   */
  readonly resources?: ScheduleSpecRestoreResources;

  /**
   * @schema ScheduleSpecRestore#restoreFilter
   */
  readonly restoreFilter?: string;

  /**
   * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
   *
   * @schema ScheduleSpecRestore#restoreMethod
   */
  readonly restoreMethod?: ScheduleSpecRestoreRestoreMethod;

  /**
   * ScheduleDefinition is the actual cron-type expression that defines the interval of the actions.
   *
   * @schema ScheduleSpecRestore#schedule
   */
  readonly schedule?: string;

  /**
   * @schema ScheduleSpecRestore#snapshot
   */
  readonly snapshot?: string;

  /**
   * SuccessfulJobsHistoryLimit amount of successful jobs to keep for later analysis. KeepJobs is used property is not specified.
   *
   * @schema ScheduleSpecRestore#successfulJobsHistoryLimit
   */
  readonly successfulJobsHistoryLimit?: number;

  /**
   * Tags is a list of arbitrary tags that get added to the backup via Restic's tagging system
   *
   * @schema ScheduleSpecRestore#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecRestore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestore(obj: ScheduleSpecRestore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'backend': toJson_ScheduleSpecRestoreBackend(obj.backend),
    'concurrentRunsAllowed': obj.concurrentRunsAllowed,
    'failedJobsHistoryLimit': obj.failedJobsHistoryLimit,
    'keepJobs': obj.keepJobs,
    'podSecurityContext': toJson_ScheduleSpecRestorePodSecurityContext(obj.podSecurityContext),
    'resources': toJson_ScheduleSpecRestoreResources(obj.resources),
    'restoreFilter': obj.restoreFilter,
    'restoreMethod': toJson_ScheduleSpecRestoreRestoreMethod(obj.restoreMethod),
    'schedule': obj.schedule,
    'snapshot': obj.snapshot,
    'successfulJobsHistoryLimit': obj.successfulJobsHistoryLimit,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ScheduleSpecArchiveBackend
 */
export interface ScheduleSpecArchiveBackend {
  /**
   * @schema ScheduleSpecArchiveBackend#azure
   */
  readonly azure?: ScheduleSpecArchiveBackendAzure;

  /**
   * @schema ScheduleSpecArchiveBackend#b2
   */
  readonly b2?: ScheduleSpecArchiveBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecArchiveBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecArchiveBackendEnvFrom[];

  /**
   * @schema ScheduleSpecArchiveBackend#gcs
   */
  readonly gcs?: ScheduleSpecArchiveBackendGcs;

  /**
   * @schema ScheduleSpecArchiveBackend#local
   */
  readonly local?: ScheduleSpecArchiveBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecArchiveBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecArchiveBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecArchiveBackend#rest
   */
  readonly rest?: ScheduleSpecArchiveBackendRest;

  /**
   * @schema ScheduleSpecArchiveBackend#s3
   */
  readonly s3?: ScheduleSpecArchiveBackendS3;

  /**
   * @schema ScheduleSpecArchiveBackend#swift
   */
  readonly swift?: ScheduleSpecArchiveBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackend(obj: ScheduleSpecArchiveBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecArchiveBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecArchiveBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecArchiveBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecArchiveBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecArchiveBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecArchiveBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecArchiveBackendRest(obj.rest),
    's3': toJson_ScheduleSpecArchiveBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecArchiveBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ScheduleSpecArchivePodSecurityContext
 */
export interface ScheduleSpecArchivePodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecArchivePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecArchivePodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecArchivePodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecArchivePodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecArchivePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecArchivePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecArchivePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchivePodSecurityContext(obj: ScheduleSpecArchivePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecArchivePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecArchivePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecArchivePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecArchivePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecArchiveResources
 */
export interface ScheduleSpecArchiveResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecArchiveResources#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecArchiveResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecArchiveResources#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecArchiveResourcesRequests };

}

/**
 * Converts an object of type 'ScheduleSpecArchiveResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveResources(obj: ScheduleSpecArchiveResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
 *
 * @schema ScheduleSpecArchiveRestoreMethod
 */
export interface ScheduleSpecArchiveRestoreMethod {
  /**
   * @schema ScheduleSpecArchiveRestoreMethod#folder
   */
  readonly folder?: ScheduleSpecArchiveRestoreMethodFolder;

  /**
   * @schema ScheduleSpecArchiveRestoreMethod#s3
   */
  readonly s3?: ScheduleSpecArchiveRestoreMethodS3;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveRestoreMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveRestoreMethod(obj: ScheduleSpecArchiveRestoreMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'folder': toJson_ScheduleSpecArchiveRestoreMethodFolder(obj.folder),
    's3': toJson_ScheduleSpecArchiveRestoreMethodS3(obj.s3),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendAzure
 */
export interface ScheduleSpecBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendAzure(obj: ScheduleSpecBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendB2
 */
export interface ScheduleSpecBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendB2(obj: ScheduleSpecBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecBackendEnvFrom
 */
export interface ScheduleSpecBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendEnvFrom(obj: ScheduleSpecBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendGcs
 */
export interface ScheduleSpecBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendGcs(obj: ScheduleSpecBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendLocal
 */
export interface ScheduleSpecBackendLocal {
  /**
   * @schema ScheduleSpecBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendLocal(obj: ScheduleSpecBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendRepoPasswordSecretRef(obj: ScheduleSpecBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendRest
 */
export interface ScheduleSpecBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendRest(obj: ScheduleSpecBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendS3
 */
export interface ScheduleSpecBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendS3(obj: ScheduleSpecBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackendSwift
 */
export interface ScheduleSpecBackendSwift {
  /**
   * @schema ScheduleSpecBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendSwift(obj: ScheduleSpecBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ScheduleSpecBackupBackend
 */
export interface ScheduleSpecBackupBackend {
  /**
   * @schema ScheduleSpecBackupBackend#azure
   */
  readonly azure?: ScheduleSpecBackupBackendAzure;

  /**
   * @schema ScheduleSpecBackupBackend#b2
   */
  readonly b2?: ScheduleSpecBackupBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecBackupBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecBackupBackendEnvFrom[];

  /**
   * @schema ScheduleSpecBackupBackend#gcs
   */
  readonly gcs?: ScheduleSpecBackupBackendGcs;

  /**
   * @schema ScheduleSpecBackupBackend#local
   */
  readonly local?: ScheduleSpecBackupBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecBackupBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecBackupBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecBackupBackend#rest
   */
  readonly rest?: ScheduleSpecBackupBackendRest;

  /**
   * @schema ScheduleSpecBackupBackend#s3
   */
  readonly s3?: ScheduleSpecBackupBackendS3;

  /**
   * @schema ScheduleSpecBackupBackend#swift
   */
  readonly swift?: ScheduleSpecBackupBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackend(obj: ScheduleSpecBackupBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecBackupBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecBackupBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecBackupBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecBackupBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecBackupBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecBackupBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecBackupBackendRest(obj.rest),
    's3': toJson_ScheduleSpecBackupBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecBackupBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ScheduleSpecBackupPodSecurityContext
 */
export interface ScheduleSpecBackupPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecBackupPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecBackupPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecBackupPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecBackupPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecBackupPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecBackupPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecBackupPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupPodSecurityContext(obj: ScheduleSpecBackupPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecBackupPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecBackupPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecBackupPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecBackupPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecBackupResources
 */
export interface ScheduleSpecBackupResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecBackupResources#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecBackupResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecBackupResources#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecBackupResourcesRequests };

}

/**
 * Converts an object of type 'ScheduleSpecBackupResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupResources(obj: ScheduleSpecBackupResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ScheduleSpecCheckBackend
 */
export interface ScheduleSpecCheckBackend {
  /**
   * @schema ScheduleSpecCheckBackend#azure
   */
  readonly azure?: ScheduleSpecCheckBackendAzure;

  /**
   * @schema ScheduleSpecCheckBackend#b2
   */
  readonly b2?: ScheduleSpecCheckBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecCheckBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecCheckBackendEnvFrom[];

  /**
   * @schema ScheduleSpecCheckBackend#gcs
   */
  readonly gcs?: ScheduleSpecCheckBackendGcs;

  /**
   * @schema ScheduleSpecCheckBackend#local
   */
  readonly local?: ScheduleSpecCheckBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecCheckBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecCheckBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecCheckBackend#rest
   */
  readonly rest?: ScheduleSpecCheckBackendRest;

  /**
   * @schema ScheduleSpecCheckBackend#s3
   */
  readonly s3?: ScheduleSpecCheckBackendS3;

  /**
   * @schema ScheduleSpecCheckBackend#swift
   */
  readonly swift?: ScheduleSpecCheckBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackend(obj: ScheduleSpecCheckBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecCheckBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecCheckBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecCheckBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecCheckBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecCheckBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecCheckBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecCheckBackendRest(obj.rest),
    's3': toJson_ScheduleSpecCheckBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecCheckBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ScheduleSpecCheckPodSecurityContext
 */
export interface ScheduleSpecCheckPodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecCheckPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecCheckPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecCheckPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecCheckPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecCheckPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecCheckPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecCheckPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckPodSecurityContext(obj: ScheduleSpecCheckPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecCheckPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecCheckPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecCheckPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecCheckPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecCheckResources
 */
export interface ScheduleSpecCheckResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecCheckResources#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecCheckResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecCheckResources#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecCheckResourcesRequests };

}

/**
 * Converts an object of type 'ScheduleSpecCheckResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckResources(obj: ScheduleSpecCheckResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecPodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPodSecurityContextSeLinuxOptions(obj: ScheduleSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecPodSecurityContextSeccompProfile
 */
export interface ScheduleSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPodSecurityContextSeccompProfile(obj: ScheduleSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecPodSecurityContextSysctls
 */
export interface ScheduleSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPodSecurityContextSysctls(obj: ScheduleSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecPodSecurityContextWindowsOptions
 */
export interface ScheduleSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPodSecurityContextWindowsOptions(obj: ScheduleSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ScheduleSpecPruneBackend
 */
export interface ScheduleSpecPruneBackend {
  /**
   * @schema ScheduleSpecPruneBackend#azure
   */
  readonly azure?: ScheduleSpecPruneBackendAzure;

  /**
   * @schema ScheduleSpecPruneBackend#b2
   */
  readonly b2?: ScheduleSpecPruneBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecPruneBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecPruneBackendEnvFrom[];

  /**
   * @schema ScheduleSpecPruneBackend#gcs
   */
  readonly gcs?: ScheduleSpecPruneBackendGcs;

  /**
   * @schema ScheduleSpecPruneBackend#local
   */
  readonly local?: ScheduleSpecPruneBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecPruneBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecPruneBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecPruneBackend#rest
   */
  readonly rest?: ScheduleSpecPruneBackendRest;

  /**
   * @schema ScheduleSpecPruneBackend#s3
   */
  readonly s3?: ScheduleSpecPruneBackendS3;

  /**
   * @schema ScheduleSpecPruneBackend#swift
   */
  readonly swift?: ScheduleSpecPruneBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackend(obj: ScheduleSpecPruneBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecPruneBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecPruneBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecPruneBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecPruneBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecPruneBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecPruneBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecPruneBackendRest(obj.rest),
    's3': toJson_ScheduleSpecPruneBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecPruneBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ScheduleSpecPrunePodSecurityContext
 */
export interface ScheduleSpecPrunePodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecPrunePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecPrunePodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecPrunePodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecPrunePodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecPrunePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecPrunePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecPrunePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrunePodSecurityContext(obj: ScheduleSpecPrunePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecPrunePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecPrunePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecPrunePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecPrunePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecPruneResources
 */
export interface ScheduleSpecPruneResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecPruneResources#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecPruneResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecPruneResources#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecPruneResourcesRequests };

}

/**
 * Converts an object of type 'ScheduleSpecPruneResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneResources(obj: ScheduleSpecPruneResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retention sets how many backups should be kept after a forget and prune
 *
 * @schema ScheduleSpecPruneRetention
 */
export interface ScheduleSpecPruneRetention {
  /**
   * Hostnames is a filter on what hostnames the policy should be applied
   *
   * @schema ScheduleSpecPruneRetention#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema ScheduleSpecPruneRetention#keepDaily
   */
  readonly keepDaily?: number;

  /**
   * @schema ScheduleSpecPruneRetention#keepHourly
   */
  readonly keepHourly?: number;

  /**
   * @schema ScheduleSpecPruneRetention#keepLast
   */
  readonly keepLast?: number;

  /**
   * @schema ScheduleSpecPruneRetention#keepMonthly
   */
  readonly keepMonthly?: number;

  /**
   * @schema ScheduleSpecPruneRetention#keepTags
   */
  readonly keepTags?: string[];

  /**
   * @schema ScheduleSpecPruneRetention#keepWeekly
   */
  readonly keepWeekly?: number;

  /**
   * @schema ScheduleSpecPruneRetention#keepYearly
   */
  readonly keepYearly?: number;

  /**
   * Tags is a filter on what tags the policy should be applied DO NOT CONFUSE THIS WITH KeepTags OR YOU'LL have a bad time
   *
   * @schema ScheduleSpecPruneRetention#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ScheduleSpecPruneRetention' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneRetention(obj: ScheduleSpecPruneRetention | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'keepDaily': obj.keepDaily,
    'keepHourly': obj.keepHourly,
    'keepLast': obj.keepLast,
    'keepMonthly': obj.keepMonthly,
    'keepTags': obj.keepTags?.map(y => y),
    'keepWeekly': obj.keepWeekly,
    'keepYearly': obj.keepYearly,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecResourceRequirementsTemplateLimits
 */
export class ScheduleSpecResourceRequirementsTemplateLimits {
  public static fromNumber(value: number): ScheduleSpecResourceRequirementsTemplateLimits {
    return new ScheduleSpecResourceRequirementsTemplateLimits(value);
  }
  public static fromString(value: string): ScheduleSpecResourceRequirementsTemplateLimits {
    return new ScheduleSpecResourceRequirementsTemplateLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecResourceRequirementsTemplateRequests
 */
export class ScheduleSpecResourceRequirementsTemplateRequests {
  public static fromNumber(value: number): ScheduleSpecResourceRequirementsTemplateRequests {
    return new ScheduleSpecResourceRequirementsTemplateRequests(value);
  }
  public static fromString(value: string): ScheduleSpecResourceRequirementsTemplateRequests {
    return new ScheduleSpecResourceRequirementsTemplateRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Backend contains the restic repo where the job should backup to.
 *
 * @schema ScheduleSpecRestoreBackend
 */
export interface ScheduleSpecRestoreBackend {
  /**
   * @schema ScheduleSpecRestoreBackend#azure
   */
  readonly azure?: ScheduleSpecRestoreBackendAzure;

  /**
   * @schema ScheduleSpecRestoreBackend#b2
   */
  readonly b2?: ScheduleSpecRestoreBackendB2;

  /**
   * EnvFrom adds all environment variables from a an external source to the Restic job.
   *
   * @schema ScheduleSpecRestoreBackend#envFrom
   */
  readonly envFrom?: ScheduleSpecRestoreBackendEnvFrom[];

  /**
   * @schema ScheduleSpecRestoreBackend#gcs
   */
  readonly gcs?: ScheduleSpecRestoreBackendGcs;

  /**
   * @schema ScheduleSpecRestoreBackend#local
   */
  readonly local?: ScheduleSpecRestoreBackendLocal;

  /**
   * RepoPasswordSecretRef references a secret key to look up the restic repository password
   *
   * @schema ScheduleSpecRestoreBackend#repoPasswordSecretRef
   */
  readonly repoPasswordSecretRef?: ScheduleSpecRestoreBackendRepoPasswordSecretRef;

  /**
   * @schema ScheduleSpecRestoreBackend#rest
   */
  readonly rest?: ScheduleSpecRestoreBackendRest;

  /**
   * @schema ScheduleSpecRestoreBackend#s3
   */
  readonly s3?: ScheduleSpecRestoreBackendS3;

  /**
   * @schema ScheduleSpecRestoreBackend#swift
   */
  readonly swift?: ScheduleSpecRestoreBackendSwift;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackend(obj: ScheduleSpecRestoreBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_ScheduleSpecRestoreBackendAzure(obj.azure),
    'b2': toJson_ScheduleSpecRestoreBackendB2(obj.b2),
    'envFrom': obj.envFrom?.map(y => toJson_ScheduleSpecRestoreBackendEnvFrom(y)),
    'gcs': toJson_ScheduleSpecRestoreBackendGcs(obj.gcs),
    'local': toJson_ScheduleSpecRestoreBackendLocal(obj.local),
    'repoPasswordSecretRef': toJson_ScheduleSpecRestoreBackendRepoPasswordSecretRef(obj.repoPasswordSecretRef),
    'rest': toJson_ScheduleSpecRestoreBackendRest(obj.rest),
    's3': toJson_ScheduleSpecRestoreBackendS3(obj.s3),
    'swift': toJson_ScheduleSpecRestoreBackendSwift(obj.swift),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext describes the security context with which this action shall be executed.
 *
 * @schema ScheduleSpecRestorePodSecurityContext
 */
export interface ScheduleSpecRestorePodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ScheduleSpecRestorePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ScheduleSpecRestorePodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ScheduleSpecRestorePodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#sysctls
   */
  readonly sysctls?: ScheduleSpecRestorePodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ScheduleSpecRestorePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ScheduleSpecRestorePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ScheduleSpecRestorePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestorePodSecurityContext(obj: ScheduleSpecRestorePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ScheduleSpecRestorePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ScheduleSpecRestorePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ScheduleSpecRestorePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ScheduleSpecRestorePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources describes the compute resource requirements (cpu, memory, etc.)
 *
 * @schema ScheduleSpecRestoreResources
 */
export interface ScheduleSpecRestoreResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecRestoreResources#limits
   */
  readonly limits?: { [key: string]: ScheduleSpecRestoreResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ScheduleSpecRestoreResources#requests
   */
  readonly requests?: { [key: string]: ScheduleSpecRestoreResourcesRequests };

}

/**
 * Converts an object of type 'ScheduleSpecRestoreResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreResources(obj: ScheduleSpecRestoreResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestoreMethod contains how and where the restore should happen all the settings are mutual exclusive.
 *
 * @schema ScheduleSpecRestoreRestoreMethod
 */
export interface ScheduleSpecRestoreRestoreMethod {
  /**
   * @schema ScheduleSpecRestoreRestoreMethod#folder
   */
  readonly folder?: ScheduleSpecRestoreRestoreMethodFolder;

  /**
   * @schema ScheduleSpecRestoreRestoreMethod#s3
   */
  readonly s3?: ScheduleSpecRestoreRestoreMethodS3;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreRestoreMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreRestoreMethod(obj: ScheduleSpecRestoreRestoreMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'folder': toJson_ScheduleSpecRestoreRestoreMethodFolder(obj.folder),
    's3': toJson_ScheduleSpecRestoreRestoreMethodS3(obj.s3),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendAzure
 */
export interface ScheduleSpecArchiveBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecArchiveBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecArchiveBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecArchiveBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendAzure(obj: ScheduleSpecArchiveBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecArchiveBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecArchiveBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendB2
 */
export interface ScheduleSpecArchiveBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecArchiveBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecArchiveBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecArchiveBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecArchiveBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendB2(obj: ScheduleSpecArchiveBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecArchiveBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecArchiveBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecArchiveBackendEnvFrom
 */
export interface ScheduleSpecArchiveBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecArchiveBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecArchiveBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecArchiveBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecArchiveBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecArchiveBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendEnvFrom(obj: ScheduleSpecArchiveBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecArchiveBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecArchiveBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendGcs
 */
export interface ScheduleSpecArchiveBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecArchiveBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecArchiveBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecArchiveBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendGcs(obj: ScheduleSpecArchiveBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecArchiveBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecArchiveBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendLocal
 */
export interface ScheduleSpecArchiveBackendLocal {
  /**
   * @schema ScheduleSpecArchiveBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendLocal(obj: ScheduleSpecArchiveBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecArchiveBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecArchiveBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendRepoPasswordSecretRef(obj: ScheduleSpecArchiveBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendRest
 */
export interface ScheduleSpecArchiveBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecArchiveBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecArchiveBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecArchiveBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendRest(obj: ScheduleSpecArchiveBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecArchiveBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecArchiveBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendS3
 */
export interface ScheduleSpecArchiveBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecArchiveBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecArchiveBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendS3(obj: ScheduleSpecArchiveBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveBackendSwift
 */
export interface ScheduleSpecArchiveBackendSwift {
  /**
   * @schema ScheduleSpecArchiveBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecArchiveBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendSwift(obj: ScheduleSpecArchiveBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecArchivePodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecArchivePodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchivePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchivePodSecurityContextSeLinuxOptions(obj: ScheduleSpecArchivePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecArchivePodSecurityContextSeccompProfile
 */
export interface ScheduleSpecArchivePodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecArchivePodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchivePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchivePodSecurityContextSeccompProfile(obj: ScheduleSpecArchivePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecArchivePodSecurityContextSysctls
 */
export interface ScheduleSpecArchivePodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecArchivePodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecArchivePodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchivePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchivePodSecurityContextSysctls(obj: ScheduleSpecArchivePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecArchivePodSecurityContextWindowsOptions
 */
export interface ScheduleSpecArchivePodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecArchivePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecArchivePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecArchivePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecArchivePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecArchivePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchivePodSecurityContextWindowsOptions(obj: ScheduleSpecArchivePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveResourcesLimits
 */
export class ScheduleSpecArchiveResourcesLimits {
  public static fromNumber(value: number): ScheduleSpecArchiveResourcesLimits {
    return new ScheduleSpecArchiveResourcesLimits(value);
  }
  public static fromString(value: string): ScheduleSpecArchiveResourcesLimits {
    return new ScheduleSpecArchiveResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecArchiveResourcesRequests
 */
export class ScheduleSpecArchiveResourcesRequests {
  public static fromNumber(value: number): ScheduleSpecArchiveResourcesRequests {
    return new ScheduleSpecArchiveResourcesRequests(value);
  }
  public static fromString(value: string): ScheduleSpecArchiveResourcesRequests {
    return new ScheduleSpecArchiveResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecArchiveRestoreMethodFolder
 */
export interface ScheduleSpecArchiveRestoreMethodFolder {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ScheduleSpecArchiveRestoreMethodFolder#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema ScheduleSpecArchiveRestoreMethodFolder#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveRestoreMethodFolder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveRestoreMethodFolder(obj: ScheduleSpecArchiveRestoreMethodFolder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecArchiveRestoreMethodS3
 */
export interface ScheduleSpecArchiveRestoreMethodS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecArchiveRestoreMethodS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecArchiveRestoreMethodS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveRestoreMethodS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveRestoreMethodS3(obj: ScheduleSpecArchiveRestoreMethodS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendAzureAccountKeySecretRef(obj: ScheduleSpecBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendAzureAccountNameSecretRef(obj: ScheduleSpecBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendB2AccountIdSecretRef(obj: ScheduleSpecBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendB2AccountKeySecretRef(obj: ScheduleSpecBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendEnvFromConfigMapRef(obj: ScheduleSpecBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecBackendEnvFromSecretRef
 */
export interface ScheduleSpecBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendEnvFromSecretRef(obj: ScheduleSpecBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendGcsAccessTokenSecretRef(obj: ScheduleSpecBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendGcsProjectIdSecretRef(obj: ScheduleSpecBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendRestPasswordSecretReg
 */
export interface ScheduleSpecBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendRestPasswordSecretReg(obj: ScheduleSpecBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendRestUserSecretRef
 */
export interface ScheduleSpecBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendRestUserSecretRef(obj: ScheduleSpecBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendAzure
 */
export interface ScheduleSpecBackupBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecBackupBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecBackupBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecBackupBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendAzure(obj: ScheduleSpecBackupBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecBackupBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecBackupBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendB2
 */
export interface ScheduleSpecBackupBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecBackupBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecBackupBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecBackupBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecBackupBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendB2(obj: ScheduleSpecBackupBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecBackupBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecBackupBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecBackupBackendEnvFrom
 */
export interface ScheduleSpecBackupBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecBackupBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecBackupBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecBackupBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecBackupBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecBackupBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendEnvFrom(obj: ScheduleSpecBackupBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecBackupBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecBackupBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendGcs
 */
export interface ScheduleSpecBackupBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecBackupBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecBackupBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecBackupBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendGcs(obj: ScheduleSpecBackupBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecBackupBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecBackupBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendLocal
 */
export interface ScheduleSpecBackupBackendLocal {
  /**
   * @schema ScheduleSpecBackupBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendLocal(obj: ScheduleSpecBackupBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecBackupBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecBackupBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendRepoPasswordSecretRef(obj: ScheduleSpecBackupBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendRest
 */
export interface ScheduleSpecBackupBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecBackupBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecBackupBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecBackupBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendRest(obj: ScheduleSpecBackupBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecBackupBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecBackupBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendS3
 */
export interface ScheduleSpecBackupBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecBackupBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecBackupBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecBackupBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecBackupBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecBackupBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendS3(obj: ScheduleSpecBackupBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecBackupBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecBackupBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupBackendSwift
 */
export interface ScheduleSpecBackupBackendSwift {
  /**
   * @schema ScheduleSpecBackupBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecBackupBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendSwift(obj: ScheduleSpecBackupBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecBackupPodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecBackupPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupPodSecurityContextSeLinuxOptions(obj: ScheduleSpecBackupPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecBackupPodSecurityContextSeccompProfile
 */
export interface ScheduleSpecBackupPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecBackupPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupPodSecurityContextSeccompProfile(obj: ScheduleSpecBackupPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecBackupPodSecurityContextSysctls
 */
export interface ScheduleSpecBackupPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecBackupPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecBackupPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupPodSecurityContextSysctls(obj: ScheduleSpecBackupPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecBackupPodSecurityContextWindowsOptions
 */
export interface ScheduleSpecBackupPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecBackupPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecBackupPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecBackupPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecBackupPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecBackupPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupPodSecurityContextWindowsOptions(obj: ScheduleSpecBackupPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecBackupResourcesLimits
 */
export class ScheduleSpecBackupResourcesLimits {
  public static fromNumber(value: number): ScheduleSpecBackupResourcesLimits {
    return new ScheduleSpecBackupResourcesLimits(value);
  }
  public static fromString(value: string): ScheduleSpecBackupResourcesLimits {
    return new ScheduleSpecBackupResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecBackupResourcesRequests
 */
export class ScheduleSpecBackupResourcesRequests {
  public static fromNumber(value: number): ScheduleSpecBackupResourcesRequests {
    return new ScheduleSpecBackupResourcesRequests(value);
  }
  public static fromString(value: string): ScheduleSpecBackupResourcesRequests {
    return new ScheduleSpecBackupResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecCheckBackendAzure
 */
export interface ScheduleSpecCheckBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecCheckBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecCheckBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecCheckBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendAzure(obj: ScheduleSpecCheckBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecCheckBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecCheckBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendB2
 */
export interface ScheduleSpecCheckBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecCheckBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecCheckBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecCheckBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecCheckBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendB2(obj: ScheduleSpecCheckBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecCheckBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecCheckBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecCheckBackendEnvFrom
 */
export interface ScheduleSpecCheckBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecCheckBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecCheckBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecCheckBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecCheckBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecCheckBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendEnvFrom(obj: ScheduleSpecCheckBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecCheckBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecCheckBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendGcs
 */
export interface ScheduleSpecCheckBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecCheckBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecCheckBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecCheckBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendGcs(obj: ScheduleSpecCheckBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecCheckBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecCheckBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendLocal
 */
export interface ScheduleSpecCheckBackendLocal {
  /**
   * @schema ScheduleSpecCheckBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendLocal(obj: ScheduleSpecCheckBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecCheckBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecCheckBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendRepoPasswordSecretRef(obj: ScheduleSpecCheckBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendRest
 */
export interface ScheduleSpecCheckBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecCheckBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecCheckBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecCheckBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendRest(obj: ScheduleSpecCheckBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecCheckBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecCheckBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendS3
 */
export interface ScheduleSpecCheckBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecCheckBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecCheckBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecCheckBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecCheckBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecCheckBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendS3(obj: ScheduleSpecCheckBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecCheckBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecCheckBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckBackendSwift
 */
export interface ScheduleSpecCheckBackendSwift {
  /**
   * @schema ScheduleSpecCheckBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecCheckBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendSwift(obj: ScheduleSpecCheckBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecCheckPodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecCheckPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckPodSecurityContextSeLinuxOptions(obj: ScheduleSpecCheckPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecCheckPodSecurityContextSeccompProfile
 */
export interface ScheduleSpecCheckPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecCheckPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckPodSecurityContextSeccompProfile(obj: ScheduleSpecCheckPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecCheckPodSecurityContextSysctls
 */
export interface ScheduleSpecCheckPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecCheckPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecCheckPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckPodSecurityContextSysctls(obj: ScheduleSpecCheckPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecCheckPodSecurityContextWindowsOptions
 */
export interface ScheduleSpecCheckPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecCheckPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecCheckPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecCheckPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecCheckPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecCheckPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckPodSecurityContextWindowsOptions(obj: ScheduleSpecCheckPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecCheckResourcesLimits
 */
export class ScheduleSpecCheckResourcesLimits {
  public static fromNumber(value: number): ScheduleSpecCheckResourcesLimits {
    return new ScheduleSpecCheckResourcesLimits(value);
  }
  public static fromString(value: string): ScheduleSpecCheckResourcesLimits {
    return new ScheduleSpecCheckResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecCheckResourcesRequests
 */
export class ScheduleSpecCheckResourcesRequests {
  public static fromNumber(value: number): ScheduleSpecCheckResourcesRequests {
    return new ScheduleSpecCheckResourcesRequests(value);
  }
  public static fromString(value: string): ScheduleSpecCheckResourcesRequests {
    return new ScheduleSpecCheckResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecPruneBackendAzure
 */
export interface ScheduleSpecPruneBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecPruneBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecPruneBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecPruneBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendAzure(obj: ScheduleSpecPruneBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecPruneBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecPruneBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendB2
 */
export interface ScheduleSpecPruneBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecPruneBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecPruneBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecPruneBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecPruneBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendB2(obj: ScheduleSpecPruneBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecPruneBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecPruneBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecPruneBackendEnvFrom
 */
export interface ScheduleSpecPruneBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecPruneBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecPruneBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecPruneBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecPruneBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecPruneBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendEnvFrom(obj: ScheduleSpecPruneBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecPruneBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecPruneBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendGcs
 */
export interface ScheduleSpecPruneBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecPruneBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecPruneBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecPruneBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendGcs(obj: ScheduleSpecPruneBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecPruneBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecPruneBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendLocal
 */
export interface ScheduleSpecPruneBackendLocal {
  /**
   * @schema ScheduleSpecPruneBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendLocal(obj: ScheduleSpecPruneBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecPruneBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecPruneBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendRepoPasswordSecretRef(obj: ScheduleSpecPruneBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendRest
 */
export interface ScheduleSpecPruneBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecPruneBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecPruneBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecPruneBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendRest(obj: ScheduleSpecPruneBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecPruneBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecPruneBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendS3
 */
export interface ScheduleSpecPruneBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecPruneBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecPruneBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecPruneBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecPruneBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecPruneBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendS3(obj: ScheduleSpecPruneBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecPruneBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecPruneBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneBackendSwift
 */
export interface ScheduleSpecPruneBackendSwift {
  /**
   * @schema ScheduleSpecPruneBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecPruneBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendSwift(obj: ScheduleSpecPruneBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecPrunePodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecPrunePodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPrunePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrunePodSecurityContextSeLinuxOptions(obj: ScheduleSpecPrunePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecPrunePodSecurityContextSeccompProfile
 */
export interface ScheduleSpecPrunePodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecPrunePodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecPrunePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrunePodSecurityContextSeccompProfile(obj: ScheduleSpecPrunePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecPrunePodSecurityContextSysctls
 */
export interface ScheduleSpecPrunePodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecPrunePodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecPrunePodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecPrunePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrunePodSecurityContextSysctls(obj: ScheduleSpecPrunePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecPrunePodSecurityContextWindowsOptions
 */
export interface ScheduleSpecPrunePodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecPrunePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecPrunePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecPrunePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecPrunePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecPrunePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPrunePodSecurityContextWindowsOptions(obj: ScheduleSpecPrunePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecPruneResourcesLimits
 */
export class ScheduleSpecPruneResourcesLimits {
  public static fromNumber(value: number): ScheduleSpecPruneResourcesLimits {
    return new ScheduleSpecPruneResourcesLimits(value);
  }
  public static fromString(value: string): ScheduleSpecPruneResourcesLimits {
    return new ScheduleSpecPruneResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecPruneResourcesRequests
 */
export class ScheduleSpecPruneResourcesRequests {
  public static fromNumber(value: number): ScheduleSpecPruneResourcesRequests {
    return new ScheduleSpecPruneResourcesRequests(value);
  }
  public static fromString(value: string): ScheduleSpecPruneResourcesRequests {
    return new ScheduleSpecPruneResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecRestoreBackendAzure
 */
export interface ScheduleSpecRestoreBackendAzure {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendAzure#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecRestoreBackendAzureAccountKeySecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendAzure#accountNameSecretRef
   */
  readonly accountNameSecretRef?: ScheduleSpecRestoreBackendAzureAccountNameSecretRef;

  /**
   * @schema ScheduleSpecRestoreBackendAzure#container
   */
  readonly container?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendAzure(obj: ScheduleSpecRestoreBackendAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountKeySecretRef': toJson_ScheduleSpecRestoreBackendAzureAccountKeySecretRef(obj.accountKeySecretRef),
    'accountNameSecretRef': toJson_ScheduleSpecRestoreBackendAzureAccountNameSecretRef(obj.accountNameSecretRef),
    'container': obj.container,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendB2
 */
export interface ScheduleSpecRestoreBackendB2 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendB2#accountIDSecretRef
   */
  readonly accountIdSecretRef?: ScheduleSpecRestoreBackendB2AccountIdSecretRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendB2#accountKeySecretRef
   */
  readonly accountKeySecretRef?: ScheduleSpecRestoreBackendB2AccountKeySecretRef;

  /**
   * @schema ScheduleSpecRestoreBackendB2#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecRestoreBackendB2#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendB2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendB2(obj: ScheduleSpecRestoreBackendB2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountIDSecretRef': toJson_ScheduleSpecRestoreBackendB2AccountIdSecretRef(obj.accountIdSecretRef),
    'accountKeySecretRef': toJson_ScheduleSpecRestoreBackendB2AccountKeySecretRef(obj.accountKeySecretRef),
    'bucket': obj.bucket,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ScheduleSpecRestoreBackendEnvFrom
 */
export interface ScheduleSpecRestoreBackendEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ScheduleSpecRestoreBackendEnvFrom#configMapRef
   */
  readonly configMapRef?: ScheduleSpecRestoreBackendEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ScheduleSpecRestoreBackendEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ScheduleSpecRestoreBackendEnvFrom#secretRef
   */
  readonly secretRef?: ScheduleSpecRestoreBackendEnvFromSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendEnvFrom(obj: ScheduleSpecRestoreBackendEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ScheduleSpecRestoreBackendEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ScheduleSpecRestoreBackendEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendGcs
 */
export interface ScheduleSpecRestoreBackendGcs {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendGcs#accessTokenSecretRef
   */
  readonly accessTokenSecretRef?: ScheduleSpecRestoreBackendGcsAccessTokenSecretRef;

  /**
   * @schema ScheduleSpecRestoreBackendGcs#bucket
   */
  readonly bucket?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendGcs#projectIDSecretRef
   */
  readonly projectIdSecretRef?: ScheduleSpecRestoreBackendGcsProjectIdSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendGcs(obj: ScheduleSpecRestoreBackendGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_ScheduleSpecRestoreBackendGcsAccessTokenSecretRef(obj.accessTokenSecretRef),
    'bucket': obj.bucket,
    'projectIDSecretRef': toJson_ScheduleSpecRestoreBackendGcsProjectIdSecretRef(obj.projectIdSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendLocal
 */
export interface ScheduleSpecRestoreBackendLocal {
  /**
   * @schema ScheduleSpecRestoreBackendLocal#mountPath
   */
  readonly mountPath?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendLocal(obj: ScheduleSpecRestoreBackendLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepoPasswordSecretRef references a secret key to look up the restic repository password
 *
 * @schema ScheduleSpecRestoreBackendRepoPasswordSecretRef
 */
export interface ScheduleSpecRestoreBackendRepoPasswordSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendRepoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendRepoPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendRepoPasswordSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendRepoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendRepoPasswordSecretRef(obj: ScheduleSpecRestoreBackendRepoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendRest
 */
export interface ScheduleSpecRestoreBackendRest {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendRest#passwordSecretReg
   */
  readonly passwordSecretReg?: ScheduleSpecRestoreBackendRestPasswordSecretReg;

  /**
   * @schema ScheduleSpecRestoreBackendRest#url
   */
  readonly url?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendRest#userSecretRef
   */
  readonly userSecretRef?: ScheduleSpecRestoreBackendRestUserSecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendRest(obj: ScheduleSpecRestoreBackendRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretReg': toJson_ScheduleSpecRestoreBackendRestPasswordSecretReg(obj.passwordSecretReg),
    'url': obj.url,
    'userSecretRef': toJson_ScheduleSpecRestoreBackendRestUserSecretRef(obj.userSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendS3
 */
export interface ScheduleSpecRestoreBackendS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecRestoreBackendS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecRestoreBackendS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreBackendS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendS3(obj: ScheduleSpecRestoreBackendS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreBackendSwift
 */
export interface ScheduleSpecRestoreBackendSwift {
  /**
   * @schema ScheduleSpecRestoreBackendSwift#container
   */
  readonly container?: string;

  /**
   * @schema ScheduleSpecRestoreBackendSwift#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendSwift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendSwift(obj: ScheduleSpecRestoreBackendSwift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecRestorePodSecurityContextSeLinuxOptions
 */
export interface ScheduleSpecRestorePodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestorePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestorePodSecurityContextSeLinuxOptions(obj: ScheduleSpecRestorePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ScheduleSpecRestorePodSecurityContextSeccompProfile
 */
export interface ScheduleSpecRestorePodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ScheduleSpecRestorePodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestorePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestorePodSecurityContextSeccompProfile(obj: ScheduleSpecRestorePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ScheduleSpecRestorePodSecurityContextSysctls
 */
export interface ScheduleSpecRestorePodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ScheduleSpecRestorePodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ScheduleSpecRestorePodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestorePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestorePodSecurityContextSysctls(obj: ScheduleSpecRestorePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ScheduleSpecRestorePodSecurityContextWindowsOptions
 */
export interface ScheduleSpecRestorePodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ScheduleSpecRestorePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ScheduleSpecRestorePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ScheduleSpecRestorePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ScheduleSpecRestorePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ScheduleSpecRestorePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestorePodSecurityContextWindowsOptions(obj: ScheduleSpecRestorePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreResourcesLimits
 */
export class ScheduleSpecRestoreResourcesLimits {
  public static fromNumber(value: number): ScheduleSpecRestoreResourcesLimits {
    return new ScheduleSpecRestoreResourcesLimits(value);
  }
  public static fromString(value: string): ScheduleSpecRestoreResourcesLimits {
    return new ScheduleSpecRestoreResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecRestoreResourcesRequests
 */
export class ScheduleSpecRestoreResourcesRequests {
  public static fromNumber(value: number): ScheduleSpecRestoreResourcesRequests {
    return new ScheduleSpecRestoreResourcesRequests(value);
  }
  public static fromString(value: string): ScheduleSpecRestoreResourcesRequests {
    return new ScheduleSpecRestoreResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ScheduleSpecRestoreRestoreMethodFolder
 */
export interface ScheduleSpecRestoreRestoreMethodFolder {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ScheduleSpecRestoreRestoreMethodFolder#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema ScheduleSpecRestoreRestoreMethodFolder#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreRestoreMethodFolder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreRestoreMethodFolder(obj: ScheduleSpecRestoreRestoreMethodFolder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduleSpecRestoreRestoreMethodS3
 */
export interface ScheduleSpecRestoreRestoreMethodS3 {
  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef;

  /**
   * @schema ScheduleSpecRestoreRestoreMethodS3#bucket
   */
  readonly bucket?: string;

  /**
   * @schema ScheduleSpecRestoreRestoreMethodS3#endpoint
   */
  readonly endpoint?: string;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreRestoreMethodS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreRestoreMethodS3(obj: ScheduleSpecRestoreRestoreMethodS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'bucket': obj.bucket,
    'endpoint': obj.endpoint,
    'secretAccessKeySecretRef': toJson_ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecArchiveBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendAzureAccountKeySecretRef(obj: ScheduleSpecArchiveBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecArchiveBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendAzureAccountNameSecretRef(obj: ScheduleSpecArchiveBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecArchiveBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendB2AccountIdSecretRef(obj: ScheduleSpecArchiveBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecArchiveBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendB2AccountKeySecretRef(obj: ScheduleSpecArchiveBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecArchiveBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecArchiveBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecArchiveBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendEnvFromConfigMapRef(obj: ScheduleSpecArchiveBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecArchiveBackendEnvFromSecretRef
 */
export interface ScheduleSpecArchiveBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecArchiveBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendEnvFromSecretRef(obj: ScheduleSpecArchiveBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecArchiveBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendGcsAccessTokenSecretRef(obj: ScheduleSpecArchiveBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecArchiveBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendGcsProjectIdSecretRef(obj: ScheduleSpecArchiveBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendRestPasswordSecretReg
 */
export interface ScheduleSpecArchiveBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendRestPasswordSecretReg(obj: ScheduleSpecArchiveBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendRestUserSecretRef
 */
export interface ScheduleSpecArchiveBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendRestUserSecretRef(obj: ScheduleSpecArchiveBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecArchiveBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecArchiveBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef(obj: ScheduleSpecArchiveRestoreMethodS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef(obj: ScheduleSpecArchiveRestoreMethodS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecBackupBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendAzureAccountKeySecretRef(obj: ScheduleSpecBackupBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecBackupBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendAzureAccountNameSecretRef(obj: ScheduleSpecBackupBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecBackupBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendB2AccountIdSecretRef(obj: ScheduleSpecBackupBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecBackupBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendB2AccountKeySecretRef(obj: ScheduleSpecBackupBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecBackupBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecBackupBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecBackupBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendEnvFromConfigMapRef(obj: ScheduleSpecBackupBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecBackupBackendEnvFromSecretRef
 */
export interface ScheduleSpecBackupBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecBackupBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendEnvFromSecretRef(obj: ScheduleSpecBackupBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecBackupBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendGcsAccessTokenSecretRef(obj: ScheduleSpecBackupBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecBackupBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendGcsProjectIdSecretRef(obj: ScheduleSpecBackupBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendRestPasswordSecretReg
 */
export interface ScheduleSpecBackupBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendRestPasswordSecretReg(obj: ScheduleSpecBackupBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendRestUserSecretRef
 */
export interface ScheduleSpecBackupBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendRestUserSecretRef(obj: ScheduleSpecBackupBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecBackupBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecBackupBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecBackupBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecBackupBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecBackupBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecBackupBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecBackupBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecBackupBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecBackupBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecBackupBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecCheckBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendAzureAccountKeySecretRef(obj: ScheduleSpecCheckBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecCheckBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendAzureAccountNameSecretRef(obj: ScheduleSpecCheckBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecCheckBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendB2AccountIdSecretRef(obj: ScheduleSpecCheckBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecCheckBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendB2AccountKeySecretRef(obj: ScheduleSpecCheckBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecCheckBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecCheckBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecCheckBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendEnvFromConfigMapRef(obj: ScheduleSpecCheckBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecCheckBackendEnvFromSecretRef
 */
export interface ScheduleSpecCheckBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecCheckBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendEnvFromSecretRef(obj: ScheduleSpecCheckBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecCheckBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendGcsAccessTokenSecretRef(obj: ScheduleSpecCheckBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecCheckBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendGcsProjectIdSecretRef(obj: ScheduleSpecCheckBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendRestPasswordSecretReg
 */
export interface ScheduleSpecCheckBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendRestPasswordSecretReg(obj: ScheduleSpecCheckBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendRestUserSecretRef
 */
export interface ScheduleSpecCheckBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendRestUserSecretRef(obj: ScheduleSpecCheckBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecCheckBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecCheckBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecCheckBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecCheckBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecCheckBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecCheckBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecCheckBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecCheckBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecCheckBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecCheckBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecPruneBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendAzureAccountKeySecretRef(obj: ScheduleSpecPruneBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecPruneBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendAzureAccountNameSecretRef(obj: ScheduleSpecPruneBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecPruneBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendB2AccountIdSecretRef(obj: ScheduleSpecPruneBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecPruneBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendB2AccountKeySecretRef(obj: ScheduleSpecPruneBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecPruneBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecPruneBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecPruneBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendEnvFromConfigMapRef(obj: ScheduleSpecPruneBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecPruneBackendEnvFromSecretRef
 */
export interface ScheduleSpecPruneBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecPruneBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendEnvFromSecretRef(obj: ScheduleSpecPruneBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecPruneBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendGcsAccessTokenSecretRef(obj: ScheduleSpecPruneBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecPruneBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendGcsProjectIdSecretRef(obj: ScheduleSpecPruneBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendRestPasswordSecretReg
 */
export interface ScheduleSpecPruneBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendRestPasswordSecretReg(obj: ScheduleSpecPruneBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendRestUserSecretRef
 */
export interface ScheduleSpecPruneBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendRestUserSecretRef(obj: ScheduleSpecPruneBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecPruneBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecPruneBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecPruneBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecPruneBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecPruneBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecPruneBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecPruneBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecPruneBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecPruneBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecPruneBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendAzureAccountKeySecretRef
 */
export interface ScheduleSpecRestoreBackendAzureAccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendAzureAccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendAzureAccountKeySecretRef(obj: ScheduleSpecRestoreBackendAzureAccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendAzureAccountNameSecretRef
 */
export interface ScheduleSpecRestoreBackendAzureAccountNameSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountNameSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendAzureAccountNameSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendAzureAccountNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendAzureAccountNameSecretRef(obj: ScheduleSpecRestoreBackendAzureAccountNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendB2AccountIdSecretRef
 */
export interface ScheduleSpecRestoreBackendB2AccountIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendB2AccountIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendB2AccountIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendB2AccountIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendB2AccountIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendB2AccountIdSecretRef(obj: ScheduleSpecRestoreBackendB2AccountIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendB2AccountKeySecretRef
 */
export interface ScheduleSpecRestoreBackendB2AccountKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendB2AccountKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendB2AccountKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendB2AccountKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendB2AccountKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendB2AccountKeySecretRef(obj: ScheduleSpecRestoreBackendB2AccountKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ScheduleSpecRestoreBackendEnvFromConfigMapRef
 */
export interface ScheduleSpecRestoreBackendEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ScheduleSpecRestoreBackendEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendEnvFromConfigMapRef(obj: ScheduleSpecRestoreBackendEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ScheduleSpecRestoreBackendEnvFromSecretRef
 */
export interface ScheduleSpecRestoreBackendEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ScheduleSpecRestoreBackendEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendEnvFromSecretRef(obj: ScheduleSpecRestoreBackendEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendGcsAccessTokenSecretRef
 */
export interface ScheduleSpecRestoreBackendGcsAccessTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendGcsAccessTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendGcsAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendGcsAccessTokenSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendGcsAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendGcsAccessTokenSecretRef(obj: ScheduleSpecRestoreBackendGcsAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendGcsProjectIdSecretRef
 */
export interface ScheduleSpecRestoreBackendGcsProjectIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendGcsProjectIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendGcsProjectIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendGcsProjectIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendGcsProjectIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendGcsProjectIdSecretRef(obj: ScheduleSpecRestoreBackendGcsProjectIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendRestPasswordSecretReg
 */
export interface ScheduleSpecRestoreBackendRestPasswordSecretReg {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendRestPasswordSecretReg#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendRestPasswordSecretReg#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendRestPasswordSecretReg#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendRestPasswordSecretReg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendRestPasswordSecretReg(obj: ScheduleSpecRestoreBackendRestPasswordSecretReg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendRestUserSecretRef
 */
export interface ScheduleSpecRestoreBackendRestUserSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendRestUserSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendRestUserSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendRestUserSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendRestUserSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendRestUserSecretRef(obj: ScheduleSpecRestoreBackendRestUserSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef(obj: ScheduleSpecRestoreBackendS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef(obj: ScheduleSpecRestoreBackendS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef
 */
export interface ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef(obj: ScheduleSpecRestoreRestoreMethodS3AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef
 */
export interface ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef(obj: ScheduleSpecRestoreRestoreMethodS3SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8up.io/v1',
    kind: 'Snapshot',
  }

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps = {}): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps = {}) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec contains all information needed about a restic snapshot so it can be restored.
   *
   * @schema Snapshot#spec
   */
  readonly spec?: SnapshotSpec;

}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(obj: SnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec contains all information needed about a restic snapshot so it can be restored.
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * @schema SnapshotSpec#date
   */
  readonly date?: Date;

  /**
   * @schema SnapshotSpec#id
   */
  readonly id?: string;

  /**
   * @schema SnapshotSpec#paths
   */
  readonly paths?: string[];

  /**
   * @schema SnapshotSpec#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(obj: SnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date?.toISOString(),
    'id': obj.id,
    'paths': obj.paths?.map(y => y),
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

