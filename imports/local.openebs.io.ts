// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LVMNode records information about all lvm volume groups available in a node. In general, the openebs node-agent creates the LVMNode object & periodically synchronizing the volume groups available in the node. LVMNode has an owner reference pointing to the corresponding node object.
 *
 * @schema LVMNode
 */
export class LvmNode extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LVMNode"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'local.openebs.io/v1alpha1',
    kind: 'LVMNode',
  }

  /**
   * Renders a Kubernetes manifest for "LVMNode".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LvmNodeProps): any {
    return {
      ...LvmNode.GVK,
      ...toJson_LvmNodeProps(props),
    };
  }

  /**
   * Defines a "LVMNode" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LvmNodeProps) {
    super(scope, id, {
      ...LvmNode.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LvmNode.GVK,
      ...toJson_LvmNodeProps(resolved),
    };
  }
}

/**
 * LVMNode records information about all lvm volume groups available in a node. In general, the openebs node-agent creates the LVMNode object & periodically synchronizing the volume groups available in the node. LVMNode has an owner reference pointing to the corresponding node object.
 *
 * @schema LVMNode
 */
export interface LvmNodeProps {
  /**
   * @schema LVMNode#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema LVMNode#volumeGroups
   */
  readonly volumeGroups: LvmNodeVolumeGroups[];

}

/**
 * Converts an object of type 'LvmNodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmNodeProps(obj: LvmNodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'volumeGroups': obj.volumeGroups?.map(y => toJson_LvmNodeVolumeGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeGroup specifies attributes of a given vg exists on node.
 *
 * @schema LvmNodeVolumeGroups
 */
export interface LvmNodeVolumeGroups {
  /**
   * AllocationPolicy indicates the volume group allocation policy. AllocationPolicy has the following mapping between int and string for its value: [-1: "", 0: "normal", 1: "contiguous", 2: "cling", 3: "anywhere", 4: "inherited"]
   *
   * @schema LvmNodeVolumeGroups#allocationPolicy
   */
  readonly allocationPolicy: number;

  /**
   * Free specifies the available capacity of volume group.
   *
   * @schema LvmNodeVolumeGroups#free
   */
  readonly free: LvmNodeVolumeGroupsFree;

  /**
   * LVCount denotes total number of logical volumes in volume group.
   *
   * @schema LvmNodeVolumeGroups#lvCount
   */
  readonly lvCount: number;

  /**
   * MaxLV denotes maximum number of logical volumes allowed in volume group or 0 if unlimited.
   *
   * @schema LvmNodeVolumeGroups#maxLv
   */
  readonly maxLv: number;

  /**
   * MaxPV denotes maximum number of physical volumes allowed in volume group or 0 if unlimited.
   *
   * @schema LvmNodeVolumeGroups#maxPv
   */
  readonly maxPv: number;

  /**
   * MetadataCount denotes number of metadata areas on the volume group.
   *
   * @schema LvmNodeVolumeGroups#metadataCount
   */
  readonly metadataCount: number;

  /**
   * MetadataFree specifies the available metadata area space for the volume group
   *
   * @schema LvmNodeVolumeGroups#metadataFree
   */
  readonly metadataFree: LvmNodeVolumeGroupsMetadataFree;

  /**
   * MetadataSize specifies size of smallest metadata area for the volume group
   *
   * @schema LvmNodeVolumeGroups#metadataSize
   */
  readonly metadataSize: LvmNodeVolumeGroupsMetadataSize;

  /**
   * MetadataUsedCount denotes number of used metadata areas in volume group
   *
   * @schema LvmNodeVolumeGroups#metadataUsedCount
   */
  readonly metadataUsedCount: number;

  /**
   * MissingPVCount denotes number of physical volumes in volume group which are missing.
   *
   * @schema LvmNodeVolumeGroups#missingPvCount
   */
  readonly missingPvCount: number;

  /**
   * Name of the lvm volume group.
   *
   * @schema LvmNodeVolumeGroups#name
   */
  readonly name: string;

  /**
   * Permission indicates the volume group permission which can be writable or read-only. Permission has the following mapping between int and string for its value: [-1: "", 0: "writeable", 1: "read-only"]
   *
   * @schema LvmNodeVolumeGroups#permissions
   */
  readonly permissions: number;

  /**
   * PVCount denotes total number of physical volumes constituting the volume group.
   *
   * @schema LvmNodeVolumeGroups#pvCount
   */
  readonly pvCount: number;

  /**
   * Size specifies the total size of volume group.
   *
   * @schema LvmNodeVolumeGroups#size
   */
  readonly size: LvmNodeVolumeGroupsSize;

  /**
   * SnapCount denotes number of snapshots in volume group.
   *
   * @schema LvmNodeVolumeGroups#snapCount
   */
  readonly snapCount: number;

  /**
   * UUID denotes a unique identity of a lvm volume group.
   *
   * @schema LvmNodeVolumeGroups#uuid
   */
  readonly uuid: string;

}

/**
 * Converts an object of type 'LvmNodeVolumeGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmNodeVolumeGroups(obj: LvmNodeVolumeGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocationPolicy': obj.allocationPolicy,
    'free': obj.free?.value,
    'lvCount': obj.lvCount,
    'maxLv': obj.maxLv,
    'maxPv': obj.maxPv,
    'metadataCount': obj.metadataCount,
    'metadataFree': obj.metadataFree?.value,
    'metadataSize': obj.metadataSize?.value,
    'metadataUsedCount': obj.metadataUsedCount,
    'missingPvCount': obj.missingPvCount,
    'name': obj.name,
    'permissions': obj.permissions,
    'pvCount': obj.pvCount,
    'size': obj.size?.value,
    'snapCount': obj.snapCount,
    'uuid': obj.uuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Free specifies the available capacity of volume group.
 *
 * @schema LvmNodeVolumeGroupsFree
 */
export class LvmNodeVolumeGroupsFree {
  public static fromNumber(value: number): LvmNodeVolumeGroupsFree {
    return new LvmNodeVolumeGroupsFree(value);
  }
  public static fromString(value: string): LvmNodeVolumeGroupsFree {
    return new LvmNodeVolumeGroupsFree(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MetadataFree specifies the available metadata area space for the volume group
 *
 * @schema LvmNodeVolumeGroupsMetadataFree
 */
export class LvmNodeVolumeGroupsMetadataFree {
  public static fromNumber(value: number): LvmNodeVolumeGroupsMetadataFree {
    return new LvmNodeVolumeGroupsMetadataFree(value);
  }
  public static fromString(value: string): LvmNodeVolumeGroupsMetadataFree {
    return new LvmNodeVolumeGroupsMetadataFree(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MetadataSize specifies size of smallest metadata area for the volume group
 *
 * @schema LvmNodeVolumeGroupsMetadataSize
 */
export class LvmNodeVolumeGroupsMetadataSize {
  public static fromNumber(value: number): LvmNodeVolumeGroupsMetadataSize {
    return new LvmNodeVolumeGroupsMetadataSize(value);
  }
  public static fromString(value: string): LvmNodeVolumeGroupsMetadataSize {
    return new LvmNodeVolumeGroupsMetadataSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Size specifies the total size of volume group.
 *
 * @schema LvmNodeVolumeGroupsSize
 */
export class LvmNodeVolumeGroupsSize {
  public static fromNumber(value: number): LvmNodeVolumeGroupsSize {
    return new LvmNodeVolumeGroupsSize(value);
  }
  public static fromString(value: string): LvmNodeVolumeGroupsSize {
    return new LvmNodeVolumeGroupsSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * LVMSnapshot represents an LVM Snapshot of the lvm volume
 *
 * @schema LVMSnapshot
 */
export class LvmSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LVMSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'local.openebs.io/v1alpha1',
    kind: 'LVMSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "LVMSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LvmSnapshotProps): any {
    return {
      ...LvmSnapshot.GVK,
      ...toJson_LvmSnapshotProps(props),
    };
  }

  /**
   * Defines a "LVMSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LvmSnapshotProps) {
    super(scope, id, {
      ...LvmSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LvmSnapshot.GVK,
      ...toJson_LvmSnapshotProps(resolved),
    };
  }
}

/**
 * LVMSnapshot represents an LVM Snapshot of the lvm volume
 *
 * @schema LVMSnapshot
 */
export interface LvmSnapshotProps {
  /**
   * @schema LVMSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LVMSnapshotSpec defines LVMSnapshot spec
   *
   * @schema LVMSnapshot#spec
   */
  readonly spec: LvmSnapshotSpec;

}

/**
 * Converts an object of type 'LvmSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmSnapshotProps(obj: LvmSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LvmSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LVMSnapshotSpec defines LVMSnapshot spec
 *
 * @schema LvmSnapshotSpec
 */
export interface LvmSnapshotSpec {
  /**
   * OwnerNodeID is the Node ID where the volume group is present which is where the snapshot has been provisioned. OwnerNodeID can not be edited after the snapshot has been provisioned.
   *
   * @schema LvmSnapshotSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * SnapSize specifies the space reserved for the snapshot
   *
   * @schema LvmSnapshotSpec#snapSize
   */
  readonly snapSize?: string;

  /**
   * VolGroup specifies the name of the volume group where the snapshot has been created.
   *
   * @schema LvmSnapshotSpec#volGroup
   */
  readonly volGroup: string;

}

/**
 * Converts an object of type 'LvmSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmSnapshotSpec(obj: LvmSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ownerNodeID': obj.ownerNodeId,
    'snapSize': obj.snapSize,
    'volGroup': obj.volGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * LVMVolume represents a LVM based volume
 *
 * @schema LVMVolume
 */
export class LvmVolume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LVMVolume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'local.openebs.io/v1alpha1',
    kind: 'LVMVolume',
  }

  /**
   * Renders a Kubernetes manifest for "LVMVolume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LvmVolumeProps): any {
    return {
      ...LvmVolume.GVK,
      ...toJson_LvmVolumeProps(props),
    };
  }

  /**
   * Defines a "LVMVolume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LvmVolumeProps) {
    super(scope, id, {
      ...LvmVolume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LvmVolume.GVK,
      ...toJson_LvmVolumeProps(resolved),
    };
  }
}

/**
 * LVMVolume represents a LVM based volume
 *
 * @schema LVMVolume
 */
export interface LvmVolumeProps {
  /**
   * @schema LVMVolume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeInfo defines LVM info
   *
   * @schema LVMVolume#spec
   */
  readonly spec: LvmVolumeSpec;

}

/**
 * Converts an object of type 'LvmVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmVolumeProps(obj: LvmVolumeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LvmVolumeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeInfo defines LVM info
 *
 * @schema LvmVolumeSpec
 */
export interface LvmVolumeSpec {
  /**
   * Capacity of the volume
   *
   * @schema LvmVolumeSpec#capacity
   */
  readonly capacity: string;

  /**
   * OwnerNodeID is the Node ID where the volume group is present which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema LvmVolumeSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the LVM LocalPV Driver will not allow the volumes to be mounted by more than one pods.
   *
   * @schema LvmVolumeSpec#shared
   */
  readonly shared?: LvmVolumeSpecShared;

  /**
   * ThinProvision specifies whether logical volumes can be thinly provisioned. If it is set to "yes", then the LVM LocalPV Driver will create thinProvision i.e. logical volumes that are larger than the available extents.
   *
   * @schema LvmVolumeSpec#thinProvision
   */
  readonly thinProvision?: LvmVolumeSpecThinProvision;

  /**
   * VgPattern specifies the regex to choose volume groups where volume needs to be created.
   *
   * @schema LvmVolumeSpec#vgPattern
   */
  readonly vgPattern: string;

  /**
   * VolGroup specifies the name of the volume group where the volume has been created.
   *
   * @schema LvmVolumeSpec#volGroup
   */
  readonly volGroup: string;

}

/**
 * Converts an object of type 'LvmVolumeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LvmVolumeSpec(obj: LvmVolumeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity,
    'ownerNodeID': obj.ownerNodeId,
    'shared': obj.shared,
    'thinProvision': obj.thinProvision,
    'vgPattern': obj.vgPattern,
    'volGroup': obj.volGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the LVM LocalPV Driver will not allow the volumes to be mounted by more than one pods.
 *
 * @schema LvmVolumeSpecShared
 */
export enum LvmVolumeSpecShared {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * ThinProvision specifies whether logical volumes can be thinly provisioned. If it is set to "yes", then the LVM LocalPV Driver will create thinProvision i.e. logical volumes that are larger than the available extents.
 *
 * @schema LvmVolumeSpecThinProvision
 */
export enum LvmVolumeSpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

