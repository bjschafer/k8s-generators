// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecret
 */
export class ClusterExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1',
    kind: 'ClusterExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterExternalSecretProps = {}): any {
    return {
      ...ClusterExternalSecret.GVK,
      ...toJson_ClusterExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ClusterExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterExternalSecretProps = {}) {
    super(scope, id, {
      ...ClusterExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterExternalSecret.GVK,
      ...toJson_ClusterExternalSecretProps(resolved),
    };
  }
}

/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecret
 */
export interface ClusterExternalSecretProps {
  /**
   * @schema ClusterExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
   *
   * @schema ClusterExternalSecret#spec
   */
  readonly spec?: ClusterExternalSecretSpec;

}

/**
 * Converts an object of type 'ClusterExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretProps(obj: ClusterExternalSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
 *
 * @schema ClusterExternalSecretSpec
 */
export interface ClusterExternalSecretSpec {
  /**
   * The metadata of the external secrets to be created
   *
   * @schema ClusterExternalSecretSpec#externalSecretMetadata
   */
  readonly externalSecretMetadata?: ClusterExternalSecretSpecExternalSecretMetadata;

  /**
   * The name of the external secrets to be created.
   * Defaults to the name of the ClusterExternalSecret
   *
   * @default the name of the ClusterExternalSecret
   * @schema ClusterExternalSecretSpec#externalSecretName
   */
  readonly externalSecretName?: string;

  /**
   * The spec for the ExternalSecrets to be created
   *
   * @schema ClusterExternalSecretSpec#externalSecretSpec
   */
  readonly externalSecretSpec: ClusterExternalSecretSpecExternalSecretSpec;

  /**
   * The labels to select by to find the Namespaces to create the ExternalSecrets in.
   * Deprecated: Use NamespaceSelectors instead.
   *
   * @schema ClusterExternalSecretSpec#namespaceSelector
   */
  readonly namespaceSelector?: ClusterExternalSecretSpecNamespaceSelector;

  /**
   * A list of labels to select by to find the Namespaces to create the ExternalSecrets in. The selectors are ORed.
   *
   * @schema ClusterExternalSecretSpec#namespaceSelectors
   */
  readonly namespaceSelectors?: ClusterExternalSecretSpecNamespaceSelectors[];

  /**
   * Choose namespaces by name. This field is ORed with anything that NamespaceSelectors ends up choosing.
   * Deprecated: Use NamespaceSelectors instead.
   *
   * @schema ClusterExternalSecretSpec#namespaces
   */
  readonly namespaces?: string[];

  /**
   * The time in which the controller should reconcile its objects and recheck namespaces for labels.
   *
   * @schema ClusterExternalSecretSpec#refreshTime
   */
  readonly refreshTime?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpec(obj: ClusterExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalSecretMetadata': toJson_ClusterExternalSecretSpecExternalSecretMetadata(obj.externalSecretMetadata),
    'externalSecretName': obj.externalSecretName,
    'externalSecretSpec': toJson_ClusterExternalSecretSpecExternalSecretSpec(obj.externalSecretSpec),
    'namespaceSelector': toJson_ClusterExternalSecretSpecNamespaceSelector(obj.namespaceSelector),
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ClusterExternalSecretSpecNamespaceSelectors(y)),
    'namespaces': obj.namespaces?.map(y => y),
    'refreshTime': obj.refreshTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The metadata of the external secrets to be created
 *
 * @schema ClusterExternalSecretSpecExternalSecretMetadata
 */
export interface ClusterExternalSecretSpecExternalSecretMetadata {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretSpecExternalSecretMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretMetadata(obj: ClusterExternalSecretSpecExternalSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The spec for the ExternalSecrets to be created
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpec
 */
export interface ClusterExternalSecretSpecExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#data
   */
  readonly data?: ClusterExternalSecretSpecExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data
   * If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ClusterExternalSecretSpecExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider,
   * specified as Golang Duration strings.
   * Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h"
   * Example values: "1h", "2h30m", "10s"
   * May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ClusterExternalSecretSpecExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * RefreshPolicy determines how the ExternalSecret should be refreshed:
   * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
   * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
   * No periodic updates occur if refreshInterval is 0.
   * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#refreshPolicy
   */
  readonly refreshPolicy?: ClusterExternalSecretSpecExternalSecretSpecRefreshPolicy;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef?: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created
   * There can be only one target per ExternalSecret.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#target
   */
  readonly target?: ClusterExternalSecretSpecExternalSecretSpecTarget;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpec(obj: ClusterExternalSecretSpecExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'refreshPolicy': obj.refreshPolicy,
    'secretStoreRef': toJson_ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ClusterExternalSecretSpecExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The labels to select by to find the Namespaces to create the ExternalSecrets in.
 * Deprecated: Use NamespaceSelectors instead.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelector
 */
export interface ClusterExternalSecretSpecNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelector(obj: ClusterExternalSecretSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelectors
 */
export interface ClusterExternalSecretSpecNamespaceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectors#matchExpressions
   */
  readonly matchExpressions?: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelectors(obj: ClusterExternalSecretSpecNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecData
 */
export interface ClusterExternalSecretSpecExternalSecretSpecData {
  /**
   * RemoteRef points to the remote secret and defines
   * which secret (version/property/..) to fetch.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef;

  /**
   * The key in the Kubernetes Secret to store the value.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source
   * from which the value will be pulled.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecData(obj: ClusterExternalSecretSpecExternalSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret
   * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#extract
   */
  readonly extract?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions
   * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#find
   */
  readonly find?: ClusterExternalSecretSpecExternalSecretSpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider
   * Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#rewrite
   */
  readonly rewrite?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator
   * which contains secret values ready to use.
   * Use this in combination with Extract or Find pull values out of
   * a specific SecretStore.
   * When sourceRef points to a generator Extract or Find is not supported.
   * The generator returns a static map of values
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFrom(obj: ClusterExternalSecretSpecExternalSecretSpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(obj.extract),
    'find': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(y)),
    'sourceRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RefreshPolicy determines how the ExternalSecret should be refreshed:
 * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
 * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
 * No periodic updates occur if refreshInterval is 0.
 * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecRefreshPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecRefreshPolicy {
  /** CreatedOnce */
  CREATED_ONCE = "CreatedOnce",
  /** Periodic */
  PERIODIC = "Periodic",
  /** OnChange */
  ON_CHANGE = "OnChange",
}

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(obj: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created
 * There can be only one target per ExternalSecret.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTarget
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret.
   * Defaults to "Owner"
   *
   * @default Owner"
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret.
   * Defaults to "Retain"
   *
   * @default Retain"
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * The name of the Secret resource to be managed.
   * Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#template
   */
  readonly template?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTarget(obj: ClusterExternalSecretSpecExternalSecretSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions
 */
export interface ClusterExternalSecretSpecNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(obj: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions
 */
export interface ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions(obj: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRef points to the remote secret and defines
 * which secret (version/property/..) to fetch.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef allows you to override the source
 * from which the value will be pulled.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * Deprecated: The generatorRef is not implemented in .data[].
   * this will be removed with v1.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to extract multiple key/value pairs from one secret
 * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to find secrets based on tags or regular expressions
 * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#name
   */
  readonly name?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFind(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite {
  /**
   * Used to merge key/values in one single Secret
   * The resulting key will contain all values from the specified secrets
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#merge
   */
  readonly merge?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge;

  /**
   * Used to rewrite with regular expressions.
   * The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#regexp
   */
  readonly regexp?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets.
   * The resulting key will be the output of the template applied by the operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#transform
   */
  readonly transform?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'merge': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge(obj.merge),
    'regexp': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(obj.regexp),
    'transform': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(obj.transform),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef points to a store or generator
 * which contains secret values ready to use.
 * Use this in combination with Extract or Find pull values out of
 * a specific SecretStore.
 * When sourceRef points to a generator Extract or Find is not supported.
 * The generator returns a static map of values
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind
 */
export enum ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret.
 * Defaults to "Owner"
 *
 * @default Owner"
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret.
 * Defaults to "Retain"
 *
 * @default Retain"
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplate {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 *
 * Deprecated: The generatorRef is not implemented in .data[].
 * this will be removed with v1.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindName
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to merge key/values in one single Secret
 * The resulting key will contain all values from the specified secrets
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge {
  /**
   * Used to define the policy to use in conflict resolution.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge#conflictPolicy
   */
  readonly conflictPolicy?: string;

  /**
   * Used to define the target key of the merge operation.
   * Required if strategy is JSON. Ignored otherwise.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge#into
   */
  readonly into?: string;

  /**
   * Used to define key priority in conflict resolution.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge#priority
   */
  readonly priority?: string[];

  /**
   * Used to define the strategy to use in the merge operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteMerge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conflictPolicy': obj.conflictPolicy,
    'into': obj.into,
    'priority': obj.priority?.map(y => y),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to rewrite with regular expressions.
 * The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to apply string transformation on the secrets.
 * The resulting key will be the output of the template applied by the operation.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name.
   * `.value ` will specify the secret name in the template.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(obj: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Specify the Kind of the generator resource
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecretV1Beta1
 */
export class ClusterExternalSecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterExternalSecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ClusterExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterExternalSecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterExternalSecretV1Beta1Props = {}): any {
    return {
      ...ClusterExternalSecretV1Beta1.GVK,
      ...toJson_ClusterExternalSecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ClusterExternalSecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterExternalSecretV1Beta1Props = {}) {
    super(scope, id, {
      ...ClusterExternalSecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterExternalSecretV1Beta1.GVK,
      ...toJson_ClusterExternalSecretV1Beta1Props(resolved),
    };
  }
}

/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecretV1Beta1
 */
export interface ClusterExternalSecretV1Beta1Props {
  /**
   * @schema ClusterExternalSecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
   *
   * @schema ClusterExternalSecretV1Beta1#spec
   */
  readonly spec?: ClusterExternalSecretV1Beta1Spec;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1Props(obj: ClusterExternalSecretV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterExternalSecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
 *
 * @schema ClusterExternalSecretV1Beta1Spec
 */
export interface ClusterExternalSecretV1Beta1Spec {
  /**
   * The metadata of the external secrets to be created
   *
   * @schema ClusterExternalSecretV1Beta1Spec#externalSecretMetadata
   */
  readonly externalSecretMetadata?: ClusterExternalSecretV1Beta1SpecExternalSecretMetadata;

  /**
   * The name of the external secrets to be created.
   * Defaults to the name of the ClusterExternalSecret
   *
   * @default the name of the ClusterExternalSecret
   * @schema ClusterExternalSecretV1Beta1Spec#externalSecretName
   */
  readonly externalSecretName?: string;

  /**
   * The spec for the ExternalSecrets to be created
   *
   * @schema ClusterExternalSecretV1Beta1Spec#externalSecretSpec
   */
  readonly externalSecretSpec: ClusterExternalSecretV1Beta1SpecExternalSecretSpec;

  /**
   * The labels to select by to find the Namespaces to create the ExternalSecrets in
   *
   * @schema ClusterExternalSecretV1Beta1Spec#namespaceSelector
   */
  readonly namespaceSelector?: ClusterExternalSecretV1Beta1SpecNamespaceSelector;

  /**
   * A list of labels to select by to find the Namespaces to create the ExternalSecrets in. The selectors are ORed.
   *
   * @schema ClusterExternalSecretV1Beta1Spec#namespaceSelectors
   */
  readonly namespaceSelectors?: ClusterExternalSecretV1Beta1SpecNamespaceSelectors[];

  /**
   * Choose namespaces by name. This field is ORed with anything that NamespaceSelectors ends up choosing.
   * Deprecated: Use NamespaceSelectors instead.
   *
   * @schema ClusterExternalSecretV1Beta1Spec#namespaces
   */
  readonly namespaces?: string[];

  /**
   * The time in which the controller should reconcile its objects and recheck namespaces for labels.
   *
   * @schema ClusterExternalSecretV1Beta1Spec#refreshTime
   */
  readonly refreshTime?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1Spec(obj: ClusterExternalSecretV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalSecretMetadata': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretMetadata(obj.externalSecretMetadata),
    'externalSecretName': obj.externalSecretName,
    'externalSecretSpec': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpec(obj.externalSecretSpec),
    'namespaceSelector': toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelector(obj.namespaceSelector),
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectors(y)),
    'namespaces': obj.namespaces?.map(y => y),
    'refreshTime': obj.refreshTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The metadata of the external secrets to be created
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretMetadata
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretMetadata {
  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretMetadata(obj: ClusterExternalSecretV1Beta1SpecExternalSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The spec for the ExternalSecrets to be created
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#data
   */
  readonly data?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data
   * If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider,
   * specified as Golang Duration strings.
   * Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h"
   * Example values: "1h", "2h30m", "10s"
   * May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * RefreshPolicy determines how the ExternalSecret should be refreshed:
   * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
   * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
   * No periodic updates occur if refreshInterval is 0.
   * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#refreshPolicy
   */
  readonly refreshPolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecRefreshPolicy;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created
   * There can be only one target per ExternalSecret.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpec#target
   */
  readonly target?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpec(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'refreshPolicy': obj.refreshPolicy,
    'secretStoreRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The labels to select by to find the Namespaces to create the ExternalSecrets in
 *
 * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelector
 */
export interface ClusterExternalSecretV1Beta1SpecNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelector(obj: ClusterExternalSecretV1Beta1SpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectors
 */
export interface ClusterExternalSecretV1Beta1SpecNamespaceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectors#matchExpressions
   */
  readonly matchExpressions?: ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectors(obj: ClusterExternalSecretV1Beta1SpecNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecData
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecData {
  /**
   * RemoteRef points to the remote secret and defines
   * which secret (version/property/..) to fetch.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef;

  /**
   * The key in the Kubernetes Secret to store the value.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source
   * from which the value will be pulled.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecData#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecData(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret
   * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom#extract
   */
  readonly extract?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions
   * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom#find
   */
  readonly find?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider
   * Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom#rewrite
   */
  readonly rewrite?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator
   * which contains secret values ready to use.
   * Use this in combination with Extract or Find pull values out of
   * a specific SecretStore.
   * When sourceRef points to a generator Extract or Find is not supported.
   * The generator returns a static map of values
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract(obj.extract),
    'find': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite(y)),
    'sourceRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RefreshPolicy determines how the ExternalSecret should be refreshed:
 * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
 * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
 * No periodic updates occur if refreshInterval is 0.
 * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecRefreshPolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecRefreshPolicy {
  /** CreatedOnce */
  CREATED_ONCE = "CreatedOnce",
  /** Periodic */
  PERIODIC = "Periodic",
  /** OnChange */
  ON_CHANGE = "OnChange",
}

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created
 * There can be only one target per ExternalSecret.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret.
   * Defaults to "Owner"
   *
   * @default Owner"
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret.
   * Defaults to "Retain"
   *
   * @default Retain"
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * The name of the Secret resource to be managed.
   * Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget#template
   */
  readonly template?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions
 */
export interface ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions(obj: ClusterExternalSecretV1Beta1SpecNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions
 */
export interface ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions(obj: ClusterExternalSecretV1Beta1SpecNamespaceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRef points to the remote secret and defines
 * which secret (version/property/..) to fetch.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef allows you to override the source
 * from which the value will be pulled.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * Deprecated: The generatorRef is not implemented in .data[].
   * this will be removed with v1.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to extract multiple key/value pairs from one secret
 * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to find secrets based on tags or regular expressions
 * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind#name
   */
  readonly name?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions.
   * The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite#regexp
   */
  readonly regexp?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets.
   * The resulting key will be the output of the template applied by the operation.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite#transform
   */
  readonly transform?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp(obj.regexp),
    'transform': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform(obj.transform),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef points to a store or generator
 * which contains secret values ready to use.
 * Use this in combination with Extract or Find pull values out of
 * a specific SecretStore.
 * When sourceRef points to a generator Extract or Find is not supported.
 * The generator returns a static map of values
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRefKind
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecSecretStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret.
 * Defaults to "Owner"
 *
 * @default Owner"
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetCreationPolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret.
 * Defaults to "Retain"
 *
 * @default Retain"
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetDeletionPolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate {
  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefDecodingStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefMetadataPolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 *
 * Deprecated: The generatorRef is not implemented in .data[].
 * this will be removed with v1.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractConversionStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractDecodingStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractMetadataPolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindConversionStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindDecodingStrategy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to rewrite with regular expressions.
 * The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to apply string transformation on the secrets.
 * The resulting key will be the output of the template applied by the operation.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name.
   * `.value ` will specify the secret name in the template.
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromRewriteTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMergePolicy
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRefKind
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRefKind
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Specify the Kind of the generator resource
 *
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRefKind
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRefKind
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecDataFromSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromTarget
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(obj: ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ClusterExternalSecretV1Beta1SpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 *
 *
 * @schema ClusterPushSecret
 */
export class ClusterPushSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPushSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1alpha1',
    kind: 'ClusterPushSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterPushSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPushSecretProps = {}): any {
    return {
      ...ClusterPushSecret.GVK,
      ...toJson_ClusterPushSecretProps(props),
    };
  }

  /**
   * Defines a "ClusterPushSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPushSecretProps = {}) {
    super(scope, id, {
      ...ClusterPushSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPushSecret.GVK,
      ...toJson_ClusterPushSecretProps(resolved),
    };
  }
}

/**
 * @schema ClusterPushSecret
 */
export interface ClusterPushSecretProps {
  /**
   * @schema ClusterPushSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ClusterPushSecret#spec
   */
  readonly spec?: ClusterPushSecretSpec;

}

/**
 * Converts an object of type 'ClusterPushSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretProps(obj: ClusterPushSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPushSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpec
 */
export interface ClusterPushSecretSpec {
  /**
   * A list of labels to select by to find the Namespaces to create the ExternalSecrets in. The selectors are ORed.
   *
   * @schema ClusterPushSecretSpec#namespaceSelectors
   */
  readonly namespaceSelectors?: ClusterPushSecretSpecNamespaceSelectors[];

  /**
   * The metadata of the external secrets to be created
   *
   * @schema ClusterPushSecretSpec#pushSecretMetadata
   */
  readonly pushSecretMetadata?: ClusterPushSecretSpecPushSecretMetadata;

  /**
   * The name of the push secrets to be created.
   * Defaults to the name of the ClusterPushSecret
   *
   * @default the name of the ClusterPushSecret
   * @schema ClusterPushSecretSpec#pushSecretName
   */
  readonly pushSecretName?: string;

  /**
   * PushSecretSpec defines what to do with the secrets.
   *
   * @schema ClusterPushSecretSpec#pushSecretSpec
   */
  readonly pushSecretSpec: ClusterPushSecretSpecPushSecretSpec;

  /**
   * The time in which the controller should reconcile its objects and recheck namespaces for labels.
   *
   * @schema ClusterPushSecretSpec#refreshTime
   */
  readonly refreshTime?: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpec(obj: ClusterPushSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ClusterPushSecretSpecNamespaceSelectors(y)),
    'pushSecretMetadata': toJson_ClusterPushSecretSpecPushSecretMetadata(obj.pushSecretMetadata),
    'pushSecretName': obj.pushSecretName,
    'pushSecretSpec': toJson_ClusterPushSecretSpecPushSecretSpec(obj.pushSecretSpec),
    'refreshTime': obj.refreshTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterPushSecretSpecNamespaceSelectors
 */
export interface ClusterPushSecretSpecNamespaceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecNamespaceSelectors#matchExpressions
   */
  readonly matchExpressions?: ClusterPushSecretSpecNamespaceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPushSecretSpecNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecNamespaceSelectors(obj: ClusterPushSecretSpecNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPushSecretSpecNamespaceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The metadata of the external secrets to be created
 *
 * @schema ClusterPushSecretSpecPushSecretMetadata
 */
export interface ClusterPushSecretSpecPushSecretMetadata {
  /**
   * @schema ClusterPushSecretSpecPushSecretMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterPushSecretSpecPushSecretMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretMetadata(obj: ClusterPushSecretSpecPushSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PushSecretSpec defines what to do with the secrets.
 *
 * @schema ClusterPushSecretSpecPushSecretSpec
 */
export interface ClusterPushSecretSpecPushSecretSpec {
  /**
   * Secret Data that should be pushed to providers
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#data
   */
  readonly data?: ClusterPushSecretSpecPushSecretSpecData[];

  /**
   * Deletion Policy to handle Secrets in the provider.
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterPushSecretSpecPushSecretSpecDeletionPolicy;

  /**
   * The Interval to which External Secrets will try to push a secret definition
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpec#secretStoreRefs
   */
  readonly secretStoreRefs: ClusterPushSecretSpecPushSecretSpecSecretStoreRefs[];

  /**
   * The Secret Selector (k8s source) for the Push Secret
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#selector
   */
  readonly selector: ClusterPushSecretSpecPushSecretSpecSelector;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#template
   */
  readonly template?: ClusterPushSecretSpecPushSecretSpecTemplate;

  /**
   * UpdatePolicy to handle Secrets in the provider.
   *
   * @schema ClusterPushSecretSpecPushSecretSpec#updatePolicy
   */
  readonly updatePolicy?: ClusterPushSecretSpecPushSecretSpecUpdatePolicy;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpec(obj: ClusterPushSecretSpecPushSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecData(y)),
    'deletionPolicy': obj.deletionPolicy,
    'refreshInterval': obj.refreshInterval,
    'secretStoreRefs': obj.secretStoreRefs?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefs(y)),
    'selector': toJson_ClusterPushSecretSpecPushSecretSpecSelector(obj.selector),
    'template': toJson_ClusterPushSecretSpecPushSecretSpecTemplate(obj.template),
    'updatePolicy': obj.updatePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPushSecretSpecNamespaceSelectorsMatchExpressions
 */
export interface ClusterPushSecretSpecNamespaceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPushSecretSpecNamespaceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPushSecretSpecNamespaceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPushSecretSpecNamespaceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPushSecretSpecNamespaceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecNamespaceSelectorsMatchExpressions(obj: ClusterPushSecretSpecNamespaceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecData
 */
export interface ClusterPushSecretSpecPushSecretSpecData {
  /**
   * Used to define a conversion Strategy for the secret keys
   *
   * @schema ClusterPushSecretSpecPushSecretSpecData#conversionStrategy
   */
  readonly conversionStrategy?: ClusterPushSecretSpecPushSecretSpecDataConversionStrategy;

  /**
   * Match a given Secret Key to be pushed to the provider.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecData#match
   */
  readonly match: ClusterPushSecretSpecPushSecretSpecDataMatch;

  /**
   * Metadata is metadata attached to the secret.
   * The structure of metadata is provider specific, please look it up in the provider documentation.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecData#metadata
   */
  readonly metadata?: any;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecData(obj: ClusterPushSecretSpecPushSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'match': toJson_ClusterPushSecretSpecPushSecretSpecDataMatch(obj.match),
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deletion Policy to handle Secrets in the provider.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecDeletionPolicy
 */
export enum ClusterPushSecretSpecPushSecretSpecDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** None */
  NONE = "None",
}

/**
 * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefs
 */
export interface ClusterPushSecretSpecPushSecretSpecSecretStoreRefs {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefs#kind
   */
  readonly kind?: ClusterPushSecretSpecPushSecretSpecSecretStoreRefsKind;

  /**
   * Optionally, sync to secret stores with label selector
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefs#labelSelector
   */
  readonly labelSelector?: ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector;

  /**
   * Optionally, sync to the SecretStore of the given name
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefs#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSecretStoreRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefs(obj: ClusterPushSecretSpecPushSecretSpecSecretStoreRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'labelSelector': toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector(obj.labelSelector),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret Selector (k8s source) for the Push Secret
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelector
 */
export interface ClusterPushSecretSpecPushSecretSpecSelector {
  /**
   * Point to a generator to create a Secret.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelector#generatorRef
   */
  readonly generatorRef?: ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef;

  /**
   * Select a Secret to Push.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelector#secret
   */
  readonly secret?: ClusterPushSecretSpecPushSecretSpecSelectorSecret;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSelector(obj: ClusterPushSecretSpecPushSecretSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef(obj.generatorRef),
    'secret': toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecTemplate
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplate {
  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#engineVersion
   */
  readonly engineVersion?: ClusterPushSecretSpecPushSecretSpecTemplateEngineVersion;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#mergePolicy
   */
  readonly mergePolicy?: ClusterPushSecretSpecPushSecretSpecTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#metadata
   */
  readonly metadata?: ClusterPushSecretSpecPushSecretSpecTemplateMetadata;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#templateFrom
   */
  readonly templateFrom?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom[];

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplate(obj: ClusterPushSecretSpecPushSecretSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ClusterPushSecretSpecPushSecretSpecTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdatePolicy to handle Secrets in the provider.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecUpdatePolicy
 */
export enum ClusterPushSecretSpecPushSecretSpecUpdatePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** IfNotExists */
  IF_NOT_EXISTS = "IfNotExists",
}

/**
 * Used to define a conversion Strategy for the secret keys
 *
 * @schema ClusterPushSecretSpecPushSecretSpecDataConversionStrategy
 */
export enum ClusterPushSecretSpecPushSecretSpecDataConversionStrategy {
  /** None */
  NONE = "None",
  /** ReverseUnicode */
  REVERSE_UNICODE = "ReverseUnicode",
}

/**
 * Match a given Secret Key to be pushed to the provider.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecDataMatch
 */
export interface ClusterPushSecretSpecPushSecretSpecDataMatch {
  /**
   * Remote Refs to push to providers.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecDataMatch#remoteRef
   */
  readonly remoteRef: ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef;

  /**
   * Secret Key to be pushed
   *
   * @schema ClusterPushSecretSpecPushSecretSpecDataMatch#secretKey
   */
  readonly secretKey?: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecDataMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecDataMatch(obj: ClusterPushSecretSpecPushSecretSpecDataMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsKind
 */
export enum ClusterPushSecretSpecPushSecretSpecSecretStoreRefsKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Optionally, sync to secret stores with label selector
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector
 */
export interface ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector(obj: ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Point to a generator to create a Secret.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef
 */
export interface ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef#kind
   */
  readonly kind: ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef(obj: ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select a Secret to Push.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecret
 */
export interface ClusterPushSecretSpecPushSecretSpecSelectorSecret {
  /**
   * Name of the Secret.
   * The Secret must exist in the same namespace as the PushSecret manifest.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecret#name
   */
  readonly name?: string;

  /**
   * Selector chooses secrets using a labelSelector.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecret#selector
   */
  readonly selector?: ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSelectorSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecret(obj: ClusterPushSecretSpecPushSecretSpecSelectorSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateEngineVersion
 */
export enum ClusterPushSecretSpecPushSecretSpecTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateMergePolicy
 */
export enum ClusterPushSecretSpecPushSecretSpecTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateMetadata
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateMetadata {
  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateMetadata(obj: ClusterPushSecretSpecPushSecretSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom {
  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom#configMap
   */
  readonly configMap?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom#secret
   */
  readonly secret?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom#target
   */
  readonly target?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom(obj: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Remote Refs to push to providers.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef
 */
export interface ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef {
  /**
   * Name of the property in the resulting secret
   *
   * @schema ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef#property
   */
  readonly property?: string;

  /**
   * Name of the resulting provider secret.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef#remoteKey
   */
  readonly remoteKey: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef(obj: ClusterPushSecretSpecPushSecretSpecDataMatchRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'property': obj.property,
    'remoteKey': obj.remoteKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions
 */
export interface ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(obj: ClusterPushSecretSpecPushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRefKind
 */
export enum ClusterPushSecretSpecPushSecretSpecSelectorGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Selector chooses secrets using a labelSelector.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector
 */
export interface ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector(obj: ClusterPushSecretSpecPushSecretSpecSelectorSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap#items
   */
  readonly items: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap(obj: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret#items
   */
  readonly items: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret(obj: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromTarget
 */
export enum ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions
 */
export interface ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions(obj: ClusterPushSecretSpecPushSecretSpecSelectorSecretSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems(obj: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems
 */
export interface ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems(obj: ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ClusterPushSecretSpecPushSecretSpecTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export class ClusterSecretStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1',
    kind: 'ClusterSecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreProps = {}): any {
    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(props),
    };
  }

  /**
   * Defines a "ClusterSecretStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSecretStoreProps = {}) {
    super(scope, id, {
      ...ClusterSecretStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export interface ClusterSecretStoreProps {
  /**
   * @schema ClusterSecretStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStore#spec
   */
  readonly spec?: ClusterSecretStoreSpec;

}

/**
 * Converts an object of type 'ClusterSecretStoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreProps(obj: ClusterSecretStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSecretStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreSpec
 */
export interface ClusterSecretStoreSpec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema ClusterSecretStoreSpec#conditions
   */
  readonly conditions?: ClusterSecretStoreSpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName)
   * The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreSpec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreSpec#provider
   */
  readonly provider: ClusterSecretStoreSpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema ClusterSecretStoreSpec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreSpec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreSpecRetrySettings;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpec(obj: ClusterSecretStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_ClusterSecretStoreSpecConditions(y)),
    'controller': obj.controller,
    'provider': toJson_ClusterSecretStoreSpecProvider(obj.provider),
    'refreshInterval': obj.refreshInterval,
    'retrySettings': toJson_ClusterSecretStoreSpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in
 * for a ClusterSecretStore instance.
 *
 * @schema ClusterSecretStoreSpecConditions
 */
export interface ClusterSecretStoreSpecConditions {
  /**
   * Choose namespaces by using regex matching
   *
   * @schema ClusterSecretStoreSpecConditions#namespaceRegexes
   */
  readonly namespaceRegexes?: string[];

  /**
   * Choose namespace using a labelSelector
   *
   * @schema ClusterSecretStoreSpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSecretStoreSpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema ClusterSecretStoreSpecConditions#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecConditions(obj: ClusterSecretStoreSpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceRegexes': obj.namespaceRegexes?.map(y => y),
    'namespaceSelector': toJson_ClusterSecretStoreSpecConditionsNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreSpecProvider
 */
export interface ClusterSecretStoreSpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreSpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreSpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreSpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreSpecProviderAzurekv;

  /**
   * Beyondtrust configures this store to sync secrets using Password Safe provider.
   *
   * @schema ClusterSecretStoreSpecProvider#beyondtrust
   */
  readonly beyondtrust?: ClusterSecretStoreSpecProviderBeyondtrust;

  /**
   * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
   *
   * @schema ClusterSecretStoreSpecProvider#bitwardensecretsmanager
   */
  readonly bitwardensecretsmanager?: ClusterSecretStoreSpecProviderBitwardensecretsmanager;

  /**
   * Chef configures this store to sync secrets with chef server
   *
   * @schema ClusterSecretStoreSpecProvider#chef
   */
  readonly chef?: ClusterSecretStoreSpecProviderChef;

  /**
   * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#cloudrusm
   */
  readonly cloudrusm?: ClusterSecretStoreSpecProviderCloudrusm;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema ClusterSecretStoreSpecProvider#conjur
   */
  readonly conjur?: ClusterSecretStoreSpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault
   * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema ClusterSecretStoreSpecProvider#delinea
   */
  readonly delinea?: ClusterSecretStoreSpecProviderDelinea;

  /**
   * Device42 configures this store to sync secrets using the Device42 provider
   *
   * @schema ClusterSecretStoreSpecProvider#device42
   */
  readonly device42?: ClusterSecretStoreSpecProviderDevice42;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema ClusterSecretStoreSpecProvider#doppler
   */
  readonly doppler?: ClusterSecretStoreSpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreSpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreSpecProviderFake;

  /**
   * Fortanix configures this store to sync secrets using the Fortanix provider
   *
   * @schema ClusterSecretStoreSpecProvider#fortanix
   */
  readonly fortanix?: ClusterSecretStoreSpecProviderFortanix;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreSpecProviderGcpsm;

  /**
   * Github configures this store to push Github Action secrets using Github API provider
   *
   * @schema ClusterSecretStoreSpecProvider#github
   */
  readonly github?: ClusterSecretStoreSpecProviderGithub;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreSpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreSpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreSpecProviderIbm;

  /**
   * Infisical configures this store to sync secrets using the Infisical provider
   *
   * @schema ClusterSecretStoreSpecProvider#infisical
   */
  readonly infisical?: ClusterSecretStoreSpecProviderInfisical;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema ClusterSecretStoreSpecProvider#keepersecurity
   */
  readonly keepersecurity?: ClusterSecretStoreSpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreSpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderKubernetes;

  /**
   * Onboardbase configures this store to sync secrets using the Onboardbase provider
   *
   * @schema ClusterSecretStoreSpecProvider#onboardbase
   */
  readonly onboardbase?: ClusterSecretStoreSpecProviderOnboardbase;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#onepassword
   */
  readonly onepassword?: ClusterSecretStoreSpecProviderOnepassword;

  /**
   * OnePasswordSDK configures this store to use 1Password's new Go SDK to sync secrets.
   *
   * @schema ClusterSecretStoreSpecProvider#onepasswordSDK
   */
  readonly onepasswordSdk?: ClusterSecretStoreSpecProviderOnepasswordSdk;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreSpecProviderOracle;

  /**
   * @schema ClusterSecretStoreSpecProvider#passbolt
   */
  readonly passbolt?: ClusterSecretStoreSpecProviderPassbolt;

  /**
   * Configures a store to sync secrets with a Password Depot instance.
   *
   * @schema ClusterSecretStoreSpecProvider#passworddepot
   */
  readonly passworddepot?: ClusterSecretStoreSpecProviderPassworddepot;

  /**
   * Previder configures this store to sync secrets using the Previder provider
   *
   * @schema ClusterSecretStoreSpecProvider#previder
   */
  readonly previder?: ClusterSecretStoreSpecProviderPrevider;

  /**
   * Pulumi configures this store to sync secrets using the Pulumi provider
   *
   * @schema ClusterSecretStoreSpecProvider#pulumi
   */
  readonly pulumi?: ClusterSecretStoreSpecProviderPulumi;

  /**
   * Scaleway
   *
   * @schema ClusterSecretStoreSpecProvider#scaleway
   */
  readonly scaleway?: ClusterSecretStoreSpecProviderScaleway;

  /**
   * SecretServer configures this store to sync secrets using SecretServer provider
   * https://docs.delinea.com/online-help/secret-server/start.htm
   *
   * @schema ClusterSecretStoreSpecProvider#secretserver
   */
  readonly secretserver?: ClusterSecretStoreSpecProviderSecretserver;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema ClusterSecretStoreSpecProvider#senhasegura
   */
  readonly senhasegura?: ClusterSecretStoreSpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreSpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreSpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreSpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreSpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: ClusterSecretStoreSpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreSpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreSpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProvider(obj: ClusterSecretStoreSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_ClusterSecretStoreSpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_ClusterSecretStoreSpecProviderAlibaba(obj.alibaba),
    'aws': toJson_ClusterSecretStoreSpecProviderAws(obj.aws),
    'azurekv': toJson_ClusterSecretStoreSpecProviderAzurekv(obj.azurekv),
    'beyondtrust': toJson_ClusterSecretStoreSpecProviderBeyondtrust(obj.beyondtrust),
    'bitwardensecretsmanager': toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanager(obj.bitwardensecretsmanager),
    'chef': toJson_ClusterSecretStoreSpecProviderChef(obj.chef),
    'cloudrusm': toJson_ClusterSecretStoreSpecProviderCloudrusm(obj.cloudrusm),
    'conjur': toJson_ClusterSecretStoreSpecProviderConjur(obj.conjur),
    'delinea': toJson_ClusterSecretStoreSpecProviderDelinea(obj.delinea),
    'device42': toJson_ClusterSecretStoreSpecProviderDevice42(obj.device42),
    'doppler': toJson_ClusterSecretStoreSpecProviderDoppler(obj.doppler),
    'fake': toJson_ClusterSecretStoreSpecProviderFake(obj.fake),
    'fortanix': toJson_ClusterSecretStoreSpecProviderFortanix(obj.fortanix),
    'gcpsm': toJson_ClusterSecretStoreSpecProviderGcpsm(obj.gcpsm),
    'github': toJson_ClusterSecretStoreSpecProviderGithub(obj.github),
    'gitlab': toJson_ClusterSecretStoreSpecProviderGitlab(obj.gitlab),
    'ibm': toJson_ClusterSecretStoreSpecProviderIbm(obj.ibm),
    'infisical': toJson_ClusterSecretStoreSpecProviderInfisical(obj.infisical),
    'keepersecurity': toJson_ClusterSecretStoreSpecProviderKeepersecurity(obj.keepersecurity),
    'kubernetes': toJson_ClusterSecretStoreSpecProviderKubernetes(obj.kubernetes),
    'onboardbase': toJson_ClusterSecretStoreSpecProviderOnboardbase(obj.onboardbase),
    'onepassword': toJson_ClusterSecretStoreSpecProviderOnepassword(obj.onepassword),
    'onepasswordSDK': toJson_ClusterSecretStoreSpecProviderOnepasswordSdk(obj.onepasswordSdk),
    'oracle': toJson_ClusterSecretStoreSpecProviderOracle(obj.oracle),
    'passbolt': toJson_ClusterSecretStoreSpecProviderPassbolt(obj.passbolt),
    'passworddepot': toJson_ClusterSecretStoreSpecProviderPassworddepot(obj.passworddepot),
    'previder': toJson_ClusterSecretStoreSpecProviderPrevider(obj.previder),
    'pulumi': toJson_ClusterSecretStoreSpecProviderPulumi(obj.pulumi),
    'scaleway': toJson_ClusterSecretStoreSpecProviderScaleway(obj.scaleway),
    'secretserver': toJson_ClusterSecretStoreSpecProviderSecretserver(obj.secretserver),
    'senhasegura': toJson_ClusterSecretStoreSpecProviderSenhasegura(obj.senhasegura),
    'vault': toJson_ClusterSecretStoreSpecProviderVault(obj.vault),
    'webhook': toJson_ClusterSecretStoreSpecProviderWebhook(obj.webhook),
    'yandexcertificatemanager': toJson_ClusterSecretStoreSpecProviderYandexcertificatemanager(obj.yandexcertificatemanager),
    'yandexlockbox': toJson_ClusterSecretStoreSpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreSpecRetrySettings
 */
export interface ClusterSecretStoreSpecRetrySettings {
  /**
   * @schema ClusterSecretStoreSpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreSpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecRetrySettings(obj: ClusterSecretStoreSpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema ClusterSecretStoreSpecConditionsNamespaceSelector
 */
export interface ClusterSecretStoreSpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSecretStoreSpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSecretStoreSpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecConditionsNamespaceSelector(obj: ClusterSecretStoreSpecConditionsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAkeyless
 */
export interface ClusterSecretStoreSpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used
   * if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeyless(obj: ClusterSecretStoreSpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderAlibaba
 */
export interface ClusterSecretStoreSpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibaba(obj: ClusterSecretStoreSpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderAws
 */
export interface ClusterSecretStoreSpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema ClusterSecretStoreSpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS
   * if not set aws sdk will infer credentials from your environment
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreSpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreSpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * Prefix adds a prefix to all retrieved values.
   *
   * @schema ClusterSecretStoreSpecProviderAws#prefix
   */
  readonly prefix?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema ClusterSecretStoreSpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema ClusterSecretStoreSpecProviderAws#secretsManager
   */
  readonly secretsManager?: ClusterSecretStoreSpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreSpecProviderAws#service
   */
  readonly service: ClusterSecretStoreSpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema ClusterSecretStoreSpecProviderAws#sessionTags
   */
  readonly sessionTags?: ClusterSecretStoreSpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema ClusterSecretStoreSpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAws(obj: ClusterSecretStoreSpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalRoles': obj.additionalRoles?.map(y => y),
    'auth': toJson_ClusterSecretStoreSpecProviderAwsAuth(obj.auth),
    'externalID': obj.externalId,
    'prefix': obj.prefix,
    'region': obj.region,
    'role': obj.role,
    'secretsManager': toJson_ClusterSecretStoreSpecProviderAwsSecretsManager(obj.secretsManager),
    'service': obj.service,
    'sessionTags': obj.sessionTags?.map(y => toJson_ClusterSecretStoreSpecProviderAwsSessionTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAzurekv
 */
export interface ClusterSecretStoreSpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service.
   * Valid values are:
   * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
   * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreSpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for
   * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
   * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
   * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#environmentType
   */
  readonly environmentType?: ClusterSecretStoreSpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekv(obj: ClusterSecretStoreSpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'environmentType': obj.environmentType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Beyondtrust configures this store to sync secrets using Password Safe provider.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrust
 */
export interface ClusterSecretStoreSpecProviderBeyondtrust {
  /**
   * Auth configures how the operator authenticates with Beyondtrust.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrust#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderBeyondtrustAuth;

  /**
   * Auth configures how API server works.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrust#server
   */
  readonly server: ClusterSecretStoreSpecProviderBeyondtrustServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrust' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrust(obj: ClusterSecretStoreSpecProviderBeyondtrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuth(obj.auth),
    'server': toJson_ClusterSecretStoreSpecProviderBeyondtrustServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager
 */
export interface ClusterSecretStoreSpecProviderBitwardensecretsmanager {
  /**
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
   * Make sure that the token being used has permissions on the given secret.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth;

  /**
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
   */
  readonly bitwardenServerSdkurl?: string;

  /**
   * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider;

  /**
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#identityURL
   */
  readonly identityUrl?: string;

  /**
   * OrganizationID determines which organization this secret store manages.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#organizationID
   */
  readonly organizationId: string;

  /**
   * ProjectID determines which project this secret store manages.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanager#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBitwardensecretsmanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanager(obj: ClusterSecretStoreSpecProviderBitwardensecretsmanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'auth': toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth(obj.auth),
    'bitwardenServerSDKURL': obj.bitwardenServerSdkurl,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider(obj.caProvider),
    'identityURL': obj.identityUrl,
    'organizationID': obj.organizationId,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chef configures this store to sync secrets with chef server
 *
 * @schema ClusterSecretStoreSpecProviderChef
 */
export interface ClusterSecretStoreSpecProviderChef {
  /**
   * Auth defines the information necessary to authenticate against chef Server
   *
   * @schema ClusterSecretStoreSpecProviderChef#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderChefAuth;

  /**
   * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
   *
   * @schema ClusterSecretStoreSpecProviderChef#serverUrl
   */
  readonly serverUrl: string;

  /**
   * UserName should be the user ID on the chef server
   *
   * @schema ClusterSecretStoreSpecProviderChef#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderChef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderChef(obj: ClusterSecretStoreSpecProviderChef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderChefAuth(obj.auth),
    'serverUrl': obj.serverUrl,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderCloudrusm
 */
export interface ClusterSecretStoreSpecProviderCloudrusm {
  /**
   * CSMAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusm#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderCloudrusmAuth;

  /**
   * ProjectID is the project, which the secrets are stored in.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderCloudrusm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderCloudrusm(obj: ClusterSecretStoreSpecProviderCloudrusm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderCloudrusmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema ClusterSecretStoreSpecProviderConjur
 */
export interface ClusterSecretStoreSpecProviderConjur {
  /**
   * Defines authentication settings for connecting to Conjur.
   *
   * @schema ClusterSecretStoreSpecProviderConjur#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderConjurAuth;

  /**
   * CABundle is a PEM encoded CA bundle that will be used to validate the Conjur server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates
   * for a secret store. The CAProvider points to a Secret or ConfigMap resource
   * that contains a PEM-encoded certificate.
   *
   * @schema ClusterSecretStoreSpecProviderConjur#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderConjurCaProvider;

  /**
   * URL is the endpoint of the Conjur instance.
   *
   * @schema ClusterSecretStoreSpecProviderConjur#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjur(obj: ClusterSecretStoreSpecProviderConjur | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderConjurAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderConjurCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delinea DevOps Secrets Vault
 * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema ClusterSecretStoreSpecProviderDelinea
 */
export interface ClusterSecretStoreSpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema ClusterSecretStoreSpecProviderDelinea#clientId
   */
  readonly clientId: ClusterSecretStoreSpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema ClusterSecretStoreSpecProviderDelinea#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreSpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema ClusterSecretStoreSpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning.
   * If unset, defaults to "com".
   *
   * @schema ClusterSecretStoreSpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate
   * If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema ClusterSecretStoreSpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDelinea(obj: ClusterSecretStoreSpecProviderDelinea | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreSpecProviderDelineaClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreSpecProviderDelineaClientSecret(obj.clientSecret),
    'tenant': obj.tenant,
    'tld': obj.tld,
    'urlTemplate': obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Device42 configures this store to sync secrets using the Device42 provider
 *
 * @schema ClusterSecretStoreSpecProviderDevice42
 */
export interface ClusterSecretStoreSpecProviderDevice42 {
  /**
   * Auth configures how secret-manager authenticates with a Device42 instance.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderDevice42Auth;

  /**
   * URL configures the Device42 instance URL.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDevice42' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDevice42(obj: ClusterSecretStoreSpecProviderDevice42 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderDevice42Auth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema ClusterSecretStoreSpecProviderDoppler
 */
export interface ClusterSecretStoreSpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema ClusterSecretStoreSpecProviderDoppler#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreSpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema ClusterSecretStoreSpecProviderDoppler#format
   */
  readonly format?: ClusterSecretStoreSpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema ClusterSecretStoreSpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: ClusterSecretStoreSpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreSpecProviderDoppler#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDoppler(obj: ClusterSecretStoreSpecProviderDoppler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderDopplerAuth(obj.auth),
    'config': obj.config,
    'format': obj.format,
    'nameTransformer': obj.nameTransformer,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreSpecProviderFake
 */
export interface ClusterSecretStoreSpecProviderFake {
  /**
   * @schema ClusterSecretStoreSpecProviderFake#data
   */
  readonly data: ClusterSecretStoreSpecProviderFakeData[];

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFake(obj: ClusterSecretStoreSpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterSecretStoreSpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fortanix configures this store to sync secrets using the Fortanix provider
 *
 * @schema ClusterSecretStoreSpecProviderFortanix
 */
export interface ClusterSecretStoreSpecProviderFortanix {
  /**
   * APIKey is the API token to access SDKMS Applications.
   *
   * @schema ClusterSecretStoreSpecProviderFortanix#apiKey
   */
  readonly apiKey?: ClusterSecretStoreSpecProviderFortanixApiKey;

  /**
   * APIURL is the URL of SDKMS API. Defaults to `sdkms.fortanix.com`.
   *
   * @default sdkms.fortanix.com`.
   * @schema ClusterSecretStoreSpecProviderFortanix#apiUrl
   */
  readonly apiUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFortanix' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFortanix(obj: ClusterSecretStoreSpecProviderFortanix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_ClusterSecretStoreSpecProviderFortanixApiKey(obj.apiKey),
    'apiUrl': obj.apiUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderGcpsm
 */
export interface ClusterSecretStoreSpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderGcpsmAuth;

  /**
   * Location optionally defines a location for a secret
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#location
   */
  readonly location?: string;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsm(obj: ClusterSecretStoreSpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderGcpsmAuth(obj.auth),
    'location': obj.location,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Github configures this store to push Github Action secrets using Github API provider
 *
 * @schema ClusterSecretStoreSpecProviderGithub
 */
export interface ClusterSecretStoreSpecProviderGithub {
  /**
   * appID specifies the Github APP that will be used to authenticate the client
   *
   * @schema ClusterSecretStoreSpecProviderGithub#appID
   */
  readonly appId: number;

  /**
   * auth configures how secret-manager authenticates with a Github instance.
   *
   * @schema ClusterSecretStoreSpecProviderGithub#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderGithubAuth;

  /**
   * environment will be used to fetch secrets from a particular environment within a github repository
   *
   * @schema ClusterSecretStoreSpecProviderGithub#environment
   */
  readonly environment?: string;

  /**
   * installationID specifies the Github APP installation that will be used to authenticate the client
   *
   * @schema ClusterSecretStoreSpecProviderGithub#installationID
   */
  readonly installationId: number;

  /**
   * organization will be used to fetch secrets from the Github organization
   *
   * @schema ClusterSecretStoreSpecProviderGithub#organization
   */
  readonly organization: string;

  /**
   * repository will be used to fetch secrets from the Github repository within an organization
   *
   * @schema ClusterSecretStoreSpecProviderGithub#repository
   */
  readonly repository?: string;

  /**
   * Upload URL for enterprise instances. Default to URL.
   *
   * @default URL.
   * @schema ClusterSecretStoreSpecProviderGithub#uploadURL
   */
  readonly uploadUrl?: string;

  /**
   * URL configures the Github instance URL. Defaults to https://github.com/.
   *
   * @default https://github.com/.
   * @schema ClusterSecretStoreSpecProviderGithub#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGithub(obj: ClusterSecretStoreSpecProviderGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appID': obj.appId,
    'auth': toJson_ClusterSecretStoreSpecProviderGithubAuth(obj.auth),
    'environment': obj.environment,
    'installationID': obj.installationId,
    'organization': obj.organization,
    'repository': obj.repository,
    'uploadURL': obj.uploadUrl,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreSpecProviderGitlab
 */
export interface ClusterSecretStoreSpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderGitlabAuth;

  /**
   * Base64 encoded certificate for the GitLab server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderGitlabCaProvider;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreSpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlab(obj: ClusterSecretStoreSpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderGitlabAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderGitlabCaProvider(obj.caProvider),
    'environment': obj.environment,
    'groupIDs': obj.groupIDs?.map(y => y),
    'inheritFromGroups': obj.inheritFromGroups,
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderIbm
 */
export interface ClusterSecretStoreSpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreSpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreSpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbm(obj: ClusterSecretStoreSpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Infisical configures this store to sync secrets using the Infisical provider
 *
 * @schema ClusterSecretStoreSpecProviderInfisical
 */
export interface ClusterSecretStoreSpecProviderInfisical {
  /**
   * Auth configures how the Operator authenticates with the Infisical API
   *
   * @schema ClusterSecretStoreSpecProviderInfisical#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderInfisicalAuth;

  /**
   * HostAPI specifies the base URL of the Infisical API. If not provided, it defaults to "https://app.infisical.com/api".
   *
   * @schema ClusterSecretStoreSpecProviderInfisical#hostAPI
   */
  readonly hostApi?: string;

  /**
   * SecretsScope defines the scope of the secrets within the workspace
   *
   * @schema ClusterSecretStoreSpecProviderInfisical#secretsScope
   */
  readonly secretsScope: ClusterSecretStoreSpecProviderInfisicalSecretsScope;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisical(obj: ClusterSecretStoreSpecProviderInfisical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderInfisicalAuth(obj.auth),
    'hostAPI': obj.hostApi,
    'secretsScope': toJson_ClusterSecretStoreSpecProviderInfisicalSecretsScope(obj.secretsScope),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema ClusterSecretStoreSpecProviderKeepersecurity
 */
export interface ClusterSecretStoreSpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKeepersecurity#authRef
   */
  readonly authRef: ClusterSecretStoreSpecProviderKeepersecurityAuthRef;

  /**
   * @schema ClusterSecretStoreSpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKeepersecurity(obj: ClusterSecretStoreSpecProviderKeepersecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authRef': toJson_ClusterSecretStoreSpecProviderKeepersecurityAuthRef(obj.authRef),
    'folderID': obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetes
 */
export interface ClusterSecretStoreSpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderKubernetesAuth;

  /**
   * A reference to a secret that contains the auth information.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#authRef
   */
  readonly authRef?: ClusterSecretStoreSpecProviderKubernetesAuthRef;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreSpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetes(obj: ClusterSecretStoreSpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderKubernetesAuth(obj.auth),
    'authRef': toJson_ClusterSecretStoreSpecProviderKubernetesAuthRef(obj.authRef),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_ClusterSecretStoreSpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Onboardbase configures this store to sync secrets using the Onboardbase provider
 *
 * @schema ClusterSecretStoreSpecProviderOnboardbase
 */
export interface ClusterSecretStoreSpecProviderOnboardbase {
  /**
   * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbase#apiHost
   */
  readonly apiHost: string;

  /**
   * Auth configures how the Operator authenticates with the Onboardbase API
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbase#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderOnboardbaseAuth;

  /**
   * Environment is the name of an environmnent within a project to pull the secrets from
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbase#environment
   */
  readonly environment: string;

  /**
   * Project is an onboardbase project that the secrets should be pulled from
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbase#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnboardbase' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnboardbase(obj: ClusterSecretStoreSpecProviderOnboardbase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiHost': obj.apiHost,
    'auth': toJson_ClusterSecretStoreSpecProviderOnboardbaseAuth(obj.auth),
    'environment': obj.environment,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderOnepassword
 */
export interface ClusterSecretStoreSpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema ClusterSecretStoreSpecProviderOnepassword#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema ClusterSecretStoreSpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema ClusterSecretStoreSpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepassword(obj: ClusterSecretStoreSpecProviderOnepassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderOnepasswordAuth(obj.auth),
    'connectHost': obj.connectHost,
    'vaults': ((obj.vaults) === undefined) ? undefined : (Object.entries(obj.vaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordSDK configures this store to use 1Password's new Go SDK to sync secrets.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordSdk
 */
export interface ClusterSecretStoreSpecProviderOnepasswordSdk {
  /**
   * Auth defines the information necessary to authenticate against OnePassword API.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdk#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderOnepasswordSdkAuth;

  /**
   * IntegrationInfo specifies the name and version of the integration built using the 1Password Go SDK.
   * If you don't know which name and version to use, use `DefaultIntegrationName` and `DefaultIntegrationVersion`, respectively.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdk#integrationInfo
   */
  readonly integrationInfo?: ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo;

  /**
   * Vault defines the vault's name or uuid to access. Do NOT add op:// prefix. This will be done automatically.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdk#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordSdk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordSdk(obj: ClusterSecretStoreSpecProviderOnepasswordSdk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderOnepasswordSdkAuth(obj.auth),
    'integrationInfo': toJson_ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo(obj.integrationInfo),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderOracle
 */
export interface ClusterSecretStoreSpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault.
   * If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID.
   * Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault.
   * Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will
   * determine the principal type. This optional field must be specified if using
   * workload identity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreSpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracle(obj: ClusterSecretStoreSpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderPassbolt
 */
export interface ClusterSecretStoreSpecProviderPassbolt {
  /**
   * Auth defines the information necessary to authenticate against Passbolt Server
   *
   * @schema ClusterSecretStoreSpecProviderPassbolt#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderPassboltAuth;

  /**
   * Host defines the Passbolt Server to connect to
   *
   * @schema ClusterSecretStoreSpecProviderPassbolt#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassbolt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassbolt(obj: ClusterSecretStoreSpecProviderPassbolt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderPassboltAuth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configures a store to sync secrets with a Password Depot instance.
 *
 * @schema ClusterSecretStoreSpecProviderPassworddepot
 */
export interface ClusterSecretStoreSpecProviderPassworddepot {
  /**
   * Auth configures how secret-manager authenticates with a Password Depot instance.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepot#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderPassworddepotAuth;

  /**
   * Database to use as source
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepot#database
   */
  readonly database: string;

  /**
   * URL configures the Password Depot instance URL.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepot#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassworddepot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassworddepot(obj: ClusterSecretStoreSpecProviderPassworddepot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderPassworddepotAuth(obj.auth),
    'database': obj.database,
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Previder configures this store to sync secrets using the Previder provider
 *
 * @schema ClusterSecretStoreSpecProviderPrevider
 */
export interface ClusterSecretStoreSpecProviderPrevider {
  /**
   * PreviderAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreSpecProviderPrevider#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderPreviderAuth;

  /**
   * @schema ClusterSecretStoreSpecProviderPrevider#baseUri
   */
  readonly baseUri?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPrevider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPrevider(obj: ClusterSecretStoreSpecProviderPrevider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderPreviderAuth(obj.auth),
    'baseUri': obj.baseUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pulumi configures this store to sync secrets using the Pulumi provider
 *
 * @schema ClusterSecretStoreSpecProviderPulumi
 */
export interface ClusterSecretStoreSpecProviderPulumi {
  /**
   * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
   *
   * @schema ClusterSecretStoreSpecProviderPulumi#accessToken
   */
  readonly accessToken: ClusterSecretStoreSpecProviderPulumiAccessToken;

  /**
   * APIURL is the URL of the Pulumi API.
   *
   * @schema ClusterSecretStoreSpecProviderPulumi#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Environment are YAML documents composed of static key-value pairs, programmatic expressions,
   * dynamically retrieved values from supported providers including all major clouds,
   * and other Pulumi ESC environments.
   * To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
   *
   * @schema ClusterSecretStoreSpecProviderPulumi#environment
   */
  readonly environment: string;

  /**
   * Organization are a space to collaborate on shared projects and stacks.
   * To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
   *
   * @schema ClusterSecretStoreSpecProviderPulumi#organization
   */
  readonly organization: string;

  /**
   * Project is the name of the Pulumi ESC project the environment belongs to.
   *
   * @schema ClusterSecretStoreSpecProviderPulumi#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPulumi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPulumi(obj: ClusterSecretStoreSpecProviderPulumi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreSpecProviderPulumiAccessToken(obj.accessToken),
    'apiUrl': obj.apiUrl,
    'environment': obj.environment,
    'organization': obj.organization,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scaleway
 *
 * @schema ClusterSecretStoreSpecProviderScaleway
 */
export interface ClusterSecretStoreSpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreSpecProviderScaleway#accessKey
   */
  readonly accessKey: ClusterSecretStoreSpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema ClusterSecretStoreSpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema ClusterSecretStoreSpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema ClusterSecretStoreSpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreSpecProviderScaleway#secretKey
   */
  readonly secretKey: ClusterSecretStoreSpecProviderScalewaySecretKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderScaleway(obj: ClusterSecretStoreSpecProviderScaleway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_ClusterSecretStoreSpecProviderScalewayAccessKey(obj.accessKey),
    'apiUrl': obj.apiUrl,
    'projectId': obj.projectId,
    'region': obj.region,
    'secretKey': toJson_ClusterSecretStoreSpecProviderScalewaySecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretServer configures this store to sync secrets using SecretServer provider
 * https://docs.delinea.com/online-help/secret-server/start.htm
 *
 * @schema ClusterSecretStoreSpecProviderSecretserver
 */
export interface ClusterSecretStoreSpecProviderSecretserver {
  /**
   * Password is the secret server account password.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserver#password
   */
  readonly password: ClusterSecretStoreSpecProviderSecretserverPassword;

  /**
   * ServerURL
   * URL to your secret server installation
   *
   * @schema ClusterSecretStoreSpecProviderSecretserver#serverURL
   */
  readonly serverUrl: string;

  /**
   * Username is the secret server account username.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserver#username
   */
  readonly username: ClusterSecretStoreSpecProviderSecretserverUsername;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSecretserver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSecretserver(obj: ClusterSecretStoreSpecProviderSecretserver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ClusterSecretStoreSpecProviderSecretserverPassword(obj.password),
    'serverURL': obj.serverUrl,
    'username': toJson_ClusterSecretStoreSpecProviderSecretserverUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema ClusterSecretStoreSpecProviderSenhasegura
 */
export interface ClusterSecretStoreSpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema ClusterSecretStoreSpecProviderSenhasegura#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema ClusterSecretStoreSpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema ClusterSecretStoreSpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema ClusterSecretStoreSpecProviderSenhasegura#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSenhasegura(obj: ClusterSecretStoreSpecProviderSenhasegura | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderSenhaseguraAuth(obj.auth),
    'ignoreSslCertificate': obj.ignoreSslCertificate,
    'module': obj.module,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreSpecProviderVault
 */
export interface ClusterSecretStoreSpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVault#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault
   * leader instead of simply retrying within a loop. This can increase performance if
   * the option is enabled serverside.
   * https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreSpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Headers to be added in Vault request
   *
   * @schema ClusterSecretStoreSpecProviderVault#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreSpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g:
   * "secret". The v2 KV secret engine version specific "/data" path suffix
   * for fetching secrets from Vault is optional and will be appended
   * if not present in specified path.
   *
   * @schema ClusterSecretStoreSpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by
   * providing discovered cluster replication states in each request.
   * More information about eventual consistency in Vault can be found here
   * https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreSpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreSpecProviderVault#server
   */
  readonly server: string;

  /**
   * The configuration used for client side related TLS communication, when the Vault server
   * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
   * This parameter is ignored for plain HTTP protocol connection.
   * It's worth noting this configuration is different from the "TLS certificates auth method",
   * which is available under the `auth.cert` section.
   *
   * @schema ClusterSecretStoreSpecProviderVault#tls
   */
  readonly tls?: ClusterSecretStoreSpecProviderVaultTls;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or
   * "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreSpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreSpecProviderVaultVersion;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVault(obj: ClusterSecretStoreSpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'tls': toJson_ClusterSecretStoreSpecProviderVaultTls(obj.tls),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreSpecProviderWebhook
 */
export interface ClusterSecretStoreSpecProviderWebhook {
  /**
   * Auth specifies a authorization protocol. Only one protocol may be set.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderWebhookAuth;

  /**
   * Body
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreSpecProviderWebhookResult;

  /**
   * Secrets to fill in templates
   * These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreSpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhook(obj: ClusterSecretStoreSpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderWebhookAuth(obj.auth),
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_ClusterSecretStoreSpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_ClusterSecretStoreSpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderYandexcertificatemanager
 */
export interface ClusterSecretStoreSpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanager#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexcertificatemanager(obj: ClusterSecretStoreSpecProviderYandexcertificatemanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockbox
 */
export interface ClusterSecretStoreSpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockbox(obj: ClusterSecretStoreSpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions
 */
export interface ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions(obj: ClusterSecretStoreSpecConditionsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount
   * token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details
   * to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreSpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(obj: ClusterSecretStoreSpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreSpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuth(obj: ClusterSecretStoreSpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS
 * if not set aws sdk will infer credentials from your environment
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuth
 */
export interface ClusterSecretStoreSpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials
   * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuth(obj: ClusterSecretStoreSpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema ClusterSecretStoreSpecProviderAwsSecretsManager
 */
export interface ClusterSecretStoreSpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You
   * can't use both this parameter and RecoveryWindowInDays in the same call.
   * If you don't use either, then by default Secrets Manager uses a 30 day
   * recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema ClusterSecretStoreSpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before
   * permanently deleting the secret. You can't use both this parameter and
   * ForceDeleteWithoutRecovery in the same call. If you don't use either,
   * then by default Secrets Manager uses a 30 day recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema ClusterSecretStoreSpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsSecretsManager(obj: ClusterSecretStoreSpecProviderAwsSecretsManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreSpecProviderAwsService
 */
export enum ClusterSecretStoreSpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema ClusterSecretStoreSpecProviderAwsSessionTags
 */
export interface ClusterSecretStoreSpecProviderAwsSessionTags {
  /**
   * @schema ClusterSecretStoreSpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAwsSessionTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsSessionTags(obj: ClusterSecretStoreSpecProviderAwsSessionTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure ClientCertificate of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientCertificate
   */
  readonly clientCertificate?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate;

  /**
   * The Azure clientId of the service principle or managed identity used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret;

  /**
   * The Azure tenantId of the managed identity used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#tenantId
   */
  readonly tenantId?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate(obj.clientCertificate),
    'clientId': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
    'tenantId': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId(obj.tenantId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service.
 * Valid values are:
 * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
 * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreSpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for
 * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
 * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
 * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvEnvironmentType
 */
export enum ClusterSecretStoreSpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(obj: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Beyondtrust.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuth {
  /**
   * APIKey If not provided then ClientID/ClientSecret become required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth#apiKey
   */
  readonly apiKey?: ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey;

  /**
   * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth#certificate
   */
  readonly certificate?: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate;

  /**
   * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth#certificateKey
   */
  readonly certificateKey?: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey;

  /**
   * ClientID is the API OAuth Client ID.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth#clientId
   */
  readonly clientId?: ClusterSecretStoreSpecProviderBeyondtrustAuthClientId;

  /**
   * ClientSecret is the API OAuth Client Secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuth#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuth(obj: ClusterSecretStoreSpecProviderBeyondtrustAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey(obj.apiKey),
    'certificate': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate(obj.certificate),
    'certificateKey': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey(obj.certificateKey),
    'clientId': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how API server works.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustServer
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustServer {
  /**
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#apiUrl
   */
  readonly apiUrl: string;

  /**
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
   *
   * @default 45 seconds.
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#clientTimeOutSeconds
   */
  readonly clientTimeOutSeconds?: number;

  /**
   * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#retrievalType
   */
  readonly retrievalType?: string;

  /**
   * A character that separates the folder names.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#separator
   */
  readonly separator?: string;

  /**
   * @schema ClusterSecretStoreSpecProviderBeyondtrustServer#verifyCA
   */
  readonly verifyCa: boolean;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustServer(obj: ClusterSecretStoreSpecProviderBeyondtrustServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiUrl': obj.apiUrl,
    'apiVersion': obj.apiVersion,
    'clientTimeOutSeconds': obj.clientTimeOutSeconds,
    'retrievalType': obj.retrievalType,
    'separator': obj.separator,
    'verifyCA': obj.verifyCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
 * Make sure that the token being used has permissions on the given secret.
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth
 */
export interface ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth {
  /**
   * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth(obj: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider
 */
export interface ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider(obj: ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against chef Server
 *
 * @schema ClusterSecretStoreSpecProviderChefAuth
 */
export interface ClusterSecretStoreSpecProviderChefAuth {
  /**
   * ChefAuthSecretRef holds secret references for chef server login credentials.
   *
   * @schema ClusterSecretStoreSpecProviderChefAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderChefAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderChefAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderChefAuth(obj: ClusterSecretStoreSpecProviderChefAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderChefAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreSpecProviderCloudrusmAuth
 */
export interface ClusterSecretStoreSpecProviderCloudrusmAuth {
  /**
   * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderCloudrusmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderCloudrusmAuth(obj: ClusterSecretStoreSpecProviderCloudrusmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines authentication settings for connecting to Conjur.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuth
 */
export interface ClusterSecretStoreSpecProviderConjurAuth {
  /**
   * Authenticates with Conjur using an API key.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuth#apikey
   */
  readonly apikey?: ClusterSecretStoreSpecProviderConjurAuthApikey;

  /**
   * Jwt enables JWT authentication using Kubernetes service account tokens.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderConjurAuthJwt;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuth(obj: ClusterSecretStoreSpecProviderConjurAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apikey': toJson_ClusterSecretStoreSpecProviderConjurAuthApikey(obj.apikey),
    'jwt': toJson_ClusterSecretStoreSpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates
 * for a secret store. The CAProvider points to a Secret or ConfigMap resource
 * that contains a PEM-encoded certificate.
 *
 * @schema ClusterSecretStoreSpecProviderConjurCaProvider
 */
export interface ClusterSecretStoreSpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderConjurCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderConjurCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurCaProvider(obj: ClusterSecretStoreSpecProviderConjurCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema ClusterSecretStoreSpecProviderDelineaClientId
 */
export interface ClusterSecretStoreSpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDelineaClientId(obj: ClusterSecretStoreSpecProviderDelineaClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderDelineaClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema ClusterSecretStoreSpecProviderDelineaClientSecret
 */
export interface ClusterSecretStoreSpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDelineaClientSecret(obj: ClusterSecretStoreSpecProviderDelineaClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Device42 instance.
 *
 * @schema ClusterSecretStoreSpecProviderDevice42Auth
 */
export interface ClusterSecretStoreSpecProviderDevice42Auth {
  /**
   * @schema ClusterSecretStoreSpecProviderDevice42Auth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderDevice42AuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDevice42Auth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDevice42Auth(obj: ClusterSecretStoreSpecProviderDevice42Auth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderDevice42AuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema ClusterSecretStoreSpecProviderDopplerAuth
 */
export interface ClusterSecretStoreSpecProviderDopplerAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderDopplerAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDopplerAuth(obj: ClusterSecretStoreSpecProviderDopplerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderDopplerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema ClusterSecretStoreSpecProviderDopplerFormat
 */
export enum ClusterSecretStoreSpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema ClusterSecretStoreSpecProviderDopplerNameTransformer
 */
export enum ClusterSecretStoreSpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema ClusterSecretStoreSpecProviderFakeData
 */
export interface ClusterSecretStoreSpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#value
   */
  readonly value: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFakeData(obj: ClusterSecretStoreSpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey is the API token to access SDKMS Applications.
 *
 * @schema ClusterSecretStoreSpecProviderFortanixApiKey
 */
export interface ClusterSecretStoreSpecProviderFortanixApiKey {
  /**
   * SecretRef is a reference to a secret containing the SDKMS API Key.
   *
   * @schema ClusterSecretStoreSpecProviderFortanixApiKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderFortanixApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFortanixApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFortanixApiKey(obj: ClusterSecretStoreSpecProviderFortanixApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderFortanixApiKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuth(obj: ClusterSecretStoreSpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * auth configures how secret-manager authenticates with a Github instance.
 *
 * @schema ClusterSecretStoreSpecProviderGithubAuth
 */
export interface ClusterSecretStoreSpecProviderGithubAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderGithubAuth#privateKey
   */
  readonly privateKey: ClusterSecretStoreSpecProviderGithubAuthPrivateKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGithubAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGithubAuth(obj: ClusterSecretStoreSpecProviderGithubAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKey': toJson_ClusterSecretStoreSpecProviderGithubAuthPrivateKey(obj.privateKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuth
 */
export interface ClusterSecretStoreSpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuth(obj: ClusterSecretStoreSpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreSpecProviderGitlabCaProvider
 */
export interface ClusterSecretStoreSpecProviderGitlabCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderGitlabCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderGitlabCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabCaProvider(obj: ClusterSecretStoreSpecProviderGitlabCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuth
 */
export interface ClusterSecretStoreSpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: ClusterSecretStoreSpecProviderIbmAuthContainerAuth;

  /**
   * @schema ClusterSecretStoreSpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuth(obj: ClusterSecretStoreSpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerAuth': toJson_ClusterSecretStoreSpecProviderIbmAuthContainerAuth(obj.containerAuth),
    'secretRef': toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Infisical API
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalAuth
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderInfisicalAuth#azureAuthCredentials
   */
  readonly azureAuthCredentials?: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials;

  /**
   * @schema ClusterSecretStoreSpecProviderInfisicalAuth#universalAuthCredentials
   */
  readonly universalAuthCredentials?: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuth(obj: ClusterSecretStoreSpecProviderInfisicalAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureAuthCredentials': toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials(obj.azureAuthCredentials),
    'universalAuthCredentials': toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials(obj.universalAuthCredentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsScope defines the scope of the secrets within the workspace
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope
 */
export interface ClusterSecretStoreSpecProviderInfisicalSecretsScope {
  /**
   * EnvironmentSlug is the required slug identifier for the environment.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope#environmentSlug
   */
  readonly environmentSlug: string;

  /**
   * ExpandSecretReferences indicates whether secret references should be expanded. Defaults to true if not provided.
   *
   * @default true if not provided.
   * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope#expandSecretReferences
   */
  readonly expandSecretReferences?: boolean;

  /**
   * ProjectSlug is the required slug identifier for the project.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope#projectSlug
   */
  readonly projectSlug: string;

  /**
   * Recursive indicates whether the secrets should be fetched recursively. Defaults to false if not provided.
   *
   * @default false if not provided.
   * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope#recursive
   */
  readonly recursive?: boolean;

  /**
   * SecretsPath specifies the path to the secrets within the workspace. Defaults to "/" if not provided.
   *
   * @default if not provided.
   * @schema ClusterSecretStoreSpecProviderInfisicalSecretsScope#secretsPath
   */
  readonly secretsPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalSecretsScope' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalSecretsScope(obj: ClusterSecretStoreSpecProviderInfisicalSecretsScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environmentSlug': obj.environmentSlug,
    'expandSecretReferences': obj.expandSecretReferences,
    'projectSlug': obj.projectSlug,
    'recursive': obj.recursive,
    'secretsPath': obj.secretsPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKeepersecurityAuthRef
 */
export interface ClusterSecretStoreSpecProviderKeepersecurityAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKeepersecurityAuthRef(obj: ClusterSecretStoreSpecProviderKeepersecurityAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreSpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuth(obj: ClusterSecretStoreSpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a secret that contains the auth information.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthRef
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthRef(obj: ClusterSecretStoreSpecProviderKubernetesAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServer
 */
export interface ClusterSecretStoreSpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServer(obj: ClusterSecretStoreSpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Onboardbase API
 *
 * @schema ClusterSecretStoreSpecProviderOnboardbaseAuth
 */
export interface ClusterSecretStoreSpecProviderOnboardbaseAuth {
  /**
   * OnboardbaseAPIKey is the APIKey generated by an admin account.
   * It is used to recognize and authorize access to a project and environment within onboardbase
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuth#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef;

  /**
   * OnboardbasePasscode is the passcode attached to the API Key
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuth#passcodeRef
   */
  readonly passcodeRef: ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnboardbaseAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnboardbaseAuth(obj: ClusterSecretStoreSpecProviderOnboardbaseAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRef': toJson_ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef(obj.apiKeyRef),
    'passcodeRef': toJson_ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef(obj.passcodeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordAuth
 */
export interface ClusterSecretStoreSpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordAuth(obj: ClusterSecretStoreSpecProviderOnepasswordAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword API.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuth
 */
export interface ClusterSecretStoreSpecProviderOnepasswordSdkAuth {
  /**
   * ServiceAccountSecretRef points to the secret containing the token to access 1Password vault.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuth#serviceAccountSecretRef
   */
  readonly serviceAccountSecretRef: ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordSdkAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordSdkAuth(obj: ClusterSecretStoreSpecProviderOnepasswordSdkAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountSecretRef': toJson_ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef(obj.serviceAccountSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IntegrationInfo specifies the name and version of the integration built using the 1Password Go SDK.
 * If you don't know which name and version to use, use `DefaultIntegrationName` and `DefaultIntegrationVersion`, respectively.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo
 */
export interface ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo {
  /**
   * Name defaults to "1Password SDK".
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo#name
   */
  readonly name?: string;

  /**
   * Version defaults to "v1.0.0".
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo(obj: ClusterSecretStoreSpecProviderOnepasswordSdkIntegrationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault.
 * If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuth
 */
export interface ClusterSecretStoreSpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuth(obj: ClusterSecretStoreSpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will
 * determine the principal type. This optional field must be specified if using
 * workload identity.
 *
 * @schema ClusterSecretStoreSpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreSpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(obj: ClusterSecretStoreSpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Passbolt Server
 *
 * @schema ClusterSecretStoreSpecProviderPassboltAuth
 */
export interface ClusterSecretStoreSpecProviderPassboltAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuth#passwordSecretRef
   */
  readonly passwordSecretRef: ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuth#privateKeySecretRef
   */
  readonly privateKeySecretRef: ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassboltAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassboltAuth(obj: ClusterSecretStoreSpecProviderPassboltAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef(obj.passwordSecretRef),
    'privateKeySecretRef': toJson_ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Password Depot instance.
 *
 * @schema ClusterSecretStoreSpecProviderPassworddepotAuth
 */
export interface ClusterSecretStoreSpecProviderPassworddepotAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderPassworddepotAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassworddepotAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassworddepotAuth(obj: ClusterSecretStoreSpecProviderPassworddepotAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreSpecProviderPreviderAuth
 */
export interface ClusterSecretStoreSpecProviderPreviderAuth {
  /**
   * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
   *
   * @schema ClusterSecretStoreSpecProviderPreviderAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderPreviderAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPreviderAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPreviderAuth(obj: ClusterSecretStoreSpecProviderPreviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderPreviderAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
 *
 * @schema ClusterSecretStoreSpecProviderPulumiAccessToken
 */
export interface ClusterSecretStoreSpecProviderPulumiAccessToken {
  /**
   * SecretRef is a reference to a secret containing the Pulumi API token.
   *
   * @schema ClusterSecretStoreSpecProviderPulumiAccessToken#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPulumiAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPulumiAccessToken(obj: ClusterSecretStoreSpecProviderPulumiAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreSpecProviderScalewayAccessKey
 */
export interface ClusterSecretStoreSpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderScalewayAccessKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderScalewayAccessKey(obj: ClusterSecretStoreSpecProviderScalewayAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreSpecProviderScalewaySecretKey
 */
export interface ClusterSecretStoreSpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderScalewaySecretKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderScalewaySecretKey(obj: ClusterSecretStoreSpecProviderScalewaySecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password is the secret server account password.
 *
 * @schema ClusterSecretStoreSpecProviderSecretserverPassword
 */
export interface ClusterSecretStoreSpecProviderSecretserverPassword {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverPassword#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverPassword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSecretserverPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSecretserverPassword(obj: ClusterSecretStoreSpecProviderSecretserverPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username is the secret server account username.
 *
 * @schema ClusterSecretStoreSpecProviderSecretserverUsername
 */
export interface ClusterSecretStoreSpecProviderSecretserverUsername {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverUsername#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverUsername#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSecretserverUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSecretserverUsername(obj: ClusterSecretStoreSpecProviderSecretserverUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema ClusterSecretStoreSpecProviderSenhaseguraAuth
 */
export interface ClusterSecretStoreSpecProviderSenhaseguraAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSenhaseguraAuth(obj: ClusterSecretStoreSpecProviderSenhaseguraAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuth
 */
export interface ClusterSecretStoreSpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism,
   * with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreSpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
   * Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
   * AWS IAM authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#iam
   */
  readonly iam?: ClusterSecretStoreSpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the
   * JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount
   * token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using
   * the LDAP authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreSpecProviderVaultAuthLdap;

  /**
   * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in.
   * Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   * This will default to Vault.Namespace field if set, or empty otherwise
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#namespace
   */
  readonly namespace?: string;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#userPass
   */
  readonly userPass?: ClusterSecretStoreSpecProviderVaultAuthUserPass;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuth(obj: ClusterSecretStoreSpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_ClusterSecretStoreSpecProviderVaultAuthCert(obj.cert),
    'iam': toJson_ClusterSecretStoreSpecProviderVaultAuthIam(obj.iam),
    'jwt': toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(obj.ldap),
    'namespace': obj.namespace,
    'tokenSecretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_ClusterSecretStoreSpecProviderVaultAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreSpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultCaProvider(obj: ClusterSecretStoreSpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration used for client side related TLS communication, when the Vault server
 * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
 * This parameter is ignored for plain HTTP protocol connection.
 * It's worth noting this configuration is different from the "TLS certificates auth method",
 * which is available under the `auth.cert` section.
 *
 * @schema ClusterSecretStoreSpecProviderVaultTls
 */
export interface ClusterSecretStoreSpecProviderVaultTls {
  /**
   * CertSecretRef is a certificate added to the transport layer
   * when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTls#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreSpecProviderVaultTlsCertSecretRef;

  /**
   * KeySecretRef to a key in a Secret resource containing client private key
   * added to the transport layer when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.key'.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTls#keySecretRef
   */
  readonly keySecretRef?: ClusterSecretStoreSpecProviderVaultTlsKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultTls(obj: ClusterSecretStoreSpecProviderVaultTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreSpecProviderVaultTlsCertSecretRef(obj.certSecretRef),
    'keySecretRef': toJson_ClusterSecretStoreSpecProviderVaultTlsKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or
 * "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreSpecProviderVaultVersion
 */
export enum ClusterSecretStoreSpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * Auth specifies a authorization protocol. Only one protocol may be set.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookAuth
 */
export interface ClusterSecretStoreSpecProviderWebhookAuth {
  /**
   * NTLMProtocol configures the store to use NTLM for auth
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuth#ntlm
   */
  readonly ntlm?: ClusterSecretStoreSpecProviderWebhookAuthNtlm;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookAuth(obj: ClusterSecretStoreSpecProviderWebhookAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ntlm': toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlm(obj.ntlm),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreSpecProviderWebhookCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(obj: ClusterSecretStoreSpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreSpecProviderWebhookResult
 */
export interface ClusterSecretStoreSpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreSpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookResult(obj: ClusterSecretStoreSpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreSpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecrets(obj: ClusterSecretStoreSpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth
 */
export interface ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth(obj: ClusterSecretStoreSpecProviderYandexcertificatemanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider
 */
export interface ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider(obj: ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(obj: ClusterSecretStoreSpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(obj: ClusterSecretStoreSpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount
 * token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Akeyless. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Akeyless. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details
 * to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreSpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(obj: ClusterSecretStoreSpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(obj: ClusterSecretStoreSpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials
 * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientCertificate of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle or managed identity used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure tenantId of the managed identity used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefTenantId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey If not provided then ClientID/ClientSecret become required.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the API OAuth Client ID.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientId
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientId(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the API OAuth Client Secret.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
   * AccessToken used for the bitwarden instance.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
   */
  readonly credentials: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef(obj: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProviderType
 */
export enum ClusterSecretStoreSpecProviderBitwardensecretsmanagerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * ChefAuthSecretRef holds secret references for chef server login credentials.
 *
 * @schema ClusterSecretStoreSpecProviderChefAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderChefAuthSecretRef {
  /**
   * SecretKey is the Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderChefAuthSecretRef#privateKeySecretRef
   */
  readonly privateKeySecretRef: ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderChefAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderChefAuthSecretRef(obj: ClusterSecretStoreSpecProviderChefAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKeySecretRef': toJson_ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
 *
 * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef(obj: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticates with Conjur using an API key.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthApikey
 */
export interface ClusterSecretStoreSpecProviderConjurAuthApikey {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' containing the Conjur API key
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' containing the Conjur username
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthApikey(obj: ClusterSecretStoreSpecProviderConjurAuthApikey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'apiKeyRef': toJson_ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef(obj.apiKeyRef),
    'userRef': toJson_ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef(obj.userRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt enables JWT authentication using Kubernetes service account tokens.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthJwt
 */
export interface ClusterSecretStoreSpecProviderConjurAuthJwt {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional HostID for JWT authentication. This may be used depending
   * on how the Conjur JWT authenticator policy is configured.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwt#hostId
   */
  readonly hostId?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Conjur using the JWT authentication method.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthJwt(obj: ClusterSecretStoreSpecProviderConjurAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'hostId': obj.hostId,
    'secretRef': toJson_ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef(obj.serviceAccountRef),
    'serviceID': obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderConjurCaProviderType
 */
export enum ClusterSecretStoreSpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderDelineaClientIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderDelineaClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDelineaClientIdSecretRef(obj: ClusterSecretStoreSpecProviderDelineaClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef(obj: ClusterSecretStoreSpecProviderDelineaClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderDevice42AuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRef#credentials
   */
  readonly credentials?: ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDevice42AuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDevice42AuthSecretRef(obj: ClusterSecretStoreSpecProviderDevice42AuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication.
   * See https://docs.doppler.com/reference/api#authentication for auth token types.
   * The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDopplerAuthSecretRef(obj: ClusterSecretStoreSpecProviderDopplerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dopplerToken': toJson_ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken(obj.dopplerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the SDKMS API Key.
 *
 * @schema ClusterSecretStoreSpecProviderFortanixApiKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderFortanixApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderFortanixApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderFortanixApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderFortanixApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFortanixApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFortanixApiKeySecretRef(obj: ClusterSecretStoreSpecProviderFortanixApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * ClusterLocation is the location of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation?: string;

  /**
   * ClusterName is the name of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterProjectID is the project ID of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderGithubAuthPrivateKey
 */
export interface ClusterSecretStoreSpecProviderGithubAuthPrivateKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGithubAuthPrivateKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGithubAuthPrivateKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGithubAuthPrivateKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGithubAuthPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGithubAuthPrivateKey(obj: ClusterSecretStoreSpecProviderGithubAuthPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderGitlabCaProviderType
 */
export enum ClusterSecretStoreSpecProviderGitlabCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuthContainerAuth
 */
export interface ClusterSecretStoreSpecProviderIbmAuthContainerAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthContainerAuth(obj: ClusterSecretStoreSpecProviderIbmAuthContainerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamEndpoint': obj.iamEndpoint,
    'profile': obj.profile,
    'tokenLocation': obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(obj: ClusterSecretStoreSpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials#identityId
   */
  readonly identityId: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials#resource
   */
  readonly resource?: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials(obj: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityId': toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId(obj.identityId),
    'resource': toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource(obj.resource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials#clientId
   */
  readonly clientId: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials(obj: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(obj: ClusterSecretStoreSpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(obj: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(obj: ClusterSecretStoreSpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreSpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(obj: ClusterSecretStoreSpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbaseAPIKey is the APIKey generated by an admin account.
 * It is used to recognize and authorize access to a project and environment within onboardbase
 *
 * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef
 */
export interface ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef(obj: ClusterSecretStoreSpecProviderOnboardbaseAuthApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbasePasscode is the passcode attached to the API Key
 *
 * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef
 */
export interface ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef(obj: ClusterSecretStoreSpecProviderOnboardbaseAuthPasscodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef(obj: ClusterSecretStoreSpecProviderOnepasswordAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTokenSecretRef': toJson_ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj.connectTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountSecretRef points to the secret containing the token to access 1Password vault.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef
 */
export interface ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef(obj: ClusterSecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef
 */
export interface ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef(obj: ClusterSecretStoreSpecProviderPassboltAuthPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef(obj: ClusterSecretStoreSpecProviderPassboltAuthPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef#credentials
   */
  readonly credentials?: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef(obj: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
 *
 * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderPreviderAuthSecretRef {
  /**
   * The AccessToken is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRef#accessToken
   */
  readonly accessToken: ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPreviderAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPreviderAuthSecretRef(obj: ClusterSecretStoreSpecProviderPreviderAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the Pulumi API token.
 *
 * @schema ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef(obj: ClusterSecretStoreSpecProviderPulumiAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderScalewayAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef(obj: ClusterSecretStoreSpecProviderScalewaySecretKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef
 */
export interface ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef(obj: ClusterSecretStoreSpecProviderSecretserverPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef
 */
export interface ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef(obj: ClusterSecretStoreSpecProviderSecretserverUsernameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef(obj: ClusterSecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism,
 * with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted
   * in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting
   * up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role id.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(obj: ClusterSecretStoreSpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
 * Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault
   * authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to
   * authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCert(obj: ClusterSecretStoreSpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
 * AWS IAM authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIam
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIam(obj: ClusterSecretStoreSpecProviderVaultAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_ClusterSecretStoreSpecProviderVaultAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the
 * JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted
   * in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault
   * authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(obj: ClusterSecretStoreSpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount
 * token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g:
   * "kubernetes"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a
   * Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Vault. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Vault. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using
 * the LDAP authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted
   * in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP
   * user used to authenticate with Vault using the LDAP authentication
   * method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is an LDAP username used to authenticate using the LDAP Vault
   * authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(obj: ClusterSecretStoreSpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthUserPass
 */
export interface ClusterSecretStoreSpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted
   * in Vault, e.g: "userpass"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the
   * user used to authenticate with Vault using the UserPass authentication
   * method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a username used to authenticate using the UserPass Vault
   * authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthUserPass(obj: ClusterSecretStoreSpecProviderVaultAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreSpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * CertSecretRef is a certificate added to the transport layer
 * when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
 *
 * @schema ClusterSecretStoreSpecProviderVaultTlsCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultTlsCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultTlsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultTlsCertSecretRef(obj: ClusterSecretStoreSpecProviderVaultTlsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySecretRef to a key in a Secret resource containing client private key
 * added to the transport layer when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.key'.
 *
 * @schema ClusterSecretStoreSpecProviderVaultTlsKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultTlsKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultTlsKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultTlsKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultTlsKeySecretRef(obj: ClusterSecretStoreSpecProviderVaultTlsKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NTLMProtocol configures the store to use NTLM for auth
 *
 * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlm
 */
export interface ClusterSecretStoreSpecProviderWebhookAuthNtlm {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlm#passwordSecret
   */
  readonly passwordSecret: ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlm#usernameSecret
   */
  readonly usernameSecret: ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookAuthNtlm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlm(obj: ClusterSecretStoreSpecProviderWebhookAuthNtlm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecret': toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret(obj.passwordSecret),
    'usernameSecret': toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret(obj.usernameSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreSpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreSpecProviderWebhookSecretsSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(obj: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj: ClusterSecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Akeyless. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Akeyless. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef(obj: ClusterSecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken used for the bitwarden instance.
 *
 * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
 */
export interface ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj: ClusterSecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef(obj: ClusterSecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur API key
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef
 */
export interface ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef(obj: ClusterSecretStoreSpecProviderConjurAuthApikeyApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur username
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef
 */
export interface ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef(obj: ClusterSecretStoreSpecProviderConjurAuthApikeyUserRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Conjur using the JWT authentication method.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef
 */
export interface ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef(obj: ClusterSecretStoreSpecProviderConjurAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef(obj: ClusterSecretStoreSpecProviderConjurAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials
 */
export interface ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials(obj: ClusterSecretStoreSpecProviderDevice42AuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The DopplerToken is used for authentication.
 * See https://docs.doppler.com/reference/api#authentication for auth token types.
 * The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken(obj: ClusterSecretStoreSpecProviderDopplerAuthSecretRefDopplerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId(obj: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource(obj: ClusterSecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
 */
export interface ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj: ClusterSecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreSpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj: ClusterSecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials
 */
export interface ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(obj: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessToken is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken(obj: ClusterSecretStoreSpecProviderPreviderAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role id.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef(obj: ClusterSecretStoreSpecProviderVaultAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault
 * authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(obj: ClusterSecretStoreSpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to
 * authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwt
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamJwt(obj: ClusterSecretStoreSpecProviderVaultAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service
   * account token for the service account referenced by `serviceAccountRef`.
   * Defaults to a single audience `vault` it not specified.
   * Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary
   * Kubernetes service account token for the service account referenced by
   * `serviceAccountRef`.
   * Deprecated: this will be removed in the future.
   * Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Vault. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Vault. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP
 * user used to authenticate with Vault using the LDAP authentication
 * method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the
 * user used to authenticate with Vault using the UserPass authentication
 * method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret
 */
export interface ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret(obj: ClusterSecretStoreSpecProviderWebhookAuthNtlmPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret
 */
export interface ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret(obj: ClusterSecretStoreSpecProviderWebhookAuthNtlmUsernameSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef(obj: ClusterSecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export class ClusterSecretStoreV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStoreV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ClusterSecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStoreV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreV1Beta1Props = {}): any {
    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ClusterSecretStoreV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSecretStoreV1Beta1Props = {}) {
    super(scope, id, {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export interface ClusterSecretStoreV1Beta1Props {
  /**
   * @schema ClusterSecretStoreV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1#spec
   */
  readonly spec?: ClusterSecretStoreV1Beta1Spec;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1Props(obj: ClusterSecretStoreV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSecretStoreV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreV1Beta1Spec
 */
export interface ClusterSecretStoreV1Beta1Spec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema ClusterSecretStoreV1Beta1Spec#conditions
   */
  readonly conditions?: ClusterSecretStoreV1Beta1SpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName)
   * The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreV1Beta1Spec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreV1Beta1Spec#provider
   */
  readonly provider: ClusterSecretStoreV1Beta1SpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema ClusterSecretStoreV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreV1Beta1Spec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreV1Beta1SpecRetrySettings;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1Spec(obj: ClusterSecretStoreV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_ClusterSecretStoreV1Beta1SpecConditions(y)),
    'controller': obj.controller,
    'provider': toJson_ClusterSecretStoreV1Beta1SpecProvider(obj.provider),
    'refreshInterval': obj.refreshInterval,
    'retrySettings': toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in
 * for a ClusterSecretStore instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditions
 */
export interface ClusterSecretStoreV1Beta1SpecConditions {
  /**
   * Choose namespaces by using regex matching
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaceRegexes
   */
  readonly namespaceRegexes?: string[];

  /**
   * Choose namespace using a labelSelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditions(obj: ClusterSecretStoreV1Beta1SpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceRegexes': obj.namespaceRegexes?.map(y => y),
    'namespaceSelector': toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreV1Beta1SpecProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreV1Beta1SpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreV1Beta1SpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreV1Beta1SpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreV1Beta1SpecProviderAzurekv;

  /**
   * Beyondtrust configures this store to sync secrets using Password Safe provider.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#beyondtrust
   */
  readonly beyondtrust?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrust;

  /**
   * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#bitwardensecretsmanager
   */
  readonly bitwardensecretsmanager?: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager;

  /**
   * Chef configures this store to sync secrets with chef server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#chef
   */
  readonly chef?: ClusterSecretStoreV1Beta1SpecProviderChef;

  /**
   * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#cloudrusm
   */
  readonly cloudrusm?: ClusterSecretStoreV1Beta1SpecProviderCloudrusm;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#conjur
   */
  readonly conjur?: ClusterSecretStoreV1Beta1SpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault
   * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#delinea
   */
  readonly delinea?: ClusterSecretStoreV1Beta1SpecProviderDelinea;

  /**
   * Device42 configures this store to sync secrets using the Device42 provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#device42
   */
  readonly device42?: ClusterSecretStoreV1Beta1SpecProviderDevice42;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#doppler
   */
  readonly doppler?: ClusterSecretStoreV1Beta1SpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreV1Beta1SpecProviderFake;

  /**
   * Fortanix configures this store to sync secrets using the Fortanix provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#fortanix
   */
  readonly fortanix?: ClusterSecretStoreV1Beta1SpecProviderFortanix;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreV1Beta1SpecProviderGcpsm;

  /**
   * Github configures this store to push Github Action secrets using Github API provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#github
   */
  readonly github?: ClusterSecretStoreV1Beta1SpecProviderGithub;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreV1Beta1SpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreV1Beta1SpecProviderIbm;

  /**
   * Infisical configures this store to sync secrets using the Infisical provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#infisical
   */
  readonly infisical?: ClusterSecretStoreV1Beta1SpecProviderInfisical;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#keepersecurity
   */
  readonly keepersecurity?: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderKubernetes;

  /**
   * Onboardbase configures this store to sync secrets using the Onboardbase provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#onboardbase
   */
  readonly onboardbase?: ClusterSecretStoreV1Beta1SpecProviderOnboardbase;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#onepassword
   */
  readonly onepassword?: ClusterSecretStoreV1Beta1SpecProviderOnepassword;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreV1Beta1SpecProviderOracle;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProvider#passbolt
   */
  readonly passbolt?: ClusterSecretStoreV1Beta1SpecProviderPassbolt;

  /**
   * Configures a store to sync secrets with a Password Depot instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#passworddepot
   */
  readonly passworddepot?: ClusterSecretStoreV1Beta1SpecProviderPassworddepot;

  /**
   * Previder configures this store to sync secrets using the Previder provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#previder
   */
  readonly previder?: ClusterSecretStoreV1Beta1SpecProviderPrevider;

  /**
   * Pulumi configures this store to sync secrets using the Pulumi provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#pulumi
   */
  readonly pulumi?: ClusterSecretStoreV1Beta1SpecProviderPulumi;

  /**
   * Scaleway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#scaleway
   */
  readonly scaleway?: ClusterSecretStoreV1Beta1SpecProviderScaleway;

  /**
   * SecretServer configures this store to sync secrets using SecretServer provider
   * https://docs.delinea.com/online-help/secret-server/start.htm
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#secretserver
   */
  readonly secretserver?: ClusterSecretStoreV1Beta1SpecProviderSecretserver;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#senhasegura
   */
  readonly senhasegura?: ClusterSecretStoreV1Beta1SpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreV1Beta1SpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreV1Beta1SpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProvider(obj: ClusterSecretStoreV1Beta1SpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(obj.alibaba),
    'aws': toJson_ClusterSecretStoreV1Beta1SpecProviderAws(obj.aws),
    'azurekv': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(obj.azurekv),
    'beyondtrust': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrust(obj.beyondtrust),
    'bitwardensecretsmanager': toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager(obj.bitwardensecretsmanager),
    'chef': toJson_ClusterSecretStoreV1Beta1SpecProviderChef(obj.chef),
    'cloudrusm': toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusm(obj.cloudrusm),
    'conjur': toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(obj.conjur),
    'delinea': toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(obj.delinea),
    'device42': toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42(obj.device42),
    'doppler': toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(obj.doppler),
    'fake': toJson_ClusterSecretStoreV1Beta1SpecProviderFake(obj.fake),
    'fortanix': toJson_ClusterSecretStoreV1Beta1SpecProviderFortanix(obj.fortanix),
    'gcpsm': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(obj.gcpsm),
    'github': toJson_ClusterSecretStoreV1Beta1SpecProviderGithub(obj.github),
    'gitlab': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(obj.gitlab),
    'ibm': toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(obj.ibm),
    'infisical': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisical(obj.infisical),
    'keepersecurity': toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(obj.keepersecurity),
    'kubernetes': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(obj.kubernetes),
    'onboardbase': toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbase(obj.onboardbase),
    'onepassword': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(obj.onepassword),
    'oracle': toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(obj.oracle),
    'passbolt': toJson_ClusterSecretStoreV1Beta1SpecProviderPassbolt(obj.passbolt),
    'passworddepot': toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepot(obj.passworddepot),
    'previder': toJson_ClusterSecretStoreV1Beta1SpecProviderPrevider(obj.previder),
    'pulumi': toJson_ClusterSecretStoreV1Beta1SpecProviderPulumi(obj.pulumi),
    'scaleway': toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(obj.scaleway),
    'secretserver': toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserver(obj.secretserver),
    'senhasegura': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(obj.senhasegura),
    'vault': toJson_ClusterSecretStoreV1Beta1SpecProviderVault(obj.vault),
    'webhook': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(obj.webhook),
    'yandexcertificatemanager': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj.yandexcertificatemanager),
    'yandexlockbox': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreV1Beta1SpecRetrySettings
 */
export interface ClusterSecretStoreV1Beta1SpecRetrySettings {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(obj: ClusterSecretStoreV1Beta1SpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(obj: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used
   * if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(obj: ClusterSecretStoreV1Beta1SpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(obj: ClusterSecretStoreV1Beta1SpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAws
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS
   * if not set aws sdk will infer credentials from your environment
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * Prefix adds a prefix to all retrieved values.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#prefix
   */
  readonly prefix?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#secretsManager
   */
  readonly secretsManager?: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#service
   */
  readonly service: ClusterSecretStoreV1Beta1SpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#sessionTags
   */
  readonly sessionTags?: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAws(obj: ClusterSecretStoreV1Beta1SpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalRoles': obj.additionalRoles?.map(y => y),
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(obj.auth),
    'externalID': obj.externalId,
    'prefix': obj.prefix,
    'region': obj.region,
    'role': obj.role,
    'secretsManager': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(obj.secretsManager),
    'service': obj.service,
    'sessionTags': obj.sessionTags?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service.
   * Valid values are:
   * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
   * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for
   * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
   * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
   * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#environmentType
   */
  readonly environmentType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'environmentType': obj.environmentType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Beyondtrust configures this store to sync secrets using Password Safe provider.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrust
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrust {
  /**
   * Auth configures how the operator authenticates with Beyondtrust.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrust#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth;

  /**
   * Auth configures how API server works.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrust#server
   */
  readonly server: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrust' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrust(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth(obj.auth),
    'server': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
   * Make sure that the token being used has permissions on the given secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
   */
  readonly bitwardenServerSdkurl?: string;

  /**
   * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#identityURL
   */
  readonly identityUrl?: string;

  /**
   * OrganizationID determines which organization this secret store manages.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#organizationID
   */
  readonly organizationId: string;

  /**
   * ProjectID determines which project this secret store manages.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager(obj: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(obj.auth),
    'bitwardenServerSDKURL': obj.bitwardenServerSdkurl,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(obj.caProvider),
    'identityURL': obj.identityUrl,
    'organizationID': obj.organizationId,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chef configures this store to sync secrets with chef server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderChef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderChef {
  /**
   * Auth defines the information necessary to authenticate against chef Server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChef#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderChefAuth;

  /**
   * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChef#serverUrl
   */
  readonly serverUrl: string;

  /**
   * UserName should be the user ID on the chef server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChef#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderChef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderChef(obj: ClusterSecretStoreV1Beta1SpecProviderChef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuth(obj.auth),
    'serverUrl': obj.serverUrl,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderCloudrusm {
  /**
   * CSMAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusm#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth;

  /**
   * ProjectID is the project, which the secrets are stored in.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderCloudrusm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusm(obj: ClusterSecretStoreV1Beta1SpecProviderCloudrusm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjur
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjur {
  /**
   * Defines authentication settings for connecting to Conjur.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderConjurAuth;

  /**
   * CABundle is a PEM encoded CA bundle that will be used to validate the Conjur server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates
   * for a secret store. The CAProvider points to a Secret or ConfigMap resource
   * that contains a PEM-encoded certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider;

  /**
   * URL is the endpoint of the Conjur instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(obj: ClusterSecretStoreV1Beta1SpecProviderConjur | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delinea DevOps Secrets Vault
 * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientId
   */
  readonly clientId: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning.
   * If unset, defaults to "com".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate
   * If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(obj: ClusterSecretStoreV1Beta1SpecProviderDelinea | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(obj.clientSecret),
    'tenant': obj.tenant,
    'tld': obj.tld,
    'urlTemplate': obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Device42 configures this store to sync secrets using the Device42 provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDevice42 {
  /**
   * Auth configures how secret-manager authenticates with a Device42 instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderDevice42Auth;

  /**
   * URL configures the Device42 instance URL.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDevice42' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42(obj: ClusterSecretStoreV1Beta1SpecProviderDevice42 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42Auth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#format
   */
  readonly format?: ClusterSecretStoreV1Beta1SpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(obj: ClusterSecretStoreV1Beta1SpecProviderDoppler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(obj.auth),
    'config': obj.config,
    'format': obj.format,
    'nameTransformer': obj.nameTransformer,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFake
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFake {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFake#data
   */
  readonly data: ClusterSecretStoreV1Beta1SpecProviderFakeData[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFake(obj: ClusterSecretStoreV1Beta1SpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fortanix configures this store to sync secrets using the Fortanix provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFortanix
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFortanix {
  /**
   * APIKey is the API token to access SDKMS Applications.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanix#apiKey
   */
  readonly apiKey?: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey;

  /**
   * APIURL is the URL of SDKMS API. Defaults to `sdkms.fortanix.com`.
   *
   * @default sdkms.fortanix.com`.
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanix#apiUrl
   */
  readonly apiUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFortanix' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFortanix(obj: ClusterSecretStoreV1Beta1SpecProviderFortanix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey(obj.apiKey),
    'apiUrl': obj.apiUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth;

  /**
   * Location optionally defines a location for a secret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#location
   */
  readonly location?: string;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(obj.auth),
    'location': obj.location,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Github configures this store to push Github Action secrets using Github API provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGithub
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGithub {
  /**
   * appID specifies the Github APP that will be used to authenticate the client
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#appID
   */
  readonly appId: number;

  /**
   * auth configures how secret-manager authenticates with a Github instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderGithubAuth;

  /**
   * environment will be used to fetch secrets from a particular environment within a github repository
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#environment
   */
  readonly environment?: string;

  /**
   * installationID specifies the Github APP installation that will be used to authenticate the client
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#installationID
   */
  readonly installationId: number;

  /**
   * organization will be used to fetch secrets from the Github organization
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#organization
   */
  readonly organization: string;

  /**
   * repository will be used to fetch secrets from the Github repository within an organization
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#repository
   */
  readonly repository?: string;

  /**
   * Upload URL for enterprise instances. Default to URL.
   *
   * @default URL.
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#uploadURL
   */
  readonly uploadUrl?: string;

  /**
   * URL configures the Github instance URL. Defaults to https://github.com/.
   *
   * @default https://github.com/.
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithub#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGithub(obj: ClusterSecretStoreV1Beta1SpecProviderGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appID': obj.appId,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderGithubAuth(obj.auth),
    'environment': obj.environment,
    'installationID': obj.installationId,
    'organization': obj.organization,
    'repository': obj.repository,
    'uploadURL': obj.uploadUrl,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth;

  /**
   * Base64 encoded certificate for the GitLab server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(obj: ClusterSecretStoreV1Beta1SpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider(obj.caProvider),
    'environment': obj.environment,
    'groupIDs': obj.groupIDs?.map(y => y),
    'inheritFromGroups': obj.inheritFromGroups,
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(obj: ClusterSecretStoreV1Beta1SpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Infisical configures this store to sync secrets using the Infisical provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisical
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisical {
  /**
   * Auth configures how the Operator authenticates with the Infisical API
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisical#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth;

  /**
   * HostAPI specifies the base URL of the Infisical API. If not provided, it defaults to "https://app.infisical.com/api".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisical#hostAPI
   */
  readonly hostApi?: string;

  /**
   * SecretsScope defines the scope of the secrets within the workspace
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisical#secretsScope
   */
  readonly secretsScope: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisical(obj: ClusterSecretStoreV1Beta1SpecProviderInfisical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth(obj.auth),
    'hostAPI': obj.hostApi,
    'secretsScope': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope(obj.secretsScope),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#authRef
   */
  readonly authRef: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authRef': toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj.authRef),
    'folderID': obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth;

  /**
   * A reference to a secret that contains the auth information.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#authRef
   */
  readonly authRef?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(obj.auth),
    'authRef': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef(obj.authRef),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Onboardbase configures this store to sync secrets using the Onboardbase provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbase
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnboardbase {
  /**
   * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbase#apiHost
   */
  readonly apiHost: string;

  /**
   * Auth configures how the Operator authenticates with the Onboardbase API
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbase#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth;

  /**
   * Environment is the name of an environmnent within a project to pull the secrets from
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbase#environment
   */
  readonly environment: string;

  /**
   * Project is an onboardbase project that the secrets should be pulled from
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbase#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnboardbase' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbase(obj: ClusterSecretStoreV1Beta1SpecProviderOnboardbase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiHost': obj.apiHost,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth(obj.auth),
    'environment': obj.environment,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(obj: ClusterSecretStoreV1Beta1SpecProviderOnepassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(obj.auth),
    'connectHost': obj.connectHost,
    'vaults': ((obj.vaults) === undefined) ? undefined : (Object.entries(obj.vaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracle
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault.
   * If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID.
   * Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault.
   * Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will
   * determine the principal type. This optional field must be specified if using
   * workload identity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(obj: ClusterSecretStoreV1Beta1SpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassbolt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassbolt {
  /**
   * Auth defines the information necessary to authenticate against Passbolt Server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassbolt#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderPassboltAuth;

  /**
   * Host defines the Passbolt Server to connect to
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassbolt#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassbolt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassbolt(obj: ClusterSecretStoreV1Beta1SpecProviderPassbolt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configures a store to sync secrets with a Password Depot instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepot
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassworddepot {
  /**
   * Auth configures how secret-manager authenticates with a Password Depot instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepot#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth;

  /**
   * Database to use as source
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepot#database
   */
  readonly database: string;

  /**
   * URL configures the Password Depot instance URL.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepot#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassworddepot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepot(obj: ClusterSecretStoreV1Beta1SpecProviderPassworddepot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth(obj.auth),
    'database': obj.database,
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Previder configures this store to sync secrets using the Previder provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPrevider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPrevider {
  /**
   * PreviderAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPrevider#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderPreviderAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderPrevider#baseUri
   */
  readonly baseUri?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPrevider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPrevider(obj: ClusterSecretStoreV1Beta1SpecProviderPrevider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuth(obj.auth),
    'baseUri': obj.baseUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pulumi configures this store to sync secrets using the Pulumi provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPulumi {
  /**
   * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi#accessToken
   */
  readonly accessToken: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken;

  /**
   * APIURL is the URL of the Pulumi API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Environment are YAML documents composed of static key-value pairs, programmatic expressions,
   * dynamically retrieved values from supported providers including all major clouds,
   * and other Pulumi ESC environments.
   * To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi#environment
   */
  readonly environment: string;

  /**
   * Organization are a space to collaborate on shared projects and stacks.
   * To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi#organization
   */
  readonly organization: string;

  /**
   * Project is the name of the Pulumi ESC project the environment belongs to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumi#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPulumi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPulumi(obj: ClusterSecretStoreV1Beta1SpecProviderPulumi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken(obj.accessToken),
    'apiUrl': obj.apiUrl,
    'environment': obj.environment,
    'organization': obj.organization,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scaleway
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#accessKey
   */
  readonly accessKey: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#secretKey
   */
  readonly secretKey: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(obj: ClusterSecretStoreV1Beta1SpecProviderScaleway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(obj.accessKey),
    'apiUrl': obj.apiUrl,
    'projectId': obj.projectId,
    'region': obj.region,
    'secretKey': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretServer configures this store to sync secrets using SecretServer provider
 * https://docs.delinea.com/online-help/secret-server/start.htm
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserver
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSecretserver {
  /**
   * Password is the secret server account password.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserver#password
   */
  readonly password: ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword;

  /**
   * ServerURL
   * URL to your secret server installation
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserver#serverURL
   */
  readonly serverUrl: string;

  /**
   * Username is the secret server account username.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserver#username
   */
  readonly username: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSecretserver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserver(obj: ClusterSecretStoreV1Beta1SpecProviderSecretserver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword(obj.password),
    'serverURL': obj.serverUrl,
    'username': toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(obj: ClusterSecretStoreV1Beta1SpecProviderSenhasegura | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj.auth),
    'ignoreSslCertificate': obj.ignoreSslCertificate,
    'module': obj.module,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVault
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault
   * leader instead of simply retrying within a loop. This can increase performance if
   * the option is enabled serverside.
   * https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Headers to be added in Vault request
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g:
   * "secret". The v2 KV secret engine version specific "/data" path suffix
   * for fetching secrets from Vault is optional and will be appended
   * if not present in specified path.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by
   * providing discovered cluster replication states in each request.
   * More information about eventual consistency in Vault can be found here
   * https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#server
   */
  readonly server: string;

  /**
   * The configuration used for client side related TLS communication, when the Vault server
   * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
   * This parameter is ignored for plain HTTP protocol connection.
   * It's worth noting this configuration is different from the "TLS certificates auth method",
   * which is available under the `auth.cert` section.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#tls
   */
  readonly tls?: ClusterSecretStoreV1Beta1SpecProviderVaultTls;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or
   * "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreV1Beta1SpecProviderVaultVersion;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVault(obj: ClusterSecretStoreV1Beta1SpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'tls': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTls(obj.tls),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhook {
  /**
   * Auth specifies a authorization protocol. Only one protocol may be set.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderWebhookAuth;

  /**
   * Body
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreV1Beta1SpecProviderWebhookResult;

  /**
   * Secrets to fill in templates
   * These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(obj: ClusterSecretStoreV1Beta1SpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuth(obj.auth),
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(obj: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount
   * token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details
   * to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS
 * if not set aws sdk will infer credentials from your environment
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials
   * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You
   * can't use both this parameter and RecoveryWindowInDays in the same call.
   * If you don't use either, then by default Secrets Manager uses a 30 day
   * recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before
   * permanently deleting the secret. You can't use both this parameter and
   * ForceDeleteWithoutRecovery in the same call. If you don't use either,
   * then by default Secrets Manager uses a 30 day recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(obj: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsService
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(obj: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure ClientCertificate of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientCertificate
   */
  readonly clientCertificate?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate;

  /**
   * The Azure clientId of the service principle or managed identity used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret;

  /**
   * The Azure tenantId of the managed identity used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#tenantId
   */
  readonly tenantId?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(obj.clientCertificate),
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
    'tenantId': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(obj.tenantId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service.
 * Valid values are:
 * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
 * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for
 * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
 * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
 * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Beyondtrust.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth {
  /**
   * APIKey If not provided then ClientID/ClientSecret become required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#apiKey
   */
  readonly apiKey?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey;

  /**
   * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificate
   */
  readonly certificate?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate;

  /**
   * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificateKey
   */
  readonly certificateKey?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey;

  /**
   * ClientID is the API OAuth Client ID.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientId
   */
  readonly clientId?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId;

  /**
   * ClientSecret is the API OAuth Client Secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(obj.apiKey),
    'certificate': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(obj.certificate),
    'certificateKey': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(obj.certificateKey),
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how API server works.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#apiUrl
   */
  readonly apiUrl: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
   *
   * @default 45 seconds.
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#clientTimeOutSeconds
   */
  readonly clientTimeOutSeconds?: number;

  /**
   * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#retrievalType
   */
  readonly retrievalType?: string;

  /**
   * A character that separates the folder names.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#separator
   */
  readonly separator?: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#verifyCA
   */
  readonly verifyCa: boolean;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiUrl': obj.apiUrl,
    'apiVersion': obj.apiVersion,
    'clientTimeOutSeconds': obj.clientTimeOutSeconds,
    'retrievalType': obj.retrievalType,
    'separator': obj.separator,
    'verifyCA': obj.verifyCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
 * Make sure that the token being used has permissions on the given secret.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth {
  /**
   * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against chef Server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderChefAuth {
  /**
   * ChefAuthSecretRef holds secret references for chef server login credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderChefAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuth(obj: ClusterSecretStoreV1Beta1SpecProviderChefAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth {
  /**
   * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth(obj: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines authentication settings for connecting to Conjur.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuth {
  /**
   * Authenticates with Conjur using an API key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#apikey
   */
  readonly apikey?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey;

  /**
   * Jwt enables JWT authentication using Kubernetes service account tokens.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apikey': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(obj.apikey),
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates
 * for a secret store. The CAProvider points to a Secret or ConfigMap resource
 * that contains a PEM-encoded certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Device42 instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42Auth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDevice42Auth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42Auth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDevice42Auth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42Auth(obj: ClusterSecretStoreV1Beta1SpecProviderDevice42Auth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerFormat
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#value
   */
  readonly value: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(obj: ClusterSecretStoreV1Beta1SpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey is the API token to access SDKMS Applications.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey {
  /**
   * SecretRef is a reference to a secret containing the SDKMS API Key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey(obj: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * auth configures how secret-manager authenticates with a Github instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGithubAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuth#privateKey
   */
  readonly privateKey: ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGithubAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGithubAuth(obj: ClusterSecretStoreV1Beta1SpecProviderGithubAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKey': toJson_ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey(obj.privateKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderGitlabCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerAuth': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj.containerAuth),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Infisical API
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth#universalAuthCredentials
   */
  readonly universalAuthCredentials?: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth(obj: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'universalAuthCredentials': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(obj.universalAuthCredentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsScope defines the scope of the secrets within the workspace
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope {
  /**
   * EnvironmentSlug is the required slug identifier for the environment.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#environmentSlug
   */
  readonly environmentSlug: string;

  /**
   * ExpandSecretReferences indicates whether secret references should be expanded. Defaults to true if not provided.
   *
   * @default true if not provided.
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#expandSecretReferences
   */
  readonly expandSecretReferences?: boolean;

  /**
   * ProjectSlug is the required slug identifier for the project.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#projectSlug
   */
  readonly projectSlug: string;

  /**
   * Recursive indicates whether the secrets should be fetched recursively. Defaults to false if not provided.
   *
   * @default false if not provided.
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#recursive
   */
  readonly recursive?: boolean;

  /**
   * SecretsPath specifies the path to the secrets within the workspace. Defaults to "/" if not provided.
   *
   * @default if not provided.
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#secretsPath
   */
  readonly secretsPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope(obj: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environmentSlug': obj.environmentSlug,
    'expandSecretReferences': obj.expandSecretReferences,
    'projectSlug': obj.projectSlug,
    'recursive': obj.recursive,
    'secretsPath': obj.secretsPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a secret that contains the auth information.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Onboardbase API
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth {
  /**
   * OnboardbaseAPIKey is the APIKey generated by an admin account.
   * It is used to recognize and authorize access to a project and environment within onboardbase
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef;

  /**
   * OnboardbasePasscode is the passcode attached to the API Key
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth#passcodeRef
   */
  readonly passcodeRef: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth(obj: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(obj.apiKeyRef),
    'passcodeRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(obj.passcodeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault.
 * If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will
 * determine the principal type. This optional field must be specified if using
 * workload identity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Passbolt Server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassboltAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuth#passwordSecretRef
   */
  readonly passwordSecretRef: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuth#privateKeySecretRef
   */
  readonly privateKeySecretRef: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassboltAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuth(obj: ClusterSecretStoreV1Beta1SpecProviderPassboltAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(obj.passwordSecretRef),
    'privateKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Password Depot instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth(obj: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPreviderAuth {
  /**
   * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPreviderAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuth(obj: ClusterSecretStoreV1Beta1SpecProviderPreviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken {
  /**
   * SecretRef is a reference to a secret containing the Pulumi API token.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken(obj: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(obj: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(obj: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password is the secret server account password.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword(obj: ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username is the secret server account username.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername(obj: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism,
   * with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
   * Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
   * AWS IAM authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#iam
   */
  readonly iam?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the
   * JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount
   * token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using
   * the LDAP authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap;

  /**
   * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in.
   * Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   * This will default to Vault.Namespace field if set, or empty otherwise
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#namespace
   */
  readonly namespace?: string;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#userPass
   */
  readonly userPass?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(obj.cert),
    'iam': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(obj.iam),
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(obj.ldap),
    'namespace': obj.namespace,
    'tokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration used for client side related TLS communication, when the Vault server
 * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
 * This parameter is ignored for plain HTTP protocol connection.
 * It's worth noting this configuration is different from the "TLS certificates auth method",
 * which is available under the `auth.cert` section.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTls
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultTls {
  /**
   * CertSecretRef is a certificate added to the transport layer
   * when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTls#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef;

  /**
   * KeySecretRef to a key in a Secret resource containing client private key
   * added to the transport layer when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.key'.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTls#keySecretRef
   */
  readonly keySecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTls(obj: ClusterSecretStoreV1Beta1SpecProviderVaultTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(obj.certSecretRef),
    'keySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or
 * "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultVersion
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * Auth specifies a authorization protocol. Only one protocol may be set.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookAuth {
  /**
   * NTLMProtocol configures the store to use NTLM for auth
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuth#ntlm
   */
  readonly ntlm?: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuth(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ntlm': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm(obj.ntlm),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount
 * token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Akeyless. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Akeyless. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details
 * to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials
 * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientCertificate of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle or managed identity used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure tenantId of the managed identity used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey If not provided then ClientID/ClientSecret become required.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the API OAuth Client ID.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the API OAuth Client Secret.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
   * AccessToken used for the bitwarden instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
   */
  readonly credentials: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * ChefAuthSecretRef holds secret references for chef server login credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef {
  /**
   * SecretKey is the Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef#privateKeySecretRef
   */
  readonly privateKeySecretRef: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticates with Conjur using an API key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' containing the Conjur API key
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' containing the Conjur username
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'apiKeyRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj.apiKeyRef),
    'userRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj.userRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt enables JWT authentication using Kubernetes service account tokens.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional HostID for JWT authentication. This may be used depending
   * on how the Conjur JWT authenticator policy is configured.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#hostId
   */
  readonly hostId?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Conjur using the JWT authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'hostId': obj.hostId,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj.serviceAccountRef),
    'serviceID': obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef#credentials
   */
  readonly credentials?: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication.
   * See https://docs.doppler.com/reference/api#authentication for auth token types.
   * The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dopplerToken': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj.dopplerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the SDKMS API Key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * ClusterLocation is the location of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation?: string;

  /**
   * ClusterName is the name of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterProjectID is the project ID of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey(obj: ClusterSecretStoreV1Beta1SpecProviderGithubAuthPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderGitlabCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamEndpoint': obj.iamEndpoint,
    'profile': obj.profile,
    'tokenLocation': obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientId
   */
  readonly clientId: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(obj: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbaseAPIKey is the APIKey generated by an admin account.
 * It is used to recognize and authorize access to a project and environment within onboardbase
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbasePasscode is the passcode attached to the API Key
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj.connectTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef#credentials
   */
  readonly credentials?: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef {
  /**
   * The AccessToken is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef#accessToken
   */
  readonly accessToken: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the Pulumi API token.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism,
 * with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted
   * in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting
   * up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role id.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
 * Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault
   * authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to
   * authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
 * AWS IAM authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the
 * JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted
   * in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault
   * authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount
 * token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g:
   * "kubernetes"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a
   * Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Vault. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Vault. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using
 * the LDAP authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted
   * in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP
   * user used to authenticate with Vault using the LDAP authentication
   * method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is an LDAP username used to authenticate using the LDAP Vault
   * authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted
   * in Vault, e.g: "userpass"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the
   * user used to authenticate with Vault using the UserPass authentication
   * method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a username used to authenticate using the UserPass Vault
   * authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * CertSecretRef is a certificate added to the transport layer
 * when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySecretRef to a key in a Secret resource containing client private key
 * added to the transport layer when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.key'.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NTLMProtocol configures the store to use NTLM for auth
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm#passwordSecret
   */
  readonly passwordSecret: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm#usernameSecret
   */
  readonly usernameSecret: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret(obj.passwordSecret),
    'usernameSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret(obj.usernameSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Akeyless. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Akeyless. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken used for the bitwarden instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
 */
export interface ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur API key
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur username
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Conjur using the JWT authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(obj: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The DopplerToken is used for authentication.
 * See https://docs.doppler.com/reference/api#authentication for auth token types.
 * The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(obj: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessToken is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(obj: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role id.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault
 * authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to
 * authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service
   * account token for the service account referenced by `serviceAccountRef`.
   * Defaults to a single audience `vault` it not specified.
   * Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified.
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary
   * Kubernetes service account token for the service account referenced by
   * `serviceAccountRef`.
   * Deprecated: this will be removed in the future.
   * Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Vault. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Vault. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP
 * user used to authenticate with Vault using the LDAP authentication
 * method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the
 * user used to authenticate with Vault using the UserPass authentication
 * method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export class ExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretProps = {}): any {
    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretProps = {}) {
    super(scope, id, {
      ...ExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export interface ExternalSecretProps {
  /**
   * @schema ExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecret#spec
   */
  readonly spec?: ExternalSecretSpec;

}

/**
 * Converts an object of type 'ExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretProps(obj: ExternalSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretSpec
 */
export interface ExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretSpec#data
   */
  readonly data?: ExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data
   * If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider,
   * specified as Golang Duration strings.
   * Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h"
   * Example values: "1h", "2h30m", "10s"
   * May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * RefreshPolicy determines how the ExternalSecret should be refreshed:
   * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
   * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
   * No periodic updates occur if refreshInterval is 0.
   * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
   *
   * @schema ExternalSecretSpec#refreshPolicy
   */
  readonly refreshPolicy?: ExternalSecretSpecRefreshPolicy;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef?: ExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created
   * There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretSpec#target
   */
  readonly target?: ExternalSecretSpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpec(obj: ExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretSpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretSpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'refreshPolicy': obj.refreshPolicy,
    'secretStoreRef': toJson_ExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretSpecData
 */
export interface ExternalSecretSpecData {
  /**
   * RemoteRef points to the remote secret and defines
   * which secret (version/property/..) to fetch.
   *
   * @schema ExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretSpecDataRemoteRef;

  /**
   * The key in the Kubernetes Secret to store the value.
   *
   * @schema ExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source
   * from which the value will be pulled.
   *
   * @schema ExternalSecretSpecData#sourceRef
   */
  readonly sourceRef?: ExternalSecretSpecDataSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecData(obj: ExternalSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretSpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ExternalSecretSpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecDataFrom
 */
export interface ExternalSecretSpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret
   * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretSpecDataFrom#extract
   */
  readonly extract?: ExternalSecretSpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions
   * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretSpecDataFrom#find
   */
  readonly find?: ExternalSecretSpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider
   * Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ExternalSecretSpecDataFrom#rewrite
   */
  readonly rewrite?: ExternalSecretSpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator
   * which contains secret values ready to use.
   * Use this in combination with Extract or Find pull values out of
   * a specific SecretStore.
   * When sourceRef points to a generator Extract or Find is not supported.
   * The generator returns a static map of values
   *
   * @schema ExternalSecretSpecDataFrom#sourceRef
   */
  readonly sourceRef?: ExternalSecretSpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFrom(obj: ExternalSecretSpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ExternalSecretSpecDataFromExtract(obj.extract),
    'find': toJson_ExternalSecretSpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ExternalSecretSpecDataFromRewrite(y)),
    'sourceRef': toJson_ExternalSecretSpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RefreshPolicy determines how the ExternalSecret should be refreshed:
 * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
 * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
 * No periodic updates occur if refreshInterval is 0.
 * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
 *
 * @schema ExternalSecretSpecRefreshPolicy
 */
export enum ExternalSecretSpecRefreshPolicy {
  /** CreatedOnce */
  CREATED_ONCE = "CreatedOnce",
  /** Periodic */
  PERIODIC = "Periodic",
  /** OnChange */
  ON_CHANGE = "OnChange",
}

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecSecretStoreRef
 */
export interface ExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: ExternalSecretSpecSecretStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecSecretStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecSecretStoreRef(obj: ExternalSecretSpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created
 * There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretSpecTarget
 */
export interface ExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret.
   * Defaults to "Owner"
   *
   * @default Owner"
   * @schema ExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretSpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret.
   * Defaults to "Retain"
   *
   * @default Retain"
   * @schema ExternalSecretSpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ExternalSecretSpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * The name of the Secret resource to be managed.
   * Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretSpecTarget#template
   */
  readonly template?: ExternalSecretSpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTarget(obj: ExternalSecretSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRef points to the remote secret and defines
 * which secret (version/property/..) to fetch.
 *
 * @schema ExternalSecretSpecDataRemoteRef
 */
export interface ExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretSpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretSpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretSpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretSpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataRemoteRef(obj: ExternalSecretSpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef allows you to override the source
 * from which the value will be pulled.
 *
 * @schema ExternalSecretSpecDataSourceRef
 */
export interface ExternalSecretSpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * Deprecated: The generatorRef is not implemented in .data[].
   * this will be removed with v1.
   *
   * @schema ExternalSecretSpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretSpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpecDataSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretSpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataSourceRef(obj: ExternalSecretSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretSpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretSpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to extract multiple key/value pairs from one secret
 * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretSpecDataFromExtract
 */
export interface ExternalSecretSpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretSpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretSpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretSpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretSpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromExtract(obj: ExternalSecretSpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to find secrets based on tags or regular expressions
 * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretSpecDataFromFind
 */
export interface ExternalSecretSpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretSpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretSpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ExternalSecretSpecDataFromFind#name
   */
  readonly name?: ExternalSecretSpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ExternalSecretSpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ExternalSecretSpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromFind(obj: ExternalSecretSpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ExternalSecretSpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecDataFromRewrite
 */
export interface ExternalSecretSpecDataFromRewrite {
  /**
   * Used to merge key/values in one single Secret
   * The resulting key will contain all values from the specified secrets
   *
   * @schema ExternalSecretSpecDataFromRewrite#merge
   */
  readonly merge?: ExternalSecretSpecDataFromRewriteMerge;

  /**
   * Used to rewrite with regular expressions.
   * The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ExternalSecretSpecDataFromRewrite#regexp
   */
  readonly regexp?: ExternalSecretSpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets.
   * The resulting key will be the output of the template applied by the operation.
   *
   * @schema ExternalSecretSpecDataFromRewrite#transform
   */
  readonly transform?: ExternalSecretSpecDataFromRewriteTransform;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromRewrite(obj: ExternalSecretSpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'merge': toJson_ExternalSecretSpecDataFromRewriteMerge(obj.merge),
    'regexp': toJson_ExternalSecretSpecDataFromRewriteRegexp(obj.regexp),
    'transform': toJson_ExternalSecretSpecDataFromRewriteTransform(obj.transform),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef points to a store or generator
 * which contains secret values ready to use.
 * Use this in combination with Extract or Find pull values out of
 * a specific SecretStore.
 * When sourceRef points to a generator Extract or Find is not supported.
 * The generator returns a static map of values
 *
 * @schema ExternalSecretSpecDataFromSourceRef
 */
export interface ExternalSecretSpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ExternalSecretSpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretSpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretSpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromSourceRef(obj: ExternalSecretSpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretSpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretSpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretSpecSecretStoreRefKind
 */
export enum ExternalSecretSpecSecretStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret.
 * Defaults to "Owner"
 *
 * @default Owner"
 * @schema ExternalSecretSpecTargetCreationPolicy
 */
export enum ExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret.
 * Defaults to "Retain"
 *
 * @default Retain"
 * @schema ExternalSecretSpecTargetDeletionPolicy
 */
export enum ExternalSecretSpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretSpecTargetTemplate
 */
export interface ExternalSecretSpecTargetTemplate {
  /**
   * @schema ExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * @schema ExternalSecretSpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ExternalSecretSpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplate(obj: ExternalSecretSpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretSpecDataRemoteRefDecodingStrategy
 */
export enum ExternalSecretSpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretSpecDataRemoteRefMetadataPolicy
 */
export enum ExternalSecretSpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 *
 * Deprecated: The generatorRef is not implemented in .data[].
 * this will be removed with v1.
 *
 * @schema ExternalSecretSpecDataSourceRefGeneratorRef
 */
export interface ExternalSecretSpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretSpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ExternalSecretSpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: ExternalSecretSpecDataSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretSpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataSourceRefGeneratorRef(obj: ExternalSecretSpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecDataSourceRefStoreRef
 */
export interface ExternalSecretSpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecDataSourceRefStoreRef#kind
   */
  readonly kind?: ExternalSecretSpecDataSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecDataSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataSourceRefStoreRef(obj: ExternalSecretSpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataFromExtractConversionStrategy
 */
export enum ExternalSecretSpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretSpecDataFromExtractDecodingStrategy
 */
export enum ExternalSecretSpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretSpecDataFromExtractMetadataPolicy
 */
export enum ExternalSecretSpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataFromFindConversionStrategy
 */
export enum ExternalSecretSpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretSpecDataFromFindDecodingStrategy
 */
export enum ExternalSecretSpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ExternalSecretSpecDataFromFindName
 */
export interface ExternalSecretSpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ExternalSecretSpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromFindName(obj: ExternalSecretSpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to merge key/values in one single Secret
 * The resulting key will contain all values from the specified secrets
 *
 * @schema ExternalSecretSpecDataFromRewriteMerge
 */
export interface ExternalSecretSpecDataFromRewriteMerge {
  /**
   * Used to define the policy to use in conflict resolution.
   *
   * @schema ExternalSecretSpecDataFromRewriteMerge#conflictPolicy
   */
  readonly conflictPolicy?: string;

  /**
   * Used to define the target key of the merge operation.
   * Required if strategy is JSON. Ignored otherwise.
   *
   * @schema ExternalSecretSpecDataFromRewriteMerge#into
   */
  readonly into?: string;

  /**
   * Used to define key priority in conflict resolution.
   *
   * @schema ExternalSecretSpecDataFromRewriteMerge#priority
   */
  readonly priority?: string[];

  /**
   * Used to define the strategy to use in the merge operation.
   *
   * @schema ExternalSecretSpecDataFromRewriteMerge#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromRewriteMerge' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromRewriteMerge(obj: ExternalSecretSpecDataFromRewriteMerge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conflictPolicy': obj.conflictPolicy,
    'into': obj.into,
    'priority': obj.priority?.map(y => y),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to rewrite with regular expressions.
 * The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ExternalSecretSpecDataFromRewriteRegexp
 */
export interface ExternalSecretSpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ExternalSecretSpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ExternalSecretSpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromRewriteRegexp(obj: ExternalSecretSpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to apply string transformation on the secrets.
 * The resulting key will be the output of the template applied by the operation.
 *
 * @schema ExternalSecretSpecDataFromRewriteTransform
 */
export interface ExternalSecretSpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name.
   * `.value ` will specify the secret name in the template.
   *
   * @schema ExternalSecretSpecDataFromRewriteTransform#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromRewriteTransform(obj: ExternalSecretSpecDataFromRewriteTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ExternalSecretSpecDataFromSourceRefGeneratorRef
 */
export interface ExternalSecretSpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretSpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ExternalSecretSpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: ExternalSecretSpecDataFromSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretSpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromSourceRefGeneratorRef(obj: ExternalSecretSpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecDataFromSourceRefStoreRef
 */
export interface ExternalSecretSpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: ExternalSecretSpecDataFromSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecDataFromSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFromSourceRefStoreRef(obj: ExternalSecretSpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ExternalSecretSpecTargetTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ExternalSecretSpecTargetTemplateMergePolicy
 */
export enum ExternalSecretSpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretSpecTargetTemplateMetadata
 */
export interface ExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateMetadata(obj: ExternalSecretSpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretSpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ExternalSecretSpecTargetTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFrom(obj: ExternalSecretSpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema ExternalSecretSpecDataSourceRefGeneratorRefKind
 */
export enum ExternalSecretSpecDataSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretSpecDataSourceRefStoreRefKind
 */
export enum ExternalSecretSpecDataSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Specify the Kind of the generator resource
 *
 * @schema ExternalSecretSpecDataFromSourceRefGeneratorRefKind
 */
export enum ExternalSecretSpecDataFromSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretSpecDataFromSourceRefStoreRefKind
 */
export enum ExternalSecretSpecDataFromSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj: ExternalSecretSpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromTarget
 */
export enum ExternalSecretSpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export class ExternalSecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretV1Beta1Props = {}): any {
    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ExternalSecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretV1Beta1Props = {}) {
    super(scope, id, {
      ...ExternalSecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export interface ExternalSecretV1Beta1Props {
  /**
   * @schema ExternalSecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1#spec
   */
  readonly spec?: ExternalSecretV1Beta1Spec;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1Props(obj: ExternalSecretV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1Spec
 */
export interface ExternalSecretV1Beta1Spec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretV1Beta1Spec#data
   */
  readonly data?: ExternalSecretV1Beta1SpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data
   * If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretV1Beta1Spec#dataFrom
   */
  readonly dataFrom?: ExternalSecretV1Beta1SpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider,
   * specified as Golang Duration strings.
   * Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h"
   * Example values: "1h", "2h30m", "10s"
   * May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * RefreshPolicy determines how the ExternalSecret should be refreshed:
   * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
   * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
   * No periodic updates occur if refreshInterval is 0.
   * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
   *
   * @schema ExternalSecretV1Beta1Spec#refreshPolicy
   */
  readonly refreshPolicy?: ExternalSecretV1Beta1SpecRefreshPolicy;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1Spec#secretStoreRef
   */
  readonly secretStoreRef?: ExternalSecretV1Beta1SpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created
   * There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1Spec#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1Spec(obj: ExternalSecretV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretV1Beta1SpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretV1Beta1SpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'refreshPolicy': obj.refreshPolicy,
    'secretStoreRef': toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretV1Beta1SpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretV1Beta1SpecData
 */
export interface ExternalSecretV1Beta1SpecData {
  /**
   * RemoteRef points to the remote secret and defines
   * which secret (version/property/..) to fetch.
   *
   * @schema ExternalSecretV1Beta1SpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretV1Beta1SpecDataRemoteRef;

  /**
   * The key in the Kubernetes Secret to store the value.
   *
   * @schema ExternalSecretV1Beta1SpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source
   * from which the value will be pulled.
   *
   * @schema ExternalSecretV1Beta1SpecData#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecData(obj: ExternalSecretV1Beta1SpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFrom
 */
export interface ExternalSecretV1Beta1SpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret
   * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#extract
   */
  readonly extract?: ExternalSecretV1Beta1SpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions
   * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#find
   */
  readonly find?: ExternalSecretV1Beta1SpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider
   * Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#rewrite
   */
  readonly rewrite?: ExternalSecretV1Beta1SpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator
   * which contains secret values ready to use.
   * Use this in combination with Extract or Find pull values out of
   * a specific SecretStore.
   * When sourceRef points to a generator Extract or Find is not supported.
   * The generator returns a static map of values
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFrom(obj: ExternalSecretV1Beta1SpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj.extract),
    'find': toJson_ExternalSecretV1Beta1SpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ExternalSecretV1Beta1SpecDataFromRewrite(y)),
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RefreshPolicy determines how the ExternalSecret should be refreshed:
 * - CreatedOnce: Creates the Secret only if it does not exist and does not update it thereafter
 * - Periodic: Synchronizes the Secret from the external source at regular intervals specified by refreshInterval.
 * No periodic updates occur if refreshInterval is 0.
 * - OnChange: Only synchronizes the Secret when the ExternalSecret's metadata or specification changes
 *
 * @schema ExternalSecretV1Beta1SpecRefreshPolicy
 */
export enum ExternalSecretV1Beta1SpecRefreshPolicy {
  /** CreatedOnce */
  CREATED_ONCE = "CreatedOnce",
  /** Periodic */
  PERIODIC = "Periodic",
  /** OnChange */
  ON_CHANGE = "OnChange",
}

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecSecretStoreRef
 */
export interface ExternalSecretV1Beta1SpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#kind
   */
  readonly kind?: ExternalSecretV1Beta1SpecSecretStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj: ExternalSecretV1Beta1SpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created
 * There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1SpecTarget
 */
export interface ExternalSecretV1Beta1SpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret.
   * Defaults to "Owner"
   *
   * @default Owner"
   * @schema ExternalSecretV1Beta1SpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretV1Beta1SpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret.
   * Defaults to "Retain"
   *
   * @default Retain"
   * @schema ExternalSecretV1Beta1SpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ExternalSecretV1Beta1SpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretV1Beta1SpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * The name of the Secret resource to be managed.
   * Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretV1Beta1SpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretV1Beta1SpecTarget#template
   */
  readonly template?: ExternalSecretV1Beta1SpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTarget(obj: ExternalSecretV1Beta1SpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRef points to the remote secret and defines
 * which secret (version/property/..) to fetch.
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRef
 */
export interface ExternalSecretV1Beta1SpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj: ExternalSecretV1Beta1SpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef allows you to override the source
 * from which the value will be pulled.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * Deprecated: The generatorRef is not implemented in .data[].
   * this will be removed with v1.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj: ExternalSecretV1Beta1SpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to extract multiple key/value pairs from one secret
 * Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtract
 */
export interface ExternalSecretV1Beta1SpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj: ExternalSecretV1Beta1SpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to find secrets based on tags or regular expressions
 * Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFind
 */
export interface ExternalSecretV1Beta1SpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#name
   */
  readonly name?: ExternalSecretV1Beta1SpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFind(obj: ExternalSecretV1Beta1SpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFromRewrite
 */
export interface ExternalSecretV1Beta1SpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions.
   * The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#regexp
   */
  readonly regexp?: ExternalSecretV1Beta1SpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets.
   * The resulting key will be the output of the template applied by the operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#transform
   */
  readonly transform?: ExternalSecretV1Beta1SpecDataFromRewriteTransform;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewrite(obj: ExternalSecretV1Beta1SpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj.regexp),
    'transform': toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(obj.transform),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef points to a store or generator
 * which contains secret values ready to use.
 * Use this in combination with Extract or Find pull values out of
 * a specific SecretStore.
 * When sourceRef points to a generator Extract or Find is not supported.
 * The generator returns a static map of values
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretV1Beta1SpecSecretStoreRefKind
 */
export enum ExternalSecretV1Beta1SpecSecretStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret.
 * Defaults to "Owner"
 *
 * @default Owner"
 * @schema ExternalSecretV1Beta1SpecTargetCreationPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret.
 * Defaults to "Retain"
 *
 * @default Retain"
 * @schema ExternalSecretV1Beta1SpecTargetDeletionPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplate
 */
export interface ExternalSecretV1Beta1SpecTargetTemplate {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretV1Beta1SpecTargetTemplateEngineVersion;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ExternalSecretV1Beta1SpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretV1Beta1SpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj: ExternalSecretV1Beta1SpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 *
 * Deprecated: The generatorRef is not implemented in .data[].
 * this will be removed with v1.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#kind
   */
  readonly kind?: ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindName
 */
export interface ExternalSecretV1Beta1SpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj: ExternalSecretV1Beta1SpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to rewrite with regular expressions.
 * The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj: ExternalSecretV1Beta1SpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to apply string transformation on the secrets.
 * The resulting key will be the output of the template applied by the operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name.
   * `.value ` will specify the secret name in the template.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(obj: ExternalSecretV1Beta1SpecDataFromRewriteTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   * Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateEngineVersion
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMergePolicy
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj: ExternalSecretV1Beta1SpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind
 */
export enum ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind
 */
export enum ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Specify the Kind of the generator resource
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind
 */
export enum ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
}

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 * Defaults to `SecretStore`
 *
 * @default SecretStore`
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind
 */
export enum ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 *
 *
 * @schema PushSecret
 */
export class PushSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PushSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1alpha1',
    kind: 'PushSecret',
  }

  /**
   * Renders a Kubernetes manifest for "PushSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PushSecretProps = {}): any {
    return {
      ...PushSecret.GVK,
      ...toJson_PushSecretProps(props),
    };
  }

  /**
   * Defines a "PushSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PushSecretProps = {}) {
    super(scope, id, {
      ...PushSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PushSecret.GVK,
      ...toJson_PushSecretProps(resolved),
    };
  }
}

/**
 * @schema PushSecret
 */
export interface PushSecretProps {
  /**
   * @schema PushSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PushSecretSpec configures the behavior of the PushSecret.
   *
   * @schema PushSecret#spec
   */
  readonly spec?: PushSecretSpec;

}

/**
 * Converts an object of type 'PushSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretProps(obj: PushSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PushSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PushSecretSpec configures the behavior of the PushSecret.
 *
 * @schema PushSecretSpec
 */
export interface PushSecretSpec {
  /**
   * Secret Data that should be pushed to providers
   *
   * @schema PushSecretSpec#data
   */
  readonly data?: PushSecretSpecData[];

  /**
   * Deletion Policy to handle Secrets in the provider.
   *
   * @schema PushSecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: PushSecretSpecDeletionPolicy;

  /**
   * The Interval to which External Secrets will try to push a secret definition
   *
   * @schema PushSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * @schema PushSecretSpec#secretStoreRefs
   */
  readonly secretStoreRefs: PushSecretSpecSecretStoreRefs[];

  /**
   * The Secret Selector (k8s source) for the Push Secret
   *
   * @schema PushSecretSpec#selector
   */
  readonly selector: PushSecretSpecSelector;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema PushSecretSpec#template
   */
  readonly template?: PushSecretSpecTemplate;

  /**
   * UpdatePolicy to handle Secrets in the provider.
   *
   * @schema PushSecretSpec#updatePolicy
   */
  readonly updatePolicy?: PushSecretSpecUpdatePolicy;

}

/**
 * Converts an object of type 'PushSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpec(obj: PushSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_PushSecretSpecData(y)),
    'deletionPolicy': obj.deletionPolicy,
    'refreshInterval': obj.refreshInterval,
    'secretStoreRefs': obj.secretStoreRefs?.map(y => toJson_PushSecretSpecSecretStoreRefs(y)),
    'selector': toJson_PushSecretSpecSelector(obj.selector),
    'template': toJson_PushSecretSpecTemplate(obj.template),
    'updatePolicy': obj.updatePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecData
 */
export interface PushSecretSpecData {
  /**
   * Used to define a conversion Strategy for the secret keys
   *
   * @schema PushSecretSpecData#conversionStrategy
   */
  readonly conversionStrategy?: PushSecretSpecDataConversionStrategy;

  /**
   * Match a given Secret Key to be pushed to the provider.
   *
   * @schema PushSecretSpecData#match
   */
  readonly match: PushSecretSpecDataMatch;

  /**
   * Metadata is metadata attached to the secret.
   * The structure of metadata is provider specific, please look it up in the provider documentation.
   *
   * @schema PushSecretSpecData#metadata
   */
  readonly metadata?: any;

}

/**
 * Converts an object of type 'PushSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecData(obj: PushSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'match': toJson_PushSecretSpecDataMatch(obj.match),
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deletion Policy to handle Secrets in the provider.
 *
 * @schema PushSecretSpecDeletionPolicy
 */
export enum PushSecretSpecDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** None */
  NONE = "None",
}

/**
 * @schema PushSecretSpecSecretStoreRefs
 */
export interface PushSecretSpecSecretStoreRefs {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
   *
   * @schema PushSecretSpecSecretStoreRefs#kind
   */
  readonly kind?: PushSecretSpecSecretStoreRefsKind;

  /**
   * Optionally, sync to secret stores with label selector
   *
   * @schema PushSecretSpecSecretStoreRefs#labelSelector
   */
  readonly labelSelector?: PushSecretSpecSecretStoreRefsLabelSelector;

  /**
   * Optionally, sync to the SecretStore of the given name
   *
   * @schema PushSecretSpecSecretStoreRefs#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSecretStoreRefs(obj: PushSecretSpecSecretStoreRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'labelSelector': toJson_PushSecretSpecSecretStoreRefsLabelSelector(obj.labelSelector),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret Selector (k8s source) for the Push Secret
 *
 * @schema PushSecretSpecSelector
 */
export interface PushSecretSpecSelector {
  /**
   * Point to a generator to create a Secret.
   *
   * @schema PushSecretSpecSelector#generatorRef
   */
  readonly generatorRef?: PushSecretSpecSelectorGeneratorRef;

  /**
   * Select a Secret to Push.
   *
   * @schema PushSecretSpecSelector#secret
   */
  readonly secret?: PushSecretSpecSelectorSecret;

}

/**
 * Converts an object of type 'PushSecretSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSelector(obj: PushSecretSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_PushSecretSpecSelectorGeneratorRef(obj.generatorRef),
    'secret': toJson_PushSecretSpecSelectorSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema PushSecretSpecTemplate
 */
export interface PushSecretSpecTemplate {
  /**
   * @schema PushSecretSpecTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version
   * that should be used to compile/execute the
   * template specified in .data and .templateFrom[].
   *
   * @schema PushSecretSpecTemplate#engineVersion
   */
  readonly engineVersion?: PushSecretSpecTemplateEngineVersion;

  /**
   * @schema PushSecretSpecTemplate#mergePolicy
   */
  readonly mergePolicy?: PushSecretSpecTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema PushSecretSpecTemplate#metadata
   */
  readonly metadata?: PushSecretSpecTemplateMetadata;

  /**
   * @schema PushSecretSpecTemplate#templateFrom
   */
  readonly templateFrom?: PushSecretSpecTemplateTemplateFrom[];

  /**
   * @schema PushSecretSpecTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PushSecretSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplate(obj: PushSecretSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_PushSecretSpecTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_PushSecretSpecTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdatePolicy to handle Secrets in the provider.
 *
 * @schema PushSecretSpecUpdatePolicy
 */
export enum PushSecretSpecUpdatePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** IfNotExists */
  IF_NOT_EXISTS = "IfNotExists",
}

/**
 * Used to define a conversion Strategy for the secret keys
 *
 * @schema PushSecretSpecDataConversionStrategy
 */
export enum PushSecretSpecDataConversionStrategy {
  /** None */
  NONE = "None",
  /** ReverseUnicode */
  REVERSE_UNICODE = "ReverseUnicode",
}

/**
 * Match a given Secret Key to be pushed to the provider.
 *
 * @schema PushSecretSpecDataMatch
 */
export interface PushSecretSpecDataMatch {
  /**
   * Remote Refs to push to providers.
   *
   * @schema PushSecretSpecDataMatch#remoteRef
   */
  readonly remoteRef: PushSecretSpecDataMatchRemoteRef;

  /**
   * Secret Key to be pushed
   *
   * @schema PushSecretSpecDataMatch#secretKey
   */
  readonly secretKey?: string;

}

/**
 * Converts an object of type 'PushSecretSpecDataMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecDataMatch(obj: PushSecretSpecDataMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_PushSecretSpecDataMatchRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the SecretStore resource (SecretStore or ClusterSecretStore)
 *
 * @schema PushSecretSpecSecretStoreRefsKind
 */
export enum PushSecretSpecSecretStoreRefsKind {
  /** SecretStore */
  SECRET_STORE = "SecretStore",
  /** ClusterSecretStore */
  CLUSTER_SECRET_STORE = "ClusterSecretStore",
}

/**
 * Optionally, sync to secret stores with label selector
 *
 * @schema PushSecretSpecSecretStoreRefsLabelSelector
 */
export interface PushSecretSpecSecretStoreRefsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSecretStoreRefsLabelSelector(obj: PushSecretSpecSecretStoreRefsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Point to a generator to create a Secret.
 *
 * @schema PushSecretSpecSelectorGeneratorRef
 */
export interface PushSecretSpecSelectorGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema PushSecretSpecSelectorGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the generator resource
   *
   * @schema PushSecretSpecSelectorGeneratorRef#kind
   */
  readonly kind: PushSecretSpecSelectorGeneratorRefKind;

  /**
   * Specify the name of the generator resource
   *
   * @schema PushSecretSpecSelectorGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PushSecretSpecSelectorGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSelectorGeneratorRef(obj: PushSecretSpecSelectorGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select a Secret to Push.
 *
 * @schema PushSecretSpecSelectorSecret
 */
export interface PushSecretSpecSelectorSecret {
  /**
   * Name of the Secret.
   * The Secret must exist in the same namespace as the PushSecret manifest.
   *
   * @schema PushSecretSpecSelectorSecret#name
   */
  readonly name?: string;

  /**
   * Selector chooses secrets using a labelSelector.
   *
   * @schema PushSecretSpecSelectorSecret#selector
   */
  readonly selector?: PushSecretSpecSelectorSecretSelector;

}

/**
 * Converts an object of type 'PushSecretSpecSelectorSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSelectorSecret(obj: PushSecretSpecSelectorSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_PushSecretSpecSelectorSecretSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version
 * that should be used to compile/execute the
 * template specified in .data and .templateFrom[].
 *
 * @schema PushSecretSpecTemplateEngineVersion
 */
export enum PushSecretSpecTemplateEngineVersion {
  /** v2 */
  V2 = "v2",
}

/**
 * @schema PushSecretSpecTemplateMergePolicy
 */
export enum PushSecretSpecTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema PushSecretSpecTemplateMetadata
 */
export interface PushSecretSpecTemplateMetadata {
  /**
   * @schema PushSecretSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema PushSecretSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PushSecretSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateMetadata(obj: PushSecretSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFrom
 */
export interface PushSecretSpecTemplateTemplateFrom {
  /**
   * @schema PushSecretSpecTemplateTemplateFrom#configMap
   */
  readonly configMap?: PushSecretSpecTemplateTemplateFromConfigMap;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#secret
   */
  readonly secret?: PushSecretSpecTemplateTemplateFromSecret;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#target
   */
  readonly target?: PushSecretSpecTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateTemplateFrom(obj: PushSecretSpecTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PushSecretSpecTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_PushSecretSpecTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Remote Refs to push to providers.
 *
 * @schema PushSecretSpecDataMatchRemoteRef
 */
export interface PushSecretSpecDataMatchRemoteRef {
  /**
   * Name of the property in the resulting secret
   *
   * @schema PushSecretSpecDataMatchRemoteRef#property
   */
  readonly property?: string;

  /**
   * Name of the resulting provider secret.
   *
   * @schema PushSecretSpecDataMatchRemoteRef#remoteKey
   */
  readonly remoteKey: string;

}

/**
 * Converts an object of type 'PushSecretSpecDataMatchRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecDataMatchRemoteRef(obj: PushSecretSpecDataMatchRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'property': obj.property,
    'remoteKey': obj.remoteKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions
 */
export interface PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(obj: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify the Kind of the generator resource
 *
 * @schema PushSecretSpecSelectorGeneratorRefKind
 */
export enum PushSecretSpecSelectorGeneratorRefKind {
  /** ACRAccessToken */
  ACR_ACCESS_TOKEN = "ACRAccessToken",
  /** ClusterGenerator */
  CLUSTER_GENERATOR = "ClusterGenerator",
  /** ECRAuthorizationToken */
  ECR_AUTHORIZATION_TOKEN = "ECRAuthorizationToken",
  /** Fake */
  FAKE = "Fake",
  /** GCRAccessToken */
  GCR_ACCESS_TOKEN = "GCRAccessToken",
  /** GithubAccessToken */
  GITHUB_ACCESS_TOKEN = "GithubAccessToken",
  /** QuayAccessToken */
  QUAY_ACCESS_TOKEN = "QuayAccessToken",
  /** Password */
  PASSWORD = "Password",
  /** STSSessionToken */
  STS_SESSION_TOKEN = "STSSessionToken",
  /** UUID */
  UUID = "UUID",
  /** VaultDynamicSecret */
  VAULT_DYNAMIC_SECRET = "VaultDynamicSecret",
  /** Webhook */
  WEBHOOK = "Webhook",
  /** Grafana */
  GRAFANA = "Grafana",
  /** MFA */
  MFA = "MFA",
}

/**
 * Selector chooses secrets using a labelSelector.
 *
 * @schema PushSecretSpecSelectorSecretSelector
 */
export interface PushSecretSpecSelectorSecretSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PushSecretSpecSelectorSecretSelector#matchExpressions
   */
  readonly matchExpressions?: PushSecretSpecSelectorSecretSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PushSecretSpecSelectorSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PushSecretSpecSelectorSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSelectorSecretSelector(obj: PushSecretSpecSelectorSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PushSecretSpecSelectorSecretSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMap
 */
export interface PushSecretSpecTemplateTemplateFromConfigMap {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema PushSecretSpecTemplateTemplateFromConfigMap#items
   */
  readonly items: PushSecretSpecTemplateTemplateFromConfigMapItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema PushSecretSpecTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromConfigMap(obj: PushSecretSpecTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PushSecretSpecTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromSecret
 */
export interface PushSecretSpecTemplateTemplateFromSecret {
  /**
   * A list of keys in the ConfigMap/Secret to use as templates for Secret data
   *
   * @schema PushSecretSpecTemplateTemplateFromSecret#items
   */
  readonly items: PushSecretSpecTemplateTemplateFromSecretItems[];

  /**
   * The name of the ConfigMap/Secret resource
   *
   * @schema PushSecretSpecTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromSecret(obj: PushSecretSpecTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PushSecretSpecTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromTarget
 */
export enum PushSecretSpecTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PushSecretSpecSelectorSecretSelectorMatchExpressions
 */
export interface PushSecretSpecSelectorSecretSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PushSecretSpecSelectorSecretSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PushSecretSpecSelectorSecretSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PushSecretSpecSelectorSecretSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PushSecretSpecSelectorSecretSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecSelectorSecretSelectorMatchExpressions(obj: PushSecretSpecSelectorSecretSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMapItems
 */
export interface PushSecretSpecTemplateTemplateFromConfigMapItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema PushSecretSpecTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromConfigMapItems(obj: PushSecretSpecTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromSecretItems
 */
export interface PushSecretSpecTemplateTemplateFromSecretItems {
  /**
   * A key in the ConfigMap/Secret
   *
   * @schema PushSecretSpecTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromSecretItems(obj: PushSecretSpecTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs
 */
export enum PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}


/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStore
 */
export class SecretStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1',
    kind: 'SecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "SecretStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretStoreProps = {}): any {
    return {
      ...SecretStore.GVK,
      ...toJson_SecretStoreProps(props),
    };
  }

  /**
   * Defines a "SecretStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretStoreProps = {}) {
    super(scope, id, {
      ...SecretStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretStore.GVK,
      ...toJson_SecretStoreProps(resolved),
    };
  }
}

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStore
 */
export interface SecretStoreProps {
  /**
   * @schema SecretStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema SecretStore#spec
   */
  readonly spec?: SecretStoreSpec;

}

/**
 * Converts an object of type 'SecretStoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreProps(obj: SecretStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema SecretStoreSpec
 */
export interface SecretStoreSpec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema SecretStoreSpec#conditions
   */
  readonly conditions?: SecretStoreSpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName)
   * The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema SecretStoreSpec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema SecretStoreSpec#provider
   */
  readonly provider: SecretStoreSpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema SecretStoreSpec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema SecretStoreSpec#retrySettings
   */
  readonly retrySettings?: SecretStoreSpecRetrySettings;

}

/**
 * Converts an object of type 'SecretStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpec(obj: SecretStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_SecretStoreSpecConditions(y)),
    'controller': obj.controller,
    'provider': toJson_SecretStoreSpecProvider(obj.provider),
    'refreshInterval': obj.refreshInterval,
    'retrySettings': toJson_SecretStoreSpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in
 * for a ClusterSecretStore instance.
 *
 * @schema SecretStoreSpecConditions
 */
export interface SecretStoreSpecConditions {
  /**
   * Choose namespaces by using regex matching
   *
   * @schema SecretStoreSpecConditions#namespaceRegexes
   */
  readonly namespaceRegexes?: string[];

  /**
   * Choose namespace using a labelSelector
   *
   * @schema SecretStoreSpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: SecretStoreSpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema SecretStoreSpecConditions#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'SecretStoreSpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecConditions(obj: SecretStoreSpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceRegexes': obj.namespaceRegexes?.map(y => y),
    'namespaceSelector': toJson_SecretStoreSpecConditionsNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema SecretStoreSpecProvider
 */
export interface SecretStoreSpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema SecretStoreSpecProvider#akeyless
   */
  readonly akeyless?: SecretStoreSpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema SecretStoreSpecProvider#alibaba
   */
  readonly alibaba?: SecretStoreSpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema SecretStoreSpecProvider#aws
   */
  readonly aws?: SecretStoreSpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema SecretStoreSpecProvider#azurekv
   */
  readonly azurekv?: SecretStoreSpecProviderAzurekv;

  /**
   * Beyondtrust configures this store to sync secrets using Password Safe provider.
   *
   * @schema SecretStoreSpecProvider#beyondtrust
   */
  readonly beyondtrust?: SecretStoreSpecProviderBeyondtrust;

  /**
   * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
   *
   * @schema SecretStoreSpecProvider#bitwardensecretsmanager
   */
  readonly bitwardensecretsmanager?: SecretStoreSpecProviderBitwardensecretsmanager;

  /**
   * Chef configures this store to sync secrets with chef server
   *
   * @schema SecretStoreSpecProvider#chef
   */
  readonly chef?: SecretStoreSpecProviderChef;

  /**
   * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
   *
   * @schema SecretStoreSpecProvider#cloudrusm
   */
  readonly cloudrusm?: SecretStoreSpecProviderCloudrusm;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema SecretStoreSpecProvider#conjur
   */
  readonly conjur?: SecretStoreSpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault
   * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema SecretStoreSpecProvider#delinea
   */
  readonly delinea?: SecretStoreSpecProviderDelinea;

  /**
   * Device42 configures this store to sync secrets using the Device42 provider
   *
   * @schema SecretStoreSpecProvider#device42
   */
  readonly device42?: SecretStoreSpecProviderDevice42;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema SecretStoreSpecProvider#doppler
   */
  readonly doppler?: SecretStoreSpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema SecretStoreSpecProvider#fake
   */
  readonly fake?: SecretStoreSpecProviderFake;

  /**
   * Fortanix configures this store to sync secrets using the Fortanix provider
   *
   * @schema SecretStoreSpecProvider#fortanix
   */
  readonly fortanix?: SecretStoreSpecProviderFortanix;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema SecretStoreSpecProvider#gcpsm
   */
  readonly gcpsm?: SecretStoreSpecProviderGcpsm;

  /**
   * Github configures this store to push Github Action secrets using Github API provider
   *
   * @schema SecretStoreSpecProvider#github
   */
  readonly github?: SecretStoreSpecProviderGithub;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema SecretStoreSpecProvider#gitlab
   */
  readonly gitlab?: SecretStoreSpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema SecretStoreSpecProvider#ibm
   */
  readonly ibm?: SecretStoreSpecProviderIbm;

  /**
   * Infisical configures this store to sync secrets using the Infisical provider
   *
   * @schema SecretStoreSpecProvider#infisical
   */
  readonly infisical?: SecretStoreSpecProviderInfisical;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema SecretStoreSpecProvider#keepersecurity
   */
  readonly keepersecurity?: SecretStoreSpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema SecretStoreSpecProvider#kubernetes
   */
  readonly kubernetes?: SecretStoreSpecProviderKubernetes;

  /**
   * Onboardbase configures this store to sync secrets using the Onboardbase provider
   *
   * @schema SecretStoreSpecProvider#onboardbase
   */
  readonly onboardbase?: SecretStoreSpecProviderOnboardbase;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema SecretStoreSpecProvider#onepassword
   */
  readonly onepassword?: SecretStoreSpecProviderOnepassword;

  /**
   * OnePasswordSDK configures this store to use 1Password's new Go SDK to sync secrets.
   *
   * @schema SecretStoreSpecProvider#onepasswordSDK
   */
  readonly onepasswordSdk?: SecretStoreSpecProviderOnepasswordSdk;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema SecretStoreSpecProvider#oracle
   */
  readonly oracle?: SecretStoreSpecProviderOracle;

  /**
   * @schema SecretStoreSpecProvider#passbolt
   */
  readonly passbolt?: SecretStoreSpecProviderPassbolt;

  /**
   * Configures a store to sync secrets with a Password Depot instance.
   *
   * @schema SecretStoreSpecProvider#passworddepot
   */
  readonly passworddepot?: SecretStoreSpecProviderPassworddepot;

  /**
   * Previder configures this store to sync secrets using the Previder provider
   *
   * @schema SecretStoreSpecProvider#previder
   */
  readonly previder?: SecretStoreSpecProviderPrevider;

  /**
   * Pulumi configures this store to sync secrets using the Pulumi provider
   *
   * @schema SecretStoreSpecProvider#pulumi
   */
  readonly pulumi?: SecretStoreSpecProviderPulumi;

  /**
   * Scaleway
   *
   * @schema SecretStoreSpecProvider#scaleway
   */
  readonly scaleway?: SecretStoreSpecProviderScaleway;

  /**
   * SecretServer configures this store to sync secrets using SecretServer provider
   * https://docs.delinea.com/online-help/secret-server/start.htm
   *
   * @schema SecretStoreSpecProvider#secretserver
   */
  readonly secretserver?: SecretStoreSpecProviderSecretserver;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema SecretStoreSpecProvider#senhasegura
   */
  readonly senhasegura?: SecretStoreSpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema SecretStoreSpecProvider#vault
   */
  readonly vault?: SecretStoreSpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema SecretStoreSpecProvider#webhook
   */
  readonly webhook?: SecretStoreSpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema SecretStoreSpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: SecretStoreSpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema SecretStoreSpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: SecretStoreSpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'SecretStoreSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProvider(obj: SecretStoreSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_SecretStoreSpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_SecretStoreSpecProviderAlibaba(obj.alibaba),
    'aws': toJson_SecretStoreSpecProviderAws(obj.aws),
    'azurekv': toJson_SecretStoreSpecProviderAzurekv(obj.azurekv),
    'beyondtrust': toJson_SecretStoreSpecProviderBeyondtrust(obj.beyondtrust),
    'bitwardensecretsmanager': toJson_SecretStoreSpecProviderBitwardensecretsmanager(obj.bitwardensecretsmanager),
    'chef': toJson_SecretStoreSpecProviderChef(obj.chef),
    'cloudrusm': toJson_SecretStoreSpecProviderCloudrusm(obj.cloudrusm),
    'conjur': toJson_SecretStoreSpecProviderConjur(obj.conjur),
    'delinea': toJson_SecretStoreSpecProviderDelinea(obj.delinea),
    'device42': toJson_SecretStoreSpecProviderDevice42(obj.device42),
    'doppler': toJson_SecretStoreSpecProviderDoppler(obj.doppler),
    'fake': toJson_SecretStoreSpecProviderFake(obj.fake),
    'fortanix': toJson_SecretStoreSpecProviderFortanix(obj.fortanix),
    'gcpsm': toJson_SecretStoreSpecProviderGcpsm(obj.gcpsm),
    'github': toJson_SecretStoreSpecProviderGithub(obj.github),
    'gitlab': toJson_SecretStoreSpecProviderGitlab(obj.gitlab),
    'ibm': toJson_SecretStoreSpecProviderIbm(obj.ibm),
    'infisical': toJson_SecretStoreSpecProviderInfisical(obj.infisical),
    'keepersecurity': toJson_SecretStoreSpecProviderKeepersecurity(obj.keepersecurity),
    'kubernetes': toJson_SecretStoreSpecProviderKubernetes(obj.kubernetes),
    'onboardbase': toJson_SecretStoreSpecProviderOnboardbase(obj.onboardbase),
    'onepassword': toJson_SecretStoreSpecProviderOnepassword(obj.onepassword),
    'onepasswordSDK': toJson_SecretStoreSpecProviderOnepasswordSdk(obj.onepasswordSdk),
    'oracle': toJson_SecretStoreSpecProviderOracle(obj.oracle),
    'passbolt': toJson_SecretStoreSpecProviderPassbolt(obj.passbolt),
    'passworddepot': toJson_SecretStoreSpecProviderPassworddepot(obj.passworddepot),
    'previder': toJson_SecretStoreSpecProviderPrevider(obj.previder),
    'pulumi': toJson_SecretStoreSpecProviderPulumi(obj.pulumi),
    'scaleway': toJson_SecretStoreSpecProviderScaleway(obj.scaleway),
    'secretserver': toJson_SecretStoreSpecProviderSecretserver(obj.secretserver),
    'senhasegura': toJson_SecretStoreSpecProviderSenhasegura(obj.senhasegura),
    'vault': toJson_SecretStoreSpecProviderVault(obj.vault),
    'webhook': toJson_SecretStoreSpecProviderWebhook(obj.webhook),
    'yandexcertificatemanager': toJson_SecretStoreSpecProviderYandexcertificatemanager(obj.yandexcertificatemanager),
    'yandexlockbox': toJson_SecretStoreSpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema SecretStoreSpecRetrySettings
 */
export interface SecretStoreSpecRetrySettings {
  /**
   * @schema SecretStoreSpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema SecretStoreSpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecRetrySettings(obj: SecretStoreSpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema SecretStoreSpecConditionsNamespaceSelector
 */
export interface SecretStoreSpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SecretStoreSpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SecretStoreSpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SecretStoreSpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SecretStoreSpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecConditionsNamespaceSelector(obj: SecretStoreSpecConditionsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SecretStoreSpecConditionsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema SecretStoreSpecProviderAkeyless
 */
export interface SecretStoreSpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreSpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema SecretStoreSpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: SecretStoreSpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used
   * if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema SecretStoreSpecProviderAkeyless#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeyless(obj: SecretStoreSpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_SecretStoreSpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema SecretStoreSpecProviderAlibaba
 */
export interface SecretStoreSpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreSpecProviderAlibaba#auth
   */
  readonly auth: SecretStoreSpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema SecretStoreSpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibaba(obj: SecretStoreSpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema SecretStoreSpecProviderAws
 */
export interface SecretStoreSpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema SecretStoreSpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS
   * if not set aws sdk will infer credentials from your environment
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema SecretStoreSpecProviderAws#auth
   */
  readonly auth?: SecretStoreSpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreSpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * Prefix adds a prefix to all retrieved values.
   *
   * @schema SecretStoreSpecProviderAws#prefix
   */
  readonly prefix?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema SecretStoreSpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema SecretStoreSpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema SecretStoreSpecProviderAws#secretsManager
   */
  readonly secretsManager?: SecretStoreSpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema SecretStoreSpecProviderAws#service
   */
  readonly service: SecretStoreSpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema SecretStoreSpecProviderAws#sessionTags
   */
  readonly sessionTags?: SecretStoreSpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema SecretStoreSpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAws(obj: SecretStoreSpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalRoles': obj.additionalRoles?.map(y => y),
    'auth': toJson_SecretStoreSpecProviderAwsAuth(obj.auth),
    'externalID': obj.externalId,
    'prefix': obj.prefix,
    'region': obj.region,
    'role': obj.role,
    'secretsManager': toJson_SecretStoreSpecProviderAwsSecretsManager(obj.secretsManager),
    'service': obj.service,
    'sessionTags': obj.sessionTags?.map(y => toJson_SecretStoreSpecProviderAwsSessionTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema SecretStoreSpecProviderAzurekv
 */
export interface SecretStoreSpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: SecretStoreSpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service.
   * Valid values are:
   * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
   * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema SecretStoreSpecProviderAzurekv#authType
   */
  readonly authType?: SecretStoreSpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for
   * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
   * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
   * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema SecretStoreSpecProviderAzurekv#environmentType
   */
  readonly environmentType?: SecretStoreSpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema SecretStoreSpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreSpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekv(obj: SecretStoreSpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_SecretStoreSpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'environmentType': obj.environmentType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_SecretStoreSpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Beyondtrust configures this store to sync secrets using Password Safe provider.
 *
 * @schema SecretStoreSpecProviderBeyondtrust
 */
export interface SecretStoreSpecProviderBeyondtrust {
  /**
   * Auth configures how the operator authenticates with Beyondtrust.
   *
   * @schema SecretStoreSpecProviderBeyondtrust#auth
   */
  readonly auth: SecretStoreSpecProviderBeyondtrustAuth;

  /**
   * Auth configures how API server works.
   *
   * @schema SecretStoreSpecProviderBeyondtrust#server
   */
  readonly server: SecretStoreSpecProviderBeyondtrustServer;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrust' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrust(obj: SecretStoreSpecProviderBeyondtrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderBeyondtrustAuth(obj.auth),
    'server': toJson_SecretStoreSpecProviderBeyondtrustServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanager
 */
export interface SecretStoreSpecProviderBitwardensecretsmanager {
  /**
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
   * Make sure that the token being used has permissions on the given secret.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#auth
   */
  readonly auth: SecretStoreSpecProviderBitwardensecretsmanagerAuth;

  /**
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
   */
  readonly bitwardenServerSdkurl?: string;

  /**
   * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderBitwardensecretsmanagerCaProvider;

  /**
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#identityURL
   */
  readonly identityUrl?: string;

  /**
   * OrganizationID determines which organization this secret store manages.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#organizationID
   */
  readonly organizationId: string;

  /**
   * ProjectID determines which project this secret store manages.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanager#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBitwardensecretsmanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBitwardensecretsmanager(obj: SecretStoreSpecProviderBitwardensecretsmanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'auth': toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuth(obj.auth),
    'bitwardenServerSDKURL': obj.bitwardenServerSdkurl,
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderBitwardensecretsmanagerCaProvider(obj.caProvider),
    'identityURL': obj.identityUrl,
    'organizationID': obj.organizationId,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chef configures this store to sync secrets with chef server
 *
 * @schema SecretStoreSpecProviderChef
 */
export interface SecretStoreSpecProviderChef {
  /**
   * Auth defines the information necessary to authenticate against chef Server
   *
   * @schema SecretStoreSpecProviderChef#auth
   */
  readonly auth: SecretStoreSpecProviderChefAuth;

  /**
   * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
   *
   * @schema SecretStoreSpecProviderChef#serverUrl
   */
  readonly serverUrl: string;

  /**
   * UserName should be the user ID on the chef server
   *
   * @schema SecretStoreSpecProviderChef#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderChef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderChef(obj: SecretStoreSpecProviderChef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderChefAuth(obj.auth),
    'serverUrl': obj.serverUrl,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
 *
 * @schema SecretStoreSpecProviderCloudrusm
 */
export interface SecretStoreSpecProviderCloudrusm {
  /**
   * CSMAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreSpecProviderCloudrusm#auth
   */
  readonly auth: SecretStoreSpecProviderCloudrusmAuth;

  /**
   * ProjectID is the project, which the secrets are stored in.
   *
   * @schema SecretStoreSpecProviderCloudrusm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderCloudrusm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderCloudrusm(obj: SecretStoreSpecProviderCloudrusm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderCloudrusmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema SecretStoreSpecProviderConjur
 */
export interface SecretStoreSpecProviderConjur {
  /**
   * Defines authentication settings for connecting to Conjur.
   *
   * @schema SecretStoreSpecProviderConjur#auth
   */
  readonly auth: SecretStoreSpecProviderConjurAuth;

  /**
   * CABundle is a PEM encoded CA bundle that will be used to validate the Conjur server certificate.
   *
   * @schema SecretStoreSpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates
   * for a secret store. The CAProvider points to a Secret or ConfigMap resource
   * that contains a PEM-encoded certificate.
   *
   * @schema SecretStoreSpecProviderConjur#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderConjurCaProvider;

  /**
   * URL is the endpoint of the Conjur instance.
   *
   * @schema SecretStoreSpecProviderConjur#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjur(obj: SecretStoreSpecProviderConjur | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderConjurAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderConjurCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delinea DevOps Secrets Vault
 * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema SecretStoreSpecProviderDelinea
 */
export interface SecretStoreSpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema SecretStoreSpecProviderDelinea#clientId
   */
  readonly clientId: SecretStoreSpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema SecretStoreSpecProviderDelinea#clientSecret
   */
  readonly clientSecret: SecretStoreSpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema SecretStoreSpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning.
   * If unset, defaults to "com".
   *
   * @schema SecretStoreSpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate
   * If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema SecretStoreSpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDelinea(obj: SecretStoreSpecProviderDelinea | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_SecretStoreSpecProviderDelineaClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreSpecProviderDelineaClientSecret(obj.clientSecret),
    'tenant': obj.tenant,
    'tld': obj.tld,
    'urlTemplate': obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Device42 configures this store to sync secrets using the Device42 provider
 *
 * @schema SecretStoreSpecProviderDevice42
 */
export interface SecretStoreSpecProviderDevice42 {
  /**
   * Auth configures how secret-manager authenticates with a Device42 instance.
   *
   * @schema SecretStoreSpecProviderDevice42#auth
   */
  readonly auth: SecretStoreSpecProviderDevice42Auth;

  /**
   * URL configures the Device42 instance URL.
   *
   * @schema SecretStoreSpecProviderDevice42#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDevice42' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDevice42(obj: SecretStoreSpecProviderDevice42 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderDevice42Auth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema SecretStoreSpecProviderDoppler
 */
export interface SecretStoreSpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema SecretStoreSpecProviderDoppler#auth
   */
  readonly auth: SecretStoreSpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema SecretStoreSpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema SecretStoreSpecProviderDoppler#format
   */
  readonly format?: SecretStoreSpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema SecretStoreSpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: SecretStoreSpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema SecretStoreSpecProviderDoppler#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDoppler(obj: SecretStoreSpecProviderDoppler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderDopplerAuth(obj.auth),
    'config': obj.config,
    'format': obj.format,
    'nameTransformer': obj.nameTransformer,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema SecretStoreSpecProviderFake
 */
export interface SecretStoreSpecProviderFake {
  /**
   * @schema SecretStoreSpecProviderFake#data
   */
  readonly data: SecretStoreSpecProviderFakeData[];

}

/**
 * Converts an object of type 'SecretStoreSpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderFake(obj: SecretStoreSpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_SecretStoreSpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fortanix configures this store to sync secrets using the Fortanix provider
 *
 * @schema SecretStoreSpecProviderFortanix
 */
export interface SecretStoreSpecProviderFortanix {
  /**
   * APIKey is the API token to access SDKMS Applications.
   *
   * @schema SecretStoreSpecProviderFortanix#apiKey
   */
  readonly apiKey?: SecretStoreSpecProviderFortanixApiKey;

  /**
   * APIURL is the URL of SDKMS API. Defaults to `sdkms.fortanix.com`.
   *
   * @default sdkms.fortanix.com`.
   * @schema SecretStoreSpecProviderFortanix#apiUrl
   */
  readonly apiUrl?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderFortanix' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderFortanix(obj: SecretStoreSpecProviderFortanix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_SecretStoreSpecProviderFortanixApiKey(obj.apiKey),
    'apiUrl': obj.apiUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema SecretStoreSpecProviderGcpsm
 */
export interface SecretStoreSpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema SecretStoreSpecProviderGcpsm#auth
   */
  readonly auth?: SecretStoreSpecProviderGcpsmAuth;

  /**
   * Location optionally defines a location for a secret
   *
   * @schema SecretStoreSpecProviderGcpsm#location
   */
  readonly location?: string;

  /**
   * ProjectID project where secret is located
   *
   * @schema SecretStoreSpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsm(obj: SecretStoreSpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderGcpsmAuth(obj.auth),
    'location': obj.location,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Github configures this store to push Github Action secrets using Github API provider
 *
 * @schema SecretStoreSpecProviderGithub
 */
export interface SecretStoreSpecProviderGithub {
  /**
   * appID specifies the Github APP that will be used to authenticate the client
   *
   * @schema SecretStoreSpecProviderGithub#appID
   */
  readonly appId: number;

  /**
   * auth configures how secret-manager authenticates with a Github instance.
   *
   * @schema SecretStoreSpecProviderGithub#auth
   */
  readonly auth: SecretStoreSpecProviderGithubAuth;

  /**
   * environment will be used to fetch secrets from a particular environment within a github repository
   *
   * @schema SecretStoreSpecProviderGithub#environment
   */
  readonly environment?: string;

  /**
   * installationID specifies the Github APP installation that will be used to authenticate the client
   *
   * @schema SecretStoreSpecProviderGithub#installationID
   */
  readonly installationId: number;

  /**
   * organization will be used to fetch secrets from the Github organization
   *
   * @schema SecretStoreSpecProviderGithub#organization
   */
  readonly organization: string;

  /**
   * repository will be used to fetch secrets from the Github repository within an organization
   *
   * @schema SecretStoreSpecProviderGithub#repository
   */
  readonly repository?: string;

  /**
   * Upload URL for enterprise instances. Default to URL.
   *
   * @default URL.
   * @schema SecretStoreSpecProviderGithub#uploadURL
   */
  readonly uploadUrl?: string;

  /**
   * URL configures the Github instance URL. Defaults to https://github.com/.
   *
   * @default https://github.com/.
   * @schema SecretStoreSpecProviderGithub#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGithub(obj: SecretStoreSpecProviderGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appID': obj.appId,
    'auth': toJson_SecretStoreSpecProviderGithubAuth(obj.auth),
    'environment': obj.environment,
    'installationID': obj.installationId,
    'organization': obj.organization,
    'repository': obj.repository,
    'uploadURL': obj.uploadUrl,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema SecretStoreSpecProviderGitlab
 */
export interface SecretStoreSpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema SecretStoreSpecProviderGitlab#auth
   */
  readonly auth: SecretStoreSpecProviderGitlabAuth;

  /**
   * Base64 encoded certificate for the GitLab server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema SecretStoreSpecProviderGitlab#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreSpecProviderGitlab#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderGitlabCaProvider;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema SecretStoreSpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema SecretStoreSpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema SecretStoreSpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema SecretStoreSpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema SecretStoreSpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGitlab(obj: SecretStoreSpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderGitlabAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderGitlabCaProvider(obj.caProvider),
    'environment': obj.environment,
    'groupIDs': obj.groupIDs?.map(y => y),
    'inheritFromGroups': obj.inheritFromGroups,
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema SecretStoreSpecProviderIbm
 */
export interface SecretStoreSpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema SecretStoreSpecProviderIbm#auth
   */
  readonly auth: SecretStoreSpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema SecretStoreSpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderIbm(obj: SecretStoreSpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Infisical configures this store to sync secrets using the Infisical provider
 *
 * @schema SecretStoreSpecProviderInfisical
 */
export interface SecretStoreSpecProviderInfisical {
  /**
   * Auth configures how the Operator authenticates with the Infisical API
   *
   * @schema SecretStoreSpecProviderInfisical#auth
   */
  readonly auth: SecretStoreSpecProviderInfisicalAuth;

  /**
   * HostAPI specifies the base URL of the Infisical API. If not provided, it defaults to "https://app.infisical.com/api".
   *
   * @schema SecretStoreSpecProviderInfisical#hostAPI
   */
  readonly hostApi?: string;

  /**
   * SecretsScope defines the scope of the secrets within the workspace
   *
   * @schema SecretStoreSpecProviderInfisical#secretsScope
   */
  readonly secretsScope: SecretStoreSpecProviderInfisicalSecretsScope;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisical(obj: SecretStoreSpecProviderInfisical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderInfisicalAuth(obj.auth),
    'hostAPI': obj.hostApi,
    'secretsScope': toJson_SecretStoreSpecProviderInfisicalSecretsScope(obj.secretsScope),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema SecretStoreSpecProviderKeepersecurity
 */
export interface SecretStoreSpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKeepersecurity#authRef
   */
  readonly authRef: SecretStoreSpecProviderKeepersecurityAuthRef;

  /**
   * @schema SecretStoreSpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKeepersecurity(obj: SecretStoreSpecProviderKeepersecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authRef': toJson_SecretStoreSpecProviderKeepersecurityAuthRef(obj.authRef),
    'folderID': obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema SecretStoreSpecProviderKubernetes
 */
export interface SecretStoreSpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema SecretStoreSpecProviderKubernetes#auth
   */
  readonly auth?: SecretStoreSpecProviderKubernetesAuth;

  /**
   * A reference to a secret that contains the auth information.
   *
   * @schema SecretStoreSpecProviderKubernetes#authRef
   */
  readonly authRef?: SecretStoreSpecProviderKubernetesAuthRef;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema SecretStoreSpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreSpecProviderKubernetes#server
   */
  readonly server?: SecretStoreSpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetes(obj: SecretStoreSpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderKubernetesAuth(obj.auth),
    'authRef': toJson_SecretStoreSpecProviderKubernetesAuthRef(obj.authRef),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_SecretStoreSpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Onboardbase configures this store to sync secrets using the Onboardbase provider
 *
 * @schema SecretStoreSpecProviderOnboardbase
 */
export interface SecretStoreSpecProviderOnboardbase {
  /**
   * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
   *
   * @schema SecretStoreSpecProviderOnboardbase#apiHost
   */
  readonly apiHost: string;

  /**
   * Auth configures how the Operator authenticates with the Onboardbase API
   *
   * @schema SecretStoreSpecProviderOnboardbase#auth
   */
  readonly auth: SecretStoreSpecProviderOnboardbaseAuth;

  /**
   * Environment is the name of an environmnent within a project to pull the secrets from
   *
   * @schema SecretStoreSpecProviderOnboardbase#environment
   */
  readonly environment: string;

  /**
   * Project is an onboardbase project that the secrets should be pulled from
   *
   * @schema SecretStoreSpecProviderOnboardbase#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnboardbase' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnboardbase(obj: SecretStoreSpecProviderOnboardbase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiHost': obj.apiHost,
    'auth': toJson_SecretStoreSpecProviderOnboardbaseAuth(obj.auth),
    'environment': obj.environment,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema SecretStoreSpecProviderOnepassword
 */
export interface SecretStoreSpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema SecretStoreSpecProviderOnepassword#auth
   */
  readonly auth: SecretStoreSpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema SecretStoreSpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema SecretStoreSpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepassword(obj: SecretStoreSpecProviderOnepassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderOnepasswordAuth(obj.auth),
    'connectHost': obj.connectHost,
    'vaults': ((obj.vaults) === undefined) ? undefined : (Object.entries(obj.vaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordSDK configures this store to use 1Password's new Go SDK to sync secrets.
 *
 * @schema SecretStoreSpecProviderOnepasswordSdk
 */
export interface SecretStoreSpecProviderOnepasswordSdk {
  /**
   * Auth defines the information necessary to authenticate against OnePassword API.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdk#auth
   */
  readonly auth: SecretStoreSpecProviderOnepasswordSdkAuth;

  /**
   * IntegrationInfo specifies the name and version of the integration built using the 1Password Go SDK.
   * If you don't know which name and version to use, use `DefaultIntegrationName` and `DefaultIntegrationVersion`, respectively.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdk#integrationInfo
   */
  readonly integrationInfo?: SecretStoreSpecProviderOnepasswordSdkIntegrationInfo;

  /**
   * Vault defines the vault's name or uuid to access. Do NOT add op:// prefix. This will be done automatically.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdk#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordSdk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordSdk(obj: SecretStoreSpecProviderOnepasswordSdk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderOnepasswordSdkAuth(obj.auth),
    'integrationInfo': toJson_SecretStoreSpecProviderOnepasswordSdkIntegrationInfo(obj.integrationInfo),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema SecretStoreSpecProviderOracle
 */
export interface SecretStoreSpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault.
   * If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema SecretStoreSpecProviderOracle#auth
   */
  readonly auth?: SecretStoreSpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID.
   * Required for PushSecret
   *
   * @schema SecretStoreSpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault.
   * Required for PushSecret
   *
   * @schema SecretStoreSpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will
   * determine the principal type. This optional field must be specified if using
   * workload identity.
   *
   * @schema SecretStoreSpecProviderOracle#principalType
   */
  readonly principalType?: SecretStoreSpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema SecretStoreSpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema SecretStoreSpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracle(obj: SecretStoreSpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_SecretStoreSpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderPassbolt
 */
export interface SecretStoreSpecProviderPassbolt {
  /**
   * Auth defines the information necessary to authenticate against Passbolt Server
   *
   * @schema SecretStoreSpecProviderPassbolt#auth
   */
  readonly auth: SecretStoreSpecProviderPassboltAuth;

  /**
   * Host defines the Passbolt Server to connect to
   *
   * @schema SecretStoreSpecProviderPassbolt#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassbolt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassbolt(obj: SecretStoreSpecProviderPassbolt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderPassboltAuth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configures a store to sync secrets with a Password Depot instance.
 *
 * @schema SecretStoreSpecProviderPassworddepot
 */
export interface SecretStoreSpecProviderPassworddepot {
  /**
   * Auth configures how secret-manager authenticates with a Password Depot instance.
   *
   * @schema SecretStoreSpecProviderPassworddepot#auth
   */
  readonly auth: SecretStoreSpecProviderPassworddepotAuth;

  /**
   * Database to use as source
   *
   * @schema SecretStoreSpecProviderPassworddepot#database
   */
  readonly database: string;

  /**
   * URL configures the Password Depot instance URL.
   *
   * @schema SecretStoreSpecProviderPassworddepot#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassworddepot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassworddepot(obj: SecretStoreSpecProviderPassworddepot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderPassworddepotAuth(obj.auth),
    'database': obj.database,
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Previder configures this store to sync secrets using the Previder provider
 *
 * @schema SecretStoreSpecProviderPrevider
 */
export interface SecretStoreSpecProviderPrevider {
  /**
   * PreviderAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreSpecProviderPrevider#auth
   */
  readonly auth: SecretStoreSpecProviderPreviderAuth;

  /**
   * @schema SecretStoreSpecProviderPrevider#baseUri
   */
  readonly baseUri?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPrevider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPrevider(obj: SecretStoreSpecProviderPrevider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderPreviderAuth(obj.auth),
    'baseUri': obj.baseUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pulumi configures this store to sync secrets using the Pulumi provider
 *
 * @schema SecretStoreSpecProviderPulumi
 */
export interface SecretStoreSpecProviderPulumi {
  /**
   * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
   *
   * @schema SecretStoreSpecProviderPulumi#accessToken
   */
  readonly accessToken: SecretStoreSpecProviderPulumiAccessToken;

  /**
   * APIURL is the URL of the Pulumi API.
   *
   * @schema SecretStoreSpecProviderPulumi#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Environment are YAML documents composed of static key-value pairs, programmatic expressions,
   * dynamically retrieved values from supported providers including all major clouds,
   * and other Pulumi ESC environments.
   * To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
   *
   * @schema SecretStoreSpecProviderPulumi#environment
   */
  readonly environment: string;

  /**
   * Organization are a space to collaborate on shared projects and stacks.
   * To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
   *
   * @schema SecretStoreSpecProviderPulumi#organization
   */
  readonly organization: string;

  /**
   * Project is the name of the Pulumi ESC project the environment belongs to.
   *
   * @schema SecretStoreSpecProviderPulumi#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPulumi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPulumi(obj: SecretStoreSpecProviderPulumi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreSpecProviderPulumiAccessToken(obj.accessToken),
    'apiUrl': obj.apiUrl,
    'environment': obj.environment,
    'organization': obj.organization,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scaleway
 *
 * @schema SecretStoreSpecProviderScaleway
 */
export interface SecretStoreSpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema SecretStoreSpecProviderScaleway#accessKey
   */
  readonly accessKey: SecretStoreSpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema SecretStoreSpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema SecretStoreSpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema SecretStoreSpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema SecretStoreSpecProviderScaleway#secretKey
   */
  readonly secretKey: SecretStoreSpecProviderScalewaySecretKey;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderScaleway(obj: SecretStoreSpecProviderScaleway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_SecretStoreSpecProviderScalewayAccessKey(obj.accessKey),
    'apiUrl': obj.apiUrl,
    'projectId': obj.projectId,
    'region': obj.region,
    'secretKey': toJson_SecretStoreSpecProviderScalewaySecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretServer configures this store to sync secrets using SecretServer provider
 * https://docs.delinea.com/online-help/secret-server/start.htm
 *
 * @schema SecretStoreSpecProviderSecretserver
 */
export interface SecretStoreSpecProviderSecretserver {
  /**
   * Password is the secret server account password.
   *
   * @schema SecretStoreSpecProviderSecretserver#password
   */
  readonly password: SecretStoreSpecProviderSecretserverPassword;

  /**
   * ServerURL
   * URL to your secret server installation
   *
   * @schema SecretStoreSpecProviderSecretserver#serverURL
   */
  readonly serverUrl: string;

  /**
   * Username is the secret server account username.
   *
   * @schema SecretStoreSpecProviderSecretserver#username
   */
  readonly username: SecretStoreSpecProviderSecretserverUsername;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSecretserver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSecretserver(obj: SecretStoreSpecProviderSecretserver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_SecretStoreSpecProviderSecretserverPassword(obj.password),
    'serverURL': obj.serverUrl,
    'username': toJson_SecretStoreSpecProviderSecretserverUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema SecretStoreSpecProviderSenhasegura
 */
export interface SecretStoreSpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema SecretStoreSpecProviderSenhasegura#auth
   */
  readonly auth: SecretStoreSpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema SecretStoreSpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema SecretStoreSpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema SecretStoreSpecProviderSenhasegura#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSenhasegura(obj: SecretStoreSpecProviderSenhasegura | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderSenhaseguraAuth(obj.auth),
    'ignoreSslCertificate': obj.ignoreSslCertificate,
    'module': obj.module,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema SecretStoreSpecProviderVault
 */
export interface SecretStoreSpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema SecretStoreSpecProviderVault#auth
   */
  readonly auth?: SecretStoreSpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema SecretStoreSpecProviderVault#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault
   * leader instead of simply retrying within a loop. This can increase performance if
   * the option is enabled serverside.
   * https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema SecretStoreSpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Headers to be added in Vault request
   *
   * @schema SecretStoreSpecProviderVault#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema SecretStoreSpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g:
   * "secret". The v2 KV secret engine version specific "/data" path suffix
   * for fetching secrets from Vault is optional and will be appended
   * if not present in specified path.
   *
   * @schema SecretStoreSpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by
   * providing discovered cluster replication states in each request.
   * More information about eventual consistency in Vault can be found here
   * https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema SecretStoreSpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema SecretStoreSpecProviderVault#server
   */
  readonly server: string;

  /**
   * The configuration used for client side related TLS communication, when the Vault server
   * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
   * This parameter is ignored for plain HTTP protocol connection.
   * It's worth noting this configuration is different from the "TLS certificates auth method",
   * which is available under the `auth.cert` section.
   *
   * @schema SecretStoreSpecProviderVault#tls
   */
  readonly tls?: SecretStoreSpecProviderVaultTls;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or
   * "v2". Version defaults to "v2".
   *
   * @schema SecretStoreSpecProviderVault#version
   */
  readonly version?: SecretStoreSpecProviderVaultVersion;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVault(obj: SecretStoreSpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'tls': toJson_SecretStoreSpecProviderVaultTls(obj.tls),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema SecretStoreSpecProviderWebhook
 */
export interface SecretStoreSpecProviderWebhook {
  /**
   * Auth specifies a authorization protocol. Only one protocol may be set.
   *
   * @schema SecretStoreSpecProviderWebhook#auth
   */
  readonly auth?: SecretStoreSpecProviderWebhookAuth;

  /**
   * Body
   *
   * @schema SecretStoreSpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema SecretStoreSpecProviderWebhook#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema SecretStoreSpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema SecretStoreSpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema SecretStoreSpecProviderWebhook#result
   */
  readonly result: SecretStoreSpecProviderWebhookResult;

  /**
   * Secrets to fill in templates
   * These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema SecretStoreSpecProviderWebhook#secrets
   */
  readonly secrets?: SecretStoreSpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema SecretStoreSpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema SecretStoreSpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhook(obj: SecretStoreSpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreSpecProviderWebhookAuth(obj.auth),
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_SecretStoreSpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_SecretStoreSpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema SecretStoreSpecProviderYandexcertificatemanager
 */
export interface SecretStoreSpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanager#auth
   */
  readonly auth: SecretStoreSpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderYandexcertificatemanagerCaProvider;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexcertificatemanager(obj: SecretStoreSpecProviderYandexcertificatemanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_SecretStoreSpecProviderYandexcertificatemanagerAuth(obj.auth),
    'caProvider': toJson_SecretStoreSpecProviderYandexcertificatemanagerCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema SecretStoreSpecProviderYandexlockbox
 */
export interface SecretStoreSpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreSpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema SecretStoreSpecProviderYandexlockbox#auth
   */
  readonly auth: SecretStoreSpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreSpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexlockbox(obj: SecretStoreSpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_SecretStoreSpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_SecretStoreSpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SecretStoreSpecConditionsNamespaceSelectorMatchExpressions
 */
export interface SecretStoreSpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SecretStoreSpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SecretStoreSpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SecretStoreSpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SecretStoreSpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecConditionsNamespaceSelectorMatchExpressions(obj: SecretStoreSpecConditionsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount
   * token stored in the named Secret resource.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details
   * to authenticate with Akeyless.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRef(obj: SecretStoreSpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema SecretStoreSpecProviderAkeylessCaProvider
 */
export interface SecretStoreSpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#type
   */
  readonly type: SecretStoreSpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessCaProvider(obj: SecretStoreSpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreSpecProviderAlibabaAuth
 */
export interface SecretStoreSpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema SecretStoreSpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: SecretStoreSpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema SecretStoreSpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuth(obj: SecretStoreSpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_SecretStoreSpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_SecretStoreSpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS
 * if not set aws sdk will infer credentials from your environment
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema SecretStoreSpecProviderAwsAuth
 */
export interface SecretStoreSpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema SecretStoreSpecProviderAwsAuth#jwt
   */
  readonly jwt?: SecretStoreSpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials
   * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema SecretStoreSpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuth(obj: SecretStoreSpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_SecretStoreSpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_SecretStoreSpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema SecretStoreSpecProviderAwsSecretsManager
 */
export interface SecretStoreSpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You
   * can't use both this parameter and RecoveryWindowInDays in the same call.
   * If you don't use either, then by default Secrets Manager uses a 30 day
   * recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema SecretStoreSpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before
   * permanently deleting the secret. You can't use both this parameter and
   * ForceDeleteWithoutRecovery in the same call. If you don't use either,
   * then by default Secrets Manager uses a 30 day recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema SecretStoreSpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsSecretsManager(obj: SecretStoreSpecProviderAwsSecretsManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema SecretStoreSpecProviderAwsService
 */
export enum SecretStoreSpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema SecretStoreSpecProviderAwsSessionTags
 */
export interface SecretStoreSpecProviderAwsSessionTags {
  /**
   * @schema SecretStoreSpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreSpecProviderAwsSessionTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsSessionTags(obj: SecretStoreSpecProviderAwsSessionTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRef
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure ClientCertificate of the service principle used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#clientCertificate
   */
  readonly clientCertificate?: SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate;

  /**
   * The Azure clientId of the service principle or managed identity used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: SecretStoreSpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret;

  /**
   * The Azure tenantId of the managed identity used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#tenantId
   */
  readonly tenantId?: SecretStoreSpecProviderAzurekvAuthSecretRefTenantId;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRef(obj: SecretStoreSpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate(obj.clientCertificate),
    'clientId': toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
    'tenantId': toJson_SecretStoreSpecProviderAzurekvAuthSecretRefTenantId(obj.tenantId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service.
 * Valid values are:
 * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
 * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema SecretStoreSpecProviderAzurekvAuthType
 */
export enum SecretStoreSpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for
 * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
 * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
 * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema SecretStoreSpecProviderAzurekvEnvironmentType
 */
export enum SecretStoreSpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreSpecProviderAzurekvServiceAccountRef
 */
export interface SecretStoreSpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvServiceAccountRef(obj: SecretStoreSpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Beyondtrust.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuth
 */
export interface SecretStoreSpecProviderBeyondtrustAuth {
  /**
   * APIKey If not provided then ClientID/ClientSecret become required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuth#apiKey
   */
  readonly apiKey?: SecretStoreSpecProviderBeyondtrustAuthApiKey;

  /**
   * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuth#certificate
   */
  readonly certificate?: SecretStoreSpecProviderBeyondtrustAuthCertificate;

  /**
   * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuth#certificateKey
   */
  readonly certificateKey?: SecretStoreSpecProviderBeyondtrustAuthCertificateKey;

  /**
   * ClientID is the API OAuth Client ID.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuth#clientId
   */
  readonly clientId?: SecretStoreSpecProviderBeyondtrustAuthClientId;

  /**
   * ClientSecret is the API OAuth Client Secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuth#clientSecret
   */
  readonly clientSecret?: SecretStoreSpecProviderBeyondtrustAuthClientSecret;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuth(obj: SecretStoreSpecProviderBeyondtrustAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_SecretStoreSpecProviderBeyondtrustAuthApiKey(obj.apiKey),
    'certificate': toJson_SecretStoreSpecProviderBeyondtrustAuthCertificate(obj.certificate),
    'certificateKey': toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateKey(obj.certificateKey),
    'clientId': toJson_SecretStoreSpecProviderBeyondtrustAuthClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreSpecProviderBeyondtrustAuthClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how API server works.
 *
 * @schema SecretStoreSpecProviderBeyondtrustServer
 */
export interface SecretStoreSpecProviderBeyondtrustServer {
  /**
   * @schema SecretStoreSpecProviderBeyondtrustServer#apiUrl
   */
  readonly apiUrl: string;

  /**
   * @schema SecretStoreSpecProviderBeyondtrustServer#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
   *
   * @default 45 seconds.
   * @schema SecretStoreSpecProviderBeyondtrustServer#clientTimeOutSeconds
   */
  readonly clientTimeOutSeconds?: number;

  /**
   * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
   *
   * @schema SecretStoreSpecProviderBeyondtrustServer#retrievalType
   */
  readonly retrievalType?: string;

  /**
   * A character that separates the folder names.
   *
   * @schema SecretStoreSpecProviderBeyondtrustServer#separator
   */
  readonly separator?: string;

  /**
   * @schema SecretStoreSpecProviderBeyondtrustServer#verifyCA
   */
  readonly verifyCa: boolean;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustServer(obj: SecretStoreSpecProviderBeyondtrustServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiUrl': obj.apiUrl,
    'apiVersion': obj.apiVersion,
    'clientTimeOutSeconds': obj.clientTimeOutSeconds,
    'retrievalType': obj.retrievalType,
    'separator': obj.separator,
    'verifyCA': obj.verifyCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
 * Make sure that the token being used has permissions on the given secret.
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuth
 */
export interface SecretStoreSpecProviderBitwardensecretsmanagerAuth {
  /**
   * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBitwardensecretsmanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuth(obj: SecretStoreSpecProviderBitwardensecretsmanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProvider
 */
export interface SecretStoreSpecProviderBitwardensecretsmanagerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProvider#type
   */
  readonly type: SecretStoreSpecProviderBitwardensecretsmanagerCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBitwardensecretsmanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBitwardensecretsmanagerCaProvider(obj: SecretStoreSpecProviderBitwardensecretsmanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against chef Server
 *
 * @schema SecretStoreSpecProviderChefAuth
 */
export interface SecretStoreSpecProviderChefAuth {
  /**
   * ChefAuthSecretRef holds secret references for chef server login credentials.
   *
   * @schema SecretStoreSpecProviderChefAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderChefAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderChefAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderChefAuth(obj: SecretStoreSpecProviderChefAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderChefAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreSpecProviderCloudrusmAuth
 */
export interface SecretStoreSpecProviderCloudrusmAuth {
  /**
   * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderCloudrusmAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderCloudrusmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderCloudrusmAuth(obj: SecretStoreSpecProviderCloudrusmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderCloudrusmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines authentication settings for connecting to Conjur.
 *
 * @schema SecretStoreSpecProviderConjurAuth
 */
export interface SecretStoreSpecProviderConjurAuth {
  /**
   * Authenticates with Conjur using an API key.
   *
   * @schema SecretStoreSpecProviderConjurAuth#apikey
   */
  readonly apikey?: SecretStoreSpecProviderConjurAuthApikey;

  /**
   * Jwt enables JWT authentication using Kubernetes service account tokens.
   *
   * @schema SecretStoreSpecProviderConjurAuth#jwt
   */
  readonly jwt?: SecretStoreSpecProviderConjurAuthJwt;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuth(obj: SecretStoreSpecProviderConjurAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apikey': toJson_SecretStoreSpecProviderConjurAuthApikey(obj.apikey),
    'jwt': toJson_SecretStoreSpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates
 * for a secret store. The CAProvider points to a Secret or ConfigMap resource
 * that contains a PEM-encoded certificate.
 *
 * @schema SecretStoreSpecProviderConjurCaProvider
 */
export interface SecretStoreSpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderConjurCaProvider#type
   */
  readonly type: SecretStoreSpecProviderConjurCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurCaProvider(obj: SecretStoreSpecProviderConjurCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema SecretStoreSpecProviderDelineaClientId
 */
export interface SecretStoreSpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderDelineaClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDelineaClientId(obj: SecretStoreSpecProviderDelineaClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderDelineaClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema SecretStoreSpecProviderDelineaClientSecret
 */
export interface SecretStoreSpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderDelineaClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDelineaClientSecret(obj: SecretStoreSpecProviderDelineaClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderDelineaClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Device42 instance.
 *
 * @schema SecretStoreSpecProviderDevice42Auth
 */
export interface SecretStoreSpecProviderDevice42Auth {
  /**
   * @schema SecretStoreSpecProviderDevice42Auth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderDevice42AuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDevice42Auth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDevice42Auth(obj: SecretStoreSpecProviderDevice42Auth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderDevice42AuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema SecretStoreSpecProviderDopplerAuth
 */
export interface SecretStoreSpecProviderDopplerAuth {
  /**
   * @schema SecretStoreSpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderDopplerAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDopplerAuth(obj: SecretStoreSpecProviderDopplerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderDopplerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema SecretStoreSpecProviderDopplerFormat
 */
export enum SecretStoreSpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema SecretStoreSpecProviderDopplerNameTransformer
 */
export enum SecretStoreSpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema SecretStoreSpecProviderFakeData
 */
export interface SecretStoreSpecProviderFakeData {
  /**
   * @schema SecretStoreSpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreSpecProviderFakeData#value
   */
  readonly value: string;

  /**
   * @schema SecretStoreSpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderFakeData(obj: SecretStoreSpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey is the API token to access SDKMS Applications.
 *
 * @schema SecretStoreSpecProviderFortanixApiKey
 */
export interface SecretStoreSpecProviderFortanixApiKey {
  /**
   * SecretRef is a reference to a secret containing the SDKMS API Key.
   *
   * @schema SecretStoreSpecProviderFortanixApiKey#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderFortanixApiKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderFortanixApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderFortanixApiKey(obj: SecretStoreSpecProviderFortanixApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderFortanixApiKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema SecretStoreSpecProviderGcpsmAuth
 */
export interface SecretStoreSpecProviderGcpsmAuth {
  /**
   * @schema SecretStoreSpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderGcpsmAuthSecretRef;

  /**
   * @schema SecretStoreSpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuth(obj: SecretStoreSpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * auth configures how secret-manager authenticates with a Github instance.
 *
 * @schema SecretStoreSpecProviderGithubAuth
 */
export interface SecretStoreSpecProviderGithubAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderGithubAuth#privateKey
   */
  readonly privateKey: SecretStoreSpecProviderGithubAuthPrivateKey;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGithubAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGithubAuth(obj: SecretStoreSpecProviderGithubAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKey': toJson_SecretStoreSpecProviderGithubAuthPrivateKey(obj.privateKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema SecretStoreSpecProviderGitlabAuth
 */
export interface SecretStoreSpecProviderGitlabAuth {
  /**
   * @schema SecretStoreSpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: SecretStoreSpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuth(obj: SecretStoreSpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_SecretStoreSpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreSpecProviderGitlabCaProvider
 */
export interface SecretStoreSpecProviderGitlabCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderGitlabCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderGitlabCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderGitlabCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderGitlabCaProvider#type
   */
  readonly type: SecretStoreSpecProviderGitlabCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGitlabCaProvider(obj: SecretStoreSpecProviderGitlabCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema SecretStoreSpecProviderIbmAuth
 */
export interface SecretStoreSpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema SecretStoreSpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: SecretStoreSpecProviderIbmAuthContainerAuth;

  /**
   * @schema SecretStoreSpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderIbmAuth(obj: SecretStoreSpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerAuth': toJson_SecretStoreSpecProviderIbmAuthContainerAuth(obj.containerAuth),
    'secretRef': toJson_SecretStoreSpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Infisical API
 *
 * @schema SecretStoreSpecProviderInfisicalAuth
 */
export interface SecretStoreSpecProviderInfisicalAuth {
  /**
   * @schema SecretStoreSpecProviderInfisicalAuth#azureAuthCredentials
   */
  readonly azureAuthCredentials?: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials;

  /**
   * @schema SecretStoreSpecProviderInfisicalAuth#universalAuthCredentials
   */
  readonly universalAuthCredentials?: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuth(obj: SecretStoreSpecProviderInfisicalAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureAuthCredentials': toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials(obj.azureAuthCredentials),
    'universalAuthCredentials': toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials(obj.universalAuthCredentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsScope defines the scope of the secrets within the workspace
 *
 * @schema SecretStoreSpecProviderInfisicalSecretsScope
 */
export interface SecretStoreSpecProviderInfisicalSecretsScope {
  /**
   * EnvironmentSlug is the required slug identifier for the environment.
   *
   * @schema SecretStoreSpecProviderInfisicalSecretsScope#environmentSlug
   */
  readonly environmentSlug: string;

  /**
   * ExpandSecretReferences indicates whether secret references should be expanded. Defaults to true if not provided.
   *
   * @default true if not provided.
   * @schema SecretStoreSpecProviderInfisicalSecretsScope#expandSecretReferences
   */
  readonly expandSecretReferences?: boolean;

  /**
   * ProjectSlug is the required slug identifier for the project.
   *
   * @schema SecretStoreSpecProviderInfisicalSecretsScope#projectSlug
   */
  readonly projectSlug: string;

  /**
   * Recursive indicates whether the secrets should be fetched recursively. Defaults to false if not provided.
   *
   * @default false if not provided.
   * @schema SecretStoreSpecProviderInfisicalSecretsScope#recursive
   */
  readonly recursive?: boolean;

  /**
   * SecretsPath specifies the path to the secrets within the workspace. Defaults to "/" if not provided.
   *
   * @default if not provided.
   * @schema SecretStoreSpecProviderInfisicalSecretsScope#secretsPath
   */
  readonly secretsPath?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalSecretsScope' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalSecretsScope(obj: SecretStoreSpecProviderInfisicalSecretsScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environmentSlug': obj.environmentSlug,
    'expandSecretReferences': obj.expandSecretReferences,
    'projectSlug': obj.projectSlug,
    'recursive': obj.recursive,
    'secretsPath': obj.secretsPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKeepersecurityAuthRef
 */
export interface SecretStoreSpecProviderKeepersecurityAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKeepersecurityAuthRef(obj: SecretStoreSpecProviderKeepersecurityAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema SecretStoreSpecProviderKubernetesAuth
 */
export interface SecretStoreSpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#cert
   */
  readonly cert?: SecretStoreSpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: SecretStoreSpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#token
   */
  readonly token?: SecretStoreSpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuth(obj: SecretStoreSpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_SecretStoreSpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_SecretStoreSpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_SecretStoreSpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a secret that contains the auth information.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthRef
 */
export interface SecretStoreSpecProviderKubernetesAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthRef(obj: SecretStoreSpecProviderKubernetesAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema SecretStoreSpecProviderKubernetesServer
 */
export interface SecretStoreSpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema SecretStoreSpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreSpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreSpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesServer(obj: SecretStoreSpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreSpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Onboardbase API
 *
 * @schema SecretStoreSpecProviderOnboardbaseAuth
 */
export interface SecretStoreSpecProviderOnboardbaseAuth {
  /**
   * OnboardbaseAPIKey is the APIKey generated by an admin account.
   * It is used to recognize and authorize access to a project and environment within onboardbase
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuth#apiKeyRef
   */
  readonly apiKeyRef: SecretStoreSpecProviderOnboardbaseAuthApiKeyRef;

  /**
   * OnboardbasePasscode is the passcode attached to the API Key
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuth#passcodeRef
   */
  readonly passcodeRef: SecretStoreSpecProviderOnboardbaseAuthPasscodeRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnboardbaseAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnboardbaseAuth(obj: SecretStoreSpecProviderOnboardbaseAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRef': toJson_SecretStoreSpecProviderOnboardbaseAuthApiKeyRef(obj.apiKeyRef),
    'passcodeRef': toJson_SecretStoreSpecProviderOnboardbaseAuthPasscodeRef(obj.passcodeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema SecretStoreSpecProviderOnepasswordAuth
 */
export interface SecretStoreSpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema SecretStoreSpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderOnepasswordAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordAuth(obj: SecretStoreSpecProviderOnepasswordAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderOnepasswordAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword API.
 *
 * @schema SecretStoreSpecProviderOnepasswordSdkAuth
 */
export interface SecretStoreSpecProviderOnepasswordSdkAuth {
  /**
   * ServiceAccountSecretRef points to the secret containing the token to access 1Password vault.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkAuth#serviceAccountSecretRef
   */
  readonly serviceAccountSecretRef: SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordSdkAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordSdkAuth(obj: SecretStoreSpecProviderOnepasswordSdkAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountSecretRef': toJson_SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef(obj.serviceAccountSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IntegrationInfo specifies the name and version of the integration built using the 1Password Go SDK.
 * If you don't know which name and version to use, use `DefaultIntegrationName` and `DefaultIntegrationVersion`, respectively.
 *
 * @schema SecretStoreSpecProviderOnepasswordSdkIntegrationInfo
 */
export interface SecretStoreSpecProviderOnepasswordSdkIntegrationInfo {
  /**
   * Name defaults to "1Password SDK".
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkIntegrationInfo#name
   */
  readonly name?: string;

  /**
   * Version defaults to "v1.0.0".
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkIntegrationInfo#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordSdkIntegrationInfo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordSdkIntegrationInfo(obj: SecretStoreSpecProviderOnepasswordSdkIntegrationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault.
 * If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema SecretStoreSpecProviderOracleAuth
 */
export interface SecretStoreSpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema SecretStoreSpecProviderOracleAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema SecretStoreSpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema SecretStoreSpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracleAuth(obj: SecretStoreSpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will
 * determine the principal type. This optional field must be specified if using
 * workload identity.
 *
 * @schema SecretStoreSpecProviderOraclePrincipalType
 */
export enum SecretStoreSpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreSpecProviderOracleServiceAccountRef
 */
export interface SecretStoreSpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracleServiceAccountRef(obj: SecretStoreSpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Passbolt Server
 *
 * @schema SecretStoreSpecProviderPassboltAuth
 */
export interface SecretStoreSpecProviderPassboltAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderPassboltAuth#passwordSecretRef
   */
  readonly passwordSecretRef: SecretStoreSpecProviderPassboltAuthPasswordSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderPassboltAuth#privateKeySecretRef
   */
  readonly privateKeySecretRef: SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassboltAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassboltAuth(obj: SecretStoreSpecProviderPassboltAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_SecretStoreSpecProviderPassboltAuthPasswordSecretRef(obj.passwordSecretRef),
    'privateKeySecretRef': toJson_SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Password Depot instance.
 *
 * @schema SecretStoreSpecProviderPassworddepotAuth
 */
export interface SecretStoreSpecProviderPassworddepotAuth {
  /**
   * @schema SecretStoreSpecProviderPassworddepotAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderPassworddepotAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassworddepotAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassworddepotAuth(obj: SecretStoreSpecProviderPassworddepotAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderPassworddepotAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreSpecProviderPreviderAuth
 */
export interface SecretStoreSpecProviderPreviderAuth {
  /**
   * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
   *
   * @schema SecretStoreSpecProviderPreviderAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderPreviderAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPreviderAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPreviderAuth(obj: SecretStoreSpecProviderPreviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderPreviderAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
 *
 * @schema SecretStoreSpecProviderPulumiAccessToken
 */
export interface SecretStoreSpecProviderPulumiAccessToken {
  /**
   * SecretRef is a reference to a secret containing the Pulumi API token.
   *
   * @schema SecretStoreSpecProviderPulumiAccessToken#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderPulumiAccessTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPulumiAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPulumiAccessToken(obj: SecretStoreSpecProviderPulumiAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderPulumiAccessTokenSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema SecretStoreSpecProviderScalewayAccessKey
 */
export interface SecretStoreSpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderScalewayAccessKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderScalewayAccessKey(obj: SecretStoreSpecProviderScalewayAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderScalewayAccessKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema SecretStoreSpecProviderScalewaySecretKey
 */
export interface SecretStoreSpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderScalewaySecretKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderScalewaySecretKey(obj: SecretStoreSpecProviderScalewaySecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderScalewaySecretKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password is the secret server account password.
 *
 * @schema SecretStoreSpecProviderSecretserverPassword
 */
export interface SecretStoreSpecProviderSecretserverPassword {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderSecretserverPassword#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderSecretserverPasswordSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderSecretserverPassword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSecretserverPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSecretserverPassword(obj: SecretStoreSpecProviderSecretserverPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderSecretserverPasswordSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username is the secret server account username.
 *
 * @schema SecretStoreSpecProviderSecretserverUsername
 */
export interface SecretStoreSpecProviderSecretserverUsername {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderSecretserverUsername#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderSecretserverUsernameSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderSecretserverUsername#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSecretserverUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSecretserverUsername(obj: SecretStoreSpecProviderSecretserverUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderSecretserverUsernameSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema SecretStoreSpecProviderSenhaseguraAuth
 */
export interface SecretStoreSpecProviderSenhaseguraAuth {
  /**
   * @schema SecretStoreSpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSenhaseguraAuth(obj: SecretStoreSpecProviderSenhaseguraAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema SecretStoreSpecProviderVaultAuth
 */
export interface SecretStoreSpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism,
   * with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema SecretStoreSpecProviderVaultAuth#appRole
   */
  readonly appRole?: SecretStoreSpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
   * Cert authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#cert
   */
  readonly cert?: SecretStoreSpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
   * AWS IAM authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#iam
   */
  readonly iam?: SecretStoreSpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the
   * JWT/OIDC authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#jwt
   */
  readonly jwt?: SecretStoreSpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount
   * token stored in the named Secret resource to the Vault server.
   *
   * @schema SecretStoreSpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: SecretStoreSpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using
   * the LDAP authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#ldap
   */
  readonly ldap?: SecretStoreSpecProviderVaultAuthLdap;

  /**
   * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in.
   * Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   * This will default to Vault.Namespace field if set, or empty otherwise
   *
   * @schema SecretStoreSpecProviderVaultAuth#namespace
   */
  readonly namespace?: string;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema SecretStoreSpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: SecretStoreSpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema SecretStoreSpecProviderVaultAuth#userPass
   */
  readonly userPass?: SecretStoreSpecProviderVaultAuthUserPass;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuth(obj: SecretStoreSpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_SecretStoreSpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_SecretStoreSpecProviderVaultAuthCert(obj.cert),
    'iam': toJson_SecretStoreSpecProviderVaultAuthIam(obj.iam),
    'jwt': toJson_SecretStoreSpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_SecretStoreSpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_SecretStoreSpecProviderVaultAuthLdap(obj.ldap),
    'namespace': obj.namespace,
    'tokenSecretRef': toJson_SecretStoreSpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_SecretStoreSpecProviderVaultAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema SecretStoreSpecProviderVaultCaProvider
 */
export interface SecretStoreSpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#type
   */
  readonly type: SecretStoreSpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultCaProvider(obj: SecretStoreSpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration used for client side related TLS communication, when the Vault server
 * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
 * This parameter is ignored for plain HTTP protocol connection.
 * It's worth noting this configuration is different from the "TLS certificates auth method",
 * which is available under the `auth.cert` section.
 *
 * @schema SecretStoreSpecProviderVaultTls
 */
export interface SecretStoreSpecProviderVaultTls {
  /**
   * CertSecretRef is a certificate added to the transport layer
   * when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
   *
   * @schema SecretStoreSpecProviderVaultTls#certSecretRef
   */
  readonly certSecretRef?: SecretStoreSpecProviderVaultTlsCertSecretRef;

  /**
   * KeySecretRef to a key in a Secret resource containing client private key
   * added to the transport layer when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.key'.
   *
   * @schema SecretStoreSpecProviderVaultTls#keySecretRef
   */
  readonly keySecretRef?: SecretStoreSpecProviderVaultTlsKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultTls(obj: SecretStoreSpecProviderVaultTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreSpecProviderVaultTlsCertSecretRef(obj.certSecretRef),
    'keySecretRef': toJson_SecretStoreSpecProviderVaultTlsKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or
 * "v2". Version defaults to "v2".
 *
 * @schema SecretStoreSpecProviderVaultVersion
 */
export enum SecretStoreSpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * Auth specifies a authorization protocol. Only one protocol may be set.
 *
 * @schema SecretStoreSpecProviderWebhookAuth
 */
export interface SecretStoreSpecProviderWebhookAuth {
  /**
   * NTLMProtocol configures the store to use NTLM for auth
   *
   * @schema SecretStoreSpecProviderWebhookAuth#ntlm
   */
  readonly ntlm?: SecretStoreSpecProviderWebhookAuthNtlm;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookAuth(obj: SecretStoreSpecProviderWebhookAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ntlm': toJson_SecretStoreSpecProviderWebhookAuthNtlm(obj.ntlm),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema SecretStoreSpecProviderWebhookCaProvider
 */
export interface SecretStoreSpecProviderWebhookCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#type
   */
  readonly type: SecretStoreSpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookCaProvider(obj: SecretStoreSpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema SecretStoreSpecProviderWebhookResult
 */
export interface SecretStoreSpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema SecretStoreSpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookResult(obj: SecretStoreSpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderWebhookSecrets
 */
export interface SecretStoreSpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema SecretStoreSpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema SecretStoreSpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookSecrets(obj: SecretStoreSpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_SecretStoreSpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema SecretStoreSpecProviderYandexcertificatemanagerAuth
 */
export interface SecretStoreSpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexcertificatemanagerAuth(obj: SecretStoreSpecProviderYandexcertificatemanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProvider
 */
export interface SecretStoreSpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexcertificatemanagerCaProvider(obj: SecretStoreSpecProviderYandexcertificatemanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema SecretStoreSpecProviderYandexlockboxAuth
 */
export interface SecretStoreSpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxAuth(obj: SecretStoreSpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreSpecProviderYandexlockboxCaProvider
 */
export interface SecretStoreSpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxCaProvider(obj: SecretStoreSpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount
 * token stored in the named Secret resource.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Akeyless. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Akeyless. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details
 * to authenticate with Akeyless.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderAkeylessCaProviderType
 */
export enum SecretStoreSpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema SecretStoreSpecProviderAlibabaAuthRrsa
 */
export interface SecretStoreSpecProviderAlibabaAuthRrsa {
  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthRrsa(obj: SecretStoreSpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRef(obj: SecretStoreSpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema SecretStoreSpecProviderAwsAuthJwt
 */
export interface SecretStoreSpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthJwt(obj: SecretStoreSpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials
 * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRef(obj: SecretStoreSpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientCertificate of the service principle used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate(obj: SecretStoreSpecProviderAzurekvAuthSecretRefClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle or managed identity used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj: SecretStoreSpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure tenantId of the managed identity used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefTenantId
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefTenantId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefTenantId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefTenantId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefTenantId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefTenantId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefTenantId(obj: SecretStoreSpecProviderAzurekvAuthSecretRefTenantId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey If not provided then ClientID/ClientSecret become required.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthApiKey
 */
export interface SecretStoreSpecProviderBeyondtrustAuthApiKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthApiKey#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthApiKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthApiKey(obj: SecretStoreSpecProviderBeyondtrustAuthApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthCertificate
 */
export interface SecretStoreSpecProviderBeyondtrustAuthCertificate {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificate#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificate#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthCertificate(obj: SecretStoreSpecProviderBeyondtrustAuthCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKey
 */
export interface SecretStoreSpecProviderBeyondtrustAuthCertificateKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKey#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthCertificateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateKey(obj: SecretStoreSpecProviderBeyondtrustAuthCertificateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the API OAuth Client ID.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthClientId
 */
export interface SecretStoreSpecProviderBeyondtrustAuthClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientId#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthClientId(obj: SecretStoreSpecProviderBeyondtrustAuthClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the API OAuth Client Secret.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecret
 */
export interface SecretStoreSpecProviderBeyondtrustAuthClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecret#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthClientSecret(obj: SecretStoreSpecProviderBeyondtrustAuthClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef
 */
export interface SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
   * AccessToken used for the bitwarden instance.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
   */
  readonly credentials: SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef(obj: SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanagerCaProviderType
 */
export enum SecretStoreSpecProviderBitwardensecretsmanagerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * ChefAuthSecretRef holds secret references for chef server login credentials.
 *
 * @schema SecretStoreSpecProviderChefAuthSecretRef
 */
export interface SecretStoreSpecProviderChefAuthSecretRef {
  /**
   * SecretKey is the Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreSpecProviderChefAuthSecretRef#privateKeySecretRef
   */
  readonly privateKeySecretRef: SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderChefAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderChefAuthSecretRef(obj: SecretStoreSpecProviderChefAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKeySecretRef': toJson_SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
 *
 * @schema SecretStoreSpecProviderCloudrusmAuthSecretRef
 */
export interface SecretStoreSpecProviderCloudrusmAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderCloudrusmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderCloudrusmAuthSecretRef(obj: SecretStoreSpecProviderCloudrusmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticates with Conjur using an API key.
 *
 * @schema SecretStoreSpecProviderConjurAuthApikey
 */
export interface SecretStoreSpecProviderConjurAuthApikey {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' containing the Conjur API key
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: SecretStoreSpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' containing the Conjur username
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: SecretStoreSpecProviderConjurAuthApikeyUserRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthApikey(obj: SecretStoreSpecProviderConjurAuthApikey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'apiKeyRef': toJson_SecretStoreSpecProviderConjurAuthApikeyApiKeyRef(obj.apiKeyRef),
    'userRef': toJson_SecretStoreSpecProviderConjurAuthApikeyUserRef(obj.userRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt enables JWT authentication using Kubernetes service account tokens.
 *
 * @schema SecretStoreSpecProviderConjurAuthJwt
 */
export interface SecretStoreSpecProviderConjurAuthJwt {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional HostID for JWT authentication. This may be used depending
   * on how the Conjur JWT authenticator policy is configured.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwt#hostId
   */
  readonly hostId?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Conjur using the JWT authentication method.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema SecretStoreSpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthJwt(obj: SecretStoreSpecProviderConjurAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'hostId': obj.hostId,
    'secretRef': toJson_SecretStoreSpecProviderConjurAuthJwtSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreSpecProviderConjurAuthJwtServiceAccountRef(obj.serviceAccountRef),
    'serviceID': obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderConjurCaProviderType
 */
export enum SecretStoreSpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderDelineaClientIdSecretRef
 */
export interface SecretStoreSpecProviderDelineaClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDelineaClientIdSecretRef(obj: SecretStoreSpecProviderDelineaClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderDelineaClientSecretSecretRef
 */
export interface SecretStoreSpecProviderDelineaClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDelineaClientSecretSecretRef(obj: SecretStoreSpecProviderDelineaClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderDevice42AuthSecretRef
 */
export interface SecretStoreSpecProviderDevice42AuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema SecretStoreSpecProviderDevice42AuthSecretRef#credentials
   */
  readonly credentials?: SecretStoreSpecProviderDevice42AuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDevice42AuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDevice42AuthSecretRef(obj: SecretStoreSpecProviderDevice42AuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreSpecProviderDevice42AuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderDopplerAuthSecretRef
 */
export interface SecretStoreSpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication.
   * See https://docs.doppler.com/reference/api#authentication for auth token types.
   * The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema SecretStoreSpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDopplerAuthSecretRef(obj: SecretStoreSpecProviderDopplerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dopplerToken': toJson_SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken(obj.dopplerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the SDKMS API Key.
 *
 * @schema SecretStoreSpecProviderFortanixApiKeySecretRef
 */
export interface SecretStoreSpecProviderFortanixApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderFortanixApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderFortanixApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderFortanixApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderFortanixApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderFortanixApiKeySecretRef(obj: SecretStoreSpecProviderFortanixApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderGcpsmAuthSecretRef
 */
export interface SecretStoreSpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthSecretRef(obj: SecretStoreSpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity
 */
export interface SecretStoreSpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * ClusterLocation is the location of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation?: string;

  /**
   * ClusterName is the name of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterProjectID is the project ID of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderGithubAuthPrivateKey
 */
export interface SecretStoreSpecProviderGithubAuthPrivateKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderGithubAuthPrivateKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderGithubAuthPrivateKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGithubAuthPrivateKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGithubAuthPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGithubAuthPrivateKey(obj: SecretStoreSpecProviderGithubAuthPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderGitlabAuthSecretRef
 */
export interface SecretStoreSpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuthSecretRef(obj: SecretStoreSpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderGitlabCaProviderType
 */
export enum SecretStoreSpecProviderGitlabCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema SecretStoreSpecProviderIbmAuthContainerAuth
 */
export interface SecretStoreSpecProviderIbmAuthContainerAuth {
  /**
   * @schema SecretStoreSpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema SecretStoreSpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema SecretStoreSpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderIbmAuthContainerAuth(obj: SecretStoreSpecProviderIbmAuthContainerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamEndpoint': obj.iamEndpoint,
    'profile': obj.profile,
    'tokenLocation': obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderIbmAuthSecretRef
 */
export interface SecretStoreSpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderIbmAuthSecretRef(obj: SecretStoreSpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials
 */
export interface SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials#identityId
   */
  readonly identityId: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials#resource
   */
  readonly resource?: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials(obj: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityId': toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId(obj.identityId),
    'resource': toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource(obj.resource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials
 */
export interface SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials#clientId
   */
  readonly clientId: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
   */
  readonly clientSecret: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials(obj: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCert
 */
export interface SecretStoreSpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreSpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: SecretStoreSpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCert(obj: SecretStoreSpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_SecretStoreSpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_SecretStoreSpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount
 */
export interface SecretStoreSpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthServiceAccount(obj: SecretStoreSpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema SecretStoreSpecProviderKubernetesAuthToken
 */
export interface SecretStoreSpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: SecretStoreSpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthToken(obj: SecretStoreSpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_SecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreSpecProviderKubernetesServerCaProvider
 */
export interface SecretStoreSpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#type
   */
  readonly type: SecretStoreSpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesServerCaProvider(obj: SecretStoreSpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbaseAPIKey is the APIKey generated by an admin account.
 * It is used to recognize and authorize access to a project and environment within onboardbase
 *
 * @schema SecretStoreSpecProviderOnboardbaseAuthApiKeyRef
 */
export interface SecretStoreSpecProviderOnboardbaseAuthApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnboardbaseAuthApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnboardbaseAuthApiKeyRef(obj: SecretStoreSpecProviderOnboardbaseAuthApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbasePasscode is the passcode attached to the API Key
 *
 * @schema SecretStoreSpecProviderOnboardbaseAuthPasscodeRef
 */
export interface SecretStoreSpecProviderOnboardbaseAuthPasscodeRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthPasscodeRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthPasscodeRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOnboardbaseAuthPasscodeRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnboardbaseAuthPasscodeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnboardbaseAuthPasscodeRef(obj: SecretStoreSpecProviderOnboardbaseAuthPasscodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema SecretStoreSpecProviderOnepasswordAuthSecretRef
 */
export interface SecretStoreSpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema SecretStoreSpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordAuthSecretRef(obj: SecretStoreSpecProviderOnepasswordAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTokenSecretRef': toJson_SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj.connectTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountSecretRef points to the secret containing the token to access 1Password vault.
 *
 * @schema SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef
 */
export interface SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef(obj: SecretStoreSpecProviderOnepasswordSdkAuthServiceAccountSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRef
 */
export interface SecretStoreSpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: SecretStoreSpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRef(obj: SecretStoreSpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_SecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderPassboltAuthPasswordSecretRef
 */
export interface SecretStoreSpecProviderPassboltAuthPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassboltAuthPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassboltAuthPasswordSecretRef(obj: SecretStoreSpecProviderPassboltAuthPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef
 */
export interface SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef(obj: SecretStoreSpecProviderPassboltAuthPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreSpecProviderPassworddepotAuthSecretRef
 */
export interface SecretStoreSpecProviderPassworddepotAuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema SecretStoreSpecProviderPassworddepotAuthSecretRef#credentials
   */
  readonly credentials?: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassworddepotAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassworddepotAuthSecretRef(obj: SecretStoreSpecProviderPassworddepotAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
 *
 * @schema SecretStoreSpecProviderPreviderAuthSecretRef
 */
export interface SecretStoreSpecProviderPreviderAuthSecretRef {
  /**
   * The AccessToken is used for authentication
   *
   * @schema SecretStoreSpecProviderPreviderAuthSecretRef#accessToken
   */
  readonly accessToken: SecretStoreSpecProviderPreviderAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPreviderAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPreviderAuthSecretRef(obj: SecretStoreSpecProviderPreviderAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreSpecProviderPreviderAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the Pulumi API token.
 *
 * @schema SecretStoreSpecProviderPulumiAccessTokenSecretRef
 */
export interface SecretStoreSpecProviderPulumiAccessTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderPulumiAccessTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderPulumiAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderPulumiAccessTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPulumiAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPulumiAccessTokenSecretRef(obj: SecretStoreSpecProviderPulumiAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderScalewayAccessKeySecretRef
 */
export interface SecretStoreSpecProviderScalewayAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderScalewayAccessKeySecretRef(obj: SecretStoreSpecProviderScalewayAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderScalewaySecretKeySecretRef
 */
export interface SecretStoreSpecProviderScalewaySecretKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderScalewaySecretKeySecretRef(obj: SecretStoreSpecProviderScalewaySecretKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderSecretserverPasswordSecretRef
 */
export interface SecretStoreSpecProviderSecretserverPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderSecretserverPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderSecretserverPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderSecretserverPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSecretserverPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSecretserverPasswordSecretRef(obj: SecretStoreSpecProviderSecretserverPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderSecretserverUsernameSecretRef
 */
export interface SecretStoreSpecProviderSecretserverUsernameSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderSecretserverUsernameSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderSecretserverUsernameSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderSecretserverUsernameSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSecretserverUsernameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSecretserverUsernameSecretRef(obj: SecretStoreSpecProviderSecretserverUsernameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef(obj: SecretStoreSpecProviderSenhaseguraAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism,
 * with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema SecretStoreSpecProviderVaultAuthAppRole
 */
export interface SecretStoreSpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted
   * in Vault, e.g: "approle"
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting
   * up the authentication backend in Vault.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role id.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: SecretStoreSpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role secret.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthAppRole(obj: SecretStoreSpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_SecretStoreSpecProviderVaultAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
 * Cert authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCert
 */
export interface SecretStoreSpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault
   * authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreSpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to
   * authenticate with Vault using the Cert authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCert(obj: SecretStoreSpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_SecretStoreSpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
 * AWS IAM authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthIam
 */
export interface SecretStoreSpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: SecretStoreSpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema SecretStoreSpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIam(obj: SecretStoreSpecProviderVaultAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_SecretStoreSpecProviderVaultAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the
 * JWT/OIDC authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthJwt
 */
export interface SecretStoreSpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted
   * in Vault, e.g: "jwt"
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault
   * authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwt(obj: SecretStoreSpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount
 * token stored in the named Secret resource to the Vault server.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetes
 */
export interface SecretStoreSpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g:
   * "kubernetes"
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a
   * Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Vault. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Vault. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetes(obj: SecretStoreSpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using
 * the LDAP authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthLdap
 */
export interface SecretStoreSpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted
   * in Vault, e.g: "ldap"
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP
   * user used to authenticate with Vault using the LDAP authentication
   * method
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is an LDAP username used to authenticate using the LDAP Vault
   * authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthLdap(obj: SecretStoreSpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthTokenSecretRef(obj: SecretStoreSpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema SecretStoreSpecProviderVaultAuthUserPass
 */
export interface SecretStoreSpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted
   * in Vault, e.g: "userpass"
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the
   * user used to authenticate with Vault using the UserPass authentication
   * method
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a username used to authenticate using the UserPass Vault
   * authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthUserPass(obj: SecretStoreSpecProviderVaultAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_SecretStoreSpecProviderVaultAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderVaultCaProviderType
 */
export enum SecretStoreSpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * CertSecretRef is a certificate added to the transport layer
 * when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
 *
 * @schema SecretStoreSpecProviderVaultTlsCertSecretRef
 */
export interface SecretStoreSpecProviderVaultTlsCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultTlsCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultTlsCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultTlsCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultTlsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultTlsCertSecretRef(obj: SecretStoreSpecProviderVaultTlsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySecretRef to a key in a Secret resource containing client private key
 * added to the transport layer when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.key'.
 *
 * @schema SecretStoreSpecProviderVaultTlsKeySecretRef
 */
export interface SecretStoreSpecProviderVaultTlsKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultTlsKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultTlsKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultTlsKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultTlsKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultTlsKeySecretRef(obj: SecretStoreSpecProviderVaultTlsKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NTLMProtocol configures the store to use NTLM for auth
 *
 * @schema SecretStoreSpecProviderWebhookAuthNtlm
 */
export interface SecretStoreSpecProviderWebhookAuthNtlm {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlm#passwordSecret
   */
  readonly passwordSecret: SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlm#usernameSecret
   */
  readonly usernameSecret: SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookAuthNtlm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookAuthNtlm(obj: SecretStoreSpecProviderWebhookAuthNtlm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecret': toJson_SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret(obj.passwordSecret),
    'usernameSecret': toJson_SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret(obj.usernameSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderWebhookCaProviderType
 */
export enum SecretStoreSpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema SecretStoreSpecProviderWebhookSecretsSecretRef
 */
export interface SecretStoreSpecProviderWebhookSecretsSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookSecretsSecretRef(obj: SecretStoreSpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj: SecretStoreSpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj: SecretStoreSpecProviderYandexcertificatemanagerCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Akeyless. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Akeyless. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef
 */
export interface SecretStoreSpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj: SecretStoreSpecProviderAwsAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef
 */
export interface SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef(obj: SecretStoreSpecProviderBeyondtrustAuthApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef
 */
export interface SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef(obj: SecretStoreSpecProviderBeyondtrustAuthCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef
 */
export interface SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef(obj: SecretStoreSpecProviderBeyondtrustAuthCertificateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef
 */
export interface SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef(obj: SecretStoreSpecProviderBeyondtrustAuthClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef
 */
export interface SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef(obj: SecretStoreSpecProviderBeyondtrustAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken used for the bitwarden instance.
 *
 * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
 */
export interface SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj: SecretStoreSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef
 */
export interface SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef(obj: SecretStoreSpecProviderChefAuthSecretRefPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj: SecretStoreSpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur API key
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderConjurAuthApikeyApiKeyRef
 */
export interface SecretStoreSpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthApikeyApiKeyRef(obj: SecretStoreSpecProviderConjurAuthApikeyApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur username
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderConjurAuthApikeyUserRef
 */
export interface SecretStoreSpecProviderConjurAuthApikeyUserRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthApikeyUserRef(obj: SecretStoreSpecProviderConjurAuthApikeyUserRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Conjur using the JWT authentication method.
 *
 * @schema SecretStoreSpecProviderConjurAuthJwtSecretRef
 */
export interface SecretStoreSpecProviderConjurAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthJwtSecretRef(obj: SecretStoreSpecProviderConjurAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreSpecProviderConjurAuthJwtServiceAccountRef
 */
export interface SecretStoreSpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderConjurAuthJwtServiceAccountRef(obj: SecretStoreSpecProviderConjurAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema SecretStoreSpecProviderDevice42AuthSecretRefCredentials
 */
export interface SecretStoreSpecProviderDevice42AuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderDevice42AuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderDevice42AuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderDevice42AuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDevice42AuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDevice42AuthSecretRefCredentials(obj: SecretStoreSpecProviderDevice42AuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The DopplerToken is used for authentication.
 * See https://docs.doppler.com/reference/api#authentication for auth token types.
 * The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken(obj: SecretStoreSpecProviderDopplerAuthSecretRefDopplerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken
 */
export interface SecretStoreSpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId
 */
export interface SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId(obj: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsIdentityId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource
 */
export interface SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource(obj: SecretStoreSpecProviderInfisicalAuthAzureAuthCredentialsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId
 */
export interface SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
 */
export interface SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj: SecretStoreSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert
 */
export interface SecretStoreSpecProviderKubernetesAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCertClientCert(obj: SecretStoreSpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey
 */
export interface SecretStoreSpecProviderKubernetesAuthCertClientKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCertClientKey(obj: SecretStoreSpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken
 */
export interface SecretStoreSpecProviderKubernetesAuthTokenBearerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj: SecretStoreSpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderKubernetesServerCaProviderType
 */
export enum SecretStoreSpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj: SecretStoreSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint
 */
export interface SecretStoreSpecProviderOracleAuthSecretRefFingerprint {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj: SecretStoreSpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey
 */
export interface SecretStoreSpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials
 */
export interface SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(obj: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessToken is used for authentication
 *
 * @schema SecretStoreSpecProviderPreviderAuthSecretRefAccessToken
 */
export interface SecretStoreSpecProviderPreviderAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderPreviderAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderPreviderAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderPreviderAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderPreviderAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderPreviderAuthSecretRefAccessToken(obj: SecretStoreSpecProviderPreviderAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role id.
 *
 * @schema SecretStoreSpecProviderVaultAuthAppRoleRoleRef
 */
export interface SecretStoreSpecProviderVaultAuthAppRoleRoleRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthAppRoleRoleRef(obj: SecretStoreSpecProviderVaultAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role secret.
 *
 * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthAppRoleSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj: SecretStoreSpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault
 * authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCertClientCert
 */
export interface SecretStoreSpecProviderVaultAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCertClientCert(obj: SecretStoreSpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to
 * authenticate with Vault using the Cert authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCertSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCertSecretRef(obj: SecretStoreSpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema SecretStoreSpecProviderVaultAuthIamJwt
 */
export interface SecretStoreSpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamJwt(obj: SecretStoreSpecProviderVaultAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema SecretStoreSpecProviderVaultAuthIamSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamSecretRef(obj: SecretStoreSpecProviderVaultAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service
   * account token for the service account referenced by `serviceAccountRef`.
   * Defaults to a single audience `vault` it not specified.
   * Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified.
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary
   * Kubernetes service account token for the service account referenced by
   * `serviceAccountRef`.
   * Deprecated: this will be removed in the future.
   * Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtSecretRef(obj: SecretStoreSpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Vault. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthKubernetesSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj: SecretStoreSpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Vault. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP
 * user used to authenticate with Vault using the LDAP authentication
 * method
 *
 * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthLdapSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthLdapSecretRef(obj: SecretStoreSpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the
 * user used to authenticate with Vault using the UserPass authentication
 * method
 *
 * @schema SecretStoreSpecProviderVaultAuthUserPassSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthUserPassSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthUserPassSecretRef(obj: SecretStoreSpecProviderVaultAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret
 */
export interface SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret(obj: SecretStoreSpecProviderWebhookAuthNtlmPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret
 */
export interface SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret(obj: SecretStoreSpecProviderWebhookAuthNtlmUsernameSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef(obj: SecretStoreSpecProviderVaultAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj: SecretStoreSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj: SecretStoreSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj: SecretStoreSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStoreV1Beta1
 */
export class SecretStoreV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretStoreV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'SecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "SecretStoreV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretStoreV1Beta1Props = {}): any {
    return {
      ...SecretStoreV1Beta1.GVK,
      ...toJson_SecretStoreV1Beta1Props(props),
    };
  }

  /**
   * Defines a "SecretStoreV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretStoreV1Beta1Props = {}) {
    super(scope, id, {
      ...SecretStoreV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretStoreV1Beta1.GVK,
      ...toJson_SecretStoreV1Beta1Props(resolved),
    };
  }
}

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStoreV1Beta1
 */
export interface SecretStoreV1Beta1Props {
  /**
   * @schema SecretStoreV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema SecretStoreV1Beta1#spec
   */
  readonly spec?: SecretStoreV1Beta1Spec;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1Props(obj: SecretStoreV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretStoreV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema SecretStoreV1Beta1Spec
 */
export interface SecretStoreV1Beta1Spec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema SecretStoreV1Beta1Spec#conditions
   */
  readonly conditions?: SecretStoreV1Beta1SpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName)
   * The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema SecretStoreV1Beta1Spec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema SecretStoreV1Beta1Spec#provider
   */
  readonly provider: SecretStoreV1Beta1SpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema SecretStoreV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema SecretStoreV1Beta1Spec#retrySettings
   */
  readonly retrySettings?: SecretStoreV1Beta1SpecRetrySettings;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1Spec(obj: SecretStoreV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_SecretStoreV1Beta1SpecConditions(y)),
    'controller': obj.controller,
    'provider': toJson_SecretStoreV1Beta1SpecProvider(obj.provider),
    'refreshInterval': obj.refreshInterval,
    'retrySettings': toJson_SecretStoreV1Beta1SpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in
 * for a ClusterSecretStore instance.
 *
 * @schema SecretStoreV1Beta1SpecConditions
 */
export interface SecretStoreV1Beta1SpecConditions {
  /**
   * Choose namespaces by using regex matching
   *
   * @schema SecretStoreV1Beta1SpecConditions#namespaceRegexes
   */
  readonly namespaceRegexes?: string[];

  /**
   * Choose namespace using a labelSelector
   *
   * @schema SecretStoreV1Beta1SpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: SecretStoreV1Beta1SpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema SecretStoreV1Beta1SpecConditions#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecConditions(obj: SecretStoreV1Beta1SpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceRegexes': obj.namespaceRegexes?.map(y => y),
    'namespaceSelector': toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema SecretStoreV1Beta1SpecProvider
 */
export interface SecretStoreV1Beta1SpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#akeyless
   */
  readonly akeyless?: SecretStoreV1Beta1SpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#alibaba
   */
  readonly alibaba?: SecretStoreV1Beta1SpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#aws
   */
  readonly aws?: SecretStoreV1Beta1SpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#azurekv
   */
  readonly azurekv?: SecretStoreV1Beta1SpecProviderAzurekv;

  /**
   * Beyondtrust configures this store to sync secrets using Password Safe provider.
   *
   * @schema SecretStoreV1Beta1SpecProvider#beyondtrust
   */
  readonly beyondtrust?: SecretStoreV1Beta1SpecProviderBeyondtrust;

  /**
   * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#bitwardensecretsmanager
   */
  readonly bitwardensecretsmanager?: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager;

  /**
   * Chef configures this store to sync secrets with chef server
   *
   * @schema SecretStoreV1Beta1SpecProvider#chef
   */
  readonly chef?: SecretStoreV1Beta1SpecProviderChef;

  /**
   * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#cloudrusm
   */
  readonly cloudrusm?: SecretStoreV1Beta1SpecProviderCloudrusm;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#conjur
   */
  readonly conjur?: SecretStoreV1Beta1SpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault
   * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema SecretStoreV1Beta1SpecProvider#delinea
   */
  readonly delinea?: SecretStoreV1Beta1SpecProviderDelinea;

  /**
   * Device42 configures this store to sync secrets using the Device42 provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#device42
   */
  readonly device42?: SecretStoreV1Beta1SpecProviderDevice42;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#doppler
   */
  readonly doppler?: SecretStoreV1Beta1SpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema SecretStoreV1Beta1SpecProvider#fake
   */
  readonly fake?: SecretStoreV1Beta1SpecProviderFake;

  /**
   * Fortanix configures this store to sync secrets using the Fortanix provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#fortanix
   */
  readonly fortanix?: SecretStoreV1Beta1SpecProviderFortanix;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#gcpsm
   */
  readonly gcpsm?: SecretStoreV1Beta1SpecProviderGcpsm;

  /**
   * Github configures this store to push Github Action secrets using Github API provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#github
   */
  readonly github?: SecretStoreV1Beta1SpecProviderGithub;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#gitlab
   */
  readonly gitlab?: SecretStoreV1Beta1SpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#ibm
   */
  readonly ibm?: SecretStoreV1Beta1SpecProviderIbm;

  /**
   * Infisical configures this store to sync secrets using the Infisical provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#infisical
   */
  readonly infisical?: SecretStoreV1Beta1SpecProviderInfisical;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#keepersecurity
   */
  readonly keepersecurity?: SecretStoreV1Beta1SpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#kubernetes
   */
  readonly kubernetes?: SecretStoreV1Beta1SpecProviderKubernetes;

  /**
   * Onboardbase configures this store to sync secrets using the Onboardbase provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#onboardbase
   */
  readonly onboardbase?: SecretStoreV1Beta1SpecProviderOnboardbase;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#onepassword
   */
  readonly onepassword?: SecretStoreV1Beta1SpecProviderOnepassword;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#oracle
   */
  readonly oracle?: SecretStoreV1Beta1SpecProviderOracle;

  /**
   * @schema SecretStoreV1Beta1SpecProvider#passbolt
   */
  readonly passbolt?: SecretStoreV1Beta1SpecProviderPassbolt;

  /**
   * Configures a store to sync secrets with a Password Depot instance.
   *
   * @schema SecretStoreV1Beta1SpecProvider#passworddepot
   */
  readonly passworddepot?: SecretStoreV1Beta1SpecProviderPassworddepot;

  /**
   * Previder configures this store to sync secrets using the Previder provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#previder
   */
  readonly previder?: SecretStoreV1Beta1SpecProviderPrevider;

  /**
   * Pulumi configures this store to sync secrets using the Pulumi provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#pulumi
   */
  readonly pulumi?: SecretStoreV1Beta1SpecProviderPulumi;

  /**
   * Scaleway
   *
   * @schema SecretStoreV1Beta1SpecProvider#scaleway
   */
  readonly scaleway?: SecretStoreV1Beta1SpecProviderScaleway;

  /**
   * SecretServer configures this store to sync secrets using SecretServer provider
   * https://docs.delinea.com/online-help/secret-server/start.htm
   *
   * @schema SecretStoreV1Beta1SpecProvider#secretserver
   */
  readonly secretserver?: SecretStoreV1Beta1SpecProviderSecretserver;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#senhasegura
   */
  readonly senhasegura?: SecretStoreV1Beta1SpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#vault
   */
  readonly vault?: SecretStoreV1Beta1SpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema SecretStoreV1Beta1SpecProvider#webhook
   */
  readonly webhook?: SecretStoreV1Beta1SpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: SecretStoreV1Beta1SpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: SecretStoreV1Beta1SpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProvider(obj: SecretStoreV1Beta1SpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_SecretStoreV1Beta1SpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_SecretStoreV1Beta1SpecProviderAlibaba(obj.alibaba),
    'aws': toJson_SecretStoreV1Beta1SpecProviderAws(obj.aws),
    'azurekv': toJson_SecretStoreV1Beta1SpecProviderAzurekv(obj.azurekv),
    'beyondtrust': toJson_SecretStoreV1Beta1SpecProviderBeyondtrust(obj.beyondtrust),
    'bitwardensecretsmanager': toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanager(obj.bitwardensecretsmanager),
    'chef': toJson_SecretStoreV1Beta1SpecProviderChef(obj.chef),
    'cloudrusm': toJson_SecretStoreV1Beta1SpecProviderCloudrusm(obj.cloudrusm),
    'conjur': toJson_SecretStoreV1Beta1SpecProviderConjur(obj.conjur),
    'delinea': toJson_SecretStoreV1Beta1SpecProviderDelinea(obj.delinea),
    'device42': toJson_SecretStoreV1Beta1SpecProviderDevice42(obj.device42),
    'doppler': toJson_SecretStoreV1Beta1SpecProviderDoppler(obj.doppler),
    'fake': toJson_SecretStoreV1Beta1SpecProviderFake(obj.fake),
    'fortanix': toJson_SecretStoreV1Beta1SpecProviderFortanix(obj.fortanix),
    'gcpsm': toJson_SecretStoreV1Beta1SpecProviderGcpsm(obj.gcpsm),
    'github': toJson_SecretStoreV1Beta1SpecProviderGithub(obj.github),
    'gitlab': toJson_SecretStoreV1Beta1SpecProviderGitlab(obj.gitlab),
    'ibm': toJson_SecretStoreV1Beta1SpecProviderIbm(obj.ibm),
    'infisical': toJson_SecretStoreV1Beta1SpecProviderInfisical(obj.infisical),
    'keepersecurity': toJson_SecretStoreV1Beta1SpecProviderKeepersecurity(obj.keepersecurity),
    'kubernetes': toJson_SecretStoreV1Beta1SpecProviderKubernetes(obj.kubernetes),
    'onboardbase': toJson_SecretStoreV1Beta1SpecProviderOnboardbase(obj.onboardbase),
    'onepassword': toJson_SecretStoreV1Beta1SpecProviderOnepassword(obj.onepassword),
    'oracle': toJson_SecretStoreV1Beta1SpecProviderOracle(obj.oracle),
    'passbolt': toJson_SecretStoreV1Beta1SpecProviderPassbolt(obj.passbolt),
    'passworddepot': toJson_SecretStoreV1Beta1SpecProviderPassworddepot(obj.passworddepot),
    'previder': toJson_SecretStoreV1Beta1SpecProviderPrevider(obj.previder),
    'pulumi': toJson_SecretStoreV1Beta1SpecProviderPulumi(obj.pulumi),
    'scaleway': toJson_SecretStoreV1Beta1SpecProviderScaleway(obj.scaleway),
    'secretserver': toJson_SecretStoreV1Beta1SpecProviderSecretserver(obj.secretserver),
    'senhasegura': toJson_SecretStoreV1Beta1SpecProviderSenhasegura(obj.senhasegura),
    'vault': toJson_SecretStoreV1Beta1SpecProviderVault(obj.vault),
    'webhook': toJson_SecretStoreV1Beta1SpecProviderWebhook(obj.webhook),
    'yandexcertificatemanager': toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj.yandexcertificatemanager),
    'yandexlockbox': toJson_SecretStoreV1Beta1SpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema SecretStoreV1Beta1SpecRetrySettings
 */
export interface SecretStoreV1Beta1SpecRetrySettings {
  /**
   * @schema SecretStoreV1Beta1SpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema SecretStoreV1Beta1SpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecRetrySettings(obj: SecretStoreV1Beta1SpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector
 */
export interface SecretStoreV1Beta1SpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelector(obj: SecretStoreV1Beta1SpecConditionsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeyless
 */
export interface SecretStoreV1Beta1SpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used
   * if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeyless(obj: SecretStoreV1Beta1SpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibaba
 */
export interface SecretStoreV1Beta1SpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibaba#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibaba(obj: SecretStoreV1Beta1SpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAws
 */
export interface SecretStoreV1Beta1SpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS
   * if not set aws sdk will infer credentials from your environment
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * Prefix adds a prefix to all retrieved values.
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#prefix
   */
  readonly prefix?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#secretsManager
   */
  readonly secretsManager?: SecretStoreV1Beta1SpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#service
   */
  readonly service: SecretStoreV1Beta1SpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#sessionTags
   */
  readonly sessionTags?: SecretStoreV1Beta1SpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAws(obj: SecretStoreV1Beta1SpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalRoles': obj.additionalRoles?.map(y => y),
    'auth': toJson_SecretStoreV1Beta1SpecProviderAwsAuth(obj.auth),
    'externalID': obj.externalId,
    'prefix': obj.prefix,
    'region': obj.region,
    'role': obj.role,
    'secretsManager': toJson_SecretStoreV1Beta1SpecProviderAwsSecretsManager(obj.secretsManager),
    'service': obj.service,
    'sessionTags': obj.sessionTags?.map(y => toJson_SecretStoreV1Beta1SpecProviderAwsSessionTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekv
 */
export interface SecretStoreV1Beta1SpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service.
   * Valid values are:
   * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
   * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#authType
   */
  readonly authType?: SecretStoreV1Beta1SpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for
   * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
   * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
   * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#environmentType
   */
  readonly environmentType?: SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekv(obj: SecretStoreV1Beta1SpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'environmentType': obj.environmentType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Beyondtrust configures this store to sync secrets using Password Safe provider.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrust
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrust {
  /**
   * Auth configures how the operator authenticates with Beyondtrust.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrust#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderBeyondtrustAuth;

  /**
   * Auth configures how API server works.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrust#server
   */
  readonly server: SecretStoreV1Beta1SpecProviderBeyondtrustServer;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrust' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrust(obj: SecretStoreV1Beta1SpecProviderBeyondtrust | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuth(obj.auth),
    'server': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager
 */
export interface SecretStoreV1Beta1SpecProviderBitwardensecretsmanager {
  /**
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
   * Make sure that the token being used has permissions on the given secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth;

  /**
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
   */
  readonly bitwardenServerSdkurl?: string;

  /**
   * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider;

  /**
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#identityURL
   */
  readonly identityUrl?: string;

  /**
   * OrganizationID determines which organization this secret store manages.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#organizationID
   */
  readonly organizationId: string;

  /**
   * ProjectID determines which project this secret store manages.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBitwardensecretsmanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanager(obj: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'auth': toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(obj.auth),
    'bitwardenServerSDKURL': obj.bitwardenServerSdkurl,
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(obj.caProvider),
    'identityURL': obj.identityUrl,
    'organizationID': obj.organizationId,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chef configures this store to sync secrets with chef server
 *
 * @schema SecretStoreV1Beta1SpecProviderChef
 */
export interface SecretStoreV1Beta1SpecProviderChef {
  /**
   * Auth defines the information necessary to authenticate against chef Server
   *
   * @schema SecretStoreV1Beta1SpecProviderChef#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderChefAuth;

  /**
   * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
   *
   * @schema SecretStoreV1Beta1SpecProviderChef#serverUrl
   */
  readonly serverUrl: string;

  /**
   * UserName should be the user ID on the chef server
   *
   * @schema SecretStoreV1Beta1SpecProviderChef#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderChef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderChef(obj: SecretStoreV1Beta1SpecProviderChef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderChefAuth(obj.auth),
    'serverUrl': obj.serverUrl,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CloudruSM configures this store to sync secrets using the Cloud.ru Secret Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderCloudrusm
 */
export interface SecretStoreV1Beta1SpecProviderCloudrusm {
  /**
   * CSMAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusm#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderCloudrusmAuth;

  /**
   * ProjectID is the project, which the secrets are stored in.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderCloudrusm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderCloudrusm(obj: SecretStoreV1Beta1SpecProviderCloudrusm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema SecretStoreV1Beta1SpecProviderConjur
 */
export interface SecretStoreV1Beta1SpecProviderConjur {
  /**
   * Defines authentication settings for connecting to Conjur.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjur#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderConjurAuth;

  /**
   * CABundle is a PEM encoded CA bundle that will be used to validate the Conjur server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates
   * for a secret store. The CAProvider points to a Secret or ConfigMap resource
   * that contains a PEM-encoded certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjur#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderConjurCaProvider;

  /**
   * URL is the endpoint of the Conjur instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjur#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjur(obj: SecretStoreV1Beta1SpecProviderConjur | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderConjurAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderConjurCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delinea DevOps Secrets Vault
 * https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema SecretStoreV1Beta1SpecProviderDelinea
 */
export interface SecretStoreV1Beta1SpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#clientId
   */
  readonly clientId: SecretStoreV1Beta1SpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#clientSecret
   */
  readonly clientSecret: SecretStoreV1Beta1SpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning.
   * If unset, defaults to "com".
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate
   * If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelinea(obj: SecretStoreV1Beta1SpecProviderDelinea | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_SecretStoreV1Beta1SpecProviderDelineaClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecret(obj.clientSecret),
    'tenant': obj.tenant,
    'tld': obj.tld,
    'urlTemplate': obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Device42 configures this store to sync secrets using the Device42 provider
 *
 * @schema SecretStoreV1Beta1SpecProviderDevice42
 */
export interface SecretStoreV1Beta1SpecProviderDevice42 {
  /**
   * Auth configures how secret-manager authenticates with a Device42 instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderDevice42Auth;

  /**
   * URL configures the Device42 instance URL.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDevice42' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDevice42(obj: SecretStoreV1Beta1SpecProviderDevice42 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderDevice42Auth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema SecretStoreV1Beta1SpecProviderDoppler
 */
export interface SecretStoreV1Beta1SpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#format
   */
  readonly format?: SecretStoreV1Beta1SpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: SecretStoreV1Beta1SpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDoppler(obj: SecretStoreV1Beta1SpecProviderDoppler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderDopplerAuth(obj.auth),
    'config': obj.config,
    'format': obj.format,
    'nameTransformer': obj.nameTransformer,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema SecretStoreV1Beta1SpecProviderFake
 */
export interface SecretStoreV1Beta1SpecProviderFake {
  /**
   * @schema SecretStoreV1Beta1SpecProviderFake#data
   */
  readonly data: SecretStoreV1Beta1SpecProviderFakeData[];

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFake(obj: SecretStoreV1Beta1SpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_SecretStoreV1Beta1SpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fortanix configures this store to sync secrets using the Fortanix provider
 *
 * @schema SecretStoreV1Beta1SpecProviderFortanix
 */
export interface SecretStoreV1Beta1SpecProviderFortanix {
  /**
   * APIKey is the API token to access SDKMS Applications.
   *
   * @schema SecretStoreV1Beta1SpecProviderFortanix#apiKey
   */
  readonly apiKey?: SecretStoreV1Beta1SpecProviderFortanixApiKey;

  /**
   * APIURL is the URL of SDKMS API. Defaults to `sdkms.fortanix.com`.
   *
   * @default sdkms.fortanix.com`.
   * @schema SecretStoreV1Beta1SpecProviderFortanix#apiUrl
   */
  readonly apiUrl?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFortanix' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFortanix(obj: SecretStoreV1Beta1SpecProviderFortanix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_SecretStoreV1Beta1SpecProviderFortanixApiKey(obj.apiKey),
    'apiUrl': obj.apiUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsm
 */
export interface SecretStoreV1Beta1SpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsm#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderGcpsmAuth;

  /**
   * Location optionally defines a location for a secret
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsm#location
   */
  readonly location?: string;

  /**
   * ProjectID project where secret is located
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsm(obj: SecretStoreV1Beta1SpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderGcpsmAuth(obj.auth),
    'location': obj.location,
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Github configures this store to push Github Action secrets using Github API provider
 *
 * @schema SecretStoreV1Beta1SpecProviderGithub
 */
export interface SecretStoreV1Beta1SpecProviderGithub {
  /**
   * appID specifies the Github APP that will be used to authenticate the client
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#appID
   */
  readonly appId: number;

  /**
   * auth configures how secret-manager authenticates with a Github instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderGithubAuth;

  /**
   * environment will be used to fetch secrets from a particular environment within a github repository
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#environment
   */
  readonly environment?: string;

  /**
   * installationID specifies the Github APP installation that will be used to authenticate the client
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#installationID
   */
  readonly installationId: number;

  /**
   * organization will be used to fetch secrets from the Github organization
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#organization
   */
  readonly organization: string;

  /**
   * repository will be used to fetch secrets from the Github repository within an organization
   *
   * @schema SecretStoreV1Beta1SpecProviderGithub#repository
   */
  readonly repository?: string;

  /**
   * Upload URL for enterprise instances. Default to URL.
   *
   * @default URL.
   * @schema SecretStoreV1Beta1SpecProviderGithub#uploadURL
   */
  readonly uploadUrl?: string;

  /**
   * URL configures the Github instance URL. Defaults to https://github.com/.
   *
   * @default https://github.com/.
   * @schema SecretStoreV1Beta1SpecProviderGithub#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGithub(obj: SecretStoreV1Beta1SpecProviderGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appID': obj.appId,
    'auth': toJson_SecretStoreV1Beta1SpecProviderGithubAuth(obj.auth),
    'environment': obj.environment,
    'installationID': obj.installationId,
    'organization': obj.organization,
    'repository': obj.repository,
    'uploadURL': obj.uploadUrl,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlab
 */
export interface SecretStoreV1Beta1SpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderGitlabAuth;

  /**
   * Base64 encoded certificate for the GitLab server sdk. The sdk MUST run with HTTPS to make sure no MITM attack
   * can be performed.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderGitlabCaProvider;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema SecretStoreV1Beta1SpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlab(obj: SecretStoreV1Beta1SpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderGitlabAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderGitlabCaProvider(obj.caProvider),
    'environment': obj.environment,
    'groupIDs': obj.groupIDs?.map(y => y),
    'inheritFromGroups': obj.inheritFromGroups,
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderIbm
 */
export interface SecretStoreV1Beta1SpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbm#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema SecretStoreV1Beta1SpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbm(obj: SecretStoreV1Beta1SpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Infisical configures this store to sync secrets using the Infisical provider
 *
 * @schema SecretStoreV1Beta1SpecProviderInfisical
 */
export interface SecretStoreV1Beta1SpecProviderInfisical {
  /**
   * Auth configures how the Operator authenticates with the Infisical API
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisical#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderInfisicalAuth;

  /**
   * HostAPI specifies the base URL of the Infisical API. If not provided, it defaults to "https://app.infisical.com/api".
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisical#hostAPI
   */
  readonly hostApi?: string;

  /**
   * SecretsScope defines the scope of the secrets within the workspace
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisical#secretsScope
   */
  readonly secretsScope: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisical(obj: SecretStoreV1Beta1SpecProviderInfisical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderInfisicalAuth(obj.auth),
    'hostAPI': obj.hostApi,
    'secretsScope': toJson_SecretStoreV1Beta1SpecProviderInfisicalSecretsScope(obj.secretsScope),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema SecretStoreV1Beta1SpecProviderKeepersecurity
 */
export interface SecretStoreV1Beta1SpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurity#authRef
   */
  readonly authRef: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef;

  /**
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKeepersecurity(obj: SecretStoreV1Beta1SpecProviderKeepersecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authRef': toJson_SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj.authRef),
    'folderID': obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetes
 */
export interface SecretStoreV1Beta1SpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderKubernetesAuth;

  /**
   * A reference to a secret that contains the auth information.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#authRef
   */
  readonly authRef?: SecretStoreV1Beta1SpecProviderKubernetesAuthRef;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#server
   */
  readonly server?: SecretStoreV1Beta1SpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetes(obj: SecretStoreV1Beta1SpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuth(obj.auth),
    'authRef': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthRef(obj.authRef),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_SecretStoreV1Beta1SpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Onboardbase configures this store to sync secrets using the Onboardbase provider
 *
 * @schema SecretStoreV1Beta1SpecProviderOnboardbase
 */
export interface SecretStoreV1Beta1SpecProviderOnboardbase {
  /**
   * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbase#apiHost
   */
  readonly apiHost: string;

  /**
   * Auth configures how the Operator authenticates with the Onboardbase API
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbase#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderOnboardbaseAuth;

  /**
   * Environment is the name of an environmnent within a project to pull the secrets from
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbase#environment
   */
  readonly environment: string;

  /**
   * Project is an onboardbase project that the secrets should be pulled from
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbase#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnboardbase' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnboardbase(obj: SecretStoreV1Beta1SpecProviderOnboardbase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiHost': obj.apiHost,
    'auth': toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuth(obj.auth),
    'environment': obj.environment,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepassword
 */
export interface SecretStoreV1Beta1SpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepassword(obj: SecretStoreV1Beta1SpecProviderOnepassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuth(obj.auth),
    'connectHost': obj.connectHost,
    'vaults': ((obj.vaults) === undefined) ? undefined : (Object.entries(obj.vaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderOracle
 */
export interface SecretStoreV1Beta1SpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault.
   * If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID.
   * Required for PushSecret
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault.
   * Required for PushSecret
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will
   * determine the principal type. This optional field must be specified if using
   * workload identity.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#principalType
   */
  readonly principalType?: SecretStoreV1Beta1SpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account
   * that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracle(obj: SecretStoreV1Beta1SpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderPassbolt
 */
export interface SecretStoreV1Beta1SpecProviderPassbolt {
  /**
   * Auth defines the information necessary to authenticate against Passbolt Server
   *
   * @schema SecretStoreV1Beta1SpecProviderPassbolt#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderPassboltAuth;

  /**
   * Host defines the Passbolt Server to connect to
   *
   * @schema SecretStoreV1Beta1SpecProviderPassbolt#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassbolt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassbolt(obj: SecretStoreV1Beta1SpecProviderPassbolt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderPassboltAuth(obj.auth),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configures a store to sync secrets with a Password Depot instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderPassworddepot
 */
export interface SecretStoreV1Beta1SpecProviderPassworddepot {
  /**
   * Auth configures how secret-manager authenticates with a Password Depot instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepot#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderPassworddepotAuth;

  /**
   * Database to use as source
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepot#database
   */
  readonly database: string;

  /**
   * URL configures the Password Depot instance URL.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepot#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassworddepot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassworddepot(obj: SecretStoreV1Beta1SpecProviderPassworddepot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuth(obj.auth),
    'database': obj.database,
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Previder configures this store to sync secrets using the Previder provider
 *
 * @schema SecretStoreV1Beta1SpecProviderPrevider
 */
export interface SecretStoreV1Beta1SpecProviderPrevider {
  /**
   * PreviderAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderPrevider#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderPreviderAuth;

  /**
   * @schema SecretStoreV1Beta1SpecProviderPrevider#baseUri
   */
  readonly baseUri?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPrevider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPrevider(obj: SecretStoreV1Beta1SpecProviderPrevider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderPreviderAuth(obj.auth),
    'baseUri': obj.baseUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pulumi configures this store to sync secrets using the Pulumi provider
 *
 * @schema SecretStoreV1Beta1SpecProviderPulumi
 */
export interface SecretStoreV1Beta1SpecProviderPulumi {
  /**
   * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumi#accessToken
   */
  readonly accessToken: SecretStoreV1Beta1SpecProviderPulumiAccessToken;

  /**
   * APIURL is the URL of the Pulumi API.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumi#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Environment are YAML documents composed of static key-value pairs, programmatic expressions,
   * dynamically retrieved values from supported providers including all major clouds,
   * and other Pulumi ESC environments.
   * To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumi#environment
   */
  readonly environment: string;

  /**
   * Organization are a space to collaborate on shared projects and stacks.
   * To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumi#organization
   */
  readonly organization: string;

  /**
   * Project is the name of the Pulumi ESC project the environment belongs to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumi#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPulumi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPulumi(obj: SecretStoreV1Beta1SpecProviderPulumi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreV1Beta1SpecProviderPulumiAccessToken(obj.accessToken),
    'apiUrl': obj.apiUrl,
    'environment': obj.environment,
    'organization': obj.organization,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scaleway
 *
 * @schema SecretStoreV1Beta1SpecProviderScaleway
 */
export interface SecretStoreV1Beta1SpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#accessKey
   */
  readonly accessKey: SecretStoreV1Beta1SpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema SecretStoreV1Beta1SpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#secretKey
   */
  readonly secretKey: SecretStoreV1Beta1SpecProviderScalewaySecretKey;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScaleway(obj: SecretStoreV1Beta1SpecProviderScaleway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKey(obj.accessKey),
    'apiUrl': obj.apiUrl,
    'projectId': obj.projectId,
    'region': obj.region,
    'secretKey': toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretServer configures this store to sync secrets using SecretServer provider
 * https://docs.delinea.com/online-help/secret-server/start.htm
 *
 * @schema SecretStoreV1Beta1SpecProviderSecretserver
 */
export interface SecretStoreV1Beta1SpecProviderSecretserver {
  /**
   * Password is the secret server account password.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserver#password
   */
  readonly password: SecretStoreV1Beta1SpecProviderSecretserverPassword;

  /**
   * ServerURL
   * URL to your secret server installation
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserver#serverURL
   */
  readonly serverUrl: string;

  /**
   * Username is the secret server account username.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserver#username
   */
  readonly username: SecretStoreV1Beta1SpecProviderSecretserverUsername;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSecretserver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSecretserver(obj: SecretStoreV1Beta1SpecProviderSecretserver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_SecretStoreV1Beta1SpecProviderSecretserverPassword(obj.password),
    'serverURL': obj.serverUrl,
    'username': toJson_SecretStoreV1Beta1SpecProviderSecretserverUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhasegura
 */
export interface SecretStoreV1Beta1SpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhasegura(obj: SecretStoreV1Beta1SpecProviderSenhasegura | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj.auth),
    'ignoreSslCertificate': obj.ignoreSslCertificate,
    'module': obj.module,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema SecretStoreV1Beta1SpecProviderVault
 */
export interface SecretStoreV1Beta1SpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault
   * leader instead of simply retrying within a loop. This can increase performance if
   * the option is enabled serverside.
   * https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Headers to be added in Vault request
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g:
   * "secret". The v2 KV secret engine version specific "/data" path suffix
   * for fetching secrets from Vault is optional and will be appended
   * if not present in specified path.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by
   * providing discovered cluster replication states in each request.
   * More information about eventual consistency in Vault can be found here
   * https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#server
   */
  readonly server: string;

  /**
   * The configuration used for client side related TLS communication, when the Vault server
   * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
   * This parameter is ignored for plain HTTP protocol connection.
   * It's worth noting this configuration is different from the "TLS certificates auth method",
   * which is available under the `auth.cert` section.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#tls
   */
  readonly tls?: SecretStoreV1Beta1SpecProviderVaultTls;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or
   * "v2". Version defaults to "v2".
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#version
   */
  readonly version?: SecretStoreV1Beta1SpecProviderVaultVersion;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVault(obj: SecretStoreV1Beta1SpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'tls': toJson_SecretStoreV1Beta1SpecProviderVaultTls(obj.tls),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhook
 */
export interface SecretStoreV1Beta1SpecProviderWebhook {
  /**
   * Auth specifies a authorization protocol. Only one protocol may be set.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderWebhookAuth;

  /**
   * Body
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used
   * if the Server URL is using HTTPS protocol. This parameter is ignored for
   * plain HTTP protocol connection. If not set the system root certificates
   * are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#result
   */
  readonly result: SecretStoreV1Beta1SpecProviderWebhookResult;

  /**
   * Secrets to fill in templates
   * These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#secrets
   */
  readonly secrets?: SecretStoreV1Beta1SpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhook(obj: SecretStoreV1Beta1SpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_SecretStoreV1Beta1SpecProviderWebhookAuth(obj.auth),
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_SecretStoreV1Beta1SpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_SecretStoreV1Beta1SpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj.auth),
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockbox
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockbox(obj: SecretStoreV1Beta1SpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
 */
export interface SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(obj: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount
   * token stored in the named Secret resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details
   * to authenticate with Akeyless.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj: SecretStoreV1Beta1SpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuth(obj: SecretStoreV1Beta1SpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS
 * if not set aws sdk will infer credentials from your environment
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuth
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials
   * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuth(obj: SecretStoreV1Beta1SpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager
 */
export interface SecretStoreV1Beta1SpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You
   * can't use both this parameter and RecoveryWindowInDays in the same call.
   * If you don't use either, then by default Secrets Manager uses a 30 day
   * recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before
   * permanently deleting the secret. You can't use both this parameter and
   * ForceDeleteWithoutRecovery in the same call. If you don't use either,
   * then by default Secrets Manager uses a 30 day recovery window.
   * see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsSecretsManager(obj: SecretStoreV1Beta1SpecProviderAwsSecretsManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsService
 */
export enum SecretStoreV1Beta1SpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags
 */
export interface SecretStoreV1Beta1SpecProviderAwsSessionTags {
  /**
   * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsSessionTags(obj: SecretStoreV1Beta1SpecProviderAwsSessionTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure ClientCertificate of the service principle used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientCertificate
   */
  readonly clientCertificate?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate;

  /**
   * The Azure clientId of the service principle or managed identity used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret;

  /**
   * The Azure tenantId of the managed identity used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#tenantId
   */
  readonly tenantId?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(obj.clientCertificate),
    'clientId': toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
    'tenantId': toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(obj.tenantId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service.
 * Valid values are:
 * - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
 * - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthType
 */
export enum SecretStoreV1Beta1SpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for
 * connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
 * The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
 * PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
 */
export enum SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Beyondtrust.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuth {
  /**
   * APIKey If not provided then ClientID/ClientSecret become required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth#apiKey
   */
  readonly apiKey?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey;

  /**
   * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificate
   */
  readonly certificate?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate;

  /**
   * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificateKey
   */
  readonly certificateKey?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey;

  /**
   * ClientID is the API OAuth Client ID.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientId
   */
  readonly clientId?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId;

  /**
   * ClientSecret is the API OAuth Client Secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientSecret
   */
  readonly clientSecret?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuth(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(obj.apiKey),
    'certificate': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(obj.certificate),
    'certificateKey': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(obj.certificateKey),
    'clientId': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how API server works.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustServer {
  /**
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#apiUrl
   */
  readonly apiUrl: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
   *
   * @default 45 seconds.
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#clientTimeOutSeconds
   */
  readonly clientTimeOutSeconds?: number;

  /**
   * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#retrievalType
   */
  readonly retrievalType?: string;

  /**
   * A character that separates the folder names.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#separator
   */
  readonly separator?: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustServer#verifyCA
   */
  readonly verifyCa: boolean;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustServer(obj: SecretStoreV1Beta1SpecProviderBeyondtrustServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiUrl': obj.apiUrl,
    'apiVersion': obj.apiVersion,
    'clientTimeOutSeconds': obj.clientTimeOutSeconds,
    'retrievalType': obj.retrievalType,
    'separator': obj.separator,
    'verifyCA': obj.verifyCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a bitwarden machine account instance.
 * Make sure that the token being used has permissions on the given secret.
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth
 */
export interface SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth {
  /**
   * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(obj: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(obj: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against chef Server
 *
 * @schema SecretStoreV1Beta1SpecProviderChefAuth
 */
export interface SecretStoreV1Beta1SpecProviderChefAuth {
  /**
   * ChefAuthSecretRef holds secret references for chef server login credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderChefAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderChefAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderChefAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderChefAuth(obj: SecretStoreV1Beta1SpecProviderChefAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderChefAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuth
 */
export interface SecretStoreV1Beta1SpecProviderCloudrusmAuth {
  /**
   * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderCloudrusmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuth(obj: SecretStoreV1Beta1SpecProviderCloudrusmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines authentication settings for connecting to Conjur.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuth
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuth {
  /**
   * Authenticates with Conjur using an API key.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuth#apikey
   */
  readonly apikey?: SecretStoreV1Beta1SpecProviderConjurAuthApikey;

  /**
   * Jwt enables JWT authentication using Kubernetes service account tokens.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderConjurAuthJwt;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuth(obj: SecretStoreV1Beta1SpecProviderConjurAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apikey': toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikey(obj.apikey),
    'jwt': toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates
 * for a secret store. The CAProvider points to a Secret or ConfigMap resource
 * that contains a PEM-encoded certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderConjurCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurCaProvider(obj: SecretStoreV1Beta1SpecProviderConjurCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientId
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientId(obj: SecretStoreV1Beta1SpecProviderDelineaClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecret(obj: SecretStoreV1Beta1SpecProviderDelineaClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Device42 instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderDevice42Auth
 */
export interface SecretStoreV1Beta1SpecProviderDevice42Auth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderDevice42Auth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDevice42Auth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDevice42Auth(obj: SecretStoreV1Beta1SpecProviderDevice42Auth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuth
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuth(obj: SecretStoreV1Beta1SpecProviderDopplerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerFormat
 */
export enum SecretStoreV1Beta1SpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerNameTransformer
 */
export enum SecretStoreV1Beta1SpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema SecretStoreV1Beta1SpecProviderFakeData
 */
export interface SecretStoreV1Beta1SpecProviderFakeData {
  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#value
   */
  readonly value: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFakeData(obj: SecretStoreV1Beta1SpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey is the API token to access SDKMS Applications.
 *
 * @schema SecretStoreV1Beta1SpecProviderFortanixApiKey
 */
export interface SecretStoreV1Beta1SpecProviderFortanixApiKey {
  /**
   * SecretRef is a reference to a secret containing the SDKMS API Key.
   *
   * @schema SecretStoreV1Beta1SpecProviderFortanixApiKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFortanixApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFortanixApiKey(obj: SecretStoreV1Beta1SpecProviderFortanixApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef;

  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuth(obj: SecretStoreV1Beta1SpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * auth configures how secret-manager authenticates with a Github instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderGithubAuth
 */
export interface SecretStoreV1Beta1SpecProviderGithubAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderGithubAuth#privateKey
   */
  readonly privateKey: SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGithubAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGithubAuth(obj: SecretStoreV1Beta1SpecProviderGithubAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKey': toJson_SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey(obj.privateKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuth
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuth(obj: SecretStoreV1Beta1SpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderGitlabCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderGitlabCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabCaProvider(obj: SecretStoreV1Beta1SpecProviderGitlabCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuth
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth;

  /**
   * @schema SecretStoreV1Beta1SpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuth(obj: SecretStoreV1Beta1SpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerAuth': toJson_SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj.containerAuth),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Infisical API
 *
 * @schema SecretStoreV1Beta1SpecProviderInfisicalAuth
 */
export interface SecretStoreV1Beta1SpecProviderInfisicalAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuth#universalAuthCredentials
   */
  readonly universalAuthCredentials?: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisicalAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisicalAuth(obj: SecretStoreV1Beta1SpecProviderInfisicalAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'universalAuthCredentials': toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(obj.universalAuthCredentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsScope defines the scope of the secrets within the workspace
 *
 * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope
 */
export interface SecretStoreV1Beta1SpecProviderInfisicalSecretsScope {
  /**
   * EnvironmentSlug is the required slug identifier for the environment.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#environmentSlug
   */
  readonly environmentSlug: string;

  /**
   * ExpandSecretReferences indicates whether secret references should be expanded. Defaults to true if not provided.
   *
   * @default true if not provided.
   * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#expandSecretReferences
   */
  readonly expandSecretReferences?: boolean;

  /**
   * ProjectSlug is the required slug identifier for the project.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#projectSlug
   */
  readonly projectSlug: string;

  /**
   * Recursive indicates whether the secrets should be fetched recursively. Defaults to false if not provided.
   *
   * @default false if not provided.
   * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#recursive
   */
  readonly recursive?: boolean;

  /**
   * SecretsPath specifies the path to the secrets within the workspace. Defaults to "/" if not provided.
   *
   * @default if not provided.
   * @schema SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#secretsPath
   */
  readonly secretsPath?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisicalSecretsScope' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisicalSecretsScope(obj: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environmentSlug': obj.environmentSlug,
    'expandSecretReferences': obj.expandSecretReferences,
    'projectSlug': obj.projectSlug,
    'recursive': obj.recursive,
    'secretsPath': obj.secretsPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
 */
export interface SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#cert
   */
  readonly cert?: SecretStoreV1Beta1SpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#token
   */
  readonly token?: SecretStoreV1Beta1SpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuth(obj: SecretStoreV1Beta1SpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a secret that contains the auth information.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthRef
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthRef(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServer
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesServer(obj: SecretStoreV1Beta1SpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Onboardbase API
 *
 * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuth
 */
export interface SecretStoreV1Beta1SpecProviderOnboardbaseAuth {
  /**
   * OnboardbaseAPIKey is the APIKey generated by an admin account.
   * It is used to recognize and authorize access to a project and environment within onboardbase
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuth#apiKeyRef
   */
  readonly apiKeyRef: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef;

  /**
   * OnboardbasePasscode is the passcode attached to the API Key
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuth#passcodeRef
   */
  readonly passcodeRef: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnboardbaseAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuth(obj: SecretStoreV1Beta1SpecProviderOnboardbaseAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRef': toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(obj.apiKeyRef),
    'passcodeRef': toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(obj.passcodeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuth
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuth(obj: SecretStoreV1Beta1SpecProviderOnepasswordAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault.
 * If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuth
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuth(obj: SecretStoreV1Beta1SpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will
 * determine the principal type. This optional field must be specified if using
 * workload identity.
 *
 * @schema SecretStoreV1Beta1SpecProviderOraclePrincipalType
 */
export enum SecretStoreV1Beta1SpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account
 * that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Passbolt Server
 *
 * @schema SecretStoreV1Beta1SpecProviderPassboltAuth
 */
export interface SecretStoreV1Beta1SpecProviderPassboltAuth {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuth#passwordSecretRef
   */
  readonly passwordSecretRef: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuth#privateKeySecretRef
   */
  readonly privateKeySecretRef: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassboltAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassboltAuth(obj: SecretStoreV1Beta1SpecProviderPassboltAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(obj.passwordSecretRef),
    'privateKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Password Depot instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuth
 */
export interface SecretStoreV1Beta1SpecProviderPassworddepotAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassworddepotAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuth(obj: SecretStoreV1Beta1SpecProviderPassworddepotAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderPreviderAuth
 */
export interface SecretStoreV1Beta1SpecProviderPreviderAuth {
  /**
   * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderPreviderAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPreviderAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPreviderAuth(obj: SecretStoreV1Beta1SpecProviderPreviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
 *
 * @schema SecretStoreV1Beta1SpecProviderPulumiAccessToken
 */
export interface SecretStoreV1Beta1SpecProviderPulumiAccessToken {
  /**
   * SecretRef is a reference to a secret containing the Pulumi API token.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumiAccessToken#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPulumiAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPulumiAccessToken(obj: SecretStoreV1Beta1SpecProviderPulumiAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey
 */
export interface SecretStoreV1Beta1SpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKey(obj: SecretStoreV1Beta1SpecProviderScalewayAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey
 */
export interface SecretStoreV1Beta1SpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKey(obj: SecretStoreV1Beta1SpecProviderScalewaySecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Password is the secret server account password.
 *
 * @schema SecretStoreV1Beta1SpecProviderSecretserverPassword
 */
export interface SecretStoreV1Beta1SpecProviderSecretserverPassword {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverPassword#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverPassword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSecretserverPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSecretserverPassword(obj: SecretStoreV1Beta1SpecProviderSecretserverPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username is the secret server account username.
 *
 * @schema SecretStoreV1Beta1SpecProviderSecretserverUsername
 */
export interface SecretStoreV1Beta1SpecProviderSecretserverUsername {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverUsername#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverUsername#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSecretserverUsername' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSecretserverUsername(obj: SecretStoreV1Beta1SpecProviderSecretserverUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth
 */
export interface SecretStoreV1Beta1SpecProviderSenhaseguraAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj: SecretStoreV1Beta1SpecProviderSenhaseguraAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuth
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism,
   * with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#appRole
   */
  readonly appRole?: SecretStoreV1Beta1SpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
   * Cert authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#cert
   */
  readonly cert?: SecretStoreV1Beta1SpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
   * AWS IAM authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#iam
   */
  readonly iam?: SecretStoreV1Beta1SpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the
   * JWT/OIDC authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount
   * token stored in the named Secret resource to the Vault server.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using
   * the LDAP authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#ldap
   */
  readonly ldap?: SecretStoreV1Beta1SpecProviderVaultAuthLdap;

  /**
   * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in.
   * Namespaces is a set of features within Vault Enterprise that allows
   * Vault environments to support Secure Multi-tenancy. e.g: "ns1".
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   * This will default to Vault.Namespace field if set, or empty otherwise
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#namespace
   */
  readonly namespace?: string;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#userPass
   */
  readonly userPass?: SecretStoreV1Beta1SpecProviderVaultAuthUserPass;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuth(obj: SecretStoreV1Beta1SpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_SecretStoreV1Beta1SpecProviderVaultAuthCert(obj.cert),
    'iam': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIam(obj.iam),
    'jwt': toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdap(obj.ldap),
    'namespace': obj.namespace,
    'tokenSecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultCaProvider(obj: SecretStoreV1Beta1SpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration used for client side related TLS communication, when the Vault server
 * requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
 * This parameter is ignored for plain HTTP protocol connection.
 * It's worth noting this configuration is different from the "TLS certificates auth method",
 * which is available under the `auth.cert` section.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultTls
 */
export interface SecretStoreV1Beta1SpecProviderVaultTls {
  /**
   * CertSecretRef is a certificate added to the transport layer
   * when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTls#certSecretRef
   */
  readonly certSecretRef?: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef;

  /**
   * KeySecretRef to a key in a Secret resource containing client private key
   * added to the transport layer when communicating with the Vault server.
   * If no key for the Secret is specified, external-secret will default to 'tls.key'.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTls#keySecretRef
   */
  readonly keySecretRef?: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultTls(obj: SecretStoreV1Beta1SpecProviderVaultTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(obj.certSecretRef),
    'keySecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or
 * "v2". Version defaults to "v2".
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultVersion
 */
export enum SecretStoreV1Beta1SpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * Auth specifies a authorization protocol. Only one protocol may be set.
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookAuth
 */
export interface SecretStoreV1Beta1SpecProviderWebhookAuth {
  /**
   * NTLMProtocol configures the store to use NTLM for auth
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuth#ntlm
   */
  readonly ntlm?: SecretStoreV1Beta1SpecProviderWebhookAuthNtlm;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookAuth(obj: SecretStoreV1Beta1SpecProviderWebhookAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ntlm': toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlm(obj.ntlm),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderWebhookCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookCaProvider(obj: SecretStoreV1Beta1SpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookResult
 */
export interface SecretStoreV1Beta1SpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookResult(obj: SecretStoreV1Beta1SpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets
 */
export interface SecretStoreV1Beta1SpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookSecrets(obj: SecretStoreV1Beta1SpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuth
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj: SecretStoreV1Beta1SpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount
 * token stored in the named Secret resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Akeyless. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Akeyless. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details
 * to authenticate with Akeyless.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa {
  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwt(obj: SecretStoreV1Beta1SpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials
 * both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientCertificate of the service principle used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle or managed identity used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure tenantId of the managed identity used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKey If not provided then ClientID/ClientSecret become required.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the API OAuth Client ID.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the API OAuth Client Secret.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
   * AccessToken used for the bitwarden instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
   */
  readonly credentials: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * ChefAuthSecretRef holds secret references for chef server login credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderChefAuthSecretRef {
  /**
   * SecretKey is the Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRef#privateKeySecretRef
   */
  readonly privateKeySecretRef: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderChefAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderChefAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderChefAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(obj.privateKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSMAuthSecretRef holds secret references for Cloud.ru credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticates with Conjur using an API key.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikey {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' containing the Conjur API key
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' containing the Conjur username
   * within a Secret resource. In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikey(obj: SecretStoreV1Beta1SpecProviderConjurAuthApikey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'apiKeyRef': toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj.apiKeyRef),
    'userRef': toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj.userRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt enables JWT authentication using Kubernetes service account tokens.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwt {
  /**
   * Account is the Conjur organization account name.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional HostID for JWT authentication. This may be used depending
   * on how the Conjur JWT authenticator policy is configured.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#hostId
   */
  readonly hostId?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Conjur using the JWT authentication method.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwt(obj: SecretStoreV1Beta1SpecProviderConjurAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'hostId': obj.hostId,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj.serviceAccountRef),
    'serviceID': obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef#credentials
   */
  readonly credentials?: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(obj: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication.
   * See https://docs.doppler.com/reference/api#authentication for auth token types.
   * The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dopplerToken': toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj.dopplerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the SDKMS API Key.
 *
 * @schema SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(obj: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * ClusterLocation is the location of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation?: string;

  /**
   * ClusterName is the name of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName?: string;

  /**
   * ClusterProjectID is the project ID of the cluster
   * If not specified, it fetches information from the metadata server
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey
 */
export interface SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey(obj: SecretStoreV1Beta1SpecProviderGithubAuthPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderGitlabCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamEndpoint': obj.iamEndpoint,
    'profile': obj.profile,
    'tokenLocation': obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials
 */
export interface SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientId
   */
  readonly clientId: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
   */
  readonly clientSecret: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(obj: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj.clientId),
    'clientSecret': toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthToken
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   * Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbaseAPIKey is the APIKey generated by an admin account.
 * It is used to recognize and authorize access to a project and environment within onboardbase
 *
 * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef
 */
export interface SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(obj: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnboardbasePasscode is the passcode attached to the API Key
 *
 * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef
 */
export interface SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(obj: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTokenSecretRef': toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj.connectTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(obj: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(obj: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef {
  /**
   * Username / Password is used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef#credentials
   */
  readonly credentials?: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(obj.credentials),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef {
  /**
   * The AccessToken is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef#accessToken
   */
  readonly accessToken: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret containing the Pulumi API token.
 *
 * @schema SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(obj: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(obj: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(obj: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism,
 * with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted
   * in Vault, e.g: "approle"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting
   * up the authentication backend in Vault.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role id.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
 * Cert authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault
   * authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to
   * authenticate with Vault using the Cert authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCert(obj: SecretStoreV1Beta1SpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
 * AWS IAM authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIam(obj: SecretStoreV1Beta1SpecProviderVaultAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the
 * JWT/OIDC authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
   * a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted
   * in Vault, e.g: "jwt"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault
   * authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
   * authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwt(obj: SecretStoreV1Beta1SpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount
 * token stored in the named Secret resource to the Vault server.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g:
   * "kubernetes"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a
   * Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Vault. If a name is specified without a key,
   * `token` is the default. If one is not specified, the one bound to
   * the controller will be used.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount.
   * If the service account is specified, the service account secret token JWT will be used
   * for authenticating with Vault. If the service account selector is not supplied,
   * the secretRef will be used instead.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using
 * the LDAP authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted
   * in Vault, e.g: "ldap"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP
   * user used to authenticate with Vault using the LDAP authentication
   * method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is an LDAP username used to authenticate using the LDAP Vault
   * authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdap(obj: SecretStoreV1Beta1SpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted
   * in Vault, e.g: "userpass"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the
   * user used to authenticate with Vault using the UserPass authentication
   * method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a username used to authenticate using the UserPass Vault
   * authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj: SecretStoreV1Beta1SpecProviderVaultAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * CertSecretRef is a certificate added to the transport layer
 * when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.crt'.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySecretRef to a key in a Secret resource containing client private key
 * added to the transport layer when communicating with the Vault server.
 * If no key for the Secret is specified, external-secret will default to 'tls.key'.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(obj: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NTLMProtocol configures the store to use NTLM for auth
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlm
 */
export interface SecretStoreV1Beta1SpecProviderWebhookAuthNtlm {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlm#passwordSecret
   */
  readonly passwordSecret: SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlm#usernameSecret
   */
  readonly usernameSecret: SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookAuthNtlm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlm(obj: SecretStoreV1Beta1SpecProviderWebhookAuthNtlm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecret': toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret(obj.passwordSecret),
    'usernameSecret': toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret(obj.usernameSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Akeyless. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Akeyless. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(obj: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken used for the bitwarden instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
 */
export interface SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(obj: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(obj: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef(obj: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef(obj: SecretStoreV1Beta1SpecProviderCloudrusmAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur API key
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' containing the Conjur username
 * within a Secret resource. In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Conjur using the JWT authentication method.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials
 */
export interface SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(obj: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The DopplerToken is used for authentication.
 * See https://docs.doppler.com/reference/api#authentication for auth token types.
 * The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId
 */
export interface SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(obj: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(obj: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Username / Password is used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials
 */
export interface SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(obj: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessToken is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken
 */
export interface SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(obj: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role id.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role secret.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault
 * authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to
 * authenticate with Vault using the Cert authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwt
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication
   * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
   * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request
 * a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service
   * account token for the service account referenced by `serviceAccountRef`.
   * Defaults to a single audience `vault` it not specified.
   * Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified.
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary
   * Kubernetes service account token for the service account referenced by
   * `serviceAccountRef`.
   * Deprecated: this will be removed in the future.
   * Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to
 * authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Vault. If a name is specified without a key,
 * `token` is the default. If one is not specified, the one bound to
 * the controller will be used.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount.
 * If the service account is specified, the service account secret token JWT will be used
 * for authenticating with Vault. If the service account selector is not supplied,
 * the secretRef will be used instead.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP
 * user used to authenticate with Vault using the LDAP authentication
 * method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the
 * user used to authenticate with Vault using the UserPass authentication
 * method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret
 */
export interface SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret(obj: SecretStoreV1Beta1SpecProviderWebhookAuthNtlmPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret
 */
export interface SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret(obj: SecretStoreV1Beta1SpecProviderWebhookAuthNtlmUsernameSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication
 * This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
 * see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * A key in the referenced Secret.
   * Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * The namespace of the Secret resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token
   * If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
   * then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to.
   * Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

